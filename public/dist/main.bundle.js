/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 4);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
            (typeof self !== "undefined" && self) ||
            window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(2);
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
                       (typeof global !== "undefined" && global.setImmediate) ||
                       (this && this.setImmediate);
exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
                         (typeof global !== "undefined" && global.clearImmediate) ||
                         (this && this.clearImmediate);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(3)))

/***/ }),
/* 3 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _amber = __webpack_require__(5);

var _amber2 = _interopRequireDefault(_amber);

__webpack_require__(6);

__webpack_require__(11);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * Ensure the data-confirm elements show popup confirmations
 */
document.querySelectorAll("form").forEach(function (form) {
  form.querySelectorAll("form input[type=submit]").forEach(function (submissionElem) {
    var confirmationMessage = submissionElem.getAttribute("data-confirm");

    if (confirmationMessage) {
      submissionElem.addEventListener("click", function (e) {
        e.preventDefault();

        if (confirm(confirmationMessage)) {
          form.submit();
        }
      });
    }
  });
});

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EVENTS = {
  join: 'join',
  leave: 'leave',
  message: 'message'
};
var STALE_CONNECTION_THRESHOLD_SECONDS = 100;
var SOCKET_POLLING_RATE = 10000;

/**
 * Returns a numeric value for the current time
 */
var now = function now() {
  return new Date().getTime();
};

/**
 * Returns the difference between the current time and passed `time` in seconds
 * @param {Number|Date} time - A numeric time or date object
 */
var secondsSince = function secondsSince(time) {
  return (now() - time) / 1000;
};

/**
 * Class for channel related functions (joining, leaving, subscribing and sending messages)
 */

var Channel = exports.Channel = function () {
  /**
   * @param {String} topic - topic to subscribe to
   * @param {Socket} socket - A Socket instance
   */
  function Channel(topic, socket) {
    _classCallCheck(this, Channel);

    this.topic = topic;
    this.socket = socket;
    this.onMessageHandlers = [];
  }

  /**
   * Join a channel, subscribe to all channels messages
   */


  _createClass(Channel, [{
    key: 'join',
    value: function join() {
      this.socket.ws.send(JSON.stringify({ event: EVENTS.join, topic: this.topic }));
    }

    /**
     * Leave a channel, stop subscribing to channel messages
     */

  }, {
    key: 'leave',
    value: function leave() {
      this.socket.ws.send(JSON.stringify({ event: EVENTS.leave, topic: this.topic }));
    }

    /**
     * Calls all message handlers with a matching subject
     */

  }, {
    key: 'handleMessage',
    value: function handleMessage(msg) {
      this.onMessageHandlers.forEach(function (handler) {
        if (handler.subject === msg.subject) handler.callback(msg.payload);
      });
    }

    /**
     * Subscribe to a channel subject
     * @param {String} subject - subject to listen for: `msg:new`
     * @param {function} callback - callback function when a new message arrives
     */

  }, {
    key: 'on',
    value: function on(subject, callback) {
      this.onMessageHandlers.push({ subject: subject, callback: callback });
    }

    /**
     * Send a new message to the channel
     * @param {String} subject - subject to send message to: `msg:new`
     * @param {Object} payload - payload object: `{message: 'hello'}`
     */

  }, {
    key: 'push',
    value: function push(subject, payload) {
      this.socket.ws.send(JSON.stringify({ event: EVENTS.message, topic: this.topic, subject: subject, payload: payload }));
    }
  }]);

  return Channel;
}();

/**
 * Class for maintaining connection with server and maintaining channels list
 */


var Socket = exports.Socket = function () {
  /**
   * @param {String} endpoint - Websocket endpont used in routes.cr file
   */
  function Socket(endpoint) {
    _classCallCheck(this, Socket);

    this.endpoint = endpoint;
    this.ws = null;
    this.channels = [];
    this.lastPing = now();
    this.reconnectTries = 0;
    this.attemptReconnect = true;
  }

  /**
   * Returns whether or not the last received ping has been past the threshold
   */


  _createClass(Socket, [{
    key: '_connectionIsStale',
    value: function _connectionIsStale() {
      return secondsSince(this.lastPing) > STALE_CONNECTION_THRESHOLD_SECONDS;
    }

    /**
     * Tries to reconnect to the websocket server using a recursive timeout
     */

  }, {
    key: '_reconnect',
    value: function _reconnect() {
      var _this = this;

      clearTimeout(this.reconnectTimeout);
      this.reconnectTimeout = setTimeout(function () {
        _this.reconnectTries++;
        _this.connect(_this.params);
        _this._reconnect();
      }, this._reconnectInterval());
    }

    /**
     * Returns an incrementing timeout interval based around the number of reconnection retries
     */

  }, {
    key: '_reconnectInterval',
    value: function _reconnectInterval() {
      return [1000, 2000, 5000, 10000][this.reconnectTries] || 10000;
    }

    /**
     * Sets a recursive timeout to check if the connection is stale
     */

  }, {
    key: '_poll',
    value: function _poll() {
      var _this2 = this;

      this.pollingTimeout = setTimeout(function () {
        if (_this2._connectionIsStale()) {
          _this2._reconnect();
        } else {
          _this2._poll();
        }
      }, SOCKET_POLLING_RATE);
    }

    /**
     * Clear polling timeout and start polling
     */

  }, {
    key: '_startPolling',
    value: function _startPolling() {
      clearTimeout(this.pollingTimeout);
      this._poll();
    }

    /**
     * Sets `lastPing` to the curent time
     */

  }, {
    key: '_handlePing',
    value: function _handlePing() {
      this.lastPing = now();
    }

    /**
     * Clears reconnect timeout, resets variables an starts polling
     */

  }, {
    key: '_reset',
    value: function _reset() {
      clearTimeout(this.reconnectTimeout);
      this.reconnectTries = 0;
      this.attemptReconnect = true;
      this._startPolling();
    }

    /**
     * Connect the socket to the server, and binds to native ws functions
     * @param {Object} params - Optional parameters
     * @param {String} params.location - Hostname to connect to, defaults to `window.location.hostname`
     * @param {String} parmas.port - Port to connect to, defaults to `window.location.port`
     * @param {String} params.protocol - Protocol to use, either 'wss' or 'ws'
     */

  }, {
    key: 'connect',
    value: function connect(params) {
      var _this3 = this;

      this.params = params;

      var opts = {
        location: window.location.hostname,
        port: window.location.port,
        protocol: window.location.protocol === 'https:' ? 'wss:' : 'ws:'
      };

      if (params) Object.assign(opts, params);
      if (opts.port) opts.location += ':' + opts.port;

      return new Promise(function (resolve, reject) {
        _this3.ws = new WebSocket(opts.protocol + '//' + opts.location + _this3.endpoint);
        _this3.ws.onmessage = function (msg) {
          _this3.handleMessage(msg);
        };
        _this3.ws.onclose = function () {
          if (_this3.attemptReconnect) _this3._reconnect();
        };
        _this3.ws.onopen = function () {
          _this3._reset();
          resolve();
        };
      });
    }

    /**
     * Closes the socket connection permanently
     */

  }, {
    key: 'disconnect',
    value: function disconnect() {
      this.attemptReconnect = false;
      clearTimeout(this.pollingTimeout);
      clearTimeout(this.reconnectTimeout);
      this.ws.close();
    }

    /**
     * Adds a new channel to the socket channels list
     * @param {String} topic - Topic for the channel: `chat_room:123`
     */

  }, {
    key: 'channel',
    value: function channel(topic) {
      var channel = new Channel(topic, this);
      this.channels.push(channel);
      return channel;
    }

    /**
     * Message handler for messages received
     * @param {MessageEvent} msg - Message received from ws
     */

  }, {
    key: 'handleMessage',
    value: function handleMessage(msg) {
      if (msg.data === "ping") return this._handlePing();

      var parsed_msg = JSON.parse(msg.data);
      this.channels.forEach(function (channel) {
        if (channel.topic === parsed_msg.topic) channel.handleMessage(parsed_msg);
      });
    }
  }]);

  return Socket;
}();

module.exports = {
  Socket: Socket

  /**
   * Allows delete links to post for security and ease of use similar to Rails jquery_ujs
   */
};document.addEventListener("DOMContentLoaded", function () {
  document.querySelectorAll("a[data-method='delete']").forEach(function (element) {
    element.addEventListener("click", function (e) {
      e.preventDefault();
      var message = element.getAttribute("data-confirm") || "Are you sure?";
      if (confirm(message)) {
        var form = document.createElement("form");
        var input = document.createElement("input");
        form.setAttribute("action", element.getAttribute("href"));
        form.setAttribute("method", "POST");
        input.setAttribute("type", "hidden");
        input.setAttribute("name", "_method");
        input.setAttribute("value", "DELETE");
        form.appendChild(input);
        document.body.appendChild(form);
        form.submit();
      }
      return false;
    });
  });
});

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _cytoscape = __webpack_require__(7);

var _cytoscape2 = _interopRequireDefault(_cytoscape);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var tournamentGraphElement = document.getElementById('tournament-graph'); // photos from flickr with creative commons license


if (tournamentGraphElement) {
  var tournamentDataUrl = tournamentGraphElement.getAttribute('tournament-data-url');
  fetch(tournamentDataUrl + '.json').then(function (response) {
    return response.json();
  }).then(function (tournamentData) {
    // Get rid of bye matches
    var filteredMatchData = tournamentData.matches.filter(function (match) {
      return match.level > 0 || match.player_a_id && match.player_b_id;
    });

    // Sort by lowest level, and then by id for consistent rendering order
    filteredMatchData.sort(function (a, b) {
      if (a.level != b.level) {
        b.level - a.level;
      } else {
        b.id - a.id;
      }
    });

    var matchNodes = filteredMatchData.map(function (match) {
      var player_a = tournamentData.players.find(function (player) {
        return player.id == match.player_a_id;
      });
      var player_b = tournamentData.players.find(function (player) {
        return player.id == match.player_b_id;
      });
      var winner = tournamentData.players.find(function (player) {
        return player.id == match.winner_id;
      });

      var outlineColor = void 0;
      if (winner) outlineColor = '#ef4b62';else if (player_a && player_b) outlineColor = '#ffa039';else outlineColor = '#828282';

      var playersLabel = "";
      if (player_a && player_b) {
        playersLabel = player_a.tag + ' vs ' + player_b.tag;
      } else if (player_a) {
        playersLabel = player_a.tag + ' vs ?';
      } else if (player_b) {
        playersLabel = player_b.tag + ' vs ?';
      }

      return {
        data: {
          id: 'm' + match.id,
          name: 'Match #' + match.id,
          href: match.url,
          players_vs: playersLabel,
          background: winner ? winner.image_url : 'none',
          outline: outlineColor
        }
      };
    });

    var matchEdges = filteredMatchData.filter(function (match) {
      return match.next_match_id;
    }).map(function (match) {
      // source and target and swapped around as to treat the winning node as the top of the tree (BFS)
      return {
        data: {
          target: 'm' + match.id,
          source: 'm' + match.next_match_id,
          color: match.winner_id ? "#4eb4f9" : "#828282"
        }
      };
    });

    var playerNodes = [];
    filteredMatchData.forEach(function (match) {
      [match.player_a_id, match.player_b_id].forEach(function (player_id) {
        var player = tournamentData.players.find(function (player) {
          return player.id == player_id;
        });

        if (player) playerNodes += { data: { id: 'p' + player.id, name: player.tag } };
      });
    });

    var cy = (0, _cytoscape2.default)({
      container: tournamentGraphElement,

      boxSelectionEnabled: true,
      autounselectify: true,

      maxZoom: 2,
      minZoom: 0.25,

      style: _cytoscape2.default.stylesheet().selector('node').css({
        'height': '80rem',
        'width': '80rem',
        'background-image': 'data(background)',
        'background-fit': 'cover',
        'background-color': '#343a40',
        'border-color': 'data(outline)',
        'border-width': '8rem',
        'border-opacity': 1,
        'content': 'data(players_vs)',
        'color': 'white',
        'text-outline-width': '2rem',
        'text-outline-color': '#343a40',
        'text-valign': 'bottom',
        'font-weight': 'bold',
        'font-size': '20rem',
        'font-family': 'Muli, Helvetica Neue, Helvetica, Arial, sans-serif'
      }).selector('.eating').css({
        'border-color': 'red'
      }).selector('.eater').css({
        'border-width': 10
      }).selector('edge').css({
        'curve-style': 'unbundled-bezier',
        'width': 8,
        'source-arrow-shape': 'triangle',
        'line-color': 'data(color)',
        'source-arrow-color': 'data(color)'
      }).selector('edge.played').css({
        'line-color': "#aef72f"
      }),

      elements: {
        nodes: matchNodes,
        edges: matchEdges
      },

      layout: {
        name: 'breadthfirst',
        directed: true,
        padding: 10
      }
    }); // cy init

    cy.on('tap', 'node', function () {
      var node = this._private;
      var href = node.data.href;

      if (href) window.location.href = href;
    });
  }).catch(function (error) {
    tournamentGraphElement.innerText = "Something went wrong.";
  });
}

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(setImmediate) {(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory(__webpack_require__(8), __webpack_require__(9));
	else if(typeof define === 'function' && define.amd)
		define(["lodash.debounce", "heap"], factory);
	else if(typeof exports === 'object')
		exports["cytoscape"] = factory(require("lodash.debounce"), require("heap"));
	else
		root["cytoscape"] = factory(root["lodash.debounce"], root["heap"]);
})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_26__, __WEBPACK_EXTERNAL_MODULE_32__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 20);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*global HTMLElement DocumentTouch */

var window = __webpack_require__(3);
var navigator = window ? window.navigator : null;
var document = window ? window.document : null;

var typeofstr = _typeof('');
var typeofobj = _typeof({});
var typeoffn = _typeof(function () {});
var typeofhtmlele = typeof HTMLElement === 'undefined' ? 'undefined' : _typeof(HTMLElement);

var instanceStr = function instanceStr(obj) {
  return obj && obj.instanceString && is.fn(obj.instanceString) ? obj.instanceString() : null;
};

var is = {
  defined: function defined(obj) {
    return obj != null; // not undefined or null
  },

  string: function string(obj) {
    return obj != null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) == typeofstr;
  },

  fn: function fn(obj) {
    return obj != null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === typeoffn;
  },

  array: function array(obj) {
    return Array.isArray ? Array.isArray(obj) : obj != null && obj instanceof Array;
  },

  plainObject: function plainObject(obj) {
    return obj != null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === typeofobj && !is.array(obj) && obj.constructor === Object;
  },

  object: function object(obj) {
    return obj != null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === typeofobj;
  },

  number: function number(obj) {
    return obj != null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === _typeof(1) && !isNaN(obj);
  },

  integer: function integer(obj) {
    return is.number(obj) && Math.floor(obj) === obj;
  },

  bool: function bool(obj) {
    return obj != null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === _typeof(true);
  },

  htmlElement: function htmlElement(obj) {
    if ('undefined' === typeofhtmlele) {
      return undefined;
    } else {
      return null != obj && obj instanceof HTMLElement;
    }
  },

  elementOrCollection: function elementOrCollection(obj) {
    return is.element(obj) || is.collection(obj);
  },

  element: function element(obj) {
    return instanceStr(obj) === 'collection' && obj._private.single;
  },

  collection: function collection(obj) {
    return instanceStr(obj) === 'collection' && !obj._private.single;
  },

  core: function core(obj) {
    return instanceStr(obj) === 'core';
  },

  style: function style(obj) {
    return instanceStr(obj) === 'style';
  },

  stylesheet: function stylesheet(obj) {
    return instanceStr(obj) === 'stylesheet';
  },

  event: function event(obj) {
    return instanceStr(obj) === 'event';
  },

  thread: function thread(obj) {
    return instanceStr(obj) === 'thread';
  },

  fabric: function fabric(obj) {
    return instanceStr(obj) === 'fabric';
  },

  emptyString: function emptyString(obj) {
    if (obj === undefined || obj === null) {
      // null is empty
      return true;
    } else if (obj === '' || obj.match(/^\s+$/)) {
      return true; // empty string is empty
    }

    return false; // otherwise, we don't know what we've got
  },

  nonemptyString: function nonemptyString(obj) {
    if (obj && is.string(obj) && obj !== '' && !obj.match(/^\s+$/)) {
      return true;
    }

    return false;
  },

  domElement: function domElement(obj) {
    if (typeof HTMLElement === 'undefined') {
      return false; // we're not in a browser so it doesn't matter
    } else {
      return obj instanceof HTMLElement;
    }
  },

  boundingBox: function boundingBox(obj) {
    return is.plainObject(obj) && is.number(obj.x1) && is.number(obj.x2) && is.number(obj.y1) && is.number(obj.y2);
  },

  promise: function promise(obj) {
    return is.object(obj) && is.fn(obj.then);
  },

  touch: function touch() {
    return window && ('ontouchstart' in window || window.DocumentTouch && document instanceof DocumentTouch);
  },

  gecko: function gecko() {
    return window && (typeof InstallTrigger !== 'undefined' || 'MozAppearance' in document.documentElement.style);
  },

  webkit: function webkit() {
    return window && (typeof webkitURL !== 'undefined' || 'WebkitAppearance' in document.documentElement.style);
  },

  chromium: function chromium() {
    return window && typeof chrome !== 'undefined';
  },

  khtml: function khtml() {
    return navigator && navigator.vendor.match(/kde/i); // probably a better way to detect this...
  },

  khtmlEtc: function khtmlEtc() {
    return is.khtml() || is.webkit() || is.chromium();
  },

  ms: function ms() {
    return navigator && navigator.userAgent.match(/msie|trident|edge/i); // probably a better way to detect this...
  },

  windows: function windows() {
    return navigator && navigator.appVersion.match(/Win/i);
  },

  mac: function mac() {
    return navigator && navigator.appVersion.match(/Mac/i);
  },

  linux: function linux() {
    return navigator && navigator.appVersion.match(/Linux/i);
  },

  unix: function unix() {
    return navigator && navigator.appVersion.match(/X11/i);
  }
};

module.exports = is;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*global console */

var is = __webpack_require__(0);
var math = __webpack_require__(2);

var util = {

  MAX_INT: Number.MAX_SAFE_INTEGER || 9007199254740991,

  trueify: function trueify() {
    return true;
  },

  falsify: function falsify() {
    return false;
  },

  zeroify: function zeroify() {
    return 0;
  },

  noop: function noop() {},

  error: function error(msg) {
    /* eslint-disable */
    if (console.error) {
      console.error.apply(console, arguments);

      if (console.trace) {
        console.trace();
      }
    } else {
      console.log.apply(console, arguments);

      if (console.trace) {
        console.trace();
      }
    }
    /* eslint-enable */
  },

  clone: function clone(obj) {
    return this.extend({}, obj);
  },

  // gets a shallow copy of the argument
  copy: function copy(obj) {
    if (obj == null) {
      return obj;
    }if (is.array(obj)) {
      return obj.slice();
    } else if (is.plainObject(obj)) {
      return this.clone(obj);
    } else {
      return obj;
    }
  },

  copyArray: function copyArray(arr) {
    return arr.slice();
  },

  clonePosition: function clonePosition(pos) {
    return { x: pos.x, y: pos.y };
  },

  uuid: function uuid(a, b // placeholders
  ) {
    for ( // loop :)
    b = a = ''; // b - result , a - numeric letiable
    a++ < 36; //
    b += a * 51 & 52 // if "a" is not 9 or 14 or 19 or 24
    ? //  return a random number or 4
    (a ^ 15 // if "a" is not 15
    ? // genetate a random number from 0 to 15
    8 ^ Math.random() * (a ^ 20 ? 16 : 4) // unless "a" is 20, in which case a random number from 8 to 11
    : 4 //  otherwise 4
    ).toString(16) : '-' //  in other cases (if "a" is 9,14,19,24) insert "-"
    ) {}
    return b;
  }

};

util.makeBoundingBox = math.makeBoundingBox.bind(math);

util._staticEmptyObject = {};

util.staticEmptyObject = function () {
  return util._staticEmptyObject;
};

util.extend = Object.assign != null ? Object.assign.bind(Object) : function (tgt) {
  var args = arguments;

  for (var i = 1; i < args.length; i++) {
    var obj = args[i];

    if (obj == null) {
      continue;
    }

    var keys = Object.keys(obj);

    for (var j = 0; j < keys.length; j++) {
      var k = keys[j];

      tgt[k] = obj[k];
    }
  }

  return tgt;
};

util.assign = util.extend;

util.default = function (val, def) {
  if (val === undefined) {
    return def;
  } else {
    return val;
  }
};

util.removeFromArray = function (arr, ele, manyCopies) {
  for (var i = arr.length; i >= 0; i--) {
    if (arr[i] === ele) {
      arr.splice(i, 1);

      if (!manyCopies) {
        break;
      }
    }
  }
};

util.clearArray = function (arr) {
  arr.splice(0, arr.length);
};

util.push = function (arr, otherArr) {
  for (var i = 0; i < otherArr.length; i++) {
    var el = otherArr[i];

    arr.push(el);
  }
};

util.getPrefixedProperty = function (obj, propName, prefix) {
  if (prefix) {
    propName = this.prependCamel(prefix, propName); // e.g. (labelWidth, source) => sourceLabelWidth
  }

  return obj[propName];
};

util.setPrefixedProperty = function (obj, propName, prefix, value) {
  if (prefix) {
    propName = this.prependCamel(prefix, propName); // e.g. (labelWidth, source) => sourceLabelWidth
  }

  obj[propName] = value;
};

[__webpack_require__(21), __webpack_require__(22), { memoize: __webpack_require__(13) }, __webpack_require__(23), __webpack_require__(24), __webpack_require__(25), __webpack_require__(27)].forEach(function (req) {
  util.extend(util, req);
});

module.exports = util;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var math = {};

math.arePositionsSame = function (p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
};

math.copyPosition = function (p) {
  return { x: p.x, y: p.y };
};

math.modelToRenderedPosition = function (p, zoom, pan) {
  return {
    x: p.x * zoom + pan.x,
    y: p.y * zoom + pan.y
  };
};

math.renderedToModelPosition = function (p, zoom, pan) {
  return {
    x: (p.x - pan.x) / zoom,
    y: (p.y - pan.y) / zoom
  };
};

math.array2point = function (arr) {
  return {
    x: arr[0],
    y: arr[1]
  };
};

math.deg2rad = function (deg) {
  return Math.PI * deg / 180;
};

math.getAngleFromDisp = function (dispX, dispY) {
  return Math.atan2(dispY, dispX) - Math.PI / 2;
};

math.log2 = Math.log2 || function (n) {
  return Math.log(n) / Math.log(2);
};

math.signum = function (x) {
  if (x > 0) {
    return 1;
  } else if (x < 0) {
    return -1;
  } else {
    return 0;
  }
};

math.dist = function (p1, p2) {
  return Math.sqrt(math.sqdist(p1, p2));
};

math.sqdist = function (p1, p2) {
  var dx = p2.x - p1.x;
  var dy = p2.y - p1.y;

  return dx * dx + dy * dy;
};

// from http://en.wikipedia.org/wiki/Bézier_curve#Quadratic_curves
math.qbezierAt = function (p0, p1, p2, t) {
  return (1 - t) * (1 - t) * p0 + 2 * (1 - t) * t * p1 + t * t * p2;
};

math.qbezierPtAt = function (p0, p1, p2, t) {
  return {
    x: math.qbezierAt(p0.x, p1.x, p2.x, t),
    y: math.qbezierAt(p0.y, p1.y, p2.y, t)
  };
};

math.lineAt = function (p0, p1, t, d) {
  var vec = {
    x: p1.x - p0.x,
    y: p1.y - p0.y
  };

  var vecDist = math.dist(p0, p1);

  var normVec = {
    x: vec.x / vecDist,
    y: vec.y / vecDist
  };

  t = t == null ? 0 : t;

  d = d != null ? d : t * vecDist;

  return {
    x: p0.x + normVec.x * d,
    y: p0.y + normVec.y * d
  };
};

math.lineAtDist = function (p0, p1, d) {
  return math.lineAt(p0, p1, undefined, d);
};

// get angle at A via cosine law
math.triangleAngle = function (A, B, C) {
  var a = math.dist(B, C);
  var b = math.dist(A, C);
  var c = math.dist(A, B);

  return Math.acos((a * a + b * b - c * c) / (2 * a * b));
};

math.bound = function (min, val, max) {
  return Math.max(min, Math.min(max, val));
};

// makes a full bb (x1, y1, x2, y2, w, h) from implicit params
math.makeBoundingBox = function (bb) {
  if (bb == null) {
    return {
      x1: Infinity,
      y1: Infinity,
      x2: -Infinity,
      y2: -Infinity,
      w: 0,
      h: 0
    };
  } else if (bb.x1 != null && bb.y1 != null) {
    if (bb.x2 != null && bb.y2 != null && bb.x2 >= bb.x1 && bb.y2 >= bb.y1) {
      return {
        x1: bb.x1,
        y1: bb.y1,
        x2: bb.x2,
        y2: bb.y2,
        w: bb.x2 - bb.x1,
        h: bb.y2 - bb.y1
      };
    } else if (bb.w != null && bb.h != null && bb.w >= 0 && bb.h >= 0) {
      return {
        x1: bb.x1,
        y1: bb.y1,
        x2: bb.x1 + bb.w,
        y2: bb.y1 + bb.h,
        w: bb.w,
        h: bb.h
      };
    }
  }
};

math.updateBoundingBox = function (bb1, bb2) {
  // update bb1 with bb2 bounds

  bb1.x1 = Math.min(bb1.x1, bb2.x1);
  bb1.x2 = Math.max(bb1.x2, bb2.x2);
  bb1.w = bb1.x2 - bb1.x1;

  bb1.y1 = Math.min(bb1.y1, bb2.y1);
  bb1.y2 = Math.max(bb1.y2, bb2.y2);
  bb1.h = bb1.y2 - bb1.y1;
};

math.expandBoundingBoxByPoint = function (bb, x, y) {
  bb.x1 = Math.min(bb.x1, x);
  bb.x2 = Math.max(bb.x2, x);
  bb.w = bb.x2 - bb.x1;

  bb.y1 = Math.min(bb.y1, y);
  bb.y2 = Math.max(bb.y2, y);
  bb.h = bb.y2 - bb.y1;
};

math.expandBoundingBox = function (bb, padding) {
  bb.x1 -= padding;
  bb.x2 += padding;
  bb.y1 -= padding;
  bb.y2 += padding;
  bb.w = bb.x2 - bb.x1;
  bb.h = bb.y2 - bb.y1;

  return bb;
};

math.boundingBoxesIntersect = function (bb1, bb2) {
  // case: one bb to right of other
  if (bb1.x1 > bb2.x2) {
    return false;
  }
  if (bb2.x1 > bb1.x2) {
    return false;
  }

  // case: one bb to left of other
  if (bb1.x2 < bb2.x1) {
    return false;
  }
  if (bb2.x2 < bb1.x1) {
    return false;
  }

  // case: one bb above other
  if (bb1.y2 < bb2.y1) {
    return false;
  }
  if (bb2.y2 < bb1.y1) {
    return false;
  }

  // case: one bb below other
  if (bb1.y1 > bb2.y2) {
    return false;
  }
  if (bb2.y1 > bb1.y2) {
    return false;
  }

  // otherwise, must have some overlap
  return true;
};

math.inBoundingBox = function (bb, x, y) {
  return bb.x1 <= x && x <= bb.x2 && bb.y1 <= y && y <= bb.y2;
};

math.pointInBoundingBox = function (bb, pt) {
  return this.inBoundingBox(bb, pt.x, pt.y);
};

math.boundingBoxInBoundingBox = function (bb1, bb2) {
  return math.inBoundingBox(bb1, bb2.x1, bb2.y1) && math.inBoundingBox(bb1, bb2.x2, bb2.y2);
};

math.roundRectangleIntersectLine = function (x, y, nodeX, nodeY, width, height, padding) {

  var cornerRadius = this.getRoundRectangleRadius(width, height);

  var halfWidth = width / 2;
  var halfHeight = height / 2;

  // Check intersections with straight line segments
  var straightLineIntersections = void 0;

  // Top segment, left to right
  {
    var topStartX = nodeX - halfWidth + cornerRadius - padding;
    var topStartY = nodeY - halfHeight - padding;
    var topEndX = nodeX + halfWidth - cornerRadius + padding;
    var topEndY = topStartY;

    straightLineIntersections = this.finiteLinesIntersect(x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false);

    if (straightLineIntersections.length > 0) {
      return straightLineIntersections;
    }
  }

  // Right segment, top to bottom
  {
    var rightStartX = nodeX + halfWidth + padding;
    var rightStartY = nodeY - halfHeight + cornerRadius - padding;
    var rightEndX = rightStartX;
    var rightEndY = nodeY + halfHeight - cornerRadius + padding;

    straightLineIntersections = this.finiteLinesIntersect(x, y, nodeX, nodeY, rightStartX, rightStartY, rightEndX, rightEndY, false);

    if (straightLineIntersections.length > 0) {
      return straightLineIntersections;
    }
  }

  // Bottom segment, left to right
  {
    var bottomStartX = nodeX - halfWidth + cornerRadius - padding;
    var bottomStartY = nodeY + halfHeight + padding;
    var bottomEndX = nodeX + halfWidth - cornerRadius + padding;
    var bottomEndY = bottomStartY;

    straightLineIntersections = this.finiteLinesIntersect(x, y, nodeX, nodeY, bottomStartX, bottomStartY, bottomEndX, bottomEndY, false);

    if (straightLineIntersections.length > 0) {
      return straightLineIntersections;
    }
  }

  // Left segment, top to bottom
  {
    var leftStartX = nodeX - halfWidth - padding;
    var leftStartY = nodeY - halfHeight + cornerRadius - padding;
    var leftEndX = leftStartX;
    var leftEndY = nodeY + halfHeight - cornerRadius + padding;

    straightLineIntersections = this.finiteLinesIntersect(x, y, nodeX, nodeY, leftStartX, leftStartY, leftEndX, leftEndY, false);

    if (straightLineIntersections.length > 0) {
      return straightLineIntersections;
    }
  }

  // Check intersections with arc segments
  var arcIntersections = void 0;

  // Top Left
  {
    var topLeftCenterX = nodeX - halfWidth + cornerRadius;
    var topLeftCenterY = nodeY - halfHeight + cornerRadius;
    arcIntersections = this.intersectLineCircle(x, y, nodeX, nodeY, topLeftCenterX, topLeftCenterY, cornerRadius + padding);

    // Ensure the intersection is on the desired quarter of the circle
    if (arcIntersections.length > 0 && arcIntersections[0] <= topLeftCenterX && arcIntersections[1] <= topLeftCenterY) {
      return [arcIntersections[0], arcIntersections[1]];
    }
  }

  // Top Right
  {
    var topRightCenterX = nodeX + halfWidth - cornerRadius;
    var topRightCenterY = nodeY - halfHeight + cornerRadius;
    arcIntersections = this.intersectLineCircle(x, y, nodeX, nodeY, topRightCenterX, topRightCenterY, cornerRadius + padding);

    // Ensure the intersection is on the desired quarter of the circle
    if (arcIntersections.length > 0 && arcIntersections[0] >= topRightCenterX && arcIntersections[1] <= topRightCenterY) {
      return [arcIntersections[0], arcIntersections[1]];
    }
  }

  // Bottom Right
  {
    var bottomRightCenterX = nodeX + halfWidth - cornerRadius;
    var bottomRightCenterY = nodeY + halfHeight - cornerRadius;
    arcIntersections = this.intersectLineCircle(x, y, nodeX, nodeY, bottomRightCenterX, bottomRightCenterY, cornerRadius + padding);

    // Ensure the intersection is on the desired quarter of the circle
    if (arcIntersections.length > 0 && arcIntersections[0] >= bottomRightCenterX && arcIntersections[1] >= bottomRightCenterY) {
      return [arcIntersections[0], arcIntersections[1]];
    }
  }

  // Bottom Left
  {
    var bottomLeftCenterX = nodeX - halfWidth + cornerRadius;
    var bottomLeftCenterY = nodeY + halfHeight - cornerRadius;
    arcIntersections = this.intersectLineCircle(x, y, nodeX, nodeY, bottomLeftCenterX, bottomLeftCenterY, cornerRadius + padding);

    // Ensure the intersection is on the desired quarter of the circle
    if (arcIntersections.length > 0 && arcIntersections[0] <= bottomLeftCenterX && arcIntersections[1] >= bottomLeftCenterY) {
      return [arcIntersections[0], arcIntersections[1]];
    }
  }

  return []; // if nothing
};

math.inLineVicinity = function (x, y, lx1, ly1, lx2, ly2, tolerance) {
  var t = tolerance;

  var x1 = Math.min(lx1, lx2);
  var x2 = Math.max(lx1, lx2);
  var y1 = Math.min(ly1, ly2);
  var y2 = Math.max(ly1, ly2);

  return x1 - t <= x && x <= x2 + t && y1 - t <= y && y <= y2 + t;
};

math.inBezierVicinity = function (x, y, x1, y1, x2, y2, x3, y3, tolerance) {

  var bb = {
    x1: Math.min(x1, x3, x2) - tolerance,
    x2: Math.max(x1, x3, x2) + tolerance,
    y1: Math.min(y1, y3, y2) - tolerance,
    y2: Math.max(y1, y3, y2) + tolerance
  };

  // if outside the rough bounding box for the bezier, then it can't be a hit
  if (x < bb.x1 || x > bb.x2 || y < bb.y1 || y > bb.y2) {
    // console.log('bezier out of rough bb')
    return false;
  } else {
    // console.log('do more expensive check');
    return true;
  }
};
math.solveQuadratic = function (a, b, c, val) {
  c -= val;

  var r = b * b - 4 * a * c;

  if (r < 0) {
    return [];
  }

  var sqrtR = Math.sqrt(r);
  var denom = 2 * a;
  var root1 = (-b + sqrtR) / denom;
  var root2 = (-b - sqrtR) / denom;

  return [root1, root2];
};

math.solveCubic = function (a, b, c, d, result) {

  // Solves a cubic function, returns root in form [r1, i1, r2, i2, r3, i3], where
  // r is the real component, i is the imaginary component

  // An implementation of the Cardano method from the year 1545
  // http://en.wikipedia.org/wiki/Cubic_function#The_nature_of_the_roots

  b /= a;
  c /= a;
  d /= a;

  var discriminant = void 0,
      q = void 0,
      r = void 0,
      dum1 = void 0,
      s = void 0,
      t = void 0,
      term1 = void 0,
      r13 = void 0;

  q = (3.0 * c - b * b) / 9.0;
  r = -(27.0 * d) + b * (9.0 * c - 2.0 * (b * b));
  r /= 54.0;

  discriminant = q * q * q + r * r;
  result[1] = 0;
  term1 = b / 3.0;

  if (discriminant > 0) {
    s = r + Math.sqrt(discriminant);
    s = s < 0 ? -Math.pow(-s, 1.0 / 3.0) : Math.pow(s, 1.0 / 3.0);
    t = r - Math.sqrt(discriminant);
    t = t < 0 ? -Math.pow(-t, 1.0 / 3.0) : Math.pow(t, 1.0 / 3.0);
    result[0] = -term1 + s + t;
    term1 += (s + t) / 2.0;
    result[4] = result[2] = -term1;
    term1 = Math.sqrt(3.0) * (-t + s) / 2;
    result[3] = term1;
    result[5] = -term1;
    return;
  }

  result[5] = result[3] = 0;

  if (discriminant === 0) {
    r13 = r < 0 ? -Math.pow(-r, 1.0 / 3.0) : Math.pow(r, 1.0 / 3.0);
    result[0] = -term1 + 2.0 * r13;
    result[4] = result[2] = -(r13 + term1);
    return;
  }

  q = -q;
  dum1 = q * q * q;
  dum1 = Math.acos(r / Math.sqrt(dum1));
  r13 = 2.0 * Math.sqrt(q);
  result[0] = -term1 + r13 * Math.cos(dum1 / 3.0);
  result[2] = -term1 + r13 * Math.cos((dum1 + 2.0 * Math.PI) / 3.0);
  result[4] = -term1 + r13 * Math.cos((dum1 + 4.0 * Math.PI) / 3.0);

  return;
};

math.sqdistToQuadraticBezier = function (x, y, x1, y1, x2, y2, x3, y3) {

  // Find minimum distance by using the minimum of the distance
  // function between the given point and the curve

  // This gives the coefficients of the resulting cubic equation
  // whose roots tell us where a possible minimum is
  // (Coefficients are divided by 4)

  var a = 1.0 * x1 * x1 - 4 * x1 * x2 + 2 * x1 * x3 + 4 * x2 * x2 - 4 * x2 * x3 + x3 * x3 + y1 * y1 - 4 * y1 * y2 + 2 * y1 * y3 + 4 * y2 * y2 - 4 * y2 * y3 + y3 * y3;

  var b = 1.0 * 9 * x1 * x2 - 3 * x1 * x1 - 3 * x1 * x3 - 6 * x2 * x2 + 3 * x2 * x3 + 9 * y1 * y2 - 3 * y1 * y1 - 3 * y1 * y3 - 6 * y2 * y2 + 3 * y2 * y3;

  var c = 1.0 * 3 * x1 * x1 - 6 * x1 * x2 + x1 * x3 - x1 * x + 2 * x2 * x2 + 2 * x2 * x - x3 * x + 3 * y1 * y1 - 6 * y1 * y2 + y1 * y3 - y1 * y + 2 * y2 * y2 + 2 * y2 * y - y3 * y;

  var d = 1.0 * x1 * x2 - x1 * x1 + x1 * x - x2 * x + y1 * y2 - y1 * y1 + y1 * y - y2 * y;

  // debug("coefficients: " + a / a + ", " + b / a + ", " + c / a + ", " + d / a);

  var roots = [];

  // Use the cubic solving algorithm
  this.solveCubic(a, b, c, d, roots);

  var zeroThreshold = 0.0000001;

  var params = [];

  for (var index = 0; index < 6; index += 2) {
    if (Math.abs(roots[index + 1]) < zeroThreshold && roots[index] >= 0 && roots[index] <= 1.0) {
      params.push(roots[index]);
    }
  }

  params.push(1.0);
  params.push(0.0);

  var minDistanceSquared = -1;

  var curX = void 0,
      curY = void 0,
      distSquared = void 0;
  for (var i = 0; i < params.length; i++) {
    curX = Math.pow(1.0 - params[i], 2.0) * x1 + 2.0 * (1 - params[i]) * params[i] * x2 + params[i] * params[i] * x3;

    curY = Math.pow(1 - params[i], 2.0) * y1 + 2 * (1.0 - params[i]) * params[i] * y2 + params[i] * params[i] * y3;

    distSquared = Math.pow(curX - x, 2) + Math.pow(curY - y, 2);
    // debug('distance for param ' + params[i] + ": " + Math.sqrt(distSquared));
    if (minDistanceSquared >= 0) {
      if (distSquared < minDistanceSquared) {
        minDistanceSquared = distSquared;
      }
    } else {
      minDistanceSquared = distSquared;
    }
  }

  return minDistanceSquared;
};

math.sqdistToFiniteLine = function (x, y, x1, y1, x2, y2) {
  var offset = [x - x1, y - y1];
  var line = [x2 - x1, y2 - y1];

  var lineSq = line[0] * line[0] + line[1] * line[1];
  var hypSq = offset[0] * offset[0] + offset[1] * offset[1];

  var dotProduct = offset[0] * line[0] + offset[1] * line[1];
  var adjSq = dotProduct * dotProduct / lineSq;

  if (dotProduct < 0) {
    return hypSq;
  }

  if (adjSq > lineSq) {
    return (x - x2) * (x - x2) + (y - y2) * (y - y2);
  }

  return hypSq - adjSq;
};

math.pointInsidePolygonPoints = function (x, y, points) {
  var x1 = void 0,
      y1 = void 0,
      x2 = void 0,
      y2 = void 0;
  var y3 = void 0;

  // Intersect with vertical line through (x, y)
  var up = 0;
  // let down = 0;
  for (var i = 0; i < points.length / 2; i++) {
    x1 = points[i * 2];
    y1 = points[i * 2 + 1];

    if (i + 1 < points.length / 2) {
      x2 = points[(i + 1) * 2];
      y2 = points[(i + 1) * 2 + 1];
    } else {
      x2 = points[(i + 1 - points.length / 2) * 2];
      y2 = points[(i + 1 - points.length / 2) * 2 + 1];
    }

    if (x1 == x && x2 == x) {
      // then ignore
    } else if (x1 >= x && x >= x2 || x1 <= x && x <= x2) {

      y3 = (x - x1) / (x2 - x1) * (y2 - y1) + y1;

      if (y3 > y) {
        up++;
      }

      // if( y3 < y ){
      // down++;
      // }
    } else {
      continue;
    }
  }

  if (up % 2 === 0) {
    return false;
  } else {
    return true;
  }
};

math.pointInsidePolygon = function (x, y, basePoints, centerX, centerY, width, height, direction, padding) {

  //let direction = arguments[6];
  var transformedPoints = new Array(basePoints.length);

  // Gives negative angle
  var angle = void 0;

  if (direction[0] != null) {
    angle = Math.atan(direction[1] / direction[0]);

    if (direction[0] < 0) {
      angle = angle + Math.PI / 2;
    } else {
      angle = -angle - Math.PI / 2;
    }
  } else {
    angle = direction;
  }

  var cos = Math.cos(-angle);
  var sin = Math.sin(-angle);

  //    console.log("base: " + basePoints);
  for (var i = 0; i < transformedPoints.length / 2; i++) {
    transformedPoints[i * 2] = width / 2 * (basePoints[i * 2] * cos - basePoints[i * 2 + 1] * sin);

    transformedPoints[i * 2 + 1] = height / 2 * (basePoints[i * 2 + 1] * cos + basePoints[i * 2] * sin);

    transformedPoints[i * 2] += centerX;
    transformedPoints[i * 2 + 1] += centerY;
  }

  var points = void 0;

  if (padding > 0) {
    var expandedLineSet = this.expandPolygon(transformedPoints, -padding);

    points = this.joinLines(expandedLineSet);
  } else {
    points = transformedPoints;
  }

  return math.pointInsidePolygonPoints(x, y, points);
};

math.joinLines = function (lineSet) {

  var vertices = new Array(lineSet.length / 2);

  var currentLineStartX = void 0,
      currentLineStartY = void 0,
      currentLineEndX = void 0,
      currentLineEndY = void 0;
  var nextLineStartX = void 0,
      nextLineStartY = void 0,
      nextLineEndX = void 0,
      nextLineEndY = void 0;

  for (var i = 0; i < lineSet.length / 4; i++) {
    currentLineStartX = lineSet[i * 4];
    currentLineStartY = lineSet[i * 4 + 1];
    currentLineEndX = lineSet[i * 4 + 2];
    currentLineEndY = lineSet[i * 4 + 3];

    if (i < lineSet.length / 4 - 1) {
      nextLineStartX = lineSet[(i + 1) * 4];
      nextLineStartY = lineSet[(i + 1) * 4 + 1];
      nextLineEndX = lineSet[(i + 1) * 4 + 2];
      nextLineEndY = lineSet[(i + 1) * 4 + 3];
    } else {
      nextLineStartX = lineSet[0];
      nextLineStartY = lineSet[1];
      nextLineEndX = lineSet[2];
      nextLineEndY = lineSet[3];
    }

    var intersection = this.finiteLinesIntersect(currentLineStartX, currentLineStartY, currentLineEndX, currentLineEndY, nextLineStartX, nextLineStartY, nextLineEndX, nextLineEndY, true);

    vertices[i * 2] = intersection[0];
    vertices[i * 2 + 1] = intersection[1];
  }

  return vertices;
};

math.expandPolygon = function (points, pad) {

  var expandedLineSet = new Array(points.length * 2);

  var currentPointX = void 0,
      currentPointY = void 0,
      nextPointX = void 0,
      nextPointY = void 0;

  for (var i = 0; i < points.length / 2; i++) {
    currentPointX = points[i * 2];
    currentPointY = points[i * 2 + 1];

    if (i < points.length / 2 - 1) {
      nextPointX = points[(i + 1) * 2];
      nextPointY = points[(i + 1) * 2 + 1];
    } else {
      nextPointX = points[0];
      nextPointY = points[1];
    }

    // Current line: [currentPointX, currentPointY] to [nextPointX, nextPointY]

    // Assume CCW polygon winding

    var offsetX = nextPointY - currentPointY;
    var offsetY = -(nextPointX - currentPointX);

    // Normalize
    var offsetLength = Math.sqrt(offsetX * offsetX + offsetY * offsetY);
    var normalizedOffsetX = offsetX / offsetLength;
    var normalizedOffsetY = offsetY / offsetLength;

    expandedLineSet[i * 4] = currentPointX + normalizedOffsetX * pad;
    expandedLineSet[i * 4 + 1] = currentPointY + normalizedOffsetY * pad;
    expandedLineSet[i * 4 + 2] = nextPointX + normalizedOffsetX * pad;
    expandedLineSet[i * 4 + 3] = nextPointY + normalizedOffsetY * pad;
  }

  return expandedLineSet;
};

math.intersectLineEllipse = function (x, y, centerX, centerY, ellipseWradius, ellipseHradius) {

  var dispX = centerX - x;
  var dispY = centerY - y;

  dispX /= ellipseWradius;
  dispY /= ellipseHradius;

  var len = Math.sqrt(dispX * dispX + dispY * dispY);

  var newLength = len - 1;

  if (newLength < 0) {
    return [];
  }

  var lenProportion = newLength / len;

  return [(centerX - x) * lenProportion + x, (centerY - y) * lenProportion + y];
};

math.checkInEllipse = function (x, y, width, height, centerX, centerY, padding) {
  x -= centerX;
  y -= centerY;

  x /= width / 2 + padding;
  y /= height / 2 + padding;

  return x * x + y * y <= 1;
};

// Returns intersections of increasing distance from line's start point
math.intersectLineCircle = function (x1, y1, x2, y2, centerX, centerY, radius) {

  // Calculate d, direction vector of line
  var d = [x2 - x1, y2 - y1]; // Direction vector of line
  var f = [x1 - centerX, y1 - centerY];

  var a = d[0] * d[0] + d[1] * d[1];
  var b = 2 * (f[0] * d[0] + f[1] * d[1]);
  var c = f[0] * f[0] + f[1] * f[1] - radius * radius;

  var discriminant = b * b - 4 * a * c;

  if (discriminant < 0) {
    return [];
  }

  var t1 = (-b + Math.sqrt(discriminant)) / (2 * a);
  var t2 = (-b - Math.sqrt(discriminant)) / (2 * a);

  var tMin = Math.min(t1, t2);
  var tMax = Math.max(t1, t2);
  var inRangeParams = [];

  if (tMin >= 0 && tMin <= 1) {
    inRangeParams.push(tMin);
  }

  if (tMax >= 0 && tMax <= 1) {
    inRangeParams.push(tMax);
  }

  if (inRangeParams.length === 0) {
    return [];
  }

  var nearIntersectionX = inRangeParams[0] * d[0] + x1;
  var nearIntersectionY = inRangeParams[0] * d[1] + y1;

  if (inRangeParams.length > 1) {

    if (inRangeParams[0] == inRangeParams[1]) {
      return [nearIntersectionX, nearIntersectionY];
    } else {

      var farIntersectionX = inRangeParams[1] * d[0] + x1;
      var farIntersectionY = inRangeParams[1] * d[1] + y1;

      return [nearIntersectionX, nearIntersectionY, farIntersectionX, farIntersectionY];
    }
  } else {
    return [nearIntersectionX, nearIntersectionY];
  }
};

math.findCircleNearPoint = function (centerX, centerY, radius, farX, farY) {

  var displacementX = farX - centerX;
  var displacementY = farY - centerY;
  var distance = Math.sqrt(displacementX * displacementX + displacementY * displacementY);

  var unitDisplacementX = displacementX / distance;
  var unitDisplacementY = displacementY / distance;

  return [centerX + unitDisplacementX * radius, centerY + unitDisplacementY * radius];
};

math.findMaxSqDistanceToOrigin = function (points) {
  var maxSqDistance = 0.000001;
  var sqDistance = void 0;

  for (var i = 0; i < points.length / 2; i++) {

    sqDistance = points[i * 2] * points[i * 2] + points[i * 2 + 1] * points[i * 2 + 1];

    if (sqDistance > maxSqDistance) {
      maxSqDistance = sqDistance;
    }
  }

  return maxSqDistance;
};

math.midOfThree = function (a, b, c) {
  if (b <= a && a <= c || c <= a && a <= b) {
    return a;
  } else if (a <= b && b <= c || c <= b && b <= a) {
    return b;
  } else {
    return c;
  }
};

// (x1,y1)=>(x2,y2) intersect with (x3,y3)=>(x4,y4)
math.finiteLinesIntersect = function (x1, y1, x2, y2, x3, y3, x4, y4, infiniteLines) {

  var dx13 = x1 - x3;
  var dx21 = x2 - x1;
  var dx43 = x4 - x3;

  var dy13 = y1 - y3;
  var dy21 = y2 - y1;
  var dy43 = y4 - y3;

  var ua_t = dx43 * dy13 - dy43 * dx13;
  var ub_t = dx21 * dy13 - dy21 * dx13;
  var u_b = dy43 * dx21 - dx43 * dy21;

  if (u_b !== 0) {
    var ua = ua_t / u_b;
    var ub = ub_t / u_b;

    var flptThreshold = 0.001;
    var min = 0 - flptThreshold;
    var max = 1 + flptThreshold;

    if (min <= ua && ua <= max && min <= ub && ub <= max) {
      return [x1 + ua * dx21, y1 + ua * dy21];
    } else {
      if (!infiniteLines) {
        return [];
      } else {
        return [x1 + ua * dx21, y1 + ua * dy21];
      }
    }
  } else {
    if (ua_t === 0 || ub_t === 0) {

      // Parallel, coincident lines. Check if overlap

      // Check endpoint of second line
      if (this.midOfThree(x1, x2, x4) === x4) {
        return [x4, y4];
      }

      // Check start point of second line
      if (this.midOfThree(x1, x2, x3) === x3) {
        return [x3, y3];
      }

      // Endpoint of first line
      if (this.midOfThree(x3, x4, x2) === x2) {
        return [x2, y2];
      }

      return [];
    } else {

      // Parallel, non-coincident
      return [];
    }
  }
};

// math.polygonIntersectLine( x, y, basePoints, centerX, centerY, width, height, padding )
// intersect a node polygon (pts transformed)
//
// math.polygonIntersectLine( x, y, basePoints, centerX, centerY )
// intersect the points (no transform)
math.polygonIntersectLine = function (x, y, basePoints, centerX, centerY, width, height, padding) {

  var intersections = [];
  var intersection = void 0;

  var transformedPoints = new Array(basePoints.length);

  var doTransform = true;
  if (arguments.length === 5) {
    doTransform = false;
  }

  var points = void 0;

  if (doTransform) {
    for (var i = 0; i < transformedPoints.length / 2; i++) {
      transformedPoints[i * 2] = basePoints[i * 2] * width + centerX;
      transformedPoints[i * 2 + 1] = basePoints[i * 2 + 1] * height + centerY;
    }

    if (padding > 0) {
      var expandedLineSet = math.expandPolygon(transformedPoints, -padding);

      points = math.joinLines(expandedLineSet);
    } else {
      points = transformedPoints;
    }
  } else {
    points = basePoints;
  }

  var currentX = void 0,
      currentY = void 0,
      nextX = void 0,
      nextY = void 0;

  for (var _i = 0; _i < points.length / 2; _i++) {

    currentX = points[_i * 2];
    currentY = points[_i * 2 + 1];

    if (_i < points.length / 2 - 1) {
      nextX = points[(_i + 1) * 2];
      nextY = points[(_i + 1) * 2 + 1];
    } else {
      nextX = points[0];
      nextY = points[1];
    }

    intersection = this.finiteLinesIntersect(x, y, centerX, centerY, currentX, currentY, nextX, nextY);

    if (intersection.length !== 0) {
      intersections.push(intersection[0], intersection[1]);
    }
  }

  return intersections;
};

math.shortenIntersection = function (intersection, offset, amount) {

  var disp = [intersection[0] - offset[0], intersection[1] - offset[1]];

  var length = Math.sqrt(disp[0] * disp[0] + disp[1] * disp[1]);

  var lenRatio = (length - amount) / length;

  if (lenRatio < 0) {
    lenRatio = 0.00001;
  }

  return [offset[0] + lenRatio * disp[0], offset[1] + lenRatio * disp[1]];
};

math.generateUnitNgonPointsFitToSquare = function (sides, rotationRadians) {
  var points = math.generateUnitNgonPoints(sides, rotationRadians);
  points = math.fitPolygonToSquare(points);

  return points;
};

math.fitPolygonToSquare = function (points) {
  var x = void 0,
      y = void 0;
  var sides = points.length / 2;
  var minX = Infinity,
      minY = Infinity,
      maxX = -Infinity,
      maxY = -Infinity;

  for (var i = 0; i < sides; i++) {
    x = points[2 * i];
    y = points[2 * i + 1];

    minX = Math.min(minX, x);
    maxX = Math.max(maxX, x);
    minY = Math.min(minY, y);
    maxY = Math.max(maxY, y);
  }

  // stretch factors
  var sx = 2 / (maxX - minX);
  var sy = 2 / (maxY - minY);

  for (var _i2 = 0; _i2 < sides; _i2++) {
    x = points[2 * _i2] = points[2 * _i2] * sx;
    y = points[2 * _i2 + 1] = points[2 * _i2 + 1] * sy;

    minX = Math.min(minX, x);
    maxX = Math.max(maxX, x);
    minY = Math.min(minY, y);
    maxY = Math.max(maxY, y);
  }

  if (minY < -1) {
    for (var _i3 = 0; _i3 < sides; _i3++) {
      y = points[2 * _i3 + 1] = points[2 * _i3 + 1] + (-1 - minY);
    }
  }

  return points;
};

math.generateUnitNgonPoints = function (sides, rotationRadians) {

  var increment = 1.0 / sides * 2 * Math.PI;
  var startAngle = sides % 2 === 0 ? Math.PI / 2.0 + increment / 2.0 : Math.PI / 2.0;

  startAngle += rotationRadians;

  var points = new Array(sides * 2);

  var currentAngle = void 0;
  for (var i = 0; i < sides; i++) {
    currentAngle = i * increment + startAngle;

    points[2 * i] = Math.cos(currentAngle); // x
    points[2 * i + 1] = Math.sin(-currentAngle); // y
  }

  return points;
};

math.getRoundRectangleRadius = function (width, height) {

  // Set the default radius, unless half of width or height is smaller than default
  return Math.min(width / 4, height / 4, 8);
};

math.getCutRectangleCornerLength = function () {
  return 8;
};

math.bezierPtsToQuadCoeff = function (p0, p1, p2) {
  return [p0 - 2 * p1 + p2, 2 * (p1 - p0), p0];
};

math.getBarrelCurveConstants = function (width, height) {
  // get curve width, height, and control point position offsets as a percentage of node height / width
  return {
    heightOffset: Math.min(15, 0.05 * height),
    widthOffset: Math.min(100, 0.25 * width),
    ctrlPtOffsetPct: 0.05
  };
};

module.exports = math;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = typeof window === 'undefined' ? null : window; // eslint-disable-line no-undef

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// use this module to cherry pick functions into your prototype
// (useful for functions shared between the core and collections, for example)

// e.g.
// let foo = define.foo({ /* params... */ })

var util = __webpack_require__(1);

var define = {};

[__webpack_require__(43), __webpack_require__(45), __webpack_require__(46)].forEach(function (m) {
  util.assign(define, m);
});

module.exports = define;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
Embeddable Minimum Strictly-Compliant Promises/A+ 1.1.1 Thenable
Copyright (c) 2013-2014 Ralf S. Engelschall (http://engelschall.com)
Licensed under The MIT License (http://opensource.org/licenses/MIT)
*/

/*  promise states [Promises/A+ 2.1]  */
var STATE_PENDING = 0; /*  [Promises/A+ 2.1.1]  */
var STATE_FULFILLED = 1; /*  [Promises/A+ 2.1.2]  */
var STATE_REJECTED = 2; /*  [Promises/A+ 2.1.3]  */

/*  promise object constructor  */
var api = function api(executor) {
  /*  optionally support non-constructor/plain-function call  */
  if (!(this instanceof api)) return new api(executor);

  /*  initialize object  */
  this.id = 'Thenable/1.0.7';
  this.state = STATE_PENDING; /*  initial state  */
  this.fulfillValue = undefined; /*  initial value  */ /*  [Promises/A+ 1.3, 2.1.2.2]  */
  this.rejectReason = undefined; /*  initial reason */ /*  [Promises/A+ 1.5, 2.1.3.2]  */
  this.onFulfilled = []; /*  initial handlers  */
  this.onRejected = []; /*  initial handlers  */

  /*  provide optional information-hiding proxy  */
  this.proxy = {
    then: this.then.bind(this)
  };

  /*  support optional executor function  */
  if (typeof executor === 'function') executor.call(this, this.fulfill.bind(this), this.reject.bind(this));
};

/*  promise API methods  */
api.prototype = {
  /*  promise resolving methods  */
  fulfill: function fulfill(value) {
    return deliver(this, STATE_FULFILLED, 'fulfillValue', value);
  },
  reject: function reject(value) {
    return deliver(this, STATE_REJECTED, 'rejectReason', value);
  },

  /*  "The then Method" [Promises/A+ 1.1, 1.2, 2.2]  */
  then: function then(onFulfilled, onRejected) {
    var curr = this;
    var next = new api(); /*  [Promises/A+ 2.2.7]  */
    curr.onFulfilled.push(resolver(onFulfilled, next, 'fulfill')); /*  [Promises/A+ 2.2.2/2.2.6]  */
    curr.onRejected.push(resolver(onRejected, next, 'reject')); /*  [Promises/A+ 2.2.3/2.2.6]  */
    execute(curr);
    return next.proxy; /*  [Promises/A+ 2.2.7, 3.3]  */
  }
};

/*  deliver an action  */
var deliver = function deliver(curr, state, name, value) {
  if (curr.state === STATE_PENDING) {
    curr.state = state; /*  [Promises/A+ 2.1.2.1, 2.1.3.1]  */
    curr[name] = value; /*  [Promises/A+ 2.1.2.2, 2.1.3.2]  */
    execute(curr);
  }
  return curr;
};

/*  execute all handlers  */
var execute = function execute(curr) {
  if (curr.state === STATE_FULFILLED) execute_handlers(curr, 'onFulfilled', curr.fulfillValue);else if (curr.state === STATE_REJECTED) execute_handlers(curr, 'onRejected', curr.rejectReason);
};

/*  execute particular set of handlers  */
var execute_handlers = function execute_handlers(curr, name, value) {
  /* global setImmediate: true */
  /* global setTimeout: true */

  /*  short-circuit processing  */
  if (curr[name].length === 0) return;

  /*  iterate over all handlers, exactly once  */
  var handlers = curr[name];
  curr[name] = []; /*  [Promises/A+ 2.2.2.3, 2.2.3.3]  */
  var func = function func() {
    for (var i = 0; i < handlers.length; i++) {
      handlers[i](value);
    } /*  [Promises/A+ 2.2.5]  */
  };

  /*  execute procedure asynchronously  */ /*  [Promises/A+ 2.2.4, 3.1]  */
  if (typeof setImmediate === 'function') setImmediate(func);else setTimeout(func, 0);
};

/*  generate a resolver function  */
var resolver = function resolver(cb, next, method) {
  return function (value) {
    if (typeof cb !== 'function') /*  [Promises/A+ 2.2.1, 2.2.7.3, 2.2.7.4]  */
      next[method].call(next, value); /*  [Promises/A+ 2.2.7.3, 2.2.7.4]  */
    else {
        var result;
        try {
          result = cb(value);
        } /*  [Promises/A+ 2.2.2.1, 2.2.3.1, 2.2.5, 3.2]  */
        catch (e) {
          next.reject(e); /*  [Promises/A+ 2.2.7.2]  */
          return;
        }
        resolve(next, result); /*  [Promises/A+ 2.2.7.1]  */
      }
  };
};

/*  "Promise Resolution Procedure"  */ /*  [Promises/A+ 2.3]  */
var resolve = function resolve(promise, x) {
  /*  sanity check arguments  */ /*  [Promises/A+ 2.3.1]  */
  if (promise === x || promise.proxy === x) {
    promise.reject(new TypeError('cannot resolve promise with itself'));
    return;
  }

  /*  surgically check for a "then" method
    (mainly to just call the "getter" of "then" only once)  */
  var then;
  if ((typeof x === 'undefined' ? 'undefined' : _typeof(x)) === 'object' && x !== null || typeof x === 'function') {
    try {
      then = x.then;
    } /*  [Promises/A+ 2.3.3.1, 3.5]  */
    catch (e) {
      promise.reject(e); /*  [Promises/A+ 2.3.3.2]  */
      return;
    }
  }

  /*  handle own Thenables    [Promises/A+ 2.3.2]
    and similar "thenables" [Promises/A+ 2.3.3]  */
  if (typeof then === 'function') {
    var resolved = false;
    try {
      /*  call retrieved "then" method */ /*  [Promises/A+ 2.3.3.3]  */
      then.call(x,
      /*  resolvePromise  */ /*  [Promises/A+ 2.3.3.3.1]  */
      function (y) {
        if (resolved) return;resolved = true; /*  [Promises/A+ 2.3.3.3.3]  */
        if (y === x) /*  [Promises/A+ 3.6]  */
          promise.reject(new TypeError('circular thenable chain'));else resolve(promise, y);
      },

      /*  rejectPromise  */ /*  [Promises/A+ 2.3.3.3.2]  */
      function (r) {
        if (resolved) return;resolved = true; /*  [Promises/A+ 2.3.3.3.3]  */
        promise.reject(r);
      });
    } catch (e) {
      if (!resolved) /*  [Promises/A+ 2.3.3.3.3]  */
        promise.reject(e); /*  [Promises/A+ 2.3.3.3.4]  */
    }
    return;
  }

  /*  handle other values  */
  promise.fulfill(x); /*  [Promises/A+ 2.3.4, 2.3.3.4]  */
};

// so we always have Promise.all()
api.all = function (ps) {
  return new api(function (resolveAll, rejectAll) {
    var vals = new Array(ps.length);
    var doneCount = 0;

    var fulfill = function fulfill(i, val) {
      vals[i] = val;
      doneCount++;

      if (doneCount === ps.length) {
        resolveAll(vals);
      }
    };

    for (var i = 0; i < ps.length; i++) {
      (function (i) {
        var p = ps[i];
        var isPromise = p != null && p.then != null;

        if (isPromise) {
          p.then(function (val) {
            fulfill(i, val);
          }, function (err) {
            rejectAll(err);
          });
        } else {
          var val = p;
          fulfill(i, val);
        }
      })(i);
    }
  });
};

api.resolve = function (val) {
  return new api(function (resolve, reject) {
    resolve(val);
  });
};

api.reject = function (val) {
  return new api(function (resolve, reject) {
    reject(val);
  });
};

module.exports = typeof Promise !== 'undefined' ? Promise : api; // eslint-disable-line no-undef

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);
var util = __webpack_require__(1);
var newQuery = __webpack_require__(10);

var Selector = function Selector(selector) {
  var self = this;

  self._private = {
    selectorText: selector,
    invalid: true
  };

  if (selector == null || is.string(selector) && selector.match(/^\s*$/)) {

    self.length = 0;
  } else if (selector === '*' || selector === 'edge' || selector === 'node') {

    // make single, group-only selectors cheap to make and cheap to filter

    self[0] = newQuery();
    self[0].group = selector === '*' ? selector : selector + 's';
    self[0].groupOnly = true;
    self[0].length = 1;
    self._private.invalid = false;
    self.length = 1;
  } else if (is.elementOrCollection(selector)) {

    var collection = selector.collection();

    self[0] = newQuery();
    self[0].collection = collection;
    self[0].length = 1;
    self.length = 1;
  } else if (is.fn(selector)) {

    self[0] = newQuery();
    self[0].filter = selector;
    self[0].length = 1;
    self.length = 1;
  } else if (is.string(selector)) {
    if (!self.parse(selector)) {
      return;
    }
  } else {
    util.error('A selector must be created from a string; found ', selector);
    return;
  }

  self._private.invalid = false;
};

var selfn = Selector.prototype;

selfn.valid = function () {
  return !this._private.invalid;
};

selfn.invalid = function () {
  return this._private.invalid;
};

selfn.text = function () {
  return this._private.selectorText;
};

selfn.size = function () {
  return this.length;
};

selfn.eq = function (i) {
  return this[i];
};

selfn.sameText = function (otherSel) {
  return this.text() === otherSel.text();
};

selfn.toString = selfn.selector = function () {

  if (this._private.toStringCache != null) {
    return this._private.toStringCache;
  }

  var i = void 0;
  var str = '';

  var clean = function clean(obj) {
    if (obj == null) {
      return '';
    } else {
      return obj;
    }
  };

  var cleanVal = function cleanVal(val) {
    if (is.string(val)) {
      return '"' + val + '"';
    } else {
      return clean(val);
    }
  };

  var space = function space(val) {
    return ' ' + val + ' ';
  };

  var queryToString = function queryToString(query) {
    var str = '';
    var j = void 0,
        sel = void 0;

    if (query.subject === query) {
      str += '$';
    }

    var group = clean(query.group);
    str += group.substring(0, group.length - 1);

    for (j = 0; j < query.data.length; j++) {
      var data = query.data[j];

      if (data.value) {
        str += '[' + data.field + space(clean(data.operator)) + cleanVal(data.value) + ']';
      } else {
        str += '[' + clean(data.operator) + data.field + ']';
      }
    }

    for (j = 0; j < query.meta.length; j++) {
      var meta = query.meta[j];
      str += '[[' + meta.field + space(clean(meta.operator)) + cleanVal(meta.value) + ']]';
    }

    for (j = 0; j < query.colonSelectors.length; j++) {
      sel = query.colonSelectors[i];
      str += sel;
    }

    for (j = 0; j < query.ids.length; j++) {
      sel = '#' + query.ids[i];
      str += sel;
    }

    for (j = 0; j < query.classes.length; j++) {
      sel = '.' + query.classes[j];
      str += sel;
    }

    if (query.source != null && query.target != null) {
      str = queryToString(query.source) + ' -> ' + queryToString(query.target);
    }

    if (query.connectedNodes != null) {
      var n = query.connectedNodes;

      str = queryToString(n[0]) + ' <-> ' + queryToString(n[1]);
    }

    if (query.parent != null) {
      str = queryToString(query.parent) + ' > ' + str;
    }

    if (query.ancestor != null) {
      str = queryToString(query.ancestor) + ' ' + str;
    }

    if (query.child != null) {
      str += ' > ' + queryToString(query.child);
    }

    if (query.descendant != null) {
      str += ' ' + queryToString(query.descendant);
    }

    return str;
  };

  for (i = 0; i < this.length; i++) {
    var query = this[i];

    str += queryToString(query);

    if (this.length > 1 && i < this.length - 1) {
      str += ', ';
    }
  }

  this._private.toStringCache = str;

  return str;
};

[__webpack_require__(49), __webpack_require__(52)].forEach(function (p) {
  return util.assign(selfn, p);
});

module.exports = Selector;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);
var is = __webpack_require__(0);
var Map = __webpack_require__(28);
var Set = __webpack_require__(8);

var Element = __webpack_require__(14);

// factory for generating edge ids when no id is specified for a new element
var idFactory = {
  generate: function generate(cy, element, tryThisId) {
    var id = tryThisId != null ? tryThisId : util.uuid();

    while (cy.hasElementWithId(id)) {
      id = util.uuid();
    }

    return id;
  }
};

// represents a set of nodes, edges, or both together
var Collection = function Collection(cy, elements, options) {
  if (cy === undefined || !is.core(cy)) {
    util.error('A collection must have a reference to the core');
    return;
  }

  var map = new Map();
  var createdElements = false;

  if (!elements) {
    elements = [];
  } else if (elements.length > 0 && is.plainObject(elements[0]) && !is.element(elements[0])) {
    createdElements = true;

    // make elements from json and restore all at once later
    var eles = [];
    var elesIds = new Set();

    for (var i = 0, l = elements.length; i < l; i++) {
      var json = elements[i];

      if (json.data == null) {
        json.data = {};
      }

      var data = json.data;

      // make sure newly created elements have valid ids
      if (data.id == null) {
        data.id = idFactory.generate(cy, json);
      } else if (cy.hasElementWithId(data.id) || elesIds.has(data.id)) {
        continue; // can't create element if prior id already exists
      }

      var ele = new Element(cy, json, false);
      eles.push(ele);
      elesIds.add(data.id);
    }

    elements = eles;
  }

  this.length = 0;

  for (var _i = 0, _l = elements.length; _i < _l; _i++) {
    var element = elements[_i];
    if (element == null) {
      continue;
    }

    var id = element._private.data.id;

    if (options == null || options.unique && !map.has(id)) {
      map.set(id, {
        index: this.length,
        ele: element
      });

      this[this.length] = element;
      this.length++;
    }
  }

  this._private = {
    cy: cy,
    map: map
  };

  // restore the elements if we created them from json
  if (createdElements) {
    this.restore();
  }
};

// Functions
////////////////////////////////////////////////////////////////////////////////////////////////////

// keep the prototypes in sync (an element has the same functions as a collection)
// and use elefn and elesfn as shorthands to the prototypes
var elesfn = Element.prototype = Collection.prototype;

elesfn.instanceString = function () {
  return 'collection';
};

elesfn.spawn = function (cy, eles, opts) {
  if (!is.core(cy)) {
    // cy is optional
    opts = eles;
    eles = cy;
    cy = this.cy();
  }

  return new Collection(cy, eles, opts);
};

elesfn.spawnSelf = function () {
  return this.spawn(this);
};

elesfn.cy = function () {
  return this._private.cy;
};

elesfn.renderer = function () {
  return this._private.cy.renderer();
};

elesfn.element = function () {
  return this[0];
};

elesfn.collection = function () {
  if (is.collection(this)) {
    return this;
  } else {
    // an element
    return new Collection(this._private.cy, [this]);
  }
};

elesfn.unique = function () {
  return new Collection(this._private.cy, this, { unique: true });
};

elesfn.hasElementWithId = function (id) {
  return this._private.map.has(id);
};

elesfn.getElementById = function (id) {
  var cy = this._private.cy;
  var entry = this._private.map.get(id);

  return entry ? entry.ele : new Collection(cy); // get ele or empty collection
};

elesfn.$id = elesfn.getElementById;

elesfn.poolIndex = function () {
  var cy = this._private.cy;
  var eles = cy._private.elements;
  var id = this._private.data.id;

  return eles._private.map.get(id).index;
};

elesfn.json = function (obj) {
  var ele = this.element();
  var cy = this.cy();

  if (ele == null && obj) {
    return this;
  } // can't set to no eles

  if (ele == null) {
    return undefined;
  } // can't get from no eles

  var p = ele._private;

  if (is.plainObject(obj)) {
    // set

    cy.startBatch();

    if (obj.data) {
      ele.data(obj.data);

      var data = p.data;

      if (ele.isEdge()) {
        // source and target are immutable via data()
        var move = false;
        var spec = {};
        var src = obj.data.source;
        var tgt = obj.data.target;

        if (src != null && src !== data.source) {
          spec.source = src;
          move = true;
        }

        if (tgt != null && tgt !== data.target) {
          spec.target = tgt;
          move = true;
        }

        if (move) {
          ele = ele.move(spec);
        }
      } else {
        // parent is immutable via data()
        var parent = obj.data.parent;

        if (parent != null && parent !== data.parent) {
          ele = ele.move({ parent: parent });
        }
      }
    }

    if (obj.position) {
      ele.position(obj.position);
    }

    // ignore group -- immutable

    var checkSwitch = function checkSwitch(k, trueFnName, falseFnName) {
      var obj_k = obj[k];

      if (obj_k != null && obj_k !== p[k]) {
        if (obj_k) {
          ele[trueFnName]();
        } else {
          ele[falseFnName]();
        }
      }
    };

    checkSwitch('removed', 'remove', 'restore');

    checkSwitch('selected', 'select', 'unselect');

    checkSwitch('selectable', 'selectify', 'unselectify');

    checkSwitch('locked', 'lock', 'unlock');

    checkSwitch('grabbable', 'grabify', 'ungrabify');

    if (obj.classes != null) {
      ele.classes(obj.classes);
    }

    cy.endBatch();

    return this;
  } else if (obj === undefined) {
    // get

    var json = {
      data: util.copy(p.data),
      position: util.copy(p.position),
      group: p.group,
      removed: p.removed,
      selected: p.selected,
      selectable: p.selectable,
      locked: p.locked,
      grabbable: p.grabbable,
      classes: null
    };

    json.classes = '';

    var i = 0;
    p.classes.forEach(function (cls) {
      return json.classes += i++ === 0 ? cls : ' ' + cls;
    });

    return json;
  }
};

elesfn.jsons = function () {
  var jsons = [];

  for (var i = 0; i < this.length; i++) {
    var ele = this[i];
    var json = ele.json();

    jsons.push(json);
  }

  return jsons;
};

elesfn.clone = function () {
  var cy = this.cy();
  var elesArr = [];

  for (var i = 0; i < this.length; i++) {
    var ele = this[i];
    var json = ele.json();
    var clone = new Element(cy, json, false); // NB no restore

    elesArr.push(clone);
  }

  return new Collection(cy, elesArr);
};
elesfn.copy = elesfn.clone;

elesfn.restore = function (notifyRenderer) {
  var self = this;
  var cy = self.cy();
  var cy_p = cy._private;

  if (notifyRenderer === undefined) {
    notifyRenderer = true;
  }

  // create arrays of nodes and edges, since we need to
  // restore the nodes first
  var nodes = [];
  var edges = [];
  var elements = void 0;
  for (var _i2 = 0, l = self.length; _i2 < l; _i2++) {
    var ele = self[_i2];

    if (!ele.removed()) {
      // don't need to handle this ele
      continue;
    }

    // keep nodes first in the array and edges after
    if (ele.isNode()) {
      // put to front of array if node
      nodes.push(ele);
    } else {
      // put to end of array if edge
      edges.push(ele);
    }
  }

  elements = nodes.concat(edges);

  var i = void 0;
  var removeFromElements = function removeFromElements() {
    elements.splice(i, 1);
    i--;
  };

  // now, restore each element
  for (i = 0; i < elements.length; i++) {
    var _ele = elements[i];

    var _private = _ele._private;
    var data = _private.data;

    // the traversal cache should start fresh when ele is added
    _ele.clearTraversalCache();

    // set id and validate
    if (data.id === undefined) {
      data.id = idFactory.generate(cy, _ele);
    } else if (is.number(data.id)) {
      data.id = '' + data.id; // now it's a string
    } else if (is.emptyString(data.id) || !is.string(data.id)) {
      util.error('Can not create element with invalid string ID `' + data.id + '`');

      // can't create element if it has empty string as id or non-string id
      removeFromElements();
      continue;
    } else if (cy.hasElementWithId(data.id)) {
      util.error('Can not create second element with ID `' + data.id + '`');

      // can't create element if one already has that id
      removeFromElements();
      continue;
    }

    var id = data.id; // id is finalised, now let's keep a ref

    if (_ele.isNode()) {
      // extra checks for nodes
      var pos = _private.position;

      // make sure the nodes have a defined position

      if (pos.x == null) {
        pos.x = 0;
      }

      if (pos.y == null) {
        pos.y = 0;
      }
    }

    if (_ele.isEdge()) {
      // extra checks for edges

      var edge = _ele;
      var fields = ['source', 'target'];
      var fieldsLength = fields.length;
      var badSourceOrTarget = false;
      for (var j = 0; j < fieldsLength; j++) {

        var field = fields[j];
        var val = data[field];

        if (is.number(val)) {
          val = data[field] = '' + data[field]; // now string
        }

        if (val == null || val === '') {
          // can't create if source or target is not defined properly
          util.error('Can not create edge `' + id + '` with unspecified ' + field);
          badSourceOrTarget = true;
        } else if (!cy.hasElementWithId(val)) {
          // can't create edge if one of its nodes doesn't exist
          util.error('Can not create edge `' + id + '` with nonexistant ' + field + ' `' + val + '`');
          badSourceOrTarget = true;
        }
      }

      if (badSourceOrTarget) {
        removeFromElements();continue;
      } // can't create this

      var src = cy.getElementById(data.source);
      var tgt = cy.getElementById(data.target);

      src._private.edges.push(edge);
      tgt._private.edges.push(edge);

      edge._private.source = src;
      edge._private.target = tgt;
    } // if is edge

    // create mock ids / indexes maps for element so it can be used like collections
    _private.map = new Map();
    _private.map.set(id, { ele: _ele, index: 0 });

    _private.removed = false;
    cy.addToPool(_ele);
  } // for each element

  // do compound node sanity checks
  for (var _i3 = 0; _i3 < nodes.length; _i3++) {
    // each node
    var node = nodes[_i3];
    var _data = node._private.data;

    if (is.number(_data.parent)) {
      // then automake string
      _data.parent = '' + _data.parent;
    }

    var parentId = _data.parent;

    var specifiedParent = parentId != null;

    if (specifiedParent) {
      var parent = cy.getElementById(parentId);

      if (parent.empty()) {
        // non-existant parent; just remove it
        _data.parent = undefined;
      } else {
        var selfAsParent = false;
        var ancestor = parent;
        while (!ancestor.empty()) {
          if (node.same(ancestor)) {
            // mark self as parent and remove from data
            selfAsParent = true;
            _data.parent = undefined; // remove parent reference

            // exit or we loop forever
            break;
          }

          ancestor = ancestor.parent();
        }

        if (!selfAsParent) {
          // connect with children
          parent[0]._private.children.push(node);
          node._private.parent = parent[0];

          // let the core know we have a compound graph
          cy_p.hasCompoundNodes = true;
        }
      } // else
    } // if specified parent
  } // for each node

  if (elements.length > 0) {
    var restored = new Collection(cy, elements);

    for (var _i4 = 0; _i4 < restored.length; _i4++) {
      var _ele2 = restored[_i4];

      if (_ele2.isNode()) {
        continue;
      }

      // adding an edge invalidates the traversal caches for the parallel edges
      _ele2.parallelEdges().clearTraversalCache();

      // adding an edge invalidates the traversal cache for the connected nodes
      _ele2.source().clearTraversalCache();
      _ele2.target().clearTraversalCache();
    }

    var toUpdateStyle = void 0;

    if (cy_p.hasCompoundNodes) {
      toUpdateStyle = cy.collection().merge(restored).merge(restored.connectedNodes()).merge(restored.parent());
    } else {
      toUpdateStyle = restored;
    }

    toUpdateStyle.dirtyCompoundBoundsCache().updateStyle(notifyRenderer);

    if (notifyRenderer) {
      restored.emitAndNotify('add');
    } else {
      restored.emit('add');
    }
  }

  return self; // chainability
};

elesfn.removed = function () {
  var ele = this[0];
  return ele && ele._private.removed;
};

elesfn.inside = function () {
  var ele = this[0];
  return ele && !ele._private.removed;
};

elesfn.remove = function (notifyRenderer) {
  var self = this;
  var removed = [];
  var elesToRemove = [];
  var elesToRemoveIds = {};
  var cy = self._private.cy;

  if (notifyRenderer === undefined) {
    notifyRenderer = true;
  }

  // add connected edges
  function addConnectedEdges(node) {
    var edges = node._private.edges;
    for (var i = 0; i < edges.length; i++) {
      add(edges[i]);
    }
  }

  // add descendant nodes
  function addChildren(node) {
    var children = node._private.children;

    for (var i = 0; i < children.length; i++) {
      add(children[i]);
    }
  }

  function add(ele) {
    var alreadyAdded = elesToRemoveIds[ele.id()];
    if (ele.removed() || alreadyAdded) {
      return;
    } else {
      elesToRemoveIds[ele.id()] = true;
    }

    if (ele.isNode()) {
      elesToRemove.push(ele); // nodes are removed last

      addConnectedEdges(ele);
      addChildren(ele);
    } else {
      elesToRemove.unshift(ele); // edges are removed first
    }
  }

  // make the list of elements to remove
  // (may be removing more than specified due to connected edges etc)

  for (var i = 0, l = self.length; i < l; i++) {
    var ele = self[i];

    add(ele);
  }

  function removeEdgeRef(node, edge) {
    var connectedEdges = node._private.edges;

    util.removeFromArray(connectedEdges, edge);

    // removing an edges invalidates the traversal cache for its nodes
    node.clearTraversalCache();
  }

  function removeParallelRefs(edge) {
    // removing an edge invalidates the traversal caches for the parallel edges
    edge.parallelEdges().clearTraversalCache();
  }

  var alteredParents = [];
  alteredParents.ids = {};

  function removeChildRef(parent, ele) {
    ele = ele[0];
    parent = parent[0];

    var children = parent._private.children;
    var pid = parent.id();

    util.removeFromArray(children, ele);

    if (!alteredParents.ids[pid]) {
      alteredParents.ids[pid] = true;
      alteredParents.push(parent);
    }
  }

  self.dirtyCompoundBoundsCache();

  cy.removeFromPool(elesToRemove); // remove from core pool

  for (var _i5 = 0; _i5 < elesToRemove.length; _i5++) {
    var _ele3 = elesToRemove[_i5];

    // mark as removed
    _ele3._private.removed = true;

    // add to list of removed elements
    removed.push(_ele3);

    if (_ele3.isEdge()) {
      // remove references to this edge in its connected nodes
      var src = _ele3.source()[0];
      var tgt = _ele3.target()[0];

      removeEdgeRef(src, _ele3);
      removeEdgeRef(tgt, _ele3);
      removeParallelRefs(_ele3);
    } else {
      // remove reference to parent
      var parent = _ele3.parent();

      if (parent.length !== 0) {
        removeChildRef(parent, _ele3);
      }
    }
  }

  // check to see if we have a compound graph or not
  var elesStillInside = cy._private.elements;
  cy._private.hasCompoundNodes = false;
  for (var _i6 = 0; _i6 < elesStillInside.length; _i6++) {
    var _ele4 = elesStillInside[_i6];

    if (_ele4.isParent()) {
      cy._private.hasCompoundNodes = true;
      break;
    }
  }

  var removedElements = new Collection(this.cy(), removed);
  if (removedElements.size() > 0) {
    // must manually notify since trigger won't do this automatically once removed

    if (notifyRenderer) {
      this.cy().notify({
        type: 'remove',
        eles: removedElements
      });
    }

    removedElements.emit('remove');
  }

  // the parents who were modified by the removal need their style updated
  for (var _i7 = 0; _i7 < alteredParents.length; _i7++) {
    var _ele5 = alteredParents[_i7];

    if (!_ele5.removed()) {
      _ele5.updateStyle();
    }
  }

  return new Collection(cy, removed);
};

elesfn.move = function (struct) {
  var cy = this._private.cy;

  if (struct.source !== undefined || struct.target !== undefined) {
    var srcId = struct.source;
    var tgtId = struct.target;
    var srcExists = cy.hasElementWithId(srcId);
    var tgtExists = cy.hasElementWithId(tgtId);

    if (srcExists || tgtExists) {
      var jsons = this.jsons();

      this.remove();

      for (var i = 0; i < jsons.length; i++) {
        var json = jsons[i];
        var ele = this[i];

        if (json.group === 'edges') {
          if (srcExists) {
            json.data.source = srcId;
          }

          if (tgtExists) {
            json.data.target = tgtId;
          }

          json.scratch = ele._private.scratch;
        }
      }

      return cy.add(jsons);
    }
  } else if (struct.parent !== undefined) {
    // move node to new parent
    var parentId = struct.parent;
    var parentExists = parentId === null || cy.hasElementWithId(parentId);

    if (parentExists) {
      var _jsons = this.jsons();
      var descs = this.descendants();
      var descsEtcJsons = descs.union(descs.union(this).connectedEdges()).jsons();

      this.remove(); // NB: also removes descendants and their connected edges

      for (var _i8 = 0; _i8 < _jsons.length; _i8++) {
        var _json = _jsons[_i8];
        var _ele6 = this[_i8];

        if (_json.group === 'nodes') {
          _json.data.parent = parentId === null ? undefined : parentId;

          _json.scratch = _ele6._private.scratch;
        }
      }

      return cy.add(_jsons.concat(descsEtcJsons));
    }
  }

  return this; // if nothing done
};

[__webpack_require__(29), __webpack_require__(42), __webpack_require__(47), __webpack_require__(48), __webpack_require__(53), __webpack_require__(54), __webpack_require__(55), __webpack_require__(56), __webpack_require__(61), __webpack_require__(62), __webpack_require__(63), __webpack_require__(7), __webpack_require__(64), __webpack_require__(65), __webpack_require__(66), __webpack_require__(67), __webpack_require__(68)].forEach(function (props) {
  util.extend(elesfn, props);
});

module.exports = Collection;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* global Set */

var undef =  true ? 'undefined' : _typeof(undefined);

var ObjectSet = function () {
  function ObjectSet(arrayOrObjectSet) {
    _classCallCheck(this, ObjectSet);

    this._obj = Object.create(null);

    if (arrayOrObjectSet != null) {
      var arr = void 0;

      if (arrayOrObjectSet.instanceString != null && arrayOrObjectSet.instanceString() === this.instanceString()) {
        arr = arrayOrObjectSet.toArray();
      } else {
        arr = arrayOrObjectSet;
      }

      for (var i = 0; i < arr.length; i++) {
        this.add(arr[i]);
      }
    }
  }

  _createClass(ObjectSet, [{
    key: 'instanceString',
    value: function instanceString() {
      return 'set';
    }
  }, {
    key: 'add',
    value: function add(val) {
      this._obj[val] = 1;
    }
  }, {
    key: 'delete',
    value: function _delete(val) {
      this._obj[val] = 0;
    }
  }, {
    key: 'clear',
    value: function clear() {
      this._obj = Object.create(null);
    }
  }, {
    key: 'has',
    value: function has(val) {
      return this._obj[val] === 1;
    }
  }, {
    key: 'toArray',
    value: function toArray() {
      var _this = this;

      return Object.keys(this._obj).filter(function (key) {
        return _this.has(key);
      });
    }
  }, {
    key: 'forEach',
    value: function forEach(callback, thisArg) {
      return this.toArray().forEach(callback, thisArg);
    }
  }, {
    key: 'size',
    get: function get() {
      return this.toArray().length;
    }
  }]);

  return ObjectSet;
}();

// TODO use the stdlib Set in future...
// module.exports = typeof Set !== undef ? Set : ObjectSet;


module.exports = ObjectSet;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(32);

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// storage for parsed queries
var newQuery = function newQuery() {
  return {
    classes: [],
    colonSelectors: [],
    data: [],
    group: null,
    ids: [],
    meta: [],

    // fake selectors
    collection: null, // a collection to match against
    filter: null, // filter function

    // these are defined in the upward direction rather than down (e.g. child)
    // because we need to go up in Selector.filter()
    parent: null, // parent query obj
    ancestor: null, // ancestor query obj
    subject: null, // defines subject in compound query (subject query obj; points to self if subject)

    // use these only when subject has been defined
    child: null,
    descendant: null
  };
};

module.exports = newQuery;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);
var is = __webpack_require__(0);
var Event = __webpack_require__(16);

var eventRegex = /^([^.]+)(\.(?:[^.]+))?$/; // regex for matching event strings (e.g. "click.namespace")
var universalNamespace = '.*'; // matches as if no namespace specified and prevents users from unbinding accidentally

var defaults = {
  qualifierCompare: function qualifierCompare(q1, q2) {
    return q1 === q2;
  },
  eventMatches: function eventMatches() /*context, listener, eventObj*/{
    return true;
  },
  eventFields: function eventFields() /*context*/{
    return {};
  },
  callbackContext: function callbackContext(context /*, listener, eventObj*/) {
    return context;
  },
  beforeEmit: function beforeEmit() /* context, listener, eventObj */{},
  afterEmit: function afterEmit() /* context, listener, eventObj */{},
  bubble: function bubble() /*context*/{
    return false;
  },
  parent: function parent() /*context*/{
    return null;
  },
  context: undefined
};

function Emitter(opts) {
  util.assign(this, defaults, opts);

  this.listeners = [];
  this.emitting = 0;
}

var p = Emitter.prototype;

var forEachEvent = function forEachEvent(self, handler, events, qualifier, callback, conf, confOverrides) {
  if (is.fn(qualifier)) {
    callback = qualifier;
    qualifier = null;
  }

  if (confOverrides) {
    if (conf == null) {
      conf = confOverrides;
    } else {
      conf = util.assign({}, conf, confOverrides);
    }
  }

  var eventList = events.split(/\s+/);

  for (var i = 0; i < eventList.length; i++) {
    var evt = eventList[i];

    if (is.emptyString(evt)) {
      continue;
    }

    var match = evt.match(eventRegex); // type[.namespace]

    if (match) {
      var type = match[1];
      var namespace = match[2] ? match[2] : null;
      var ret = handler(self, evt, type, namespace, qualifier, callback, conf);

      if (ret === false) {
        break;
      } // allow exiting early
    }
  }
};

var makeEventObj = function makeEventObj(self, obj) {
  return new Event(obj.type, util.assign(obj, self.eventFields(self.context)));
};

var forEachEventObj = function forEachEventObj(self, handler, events) {
  if (is.event(events)) {
    handler(self, events);

    return;
  } else if (is.plainObject(events)) {
    handler(self, makeEventObj(self, events));

    return;
  }

  var eventList = events.split(/\s+/);

  for (var i = 0; i < eventList.length; i++) {
    var evt = eventList[i];

    if (is.emptyString(evt)) {
      continue;
    }

    var match = evt.match(eventRegex); // type[.namespace]

    if (match) {
      var type = match[1];
      var namespace = match[2] ? match[2] : null;
      var eventObj = makeEventObj(self, {
        type: type,
        namespace: namespace,
        target: self.context
      });

      handler(self, eventObj);
    }
  }
};

p.on = p.addListener = function (events, qualifier, callback, conf, confOverrides) {
  forEachEvent(this, function (self, event, type, namespace, qualifier, callback, conf) {
    if (is.fn(callback)) {
      self.listeners.push({
        event: event, // full event string
        callback: callback, // callback to run
        type: type, // the event type (e.g. 'click')
        namespace: namespace, // the event namespace (e.g. ".foo")
        qualifier: qualifier, // a restriction on whether to match this emitter
        conf: conf // additional configuration
      });
    }
  }, events, qualifier, callback, conf, confOverrides);

  return this;
};

p.one = function (events, qualifier, callback, conf) {
  return this.on(events, qualifier, callback, conf, { one: true });
};

p.removeListener = p.off = function (events, qualifier, callback, conf) {
  var _this = this;

  if (this.emitting !== 0) {
    this.listeners = util.copyArray(this.listeners);
  }

  var listeners = this.listeners;

  var _loop = function _loop(i) {
    var listener = listeners[i];

    forEachEvent(_this, function (self, event, type, namespace, qualifier, callback /*, conf*/) {
      if (listener.type === type && (!namespace || listener.namespace === namespace) && (!qualifier || self.qualifierCompare(listener.qualifier, qualifier)) && (!callback || listener.callback === callback)) {
        listeners.splice(i, 1);

        return false;
      }
    }, events, qualifier, callback, conf);
  };

  for (var i = listeners.length - 1; i >= 0; i--) {
    _loop(i);
  }

  return this;
};

p.emit = p.trigger = function (events, extraParams, manualCallback) {
  var listeners = this.listeners;
  var numListenersBeforeEmit = listeners.length;

  this.emitting++;

  if (!is.array(extraParams)) {
    extraParams = [extraParams];
  }

  forEachEventObj(this, function (self, eventObj) {
    if (manualCallback != null) {
      listeners = [{
        event: eventObj.event,
        type: eventObj.type,
        namespace: eventObj.namespace,
        callback: manualCallback
      }];

      numListenersBeforeEmit = listeners.length;
    }

    var _loop2 = function _loop2(i) {
      var listener = listeners[i];

      if (listener.type === eventObj.type && (!listener.namespace || listener.namespace === eventObj.namespace || listener.namespace === universalNamespace) && self.eventMatches(self.context, listener, eventObj)) {
        var args = [eventObj];

        if (extraParams != null) {
          util.push(args, extraParams);
        }

        self.beforeEmit(self.context, listener, eventObj);

        if (listener.conf && listener.conf.one) {
          self.listeners = self.listeners.filter(function (l) {
            return l !== listener;
          });
        }

        var context = self.callbackContext(self.context, listener, eventObj);
        var ret = listener.callback.apply(context, args);

        self.afterEmit(self.context, listener, eventObj);

        if (ret === false) {
          eventObj.stopPropagation();
          eventObj.preventDefault();
        }
      } // if listener matches
    };

    for (var i = 0; i < numListenersBeforeEmit; i++) {
      _loop2(i);
    } // for listener

    if (self.bubble(self.context) && !eventObj.isPropagationStopped()) {
      self.parent(self.context).emit(eventObj, extraParams);
    }
  }, events);

  this.emitting--;

  return this;
};

module.exports = Emitter;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var window = __webpack_require__(3);
var util = __webpack_require__(1);
var Collection = __webpack_require__(7);
var is = __webpack_require__(0);
var Promise = __webpack_require__(5);
var define = __webpack_require__(4);

var Core = function Core(opts) {
  var cy = this;

  opts = util.extend({}, opts);

  var container = opts.container;

  // allow for passing a wrapped jquery object
  // e.g. cytoscape({ container: $('#cy') })
  if (container && !is.htmlElement(container) && is.htmlElement(container[0])) {
    container = container[0];
  }

  var reg = container ? container._cyreg : null; // e.g. already registered some info (e.g. readies) via jquery
  reg = reg || {};

  if (reg && reg.cy) {
    reg.cy.destroy();

    reg = {}; // old instance => replace reg completely
  }

  var readies = reg.readies = reg.readies || [];

  if (container) {
    container._cyreg = reg;
  } // make sure container assoc'd reg points to this cy
  reg.cy = cy;

  var head = window !== undefined && container !== undefined && !opts.headless;
  var options = opts;
  options.layout = util.extend({ name: head ? 'grid' : 'null' }, options.layout);
  options.renderer = util.extend({ name: head ? 'canvas' : 'null' }, options.renderer);

  var defVal = function defVal(def, val, altVal) {
    if (val !== undefined) {
      return val;
    } else if (altVal !== undefined) {
      return altVal;
    } else {
      return def;
    }
  };

  var _p = this._private = {
    container: container, // html dom ele container
    ready: false, // whether ready has been triggered
    options: options, // cached options
    elements: new Collection(this), // elements in the graph
    listeners: [], // list of listeners
    aniEles: new Collection(this), // elements being animated
    scratch: {}, // scratch object for core
    layout: null,
    renderer: null,
    destroyed: false, // whether destroy was called
    notificationsEnabled: true, // whether notifications are sent to the renderer
    minZoom: 1e-50,
    maxZoom: 1e50,
    zoomingEnabled: defVal(true, options.zoomingEnabled),
    userZoomingEnabled: defVal(true, options.userZoomingEnabled),
    panningEnabled: defVal(true, options.panningEnabled),
    userPanningEnabled: defVal(true, options.userPanningEnabled),
    boxSelectionEnabled: defVal(true, options.boxSelectionEnabled),
    autolock: defVal(false, options.autolock, options.autolockNodes),
    autoungrabify: defVal(false, options.autoungrabify, options.autoungrabifyNodes),
    autounselectify: defVal(false, options.autounselectify),
    styleEnabled: options.styleEnabled === undefined ? head : options.styleEnabled,
    zoom: is.number(options.zoom) ? options.zoom : 1,
    pan: {
      x: is.plainObject(options.pan) && is.number(options.pan.x) ? options.pan.x : 0,
      y: is.plainObject(options.pan) && is.number(options.pan.y) ? options.pan.y : 0
    },
    animation: { // object for currently-running animations
      current: [],
      queue: []
    },
    hasCompoundNodes: false
  };

  this.createEmitter();

  // set selection type
  var selType = options.selectionType;
  if (selType === undefined || selType !== 'additive' && selType !== 'single') {
    // then set default

    _p.selectionType = 'single';
  } else {
    _p.selectionType = selType;
  }

  // init zoom bounds
  if (is.number(options.minZoom) && is.number(options.maxZoom) && options.minZoom < options.maxZoom) {
    _p.minZoom = options.minZoom;
    _p.maxZoom = options.maxZoom;
  } else if (is.number(options.minZoom) && options.maxZoom === undefined) {
    _p.minZoom = options.minZoom;
  } else if (is.number(options.maxZoom) && options.minZoom === undefined) {
    _p.maxZoom = options.maxZoom;
  }

  var loadExtData = function loadExtData(extData, next) {
    var anyIsPromise = extData.some(is.promise);

    if (anyIsPromise) {
      return Promise.all(extData).then(next); // load all data asynchronously, then exec rest of init
    } else {
      next(extData); // exec synchronously for convenience
    }
  };

  // start with the default stylesheet so we have something before loading an external stylesheet
  if (_p.styleEnabled) {
    cy.setStyle([]);
  }

  // create the renderer
  cy.initRenderer(util.extend({
    hideEdgesOnViewport: options.hideEdgesOnViewport,
    textureOnViewport: options.textureOnViewport,
    wheelSensitivity: is.number(options.wheelSensitivity) && options.wheelSensitivity > 0 ? options.wheelSensitivity : 1,
    motionBlur: options.motionBlur === undefined ? false : options.motionBlur, // off by default
    motionBlurOpacity: options.motionBlurOpacity === undefined ? 0.05 : options.motionBlurOpacity,
    pixelRatio: is.number(options.pixelRatio) && options.pixelRatio > 0 ? options.pixelRatio : undefined,
    desktopTapThreshold: options.desktopTapThreshold === undefined ? 4 : options.desktopTapThreshold,
    touchTapThreshold: options.touchTapThreshold === undefined ? 8 : options.touchTapThreshold
  }, options.renderer));

  var setElesAndLayout = function setElesAndLayout(elements, onload, ondone) {
    cy.notifications(false);

    // remove old elements
    var oldEles = cy.mutableElements();
    if (oldEles.length > 0) {
      oldEles.remove();
    }

    if (elements != null) {
      if (is.plainObject(elements) || is.array(elements)) {
        cy.add(elements);
      }
    }

    cy.one('layoutready', function (e) {
      cy.notifications(true);
      cy.emit(e); // we missed this event by turning notifications off, so pass it on

      cy.notify({
        type: 'load',
        eles: cy.mutableElements()
      });

      cy.one('load', onload);
      cy.emit('load');
    }).one('layoutstop', function () {
      cy.one('done', ondone);
      cy.emit('done');
    });

    var layoutOpts = util.extend({}, cy._private.options.layout);
    layoutOpts.eles = cy.elements();

    cy.layout(layoutOpts).run();
  };

  loadExtData([options.style, options.elements], function (thens) {
    var initStyle = thens[0];
    var initEles = thens[1];

    // init style
    if (_p.styleEnabled) {
      cy.style().append(initStyle);
    }

    // initial load
    setElesAndLayout(initEles, function () {
      // onready
      cy.startAnimationLoop();
      _p.ready = true;

      // if a ready callback is specified as an option, the bind it
      if (is.fn(options.ready)) {
        cy.on('ready', options.ready);
      }

      // bind all the ready handlers registered before creating this instance
      for (var i = 0; i < readies.length; i++) {
        var fn = readies[i];
        cy.on('ready', fn);
      }
      if (reg) {
        reg.readies = [];
      } // clear b/c we've bound them all and don't want to keep it around in case a new core uses the same div etc

      cy.emit('ready');
    }, options.done);
  });
};

var corefn = Core.prototype; // short alias

util.extend(corefn, {
  instanceString: function instanceString() {
    return 'core';
  },

  isReady: function isReady() {
    return this._private.ready;
  },

  isDestroyed: function isDestroyed() {
    return this._private.destroyed;
  },

  ready: function ready(fn) {
    if (this.isReady()) {
      this.emitter().emit('ready', [], fn); // just calls fn as though triggered via ready event
    } else {
      this.on('ready', fn);
    }

    return this;
  },

  destroy: function destroy() {
    var cy = this;
    if (cy.isDestroyed()) return;

    cy.stopAnimationLoop();

    cy.destroyRenderer();

    this.emit('destroy');

    cy._private.destroyed = true;

    return cy;
  },

  hasElementWithId: function hasElementWithId(id) {
    return this._private.elements.hasElementWithId(id);
  },

  getElementById: function getElementById(id) {
    return this._private.elements.getElementById(id);
  },

  selectionType: function selectionType() {
    return this._private.selectionType;
  },

  hasCompoundNodes: function hasCompoundNodes() {
    return this._private.hasCompoundNodes;
  },

  headless: function headless() {
    return this._private.options.renderer.name === 'null';
  },

  styleEnabled: function styleEnabled() {
    return this._private.styleEnabled;
  },

  addToPool: function addToPool(eles) {
    this._private.elements.merge(eles);

    return this; // chaining
  },

  removeFromPool: function removeFromPool(eles) {
    this._private.elements.unmerge(eles);

    return this;
  },

  container: function container() {
    return this._private.container;
  },

  options: function options() {
    return util.copy(this._private.options);
  },

  json: function json(obj) {
    var cy = this;
    var _p = cy._private;
    var eles = cy.mutableElements();

    if (is.plainObject(obj)) {
      // set

      cy.startBatch();

      if (obj.elements) {
        var idInJson = {};

        var updateEles = function updateEles(jsons, gr) {
          var toAdd = [];

          for (var i = 0; i < jsons.length; i++) {
            var json = jsons[i];
            var id = json.data.id;
            var ele = cy.getElementById(id);

            idInJson[id] = true;

            if (ele.length !== 0) {
              // existing element should be updated
              ele.json(json);
            } else {
              // otherwise should be added
              if (gr) {
                toAdd.push(util.extend({ group: gr }, json));
              } else {
                toAdd.push(json);
              }
            }
          }

          cy.add(toAdd);
        };

        if (is.array(obj.elements)) {
          // elements: []
          updateEles(obj.elements);
        } else {
          // elements: { nodes: [], edges: [] }
          var grs = ['nodes', 'edges'];
          for (var i = 0; i < grs.length; i++) {
            var gr = grs[i];
            var elements = obj.elements[gr];

            if (is.array(elements)) {
              updateEles(elements, gr);
            }
          }
        }

        // elements not specified in json should be removed
        eles.stdFilter(function (ele) {
          return !idInJson[ele.id()];
        }).remove();
      }

      if (obj.style) {
        cy.style(obj.style);
      }

      if (obj.zoom != null && obj.zoom !== _p.zoom) {
        cy.zoom(obj.zoom);
      }

      if (obj.pan) {
        if (obj.pan.x !== _p.pan.x || obj.pan.y !== _p.pan.y) {
          cy.pan(obj.pan);
        }
      }

      var fields = ['minZoom', 'maxZoom', 'zoomingEnabled', 'userZoomingEnabled', 'panningEnabled', 'userPanningEnabled', 'boxSelectionEnabled', 'autolock', 'autoungrabify', 'autounselectify'];

      for (var _i = 0; _i < fields.length; _i++) {
        var f = fields[_i];

        if (obj[f] != null) {
          cy[f](obj[f]);
        }
      }

      cy.endBatch();

      return this; // chaining
    } else if (obj === undefined) {
      // get
      var json = {};

      json.elements = {};
      eles.forEach(function (ele) {
        var group = ele.group();

        if (!json.elements[group]) {
          json.elements[group] = [];
        }

        json.elements[group].push(ele.json());
      });

      if (this._private.styleEnabled) {
        json.style = cy.style().json();
      }

      json.zoomingEnabled = cy._private.zoomingEnabled;
      json.userZoomingEnabled = cy._private.userZoomingEnabled;
      json.zoom = cy._private.zoom;
      json.minZoom = cy._private.minZoom;
      json.maxZoom = cy._private.maxZoom;
      json.panningEnabled = cy._private.panningEnabled;
      json.userPanningEnabled = cy._private.userPanningEnabled;
      json.pan = util.copy(cy._private.pan);
      json.boxSelectionEnabled = cy._private.boxSelectionEnabled;
      json.renderer = util.copy(cy._private.options.renderer);
      json.hideEdgesOnViewport = cy._private.options.hideEdgesOnViewport;
      json.textureOnViewport = cy._private.options.textureOnViewport;
      json.wheelSensitivity = cy._private.options.wheelSensitivity;
      json.motionBlur = cy._private.options.motionBlur;

      return json;
    }
  },

  scratch: define.data({
    field: 'scratch',
    bindingEvent: 'scratch',
    allowBinding: true,
    allowSetting: true,
    settingEvent: 'scratch',
    settingTriggersEvent: true,
    triggerFnName: 'trigger',
    allowGetting: true
  }),

  removeScratch: define.removeData({
    field: 'scratch',
    event: 'scratch',
    triggerFnName: 'trigger',
    triggerEvent: true
  })

});

corefn.$id = corefn.getElementById;

[__webpack_require__(69), __webpack_require__(70), __webpack_require__(78), __webpack_require__(79), __webpack_require__(80), __webpack_require__(81), __webpack_require__(82), __webpack_require__(83), __webpack_require__(84), __webpack_require__(93)].forEach(function (props) {
  util.extend(corefn, props);
});

module.exports = Core;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function memoize(fn, keyFn) {
  if (!keyFn) {
    keyFn = function keyFn() {
      if (arguments.length === 1) {
        return arguments[0];
      } else if (arguments.length === 0) {
        return 'undefined';
      }

      var args = [];

      for (var i = 0; i < arguments.length; i++) {
        args.push(arguments[i]);
      }

      return args.join('$');
    };
  }

  var memoizedFn = function memoizedFn() {
    var self = this;
    var args = arguments;
    var ret = void 0;
    var k = keyFn.apply(self, args);
    var cache = memoizedFn.cache;

    if (!(ret = cache[k])) {
      ret = cache[k] = fn.apply(self, args);
    }

    return ret;
  };

  memoizedFn.cache = {};

  return memoizedFn;
};

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);
var is = __webpack_require__(0);
var Set = __webpack_require__(8);

// represents a node or an edge
var Element = function Element(cy, params, restore) {
  restore = restore === undefined || restore ? true : false;

  if (cy === undefined || params === undefined || !is.core(cy)) {
    util.error('An element must have a core reference and parameters set');
    return;
  }

  var group = params.group;

  // try to automatically infer the group if unspecified
  if (group == null) {
    if (params.data && params.data.source != null && params.data.target != null) {
      group = 'edges';
    } else {
      group = 'nodes';
    }
  }

  // validate group
  if (group !== 'nodes' && group !== 'edges') {
    util.error('An element must be of type `nodes` or `edges`; you specified `' + group + '`');
    return;
  }

  // make the element array-like, just like a collection
  this.length = 1;
  this[0] = this;

  // NOTE: when something is added here, add also to ele.json()
  var _p = this._private = {
    cy: cy,
    single: true, // indicates this is an element
    data: params.data || {}, // data object
    position: params.position || {}, // (x, y) position pair
    autoWidth: undefined, // width and height of nodes calculated by the renderer when set to special 'auto' value
    autoHeight: undefined,
    autoPadding: undefined,
    compoundBoundsClean: false, // whether the compound dimensions need to be recalculated the next time dimensions are read
    listeners: [], // array of bound listeners
    group: group, // string; 'nodes' or 'edges'
    style: {}, // properties as set by the style
    rstyle: {}, // properties for style sent from the renderer to the core
    styleCxts: [], // applied style contexts from the styler
    removed: true, // whether it's inside the vis; true if removed (set true here since we call restore)
    selected: params.selected ? true : false, // whether it's selected
    selectable: params.selectable === undefined ? true : params.selectable ? true : false, // whether it's selectable
    locked: params.locked ? true : false, // whether the element is locked (cannot be moved)
    grabbed: false, // whether the element is grabbed by the mouse; renderer sets this privately
    grabbable: params.grabbable === undefined ? true : params.grabbable ? true : false, // whether the element can be grabbed
    active: false, // whether the element is active from user interaction
    classes: new Set(), // map ( className => true )
    animation: { // object for currently-running animations
      current: [],
      queue: []
    },
    rscratch: {}, // object in which the renderer can store information
    scratch: params.scratch || {}, // scratch objects
    edges: [], // array of connected edges
    children: [], // array of children
    parent: null, // parent ref
    traversalCache: {}, // cache of output of traversal functions
    backgrounding: false // whether background images are loading
  };

  // renderedPosition overrides if specified
  if (params.renderedPosition) {
    var rpos = params.renderedPosition;
    var pan = cy.pan();
    var zoom = cy.zoom();

    _p.position = {
      x: (rpos.x - pan.x) / zoom,
      y: (rpos.y - pan.y) / zoom
    };
  }

  if (is.string(params.classes)) {
    var classes = params.classes.split(/\s+/);
    for (var i = 0, l = classes.length; i < l; i++) {
      var cls = classes[i];
      if (!cls || cls === '') {
        continue;
      }

      _p.classes.add(cls);
    }
  }

  if (params.style || params.css) {
    cy.style().applyBypass(this, params.style || params.css);
  }

  this.createEmitter();

  if (restore === undefined || restore) {
    this.restore();
  }
};

module.exports = Element;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);

var stateSelectors = [{
  selector: ':selected',
  matches: function matches(ele) {
    return ele.selected();
  }
}, {
  selector: ':unselected',
  matches: function matches(ele) {
    return !ele.selected();
  }
}, {
  selector: ':selectable',
  matches: function matches(ele) {
    return ele.selectable();
  }
}, {
  selector: ':unselectable',
  matches: function matches(ele) {
    return !ele.selectable();
  }
}, {
  selector: ':locked',
  matches: function matches(ele) {
    return ele.locked();
  }
}, {
  selector: ':unlocked',
  matches: function matches(ele) {
    return !ele.locked();
  }
}, {
  selector: ':visible',
  matches: function matches(ele) {
    return ele.visible();
  }
}, {
  selector: ':hidden',
  matches: function matches(ele) {
    return !ele.visible();
  }
}, {
  selector: ':transparent',
  matches: function matches(ele) {
    return ele.transparent();
  }
}, {
  selector: ':grabbed',
  matches: function matches(ele) {
    return ele.grabbed();
  }
}, {
  selector: ':free',
  matches: function matches(ele) {
    return !ele.grabbed();
  }
}, {
  selector: ':removed',
  matches: function matches(ele) {
    return ele.removed();
  }
}, {
  selector: ':inside',
  matches: function matches(ele) {
    return !ele.removed();
  }
}, {
  selector: ':grabbable',
  matches: function matches(ele) {
    return ele.grabbable();
  }
}, {
  selector: ':ungrabbable',
  matches: function matches(ele) {
    return !ele.grabbable();
  }
}, {
  selector: ':animated',
  matches: function matches(ele) {
    return ele.animated();
  }
}, {
  selector: ':unanimated',
  matches: function matches(ele) {
    return !ele.animated();
  }
}, {
  selector: ':parent',
  matches: function matches(ele) {
    return ele.isParent();
  }
}, {
  selector: ':childless',
  matches: function matches(ele) {
    return ele.isChildless();
  }
}, {
  selector: ':child',
  matches: function matches(ele) {
    return ele.isChild();
  }
}, {
  selector: ':orphan',
  matches: function matches(ele) {
    return ele.isOrphan();
  }
}, {
  selector: ':nonorphan',
  matches: function matches(ele) {
    return ele.isChild();
  }
}, {
  selector: ':loop',
  matches: function matches(ele) {
    return ele.isLoop();
  }
}, {
  selector: ':simple',
  matches: function matches(ele) {
    return ele.isSimple();
  }
}, {
  selector: ':active',
  matches: function matches(ele) {
    return ele.active();
  }
}, {
  selector: ':inactive',
  matches: function matches(ele) {
    return !ele.active();
  }
}, {
  selector: ':backgrounding',
  matches: function matches(ele) {
    return ele.backgrounding();
  }
}, {
  selector: ':nonbackgrounding',
  matches: function matches(ele) {
    return !ele.backgrounding();
  }
}].sort(function (a, b) {
  // n.b. selectors that are starting substrings of others must have the longer ones first
  return util.sort.descending(a.selector, b.selector);
});

var stateSelectorMatches = function stateSelectorMatches(sel, ele) {
  var lookup = stateSelectorMatches.lookup = stateSelectorMatches.lookup || function () {
    var selToFn = {};
    var s = void 0;

    for (var i = 0; i < stateSelectors.length; i++) {
      s = stateSelectors[i];

      selToFn[s.selector] = s.matches;
    }

    return selToFn;
  }();

  return lookup[sel](ele);
};

var stateSelectorRegex = '(' + stateSelectors.map(function (s) {
  return s.selector;
}).join('|') + ')';

module.exports = { stateSelectors: stateSelectors, stateSelectorMatches: stateSelectorMatches, stateSelectorRegex: stateSelectorRegex };

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*!
Event object based on jQuery events, MIT license

https://jquery.org/license/
https://tldrlegal.com/license/mit-license
https://github.com/jquery/jquery/blob/master/src/event.js
*/

var Event = function Event(src, props) {
  this.recycle(src, props);
};

function returnFalse() {
  return false;
}

function returnTrue() {
  return true;
}

// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
Event.prototype = {
  instanceString: function instanceString() {
    return 'event';
  },

  recycle: function recycle(src, props) {
    this.isImmediatePropagationStopped = this.isPropagationStopped = this.isDefaultPrevented = returnFalse;

    if (src != null && src.preventDefault) {
      // Browser Event object
      this.type = src.type;

      // Events bubbling up the document may have been marked as prevented
      // by a handler lower down the tree; reflect the correct value.
      this.isDefaultPrevented = src.defaultPrevented ? returnTrue : returnFalse;
    } else if (src != null && src.type) {
      // Plain object containing all event details
      props = src;
    } else {
      // Event string
      this.type = src;
    }

    // Put explicitly provided properties onto the event object
    if (props != null) {
      // more efficient to manually copy fields we use
      this.originalEvent = props.originalEvent;
      this.type = props.type != null ? props.type : this.type;
      this.cy = props.cy;
      this.target = props.target;
      this.position = props.position;
      this.renderedPosition = props.renderedPosition;
      this.namespace = props.namespace;
      this.layout = props.layout;
    }

    if (this.cy != null && this.position != null && this.renderedPosition == null) {
      // create a rendered position based on the passed position
      var pos = this.position;
      var zoom = this.cy.zoom();
      var pan = this.cy.pan();

      this.renderedPosition = {
        x: pos.x * zoom + pan.x,
        y: pos.y * zoom + pan.y
      };
    }

    // Create a timestamp if incoming event doesn't have one
    this.timeStamp = src && src.timeStamp || Date.now();
  },

  preventDefault: function preventDefault() {
    this.isDefaultPrevented = returnTrue;

    var e = this.originalEvent;
    if (!e) {
      return;
    }

    // if preventDefault exists run it on the original event
    if (e.preventDefault) {
      e.preventDefault();
    }
  },

  stopPropagation: function stopPropagation() {
    this.isPropagationStopped = returnTrue;

    var e = this.originalEvent;
    if (!e) {
      return;
    }

    // if stopPropagation exists run it on the original event
    if (e.stopPropagation) {
      e.stopPropagation();
    }
  },

  stopImmediatePropagation: function stopImmediatePropagation() {
    this.isImmediatePropagationStopped = returnTrue;
    this.stopPropagation();
  },

  isDefaultPrevented: returnFalse,
  isPropagationStopped: returnFalse,
  isImmediatePropagationStopped: returnFalse
};

module.exports = Event;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 *  Elements are drawn in a specific order based on compound depth (low to high), the element type (nodes above edges),
 *  and z-index (low to high).  These styles affect how this applies:
 *
 *  z-compound-depth: May be `bottom | orphan | auto | top`.  The first drawn is `bottom`, then `orphan` which is the
 *      same depth as the root of the compound graph, followed by the default value `auto` which draws in order from
 *      root to leaves of the compound graph.  The last drawn is `top`.
 *  z-index-compare: May be `auto | manual`.  The default value is `auto` which always draws edges under nodes.
 *      `manual` ignores this convention and draws based on the `z-index` value setting.
 *  z-index: An integer value that affects the relative draw order of elements.  In general, an element with a higher
 *      `z-index` will be drawn on top of an element with a lower `z-index`.
 */
var util = __webpack_require__(1);

var zIndexSort = function zIndexSort(a, b) {
  var cy = a.cy();
  var hasCompoundNodes = cy.hasCompoundNodes();

  function getDepth(ele) {
    var style = ele.pstyle('z-compound-depth');
    if (style.value === 'auto') {
      return hasCompoundNodes ? ele.zDepth() : 0;
    } else if (style.value === 'bottom') {
      return -1;
    } else if (style.value === 'top') {
      return util.MAX_INT;
    }
    // 'orphan'
    return 0;
  }
  var depthDiff = getDepth(a) - getDepth(b);
  if (depthDiff !== 0) {
    return depthDiff;
  }

  function getEleDepth(ele) {
    var style = ele.pstyle('z-index-compare');
    if (style.value === 'auto') {
      return ele.isNode() ? 1 : 0;
    }
    // 'manual'
    return 0;
  }
  var eleDiff = getEleDepth(a) - getEleDepth(b);
  if (eleDiff !== 0) {
    return eleDiff;
  }

  var zDiff = a.pstyle('z-index').value - b.pstyle('z-index').value;
  if (zDiff !== 0) {
    return zDiff;
  }
  // compare indices in the core (order added to graph w/ last on top)
  return a.poolIndex() - b.poolIndex();
};

module.exports = zIndexSort;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);
var util = __webpack_require__(1);
var Selector = __webpack_require__(6);

var Style = function Style(cy) {

  if (!(this instanceof Style)) {
    return new Style(cy);
  }

  if (!is.core(cy)) {
    util.error('A style must have a core reference');
    return;
  }

  this._private = {
    cy: cy,
    coreStyle: {}
  };

  this.length = 0;

  this.resetToDefault();
};

var styfn = Style.prototype;

styfn.instanceString = function () {
  return 'style';
};

// remove all contexts
styfn.clear = function () {
  for (var i = 0; i < this.length; i++) {
    this[i] = undefined;
  }
  this.length = 0;

  var _p = this._private;

  _p.newStyle = true;

  return this; // chaining
};

styfn.resetToDefault = function () {
  this.clear();
  this.addDefaultStylesheet();

  return this;
};

// builds a style object for the 'core' selector
styfn.core = function () {
  return this._private.coreStyle;
};

// create a new context from the specified selector string and switch to that context
styfn.selector = function (selectorStr) {
  // 'core' is a special case and does not need a selector
  var selector = selectorStr === 'core' ? null : new Selector(selectorStr);

  var i = this.length++; // new context means new index
  this[i] = {
    selector: selector,
    properties: [],
    mappedProperties: [],
    index: i
  };

  return this; // chaining
};

// add one or many css rules to the current context
styfn.css = function () {
  var self = this;
  var args = arguments;

  switch (args.length) {
    case 1:
      var map = args[0];

      for (var i = 0; i < self.properties.length; i++) {
        var prop = self.properties[i];
        var mapVal = map[prop.name];

        if (mapVal === undefined) {
          mapVal = map[util.dash2camel(prop.name)];
        }

        if (mapVal !== undefined) {
          this.cssRule(prop.name, mapVal);
        }
      }

      break;

    case 2:
      this.cssRule(args[0], args[1]);
      break;

    default:
      break; // do nothing if args are invalid
  }

  return this; // chaining
};
styfn.style = styfn.css;

// add a single css rule to the current context
styfn.cssRule = function (name, value) {
  // name-value pair
  var property = this.parse(name, value);

  // add property to current context if valid
  if (property) {
    var i = this.length - 1;
    this[i].properties.push(property);
    this[i].properties[property.name] = property; // allow access by name as well

    if (property.name.match(/pie-(\d+)-background-size/) && property.value) {
      this._private.hasPie = true;
    }

    if (property.mapped) {
      this[i].mappedProperties.push(property);
    }

    // add to core style if necessary
    var currentSelectorIsCore = !this[i].selector;
    if (currentSelectorIsCore) {
      this._private.coreStyle[property.name] = property;
    }
  }

  return this; // chaining
};

styfn.append = function (style) {
  if (is.stylesheet(style)) {
    style.appendToStyle(this);
  } else if (is.array(style)) {
    this.appendFromJson(style);
  } else if (is.string(style)) {
    this.appendFromString(style);
  } // you probably wouldn't want to append a Style, since you'd duplicate the default parts

  return this;
};

// static function
Style.fromJson = function (cy, json) {
  var style = new Style(cy);

  style.fromJson(json);

  return style;
};

Style.fromString = function (cy, string) {
  return new Style(cy).fromString(string);
};

[__webpack_require__(85), __webpack_require__(86), __webpack_require__(87), __webpack_require__(88), __webpack_require__(89), __webpack_require__(90), __webpack_require__(91), __webpack_require__(92)].forEach(function (props) {
  util.extend(styfn, props);
});

Style.types = styfn.types;
Style.properties = styfn.properties;

module.exports = Style;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);

var fullFpsTime = 1000 / 60; // assume 60 frames per second

module.exports = {
  setupDequeueing: function setupDequeueing(opts) {
    return function setupDequeueingImpl() {
      var self = this;
      var r = this.renderer;

      if (self.dequeueingSetup) {
        return;
      } else {
        self.dequeueingSetup = true;
      }

      var queueRedraw = util.debounce(function () {
        r.redrawHint('eles', true);
        r.redrawHint('drag', true);

        r.redraw();
      }, opts.deqRedrawThreshold);

      var dequeue = function dequeue(willDraw, frameStartTime) {
        var startTime = util.performanceNow();
        var avgRenderTime = r.averageRedrawTime;
        var renderTime = r.lastRedrawTime;
        var deqd = [];
        var extent = r.cy.extent();
        var pixelRatio = r.getPixelRatio();

        while (true) {
          var now = util.performanceNow();
          var duration = now - startTime;
          var frameDuration = now - frameStartTime;

          if (renderTime < fullFpsTime) {
            // if we're rendering faster than the ideal fps, then do dequeueing
            // during all of the remaining frame time

            var timeAvailable = fullFpsTime - (willDraw ? avgRenderTime : 0);

            if (frameDuration >= opts.deqFastCost * timeAvailable) {
              break;
            }
          } else {
            if (willDraw) {
              if (duration >= opts.deqCost * renderTime || duration >= opts.deqAvgCost * avgRenderTime) {
                break;
              }
            } else if (frameDuration >= opts.deqNoDrawCost * fullFpsTime) {
              break;
            }
          }

          var thisDeqd = opts.deq(self, pixelRatio, extent);

          if (thisDeqd.length > 0) {
            for (var i = 0; i < thisDeqd.length; i++) {
              deqd.push(thisDeqd[i]);
            }
          } else {
            break;
          }
        }

        // callbacks on dequeue
        if (deqd.length > 0) {
          opts.onDeqd(self, deqd);

          if (!willDraw && opts.shouldRedraw(self, deqd, pixelRatio, extent)) {
            queueRedraw();
          }
        }
      };

      var priority = opts.priority || util.noop;

      r.beforeRender(dequeue, priority(self));
    };
  }
};

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);
var Core = __webpack_require__(12);
var extension = __webpack_require__(94);
var Stylesheet = __webpack_require__(136);

var cytoscape = function cytoscape(options) {
  // jshint ignore:line
  // if no options specified, use default
  if (options === undefined) {
    options = {};
  }

  // create instance
  if (is.plainObject(options)) {
    return new Core(options);
  }

  // allow for registration of extensions
  else if (is.string(options)) {
      return extension.apply(extension, arguments);
    }
};

// e.g. cytoscape.use( require('cytoscape-foo'), bar )
cytoscape.use = function (ext) {
  var args = Array.prototype.slice.call(arguments, 1); // args to pass to ext

  args.unshift(cytoscape); // cytoscape is first arg to ext

  ext.apply(null, args);

  return this;
};

// replaced by build system
cytoscape.version = __webpack_require__(137);

// expose public apis (mostly for extensions)
cytoscape.stylesheet = cytoscape.Stylesheet = Stylesheet;

module.exports = cytoscape;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);

module.exports = {
  // get [r, g, b] from #abc or #aabbcc
  hex2tuple: function hex2tuple(hex) {
    if (!(hex.length === 4 || hex.length === 7) || hex[0] !== '#') {
      return;
    }

    var shortHex = hex.length === 4;
    var r = void 0,
        g = void 0,
        b = void 0;
    var base = 16;

    if (shortHex) {
      r = parseInt(hex[1] + hex[1], base);
      g = parseInt(hex[2] + hex[2], base);
      b = parseInt(hex[3] + hex[3], base);
    } else {
      r = parseInt(hex[1] + hex[2], base);
      g = parseInt(hex[3] + hex[4], base);
      b = parseInt(hex[5] + hex[6], base);
    }

    return [r, g, b];
  },

  // get [r, g, b, a] from hsl(0, 0, 0) or hsla(0, 0, 0, 0)
  hsl2tuple: function hsl2tuple(hsl) {
    var ret = void 0;
    var h = void 0,
        s = void 0,
        l = void 0,
        a = void 0,
        r = void 0,
        g = void 0,
        b = void 0;
    function hue2rgb(p, q, t) {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1 / 6) return p + (q - p) * 6 * t;
      if (t < 1 / 2) return q;
      if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
      return p;
    }

    var m = new RegExp('^' + this.regex.hsla + '$').exec(hsl);
    if (m) {

      // get hue
      h = parseInt(m[1]);
      if (h < 0) {
        h = (360 - -1 * h % 360) % 360;
      } else if (h > 360) {
        h = h % 360;
      }
      h /= 360; // normalise on [0, 1]

      s = parseFloat(m[2]);
      if (s < 0 || s > 100) {
        return;
      } // saturation is [0, 100]
      s = s / 100; // normalise on [0, 1]

      l = parseFloat(m[3]);
      if (l < 0 || l > 100) {
        return;
      } // lightness is [0, 100]
      l = l / 100; // normalise on [0, 1]

      a = m[4];
      if (a !== undefined) {
        a = parseFloat(a);

        if (a < 0 || a > 1) {
          return;
        } // alpha is [0, 1]
      }

      // now, convert to rgb
      // code from http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript
      if (s === 0) {
        r = g = b = Math.round(l * 255); // achromatic
      } else {
        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;
        r = Math.round(255 * hue2rgb(p, q, h + 1 / 3));
        g = Math.round(255 * hue2rgb(p, q, h));
        b = Math.round(255 * hue2rgb(p, q, h - 1 / 3));
      }

      ret = [r, g, b, a];
    }

    return ret;
  },

  // get [r, g, b, a] from rgb(0, 0, 0) or rgba(0, 0, 0, 0)
  rgb2tuple: function rgb2tuple(rgb) {
    var ret = void 0;

    var m = new RegExp('^' + this.regex.rgba + '$').exec(rgb);
    if (m) {
      ret = [];

      var isPct = [];
      for (var i = 1; i <= 3; i++) {
        var channel = m[i];

        if (channel[channel.length - 1] === '%') {
          isPct[i] = true;
        }
        channel = parseFloat(channel);

        if (isPct[i]) {
          channel = channel / 100 * 255; // normalise to [0, 255]
        }

        if (channel < 0 || channel > 255) {
          return;
        } // invalid channel value

        ret.push(Math.floor(channel));
      }

      var atLeastOneIsPct = isPct[1] || isPct[2] || isPct[3];
      var allArePct = isPct[1] && isPct[2] && isPct[3];
      if (atLeastOneIsPct && !allArePct) {
        return;
      } // must all be percent values if one is

      var alpha = m[4];
      if (alpha !== undefined) {
        alpha = parseFloat(alpha);

        if (alpha < 0 || alpha > 1) {
          return;
        } // invalid alpha value

        ret.push(alpha);
      }
    }

    return ret;
  },

  colorname2tuple: function colorname2tuple(color) {
    return this.colors[color.toLowerCase()];
  },

  color2tuple: function color2tuple(color) {
    return (is.array(color) ? color : null) || this.colorname2tuple(color) || this.hex2tuple(color) || this.rgb2tuple(color) || this.hsl2tuple(color);
  },

  colors: {
    // special colour names
    transparent: [0, 0, 0, 0], // NB alpha === 0

    // regular colours
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    grey: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  }
};

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);

module.exports = {
  // has anything been set in the map
  mapEmpty: function mapEmpty(map) {
    var empty = true;

    if (map != null) {
      return Object.keys(map).length === 0;
    }

    return empty;
  },

  // pushes to the array at the end of a map (map may not be built)
  pushMap: function pushMap(options) {
    var array = this.getMap(options);

    if (array == null) {
      // if empty, put initial array
      this.setMap(this.extend({}, options, {
        value: [options.value]
      }));
    } else {
      array.push(options.value);
    }
  },

  // sets the value in a map (map may not be built)
  setMap: function setMap(options) {
    var obj = options.map;
    var key = void 0;
    var keys = options.keys;
    var l = keys.length;

    for (var i = 0; i < l; i++) {
      var _key = keys[i];

      if (is.plainObject(_key)) {
        this.error('Tried to set map with object key');
      }

      if (i < keys.length - 1) {

        // extend the map if necessary
        if (obj[_key] == null) {
          obj[_key] = {};
        }

        obj = obj[_key];
      } else {
        // set the value
        obj[_key] = options.value;
      }
    }
  },

  // gets the value in a map even if it's not built in places
  getMap: function getMap(options) {
    var obj = options.map;
    var keys = options.keys;
    var l = keys.length;

    for (var i = 0; i < l; i++) {
      var key = keys[i];

      if (is.plainObject(key)) {
        this.error('Tried to get map with object key');
      }

      obj = obj[key];

      if (obj == null) {
        return obj;
      }
    }

    return obj;
  },

  // deletes the entry in the map
  deleteMap: function deleteMap(options) {
    var obj = options.map;
    var keys = options.keys;
    var l = keys.length;
    var keepChildren = options.keepChildren;

    for (var i = 0; i < l; i++) {
      var key = keys[i];

      if (is.plainObject(key)) {
        this.error('Tried to delete map with object key');
      }

      var lastKey = i === options.keys.length - 1;
      if (lastKey) {

        if (keepChildren) {
          // then only delete child fields not in keepChildren
          var children = Object.keys(obj);

          for (var j = 0; j < children.length; j++) {
            var child = children[j];

            if (!keepChildren[child]) {
              obj[child] = undefined;
            }
          }
        } else {
          obj[key] = undefined;
        }
      } else {
        obj = obj[key];
      }
    }
  }
};

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var number = '(?:[-+]?(?:(?:\\d+|\\d*\\.\\d+)(?:[Ee][+-]?\\d+)?))';

var rgba = 'rgb[a]?\\((' + number + '[%]?)\\s*,\\s*(' + number + '[%]?)\\s*,\\s*(' + number + '[%]?)(?:\\s*,\\s*(' + number + '))?\\)';
var rgbaNoBackRefs = 'rgb[a]?\\((?:' + number + '[%]?)\\s*,\\s*(?:' + number + '[%]?)\\s*,\\s*(?:' + number + '[%]?)(?:\\s*,\\s*(?:' + number + '))?\\)';

var hsla = 'hsl[a]?\\((' + number + ')\\s*,\\s*(' + number + '[%])\\s*,\\s*(' + number + '[%])(?:\\s*,\\s*(' + number + '))?\\)';
var hslaNoBackRefs = 'hsl[a]?\\((?:' + number + ')\\s*,\\s*(?:' + number + '[%])\\s*,\\s*(?:' + number + '[%])(?:\\s*,\\s*(?:' + number + '))?\\)';

var hex3 = '\\#[0-9a-fA-F]{3}';
var hex6 = '\\#[0-9a-fA-F]{6}';

module.exports = {
  regex: {
    number: number,
    rgba: rgba,
    rgbaNoBackRefs: rgbaNoBackRefs,
    hsla: hsla,
    hslaNoBackRefs: hslaNoBackRefs,
    hex3: hex3,
    hex6: hex6
  }
};

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var memoize = __webpack_require__(13);
var is = __webpack_require__(0);

module.exports = {

  camel2dash: memoize(function (str) {
    return str.replace(/([A-Z])/g, function (v) {
      return '-' + v.toLowerCase();
    });
  }),

  dash2camel: memoize(function (str) {
    return str.replace(/(-\w)/g, function (v) {
      return v[1].toUpperCase();
    });
  }),

  prependCamel: memoize(function (prefix, str) {
    return prefix + str[0].toUpperCase() + str.substring(1);
  }, function (prefix, str) {
    return prefix + '$' + str;
  }),

  capitalize: function capitalize(str) {
    if (is.emptyString(str)) {
      return str;
    }

    return str.charAt(0).toUpperCase() + str.substring(1);
  }

};

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var window = __webpack_require__(3);
var performance = window ? window.performance : null;

var util = {};

var pnow = performance && performance.now ? function () {
  return performance.now();
} : function () {
  return Date.now();
};

var raf = function () {
  if (window) {
    if (window.requestAnimationFrame) {
      return function (fn) {
        window.requestAnimationFrame(fn);
      };
    } else if (window.mozRequestAnimationFrame) {
      return function (fn) {
        window.mozRequestAnimationFrame(fn);
      };
    } else if (window.webkitRequestAnimationFrame) {
      return function (fn) {
        window.webkitRequestAnimationFrame(fn);
      };
    } else if (window.msRequestAnimationFrame) {
      return function (fn) {
        window.msRequestAnimationFrame(fn);
      };
    }
  }

  return function (fn) {
    if (fn) {
      setTimeout(function () {
        fn(pnow());
      }, 1000 / 60);
    }
  };
}();

util.requestAnimationFrame = function (fn) {
  raf(fn);
};

util.performanceNow = pnow;

util.debounce = __webpack_require__(26);

util.now = function () {
  return Date.now();
};

module.exports = util;

/***/ }),
/* 26 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_26__;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function ascending(a, b) {
  if (a < b) {
    return -1;
  } else if (a > b) {
    return 1;
  } else {
    return 0;
  }
}

function descending(a, b) {
  return -1 * ascending(a, b);
}

module.exports = {
  sort: {
    ascending: ascending,
    descending: descending
  }
};

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function ObjectMap() {
  this._obj = {};
}

var p = ObjectMap.prototype;

p.set = function (key, val) {
  this._obj[key] = val;
};

p.delete = function (key) {
  this._obj[key] = null;
};

p.has = function (key) {
  return this._obj[key] != null;
};

p.get = function (key) {
  return this._obj[key];
};

// TODO use the stdlib Map in future...
// module.exports = typeof Map !== 'undefined' ? Map : ObjectMap;
module.exports = ObjectMap;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);

var elesfn = {};

[__webpack_require__(30), __webpack_require__(31), __webpack_require__(33), __webpack_require__(34), __webpack_require__(35), __webpack_require__(36), __webpack_require__(37), __webpack_require__(38), __webpack_require__(39), __webpack_require__(40), __webpack_require__(41)].forEach(function (props) {
  util.extend(elesfn, props);
});

module.exports = elesfn;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);

var defineSearch = function defineSearch(params) {
  params = {
    bfs: params.bfs || !params.dfs,
    dfs: params.dfs || !params.bfs
  };

  // from pseudocode on wikipedia
  return function searchFn(roots, fn, directed) {
    var options;
    if (is.plainObject(roots) && !is.elementOrCollection(roots)) {
      options = roots;
      roots = options.roots || options.root;
      fn = options.visit;
      directed = options.directed;
    }

    directed = arguments.length === 2 && !is.fn(fn) ? fn : directed;
    fn = is.fn(fn) ? fn : function () {};

    var cy = this._private.cy;
    var v = roots = is.string(roots) ? this.filter(roots) : roots;
    var Q = [];
    var connectedNodes = [];
    var connectedBy = {};
    var id2depth = {};
    var V = {};
    var j = 0;
    var found;
    var nodes = this.nodes();
    var edges = this.edges();

    // enqueue v
    for (var i = 0; i < v.length; i++) {
      if (v[i].isNode()) {
        Q.unshift(v[i]);

        if (params.bfs) {
          V[v[i].id()] = true;

          connectedNodes.push(v[i]);
        }

        id2depth[v[i].id()] = 0;
      }
    }

    while (Q.length !== 0) {
      var v = params.bfs ? Q.shift() : Q.pop();

      if (params.dfs) {
        if (V[v.id()]) {
          continue;
        }

        V[v.id()] = true;

        connectedNodes.push(v);
      }

      var depth = id2depth[v.id()];
      var prevEdge = connectedBy[v.id()];
      var prevNode = prevEdge == null ? undefined : prevEdge.connectedNodes().not(v)[0];
      var ret;

      ret = fn(v, prevEdge, prevNode, j++, depth);

      if (ret === true) {
        found = v;
        break;
      }

      if (ret === false) {
        break;
      }

      var vwEdges = v.connectedEdges(directed ? function (ele) {
        return ele.data('source') === v.id();
      } : undefined).intersect(edges);
      for (var i = 0; i < vwEdges.length; i++) {
        var e = vwEdges[i];
        var w = e.connectedNodes(function (n) {
          return n.id() !== v.id();
        }).intersect(nodes);

        if (w.length !== 0 && !V[w.id()]) {
          w = w[0];

          Q.push(w);

          if (params.bfs) {
            V[w.id()] = true;

            connectedNodes.push(w);
          }

          connectedBy[w.id()] = e;

          id2depth[w.id()] = id2depth[v.id()] + 1;
        }
      }
    }

    var connectedEles = [];

    for (var i = 0; i < connectedNodes.length; i++) {
      var node = connectedNodes[i];
      var edge = connectedBy[node.id()];

      if (edge) {
        connectedEles.push(edge);
      }

      connectedEles.push(node);
    }

    return {
      path: cy.collection(connectedEles, { unique: true }),
      found: cy.collection(found)
    };
  };
};

// search, spanning trees, etc
var elesfn = {
  breadthFirstSearch: defineSearch({ bfs: true }),
  depthFirstSearch: defineSearch({ dfs: true })
};

// nice, short mathemathical alias
elesfn.bfs = elesfn.breadthFirstSearch;
elesfn.dfs = elesfn.depthFirstSearch;

module.exports = elesfn;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);
var Heap = __webpack_require__(9);

var elesfn = {

  dijkstra: function dijkstra(root, weightFn, directed) {
    var options;
    if (is.plainObject(root) && !is.elementOrCollection(root)) {
      options = root;
      root = options.root;
      weightFn = options.weight;
      directed = options.directed;
    }

    var cy = this._private.cy;
    weightFn = is.fn(weightFn) ? weightFn : function () {
      return 1;
    }; // if not specified, assume each edge has equal weight (1)

    var source = is.string(root) ? this.filter(root)[0] : root[0];
    var dist = {};
    var prev = {};
    var knownDist = {};

    var edges = this.edges().filter(function (ele) {
      return !ele.isLoop();
    });
    var nodes = this.nodes();

    var getDist = function getDist(node) {
      return dist[node.id()];
    };

    var setDist = function setDist(node, d) {
      dist[node.id()] = d;

      Q.updateItem(node);
    };

    var Q = new Heap(function (a, b) {
      return getDist(a) - getDist(b);
    });

    for (var i = 0; i < nodes.length; i++) {
      var node = nodes[i];

      dist[node.id()] = node.same(source) ? 0 : Infinity;
      Q.push(node);
    }

    var distBetween = function distBetween(u, v) {
      var uvs = (directed ? u.edgesTo(v) : u.edgesWith(v)).intersect(edges);
      var smallestDistance = Infinity;
      var smallestEdge;

      for (var i = 0; i < uvs.length; i++) {
        var edge = uvs[i];
        var weight = weightFn(edge);

        if (weight < smallestDistance || !smallestEdge) {
          smallestDistance = weight;
          smallestEdge = edge;
        }
      }

      return {
        edge: smallestEdge,
        dist: smallestDistance
      };
    };

    while (Q.size() > 0) {
      var u = Q.pop();
      var smalletsDist = getDist(u);
      var uid = u.id();

      knownDist[uid] = smalletsDist;

      if (smalletsDist === Infinity) {
        continue;
      }

      var neighbors = u.neighborhood().intersect(nodes);
      for (var i = 0; i < neighbors.length; i++) {
        var v = neighbors[i];
        var vid = v.id();
        var vDist = distBetween(u, v);

        var alt = smalletsDist + vDist.dist;

        if (alt < getDist(v)) {
          setDist(v, alt);

          prev[vid] = {
            node: u,
            edge: vDist.edge
          };
        }
      } // for
    } // while

    return {
      distanceTo: function distanceTo(node) {
        var target = is.string(node) ? nodes.filter(node)[0] : node[0];

        return knownDist[target.id()];
      },

      pathTo: function pathTo(node) {
        var target = is.string(node) ? nodes.filter(node)[0] : node[0];
        var S = [];
        var u = target;

        if (target.length > 0) {
          S.unshift(target);

          while (prev[u.id()]) {
            var p = prev[u.id()];

            S.unshift(p.edge);
            S.unshift(p.node);

            u = p.node;
          }
        }

        return cy.collection(S);
      }
    };
  }
};

module.exports = elesfn;

/***/ }),
/* 32 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_32__;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);

// search, spanning trees, etc
var elesfn = {

  // kruskal's algorithm (finds min spanning tree, assuming undirected graph)
  // implemented from pseudocode from wikipedia
  kruskal: function kruskal(weightFn) {
    var cy = this.cy();

    weightFn = is.fn(weightFn) ? weightFn : function () {
      return 1;
    }; // if not specified, assume each edge has equal weight (1)

    function findSet(ele) {
      for (var i = 0; i < forest.length; i++) {
        var eles = forest[i];

        if (eles.anySame(ele)) {
          return {
            eles: eles,
            index: i
          };
        }
      }
    }

    var A = cy.collection(cy, []);
    var forest = [];
    var nodes = this.nodes();

    for (var i = 0; i < nodes.length; i++) {
      forest.push(nodes[i].collection());
    }

    var edges = this.edges();
    var S = edges.toArray().sort(function (a, b) {
      var weightA = weightFn(a);
      var weightB = weightFn(b);

      return weightA - weightB;
    });

    for (var i = 0; i < S.length; i++) {
      var edge = S[i];
      var u = edge.source()[0];
      var v = edge.target()[0];
      var setU = findSet(u);
      var setV = findSet(v);

      if (setU.index !== setV.index) {
        A = A.add(edge);

        // combine forests for u and v
        forest[setU.index] = setU.eles.add(setV.eles);
        forest.splice(setV.index, 1);
      }
    }

    return nodes.add(A);
  }
};

module.exports = elesfn;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);

var elesfn = {

  // Implemented from pseudocode from wikipedia
  aStar: function aStar(options) {
    var eles = this;

    options = options || {};

    // Reconstructs the path from Start to End, acumulating the result in pathAcum
    var reconstructPath = function reconstructPath(start, end, cameFromMap, pathAcum) {
      // Base case
      if (start == end) {
        pathAcum.unshift(cy.getElementById(end));
        return pathAcum;
      }

      if (end in cameFromMap) {
        // We know which node is before the last one
        var previous = cameFromMap[end];
        var previousEdge = cameFromEdge[end];

        pathAcum.unshift(cy.getElementById(previousEdge));
        pathAcum.unshift(cy.getElementById(end));

        return reconstructPath(start, previous, cameFromMap, pathAcum);
      }

      // We should not reach here!
      return undefined;
    };

    // Returns the index of the element in openSet which has minimum fScore
    var findMin = function findMin(openSet, fScore) {
      if (openSet.length === 0) {
        // Should never be the case
        return undefined;
      }
      var minPos = 0;
      var tempScore = fScore[openSet[0]];
      for (var i = 1; i < openSet.length; i++) {
        var s = fScore[openSet[i]];
        if (s < tempScore) {
          tempScore = s;
          minPos = i;
        }
      }
      return minPos;
    };

    var cy = this._private.cy;

    // root - mandatory!
    if (options != null && options.root != null) {
      var source = is.string(options.root) ?
      // use it as a selector, e.g. "#rootID
      this.filter(options.root)[0] : options.root[0];
    } else {
      return undefined;
    }

    // goal - mandatory!
    if (options.goal != null) {
      var target = is.string(options.goal) ?
      // use it as a selector, e.g. "#goalID
      this.filter(options.goal)[0] : options.goal[0];
    } else {
      return undefined;
    }

    // Heuristic function - optional
    if (options.heuristic != null && is.fn(options.heuristic)) {
      var heuristic = options.heuristic;
    } else {
      var heuristic = function heuristic() {
        return 0;
      }; // use constant if unspecified
    }

    // Weight function - optional
    if (options.weight != null && is.fn(options.weight)) {
      var weightFn = options.weight;
    } else {
      // If not specified, assume each edge has equal weight (1)
      var weightFn = function weightFn(e) {
        return 1;
      };
    }

    // directed - optional
    if (options.directed != null) {
      var directed = options.directed;
    } else {
      var directed = false;
    }

    var sid = source.id();
    var tid = target.id();

    var closedSet = [];
    var openSet = [sid];
    var cameFrom = {};
    var cameFromEdge = {};
    var gScore = {};
    var fScore = {};

    gScore[sid] = 0;
    fScore[sid] = heuristic(source);

    // Counter
    var steps = 0;

    // Main loop
    while (openSet.length > 0) {
      var minPos = findMin(openSet, fScore);
      var cMin = cy.getElementById(openSet[minPos]);
      var cMinId = cMin.id();
      steps++;

      // If we've found our goal, then we are done
      if (cMinId == tid) {
        var rPath = reconstructPath(sid, tid, cameFrom, []);

        return {
          found: true,
          distance: gScore[cMinId],
          path: eles.spawn(rPath),
          steps: steps
        };
      }

      // Add cMin to processed nodes
      closedSet.push(cMinId);
      // Remove cMin from boundary nodes
      openSet.splice(minPos, 1);

      // Update scores for neighbors of cMin
      // Take into account if graph is directed or not
      var vwEdges = cMin._private.edges;

      for (var i = 0; i < vwEdges.length; i++) {
        var e = vwEdges[i];

        // edge must be in set of calling eles
        if (!this.hasElementWithId(e.id())) {
          continue;
        }

        // cMin must be the source of edge if directed
        if (directed && e.data('source') !== cMinId) {
          continue;
        }

        var wSrc = e.source();
        var wTgt = e.target();

        var w = wSrc.id() !== cMinId ? wSrc : wTgt;
        var wid = w.id();

        // node must be in set of calling eles
        if (!this.hasElementWithId(wid)) {
          continue;
        }

        // if node is in closedSet, ignore it
        if (closedSet.indexOf(wid) != -1) {
          continue;
        }

        // New tentative score for node w
        var tempScore = gScore[cMinId] + weightFn(e);

        // Update gScore for node w if:
        //   w not present in openSet
        // OR
        //   tentative gScore is less than previous value

        // w not in openSet
        if (openSet.indexOf(wid) == -1) {
          gScore[wid] = tempScore;
          fScore[wid] = tempScore + heuristic(w);
          openSet.push(wid); // Add node to openSet
          cameFrom[wid] = cMinId;
          cameFromEdge[wid] = e.id();
          continue;
        }
        // w already in openSet, but with greater gScore
        if (tempScore < gScore[wid]) {
          gScore[wid] = tempScore;
          fScore[wid] = tempScore + heuristic(w);
          cameFrom[wid] = cMinId;
        }
      } // End of neighbors update
    } // End of main loop

    // If we've reached here, then we've not reached our goal
    return {
      found: false,
      distance: undefined,
      path: undefined,
      steps: steps
    };
  }

}; // elesfn


module.exports = elesfn;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);

var elesfn = {

  // Implemented from pseudocode from wikipedia
  floydWarshall: function floydWarshall(options) {
    options = options || {};

    var cy = this.cy();

    // Weight function - optional
    if (options.weight != null && is.fn(options.weight)) {
      var weightFn = options.weight;
    } else {
      // If not specified, assume each edge has equal weight (1)
      var weightFn = function weightFn(e) {
        return 1;
      };
    }

    // directed - optional
    if (options.directed != null) {
      var directed = options.directed;
    } else {
      var directed = false;
    }

    var edges = this.edges().stdFilter(function (e) {
      return !e.isLoop();
    });
    var nodes = this.nodes();
    var numNodes = nodes.length;

    // mapping: node id -> position in nodes array
    var id2position = {};
    for (var i = 0; i < numNodes; i++) {
      id2position[nodes[i].id()] = i;
    }

    // Initialize distance matrix
    var dist = [];
    for (var i = 0; i < numNodes; i++) {
      var newRow = new Array(numNodes);
      for (var j = 0; j < numNodes; j++) {
        if (i == j) {
          newRow[j] = 0;
        } else {
          newRow[j] = Infinity;
        }
      }
      dist.push(newRow);
    }

    // Initialize matrix used for path reconstruction
    // Initialize distance matrix
    var next = [];
    var edgeNext = [];

    var initMatrix = function initMatrix(next) {
      for (var i = 0; i < numNodes; i++) {
        var newRow = new Array(numNodes);
        for (var j = 0; j < numNodes; j++) {
          newRow[j] = undefined;
        }
        next.push(newRow);
      }
    };

    initMatrix(next);
    initMatrix(edgeNext);

    // Process edges
    for (var i = 0; i < edges.length; i++) {
      var sourceIndex = id2position[edges[i].source().id()];
      var targetIndex = id2position[edges[i].target().id()];
      var weight = weightFn(edges[i]);

      // Check if already process another edge between same 2 nodes
      if (dist[sourceIndex][targetIndex] > weight) {
        dist[sourceIndex][targetIndex] = weight;
        next[sourceIndex][targetIndex] = targetIndex;
        edgeNext[sourceIndex][targetIndex] = edges[i];
      }
    }

    // If undirected graph, process 'reversed' edges
    if (!directed) {
      for (var i = 0; i < edges.length; i++) {
        var sourceIndex = id2position[edges[i].target().id()];
        var targetIndex = id2position[edges[i].source().id()];
        var weight = weightFn(edges[i]);

        // Check if already process another edge between same 2 nodes
        if (dist[sourceIndex][targetIndex] > weight) {
          dist[sourceIndex][targetIndex] = weight;
          next[sourceIndex][targetIndex] = targetIndex;
          edgeNext[sourceIndex][targetIndex] = edges[i];
        }
      }
    }

    // Main loop
    for (var k = 0; k < numNodes; k++) {
      for (var i = 0; i < numNodes; i++) {
        for (var j = 0; j < numNodes; j++) {
          if (dist[i][k] + dist[k][j] < dist[i][j]) {
            dist[i][j] = dist[i][k] + dist[k][j];
            next[i][j] = next[i][k];
          }
        }
      }
    }

    // Build result object
    var position2id = [];
    for (var i = 0; i < numNodes; i++) {
      position2id.push(nodes[i].id());
    }

    var res = {
      distance: function distance(from, to) {
        if (is.string(from)) {
          // from is a selector string
          var fromId = cy.filter(from)[0].id();
        } else {
          // from is a node
          var fromId = from.id();
        }

        if (is.string(to)) {
          // to is a selector string
          var toId = cy.filter(to)[0].id();
        } else {
          // to is a node
          var toId = to.id();
        }

        return dist[id2position[fromId]][id2position[toId]];
      },

      path: function path(from, to) {
        var reconstructPathAux = function reconstructPathAux(from, to, next, position2id, edgeNext) {
          if (from === to) {
            return cy.getElementById(position2id[from]);
          }
          if (next[from][to] === undefined) {
            return undefined;
          }

          var path = [cy.getElementById(position2id[from])];
          var prev = from;
          while (from !== to) {
            prev = from;
            from = next[from][to];

            var edge = edgeNext[prev][from];
            path.push(edge);

            path.push(cy.getElementById(position2id[from]));
          }
          return path;
        };

        if (is.string(from)) {
          // from is a selector string
          var fromId = cy.filter(from)[0].id();
        } else {
          // from is a node
          var fromId = from.id();
        }

        if (is.string(to)) {
          // to is a selector string
          var toId = cy.filter(to)[0].id();
        } else {
          // to is a node
          var toId = to.id();
        }

        var pathArr = reconstructPathAux(id2position[fromId], id2position[toId], next, position2id, edgeNext);

        return cy.collection(pathArr);
      }
    };

    return res;
  } // floydWarshall

}; // elesfn

module.exports = elesfn;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);
var util = __webpack_require__(1);

var elesfn = {

  // Implemented from pseudocode from wikipedia
  bellmanFord: function bellmanFord(options) {
    var eles = this;

    options = options || {};

    // Weight function - optional
    if (options.weight != null && is.fn(options.weight)) {
      var weightFn = options.weight;
    } else {
      // If not specified, assume each edge has equal weight (1)
      var weightFn = function weightFn(e) {
        return 1;
      };
    }

    // directed - optional
    if (options.directed != null) {
      var directed = options.directed;
    } else {
      var directed = false;
    }

    // root - mandatory!
    if (options.root != null) {
      if (is.string(options.root)) {
        // use it as a selector, e.g. "#rootID
        var source = this.filter(options.root)[0];
      } else {
        var source = options.root[0];
      }
    } else {
      return undefined;
    }

    var cy = this._private.cy;
    var edges = this.edges().stdFilter(function (e) {
      return !e.isLoop();
    });
    var nodes = this.nodes();
    var numNodes = nodes.length;

    // mapping: node id -> position in nodes array
    var id2position = {};
    for (var i = 0; i < numNodes; i++) {
      id2position[nodes[i].id()] = i;
    }

    // Initializations
    var cost = [];
    var predecessor = [];
    var predEdge = [];

    for (var i = 0; i < numNodes; i++) {
      if (nodes[i].id() === source.id()) {
        cost[i] = 0;
      } else {
        cost[i] = Infinity;
      }
      predecessor[i] = undefined;
    }

    // Edges relaxation
    var flag = false;
    for (var i = 1; i < numNodes; i++) {
      flag = false;
      for (var e = 0; e < edges.length; e++) {
        var sourceIndex = id2position[edges[e].source().id()];
        var targetIndex = id2position[edges[e].target().id()];
        var weight = weightFn(edges[e]);

        var temp = cost[sourceIndex] + weight;
        if (temp < cost[targetIndex]) {
          cost[targetIndex] = temp;
          predecessor[targetIndex] = sourceIndex;
          predEdge[targetIndex] = edges[e];
          flag = true;
        }

        // If undirected graph, we need to take into account the 'reverse' edge
        if (!directed) {
          var temp = cost[targetIndex] + weight;
          if (temp < cost[sourceIndex]) {
            cost[sourceIndex] = temp;
            predecessor[sourceIndex] = targetIndex;
            predEdge[sourceIndex] = edges[e];
            flag = true;
          }
        }
      }

      if (!flag) {
        break;
      }
    }

    if (flag) {
      // Check for negative weight cycles
      for (var e = 0; e < edges.length; e++) {
        var sourceIndex = id2position[edges[e].source().id()];
        var targetIndex = id2position[edges[e].target().id()];
        var weight = weightFn(edges[e]);

        if (cost[sourceIndex] + weight < cost[targetIndex]) {
          util.error('Graph contains a negative weight cycle for Bellman-Ford');
          return { pathTo: undefined,
            distanceTo: undefined,
            hasNegativeWeightCycle: true };
        }
      }
    }

    // Build result object
    var position2id = [];
    for (var i = 0; i < numNodes; i++) {
      position2id.push(nodes[i].id());
    }

    var res = {
      distanceTo: function distanceTo(to) {
        if (is.string(to)) {
          // to is a selector string
          var toId = cy.filter(to)[0].id();
        } else {
          // to is a node
          var toId = to.id();
        }

        return cost[id2position[toId]];
      },

      pathTo: function pathTo(to) {

        var reconstructPathAux = function reconstructPathAux(predecessor, fromPos, toPos, position2id, acumPath, predEdge) {
          for (;;) {
            // Add toId to path
            acumPath.push(cy.getElementById(position2id[toPos]));
            acumPath.push(predEdge[toPos]);

            if (fromPos === toPos) {
              // reached starting node
              return acumPath;
            }

            // If no path exists, discart acumulated path and return undefined
            var predPos = predecessor[toPos];
            if (typeof predPos === 'undefined') {
              return undefined;
            }

            toPos = predPos;
          }
        };

        if (is.string(to)) {
          // to is a selector string
          var toId = cy.filter(to)[0].id();
        } else {
          // to is a node
          var toId = to.id();
        }
        var path = [];

        // This returns a reversed path
        var res = reconstructPathAux(predecessor, id2position[source.id()], id2position[toId], position2id, path, predEdge);

        // Get it in the correct order and return it
        if (res != null) {
          res.reverse();
        }

        return eles.spawn(res);
      },

      hasNegativeWeightCycle: false
    };

    return res;
  } // bellmanFord

}; // elesfn

module.exports = elesfn;

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);

var elesfn = {

  // Computes the minimum cut of an undirected graph
  // Returns the correct answer with high probability
  kargerStein: function kargerStein(options) {
    var eles = this;

    options = options || {};

    // Function which colapses 2 (meta) nodes into one
    // Updates the remaining edge lists
    // Receives as a paramater the edge which causes the collapse
    var colapse = function colapse(edgeIndex, nodeMap, remainingEdges) {
      var edgeInfo = remainingEdges[edgeIndex];
      var sourceIn = edgeInfo[1];
      var targetIn = edgeInfo[2];
      var partition1 = nodeMap[sourceIn];
      var partition2 = nodeMap[targetIn];

      // Delete all edges between partition1 and partition2
      var newEdges = remainingEdges.filter(function (edge) {
        if (nodeMap[edge[1]] === partition1 && nodeMap[edge[2]] === partition2) {
          return false;
        }
        if (nodeMap[edge[1]] === partition2 && nodeMap[edge[2]] === partition1) {
          return false;
        }
        return true;
      });

      // All edges pointing to partition2 should now point to partition1
      for (var i = 0; i < newEdges.length; i++) {
        var edge = newEdges[i];
        if (edge[1] === partition2) {
          // Check source
          newEdges[i] = edge.slice(0);
          newEdges[i][1] = partition1;
        } else if (edge[2] === partition2) {
          // Check target
          newEdges[i] = edge.slice(0);
          newEdges[i][2] = partition1;
        }
      }

      // Move all nodes from partition2 to partition1
      for (var i = 0; i < nodeMap.length; i++) {
        if (nodeMap[i] === partition2) {
          nodeMap[i] = partition1;
        }
      }

      return newEdges;
    };

    // Contracts a graph until we reach a certain number of meta nodes
    var contractUntil = function contractUntil(metaNodeMap, remainingEdges, size, sizeLimit) {
      // Stop condition
      if (size <= sizeLimit) {
        return remainingEdges;
      }

      // Choose an edge randomly
      var edgeIndex = Math.floor(Math.random() * remainingEdges.length);

      // Colapse graph based on edge
      var newEdges = colapse(edgeIndex, metaNodeMap, remainingEdges);

      return contractUntil(metaNodeMap, newEdges, size - 1, sizeLimit);
    };

    var cy = this._private.cy;
    var edges = this.edges().stdFilter(function (e) {
      return !e.isLoop();
    });
    var nodes = this.nodes();
    var numNodes = nodes.length;
    var numEdges = edges.length;
    var numIter = Math.ceil(Math.pow(Math.log(numNodes) / Math.LN2, 2));
    var stopSize = Math.floor(numNodes / Math.sqrt(2));

    if (numNodes < 2) {
      util.error('At least 2 nodes are required for Karger-Stein algorithm');
      return undefined;
    }

    // Create numerical identifiers for each node
    // mapping: node id -> position in nodes array
    // for reverse mapping, simply use nodes array
    var id2position = {};
    for (var i = 0; i < numNodes; i++) {
      id2position[nodes[i].id()] = i;
    }

    // Now store edge destination as indexes
    // Format for each edge (edge index, source node index, target node index)
    var edgeIndexes = [];
    for (var i = 0; i < numEdges; i++) {
      var e = edges[i];
      edgeIndexes.push([i, id2position[e.source().id()], id2position[e.target().id()]]);
    }

    // We will store the best cut found here
    var minCutSize = Infinity;
    var minCut;

    // Initial meta node partition
    var originalMetaNode = [];
    for (var i = 0; i < numNodes; i++) {
      originalMetaNode.push(i);
    }

    // Main loop
    for (var iter = 0; iter <= numIter; iter++) {
      // Create new meta node partition
      var metaNodeMap = originalMetaNode.slice(0);

      // Contract until stop point (stopSize nodes)
      var edgesState = contractUntil(metaNodeMap, edgeIndexes, numNodes, stopSize);

      // Create a copy of the colapsed nodes state
      var metaNodeMap2 = metaNodeMap.slice(0);

      // Run 2 iterations starting in the stop state
      var res1 = contractUntil(metaNodeMap, edgesState, stopSize, 2);
      var res2 = contractUntil(metaNodeMap2, edgesState, stopSize, 2);

      // Is any of the 2 results the best cut so far?
      if (res1.length <= res2.length && res1.length < minCutSize) {
        minCutSize = res1.length;
        minCut = [res1, metaNodeMap];
      } else if (res2.length <= res1.length && res2.length < minCutSize) {
        minCutSize = res2.length;
        minCut = [res2, metaNodeMap2];
      }
    } // end of main loop


    // Construct result
    var resEdges = minCut[0].map(function (e) {
      return edges[e[0]];
    });
    var partition1 = [];
    var partition2 = [];

    // traverse metaNodeMap for best cut
    var witnessNodePartition = minCut[1][0];
    for (var i = 0; i < minCut[1].length; i++) {
      var partitionId = minCut[1][i];
      if (partitionId === witnessNodePartition) {
        partition1.push(nodes[i]);
      } else {
        partition2.push(nodes[i]);
      }
    }

    var ret = {
      cut: eles.spawn(cy, resEdges),
      partition1: eles.spawn(partition1),
      partition2: eles.spawn(partition2)
    };

    return ret;
  }
}; // elesfn


module.exports = elesfn;

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);

var elesfn = {

  pageRank: function pageRank(options) {
    options = options || {};

    var normalizeVector = function normalizeVector(vector) {
      var length = vector.length;

      // First, get sum of all elements
      var total = 0;
      for (var i = 0; i < length; i++) {
        total += vector[i];
      }

      // Now, divide each by the sum of all elements
      for (var i = 0; i < length; i++) {
        vector[i] = vector[i] / total;
      }
    };

    // dampingFactor - optional
    if (options != null && options.dampingFactor != null) {
      var dampingFactor = options.dampingFactor;
    } else {
      var dampingFactor = 0.8; // Default damping factor
    }

    // desired precision - optional
    if (options != null && options.precision != null) {
      var epsilon = options.precision;
    } else {
      var epsilon = 0.000001; // Default precision
    }

    // Max number of iterations - optional
    if (options != null && options.iterations != null) {
      var numIter = options.iterations;
    } else {
      var numIter = 200; // Default number of iterations
    }

    // Weight function - optional
    if (options != null && options.weight != null && is.fn(options.weight)) {
      var weightFn = options.weight;
    } else {
      // If not specified, assume each edge has equal weight (1)
      var weightFn = function weightFn(e) {
        return 1;
      };
    }

    var cy = this._private.cy;
    var edges = this.edges().stdFilter(function (e) {
      return !e.isLoop();
    });
    var nodes = this.nodes();
    var numNodes = nodes.length;
    var numEdges = edges.length;

    // Create numerical identifiers for each node
    // mapping: node id -> position in nodes array
    // for reverse mapping, simply use nodes array
    var id2position = {};
    for (var i = 0; i < numNodes; i++) {
      id2position[nodes[i].id()] = i;
    }

    // Construct transposed adjacency matrix
    // First lets have a zeroed matrix of the right size
    // We'll also keep track of the sum of each column
    var matrix = [];
    var columnSum = [];
    var additionalProb = (1 - dampingFactor) / numNodes;

    // Create null matric
    for (var i = 0; i < numNodes; i++) {
      var newRow = [];
      for (var j = 0; j < numNodes; j++) {
        newRow.push(0.0);
      }
      matrix.push(newRow);
      columnSum.push(0.0);
    }

    // Now, process edges
    for (var i = 0; i < numEdges; i++) {
      var edge = edges[i];
      var s = id2position[edge.source().id()];
      var t = id2position[edge.target().id()];
      var w = weightFn(edge);

      // Update matrix
      matrix[t][s] += w;

      // Update column sum
      columnSum[s] += w;
    }

    // Add additional probability based on damping factor
    // Also, take into account columns that have sum = 0
    var p = 1.0 / numNodes + additionalProb; // Shorthand
    // Traverse matrix, column by column
    for (var j = 0; j < numNodes; j++) {
      if (columnSum[j] === 0) {
        // No 'links' out from node jth, assume equal probability for each possible node
        for (var i = 0; i < numNodes; i++) {
          matrix[i][j] = p;
        }
      } else {
        // Node jth has outgoing link, compute normalized probabilities
        for (var i = 0; i < numNodes; i++) {
          matrix[i][j] = matrix[i][j] / columnSum[j] + additionalProb;
        }
      }
    }

    // Compute dominant eigenvector using power method
    var eigenvector = [];
    var nullVector = [];
    var previous;

    // Start with a vector of all 1's
    // Also, initialize a null vector which will be used as shorthand
    for (var i = 0; i < numNodes; i++) {
      eigenvector.push(1.0);
      nullVector.push(0.0);
    }

    for (var iter = 0; iter < numIter; iter++) {
      // New array with all 0's
      var temp = nullVector.slice(0);

      // Multiply matrix with previous result
      for (var i = 0; i < numNodes; i++) {
        for (var j = 0; j < numNodes; j++) {
          temp[i] += matrix[i][j] * eigenvector[j];
        }
      }

      normalizeVector(temp);
      previous = eigenvector;
      eigenvector = temp;

      var diff = 0;
      // Compute difference (squared module) of both vectors
      for (var i = 0; i < numNodes; i++) {
        diff += Math.pow(previous[i] - eigenvector[i], 2);
      }

      // If difference is less than the desired threshold, stop iterating
      if (diff < epsilon) {
        break;
      }
    }

    // Construct result
    var res = {
      rank: function rank(node) {
        if (is.string(node)) {
          // is a selector string
          var nodeId = cy.filter(node)[0].id();
        } else {
          // is a node object
          var nodeId = node.id();
        }
        return eigenvector[id2position[nodeId]];
      }
    };

    return res;
  } // pageRank

}; // elesfn

module.exports = elesfn;

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);
var util = __webpack_require__(1);

var elesfn = {

  degreeCentralityNormalized: function degreeCentralityNormalized(options) {
    options = options || {};

    var cy = this.cy();

    // directed - optional
    if (options.directed != null) {
      var directed = options.directed;
    } else {
      var directed = false;
    }

    var nodes = this.nodes();
    var numNodes = nodes.length;

    if (!directed) {
      var degrees = {};
      var maxDegree = 0;

      for (var i = 0; i < numNodes; i++) {
        var node = nodes[i];
        // add current node to the current options object and call degreeCentrality
        var currDegree = this.degreeCentrality(util.extend({}, options, { root: node }));
        if (maxDegree < currDegree.degree) maxDegree = currDegree.degree;

        degrees[node.id()] = currDegree.degree;
      }

      return {
        degree: function degree(node) {
          if (maxDegree == 0) return 0;

          if (is.string(node)) {
            // from is a selector string
            var node = cy.filter(node)[0].id();
          } else {
            // from is a node
            var node = node.id();
          }

          return degrees[node] / maxDegree;
        }
      };
    } else {
      var indegrees = {};
      var outdegrees = {};
      var maxIndegree = 0;
      var maxOutdegree = 0;

      for (var i = 0; i < numNodes; i++) {
        var node = nodes[i];
        // add current node to the current options object and call degreeCentrality
        var currDegree = this.degreeCentrality(util.extend({}, options, { root: node }));

        if (maxIndegree < currDegree.indegree) maxIndegree = currDegree.indegree;

        if (maxOutdegree < currDegree.outdegree) maxOutdegree = currDegree.outdegree;

        indegrees[node.id()] = currDegree.indegree;
        outdegrees[node.id()] = currDegree.outdegree;
      }

      return {
        indegree: function indegree(node) {
          if (maxIndegree == 0) return 0;

          if (is.string(node)) {
            // from is a selector string
            var node = cy.filter(node)[0].id();
          } else {
            // from is a node
            var node = node.id();
          }

          return indegrees[node] / maxIndegree;
        },
        outdegree: function outdegree(node) {
          if (maxOutdegree == 0) return 0;

          if (is.string(node)) {
            // from is a selector string
            var node = cy.filter(node)[0].id();
          } else {
            // from is a node
            var node = node.id();
          }

          return outdegrees[node] / maxOutdegree;
        }

      };
    }
  }, // degreeCentralityNormalized

  // Implemented from the algorithm in Opsahl's paper
  // "Node centrality in weighted networks: Generalizing degree and shortest paths"
  // check the heading 2 "Degree"
  degreeCentrality: function degreeCentrality(options) {
    options = options || {};

    var callingEles = this;

    // root - mandatory!
    if (options != null && options.root != null) {
      var root = is.string(options.root) ? this.filter(options.root)[0] : options.root[0];
    } else {
      return undefined;
    }

    // weight - optional
    if (options.weight != null && is.fn(options.weight)) {
      var weightFn = options.weight;
    } else {
      // If not specified, assume each edge has equal weight (1)
      var weightFn = function weightFn(e) {
        return 1;
      };
    }

    // directed - optional
    if (options.directed != null) {
      var directed = options.directed;
    } else {
      var directed = false;
    }

    // alpha - optional
    if (options.alpha != null && is.number(options.alpha)) {
      var alpha = options.alpha;
    } else {
      alpha = 0;
    }

    if (!directed) {
      var connEdges = root.connectedEdges().intersection(callingEles);
      var k = connEdges.length;
      var s = 0;

      // Now, sum edge weights
      for (var i = 0; i < connEdges.length; i++) {
        var edge = connEdges[i];
        s += weightFn(edge);
      }

      return {
        degree: Math.pow(k, 1 - alpha) * Math.pow(s, alpha)
      };
    } else {
      var incoming = root.connectedEdges('edge[target = "' + root.id() + '"]').intersection(callingEles);
      var outgoing = root.connectedEdges('edge[source = "' + root.id() + '"]').intersection(callingEles);
      var k_in = incoming.length;
      var k_out = outgoing.length;
      var s_in = 0;
      var s_out = 0;

      // Now, sum incoming edge weights
      for (var i = 0; i < incoming.length; i++) {
        var edge = incoming[i];
        s_in += weightFn(edge);
      }

      // Now, sum outgoing edge weights
      for (var i = 0; i < outgoing.length; i++) {
        var edge = outgoing[i];
        s_out += weightFn(edge);
      }

      return {
        indegree: Math.pow(k_in, 1 - alpha) * Math.pow(s_in, alpha),
        outdegree: Math.pow(k_out, 1 - alpha) * Math.pow(s_out, alpha)
      };
    }
  } // degreeCentrality

}; // elesfn

// nice, short mathemathical alias
elesfn.dc = elesfn.degreeCentrality;
elesfn.dcn = elesfn.degreeCentralityNormalised = elesfn.degreeCentralityNormalized;

module.exports = elesfn;

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);

var elesfn = {

  closenessCentralityNormalized: function closenessCentralityNormalized(options) {
    options = options || {};

    var cy = this.cy();

    var harmonic = options.harmonic;
    if (harmonic === undefined) {
      harmonic = true;
    }

    var closenesses = {};
    var maxCloseness = 0;
    var nodes = this.nodes();
    var fw = this.floydWarshall({ weight: options.weight, directed: options.directed });

    // Compute closeness for every node and find the maximum closeness
    for (var i = 0; i < nodes.length; i++) {
      var currCloseness = 0;
      for (var j = 0; j < nodes.length; j++) {
        if (i != j) {
          var d = fw.distance(nodes[i], nodes[j]);

          if (harmonic) {
            currCloseness += 1 / d;
          } else {
            currCloseness += d;
          }
        }
      }

      if (!harmonic) {
        currCloseness = 1 / currCloseness;
      }

      if (maxCloseness < currCloseness) {
        maxCloseness = currCloseness;
      }

      closenesses[nodes[i].id()] = currCloseness;
    }

    return {
      closeness: function closeness(node) {
        if (maxCloseness == 0) {
          return 0;
        }

        if (is.string(node)) {
          // from is a selector string
          var node = cy.filter(node)[0].id();
        } else {
          // from is a node
          var node = node.id();
        }

        return closenesses[node] / maxCloseness;
      }
    };
  },

  // Implemented from pseudocode from wikipedia
  closenessCentrality: function closenessCentrality(options) {
    options = options || {};

    // root - mandatory!
    if (options.root != null) {
      if (is.string(options.root)) {
        // use it as a selector, e.g. "#rootID
        var root = this.filter(options.root)[0];
      } else {
        var root = options.root[0];
      }
    } else {
      return undefined;
    }

    // weight - optional
    if (options.weight != null && is.fn(options.weight)) {
      var weight = options.weight;
    } else {
      var weight = function weight() {
        return 1;
      };
    }

    // directed - optional
    if (options.directed != null && is.bool(options.directed)) {
      var directed = options.directed;
    } else {
      var directed = false;
    }

    var harmonic = options.harmonic;
    if (harmonic === undefined) {
      harmonic = true;
    }

    // we need distance from this node to every other node
    var dijkstra = this.dijkstra({
      root: root,
      weight: weight,
      directed: directed
    });
    var totalDistance = 0;

    var nodes = this.nodes();
    for (var i = 0; i < nodes.length; i++) {
      if (nodes[i].id() != root.id()) {
        var d = dijkstra.distanceTo(nodes[i]);

        if (harmonic) {
          totalDistance += 1 / d;
        } else {
          totalDistance += d;
        }
      }
    }

    return harmonic ? totalDistance : 1 / totalDistance;
  } // closenessCentrality

}; // elesfn

// nice, short mathemathical alias
elesfn.cc = elesfn.closenessCentrality;
elesfn.ccn = elesfn.closenessCentralityNormalised = elesfn.closenessCentralityNormalized;

module.exports = elesfn;

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);
var Heap = __webpack_require__(9);

var elesfn = {

  // Implemented from the algorithm in the paper "On Variants of Shortest-Path Betweenness Centrality and their Generic Computation" by Ulrik Brandes
  betweennessCentrality: function betweennessCentrality(options) {
    options = options || {};

    // Weight - optional
    var weighted, weightFn;
    if (is.fn(options.weight)) {
      weightFn = options.weight;
      weighted = true;
    } else {
      weighted = false;
    }

    // Directed - default false
    var directed = options.directed != null ? options.directed : false;

    var cy = this._private.cy;

    // starting
    var V = this.nodes();
    var A = {};
    var _C = {};
    var max = 0;
    var C = {
      set: function set(key, val) {
        _C[key] = val;

        if (val > max) {
          max = val;
        }
      },

      get: function get(key) {
        return _C[key];
      }
    };

    // A contains the neighborhoods of every node
    for (var i = 0; i < V.length; i++) {
      var v = V[i];
      var vid = v.id();

      if (directed) {
        A[vid] = v.outgoers().nodes(); // get outgoers of every node
      } else {
        A[vid] = v.openNeighborhood().nodes(); // get neighbors of every node
      }

      C.set(vid, 0);
    }

    for (var s = 0; s < V.length; s++) {
      var sid = V[s].id();
      var S = []; // stack
      var P = {};
      var g = {};
      var d = {};
      var Q = new Heap(function (a, b) {
        return d[a] - d[b];
      }); // queue

      // init dictionaries
      for (var i = 0; i < V.length; i++) {
        var vid = V[i].id();

        P[vid] = [];
        g[vid] = 0;
        d[vid] = Infinity;
      }

      g[sid] = 1; // sigma
      d[sid] = 0; // distance to s

      Q.push(sid);

      while (!Q.empty()) {
        var v = Q.pop();

        S.push(v);

        if (weighted) {
          for (var j = 0; j < A[v].length; j++) {
            var w = A[v][j];
            var vEle = cy.getElementById(v);

            var edge;
            if (vEle.edgesTo(w).length > 0) {
              edge = vEle.edgesTo(w)[0];
            } else {
              edge = w.edgesTo(vEle)[0];
            }

            var edgeWeight = weightFn(edge);

            w = w.id();

            if (d[w] > d[v] + edgeWeight) {
              d[w] = d[v] + edgeWeight;

              if (Q.nodes.indexOf(w) < 0) {
                //if w is not in Q
                Q.push(w);
              } else {
                // update position if w is in Q
                Q.updateItem(w);
              }

              g[w] = 0;
              P[w] = [];
            }

            if (d[w] == d[v] + edgeWeight) {
              g[w] = g[w] + g[v];
              P[w].push(v);
            }
          }
        } else {
          for (var j = 0; j < A[v].length; j++) {
            var w = A[v][j].id();

            if (d[w] == Infinity) {
              Q.push(w);

              d[w] = d[v] + 1;
            }

            if (d[w] == d[v] + 1) {
              g[w] = g[w] + g[v];
              P[w].push(v);
            }
          }
        }
      }

      var e = {};
      for (var i = 0; i < V.length; i++) {
        e[V[i].id()] = 0;
      }

      while (S.length > 0) {
        var w = S.pop();

        for (var j = 0; j < P[w].length; j++) {
          var v = P[w][j];

          e[v] = e[v] + g[v] / g[w] * (1 + e[w]);

          if (w != V[s].id()) {
            C.set(w, C.get(w) + e[w]);
          }
        }
      }
    }

    var ret = {
      betweenness: function betweenness(node) {
        if (is.string(node)) {
          var node = cy.filter(node).id();
        } else {
          var node = node.id();
        }

        return C.get(node);
      },

      betweennessNormalized: function betweennessNormalized(node) {
        if (max == 0) return 0;

        if (is.string(node)) {
          var node = cy.filter(node).id();
        } else {
          var node = node.id();
        }

        return C.get(node) / max;
      }
    };

    // alias
    ret.betweennessNormalised = ret.betweennessNormalized;

    return ret;
  } // betweennessCentrality

}; // elesfn

// nice, short mathemathical alias
elesfn.bc = elesfn.betweennessCentrality;

module.exports = elesfn;

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var define = __webpack_require__(4);

var elesfn = {
  animate: define.animate(),
  animation: define.animation(),
  animated: define.animated(),
  clearQueue: define.clearQueue(),
  delay: define.delay(),
  delayAnimation: define.delayAnimation(),
  stop: define.stop()
};

module.exports = elesfn;

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);
var Animation = __webpack_require__(44);
var math = __webpack_require__(2);
var is = __webpack_require__(0);

var define = {

  animated: function animated() {
    return function animatedImpl() {
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
      var cy = this._private.cy || this;

      if (!cy.styleEnabled()) {
        return false;
      }

      var ele = all[0];

      if (ele) {
        return ele._private.animation.current.length > 0;
      }
    };
  }, // animated

  clearQueue: function clearQueue() {
    return function clearQueueImpl() {
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
      var cy = this._private.cy || this;

      if (!cy.styleEnabled()) {
        return this;
      }

      for (var i = 0; i < all.length; i++) {
        var ele = all[i];
        ele._private.animation.queue = [];
      }

      return this;
    };
  }, // clearQueue

  delay: function delay() {
    return function delayImpl(time, complete) {
      var cy = this._private.cy || this;

      if (!cy.styleEnabled()) {
        return this;
      }

      return this.animate({
        delay: time,
        duration: time,
        complete: complete
      });
    };
  }, // delay

  delayAnimation: function delayAnimation() {
    return function delayAnimationImpl(time, complete) {
      var cy = this._private.cy || this;

      if (!cy.styleEnabled()) {
        return this;
      }

      return this.animation({
        delay: time,
        duration: time,
        complete: complete
      });
    };
  }, // delay

  animation: function animation() {
    return function animationImpl(properties, params) {
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
      var cy = this._private.cy || this;
      var isCore = !selfIsArrayLike;
      var isEles = !isCore;

      if (!cy.styleEnabled()) {
        return this;
      }

      var style = cy.style();

      properties = util.assign({}, properties, params);

      var propertiesEmpty = Object.keys(properties).length === 0;

      if (propertiesEmpty) {
        return new Animation(all[0], properties); // nothing to animate
      }

      if (properties.duration === undefined) {
        properties.duration = 400;
      }

      switch (properties.duration) {
        case 'slow':
          properties.duration = 600;
          break;
        case 'fast':
          properties.duration = 200;
          break;
      }

      if (isEles) {
        properties.style = style.getPropsList(properties.style || properties.css);

        properties.css = undefined;
      }

      if (isEles && properties.renderedPosition != null) {
        var rpos = properties.renderedPosition;
        var pan = cy.pan();
        var zoom = cy.zoom();

        properties.position = math.renderedToModelPosition(rpos, zoom, pan);
      }

      // override pan w/ panBy if set
      if (isCore && properties.panBy != null) {
        var panBy = properties.panBy;
        var cyPan = cy.pan();

        properties.pan = {
          x: cyPan.x + panBy.x,
          y: cyPan.y + panBy.y
        };
      }

      // override pan w/ center if set
      var center = properties.center || properties.centre;
      if (isCore && center != null) {
        var centerPan = cy.getCenterPan(center.eles, properties.zoom);

        if (centerPan != null) {
          properties.pan = centerPan;
        }
      }

      // override pan & zoom w/ fit if set
      if (isCore && properties.fit != null) {
        var fit = properties.fit;
        var fitVp = cy.getFitViewport(fit.eles || fit.boundingBox, fit.padding);

        if (fitVp != null) {
          properties.pan = fitVp.pan;
          properties.zoom = fitVp.zoom;
        }
      }

      // override zoom (& potentially pan) w/ zoom obj if set
      if (isCore && is.plainObject(properties.zoom)) {
        var vp = cy.getZoomedViewport(properties.zoom);

        if (vp != null) {
          if (vp.zoomed) {
            properties.zoom = vp.zoom;
          }

          if (vp.panned) {
            properties.pan = vp.pan;
          }
        }
      }

      return new Animation(all[0], properties);
    };
  }, // animate

  animate: function animate() {
    return function animateImpl(properties, params) {
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
      var cy = this._private.cy || this;

      if (!cy.styleEnabled()) {
        return this;
      }

      if (params) {
        properties = util.extend({}, properties, params);
      }

      // manually hook and run the animation
      for (var i = 0; i < all.length; i++) {
        var ele = all[i];
        var queue = ele.animated() && (properties.queue === undefined || properties.queue);

        var ani = ele.animation(properties, queue ? { queue: true } : undefined);

        ani.play();
      }

      return this; // chaining
    };
  }, // animate

  stop: function stop() {
    return function stopImpl(clearQueue, jumpToEnd) {
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
      var cy = this._private.cy || this;

      if (!cy.styleEnabled()) {
        return this;
      }

      for (var i = 0; i < all.length; i++) {
        var ele = all[i];
        var _p = ele._private;
        var anis = _p.animation.current;

        for (var j = 0; j < anis.length; j++) {
          var ani = anis[j];
          var ani_p = ani._private;

          if (jumpToEnd) {
            // next iteration of the animation loop, the animation
            // will go straight to the end and be removed
            ani_p.duration = 0;
          }
        }

        // clear the queue of future animations
        if (clearQueue) {
          _p.animation.queue = [];
        }

        if (!jumpToEnd) {
          _p.animation.current = [];
        }
      }

      // we have to notify (the animation loop doesn't do it for us on `stop`)
      cy.notify({
        eles: this,
        type: 'draw'
      });

      return this;
    };
  } // stop

}; // define

module.exports = define;

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);
var is = __webpack_require__(0);
var Promise = __webpack_require__(5);

var Animation = function Animation(target, opts, opts2) {
  var _p = this._private = util.extend({
    duration: 1000
  }, opts, opts2);

  _p.target = target;
  _p.style = _p.style || _p.css;
  _p.started = false;
  _p.playing = false;
  _p.hooked = false;
  _p.applying = false;
  _p.progress = 0;
  _p.completes = [];
  _p.frames = [];

  if (_p.complete && is.fn(_p.complete)) {
    _p.completes.push(_p.complete);
  }

  // for future timeline/animations impl
  this.length = 1;
  this[0] = this;
};

var anifn = Animation.prototype;

util.extend(anifn, {

  instanceString: function instanceString() {
    return 'animation';
  },

  hook: function hook() {
    var _p = this._private;

    if (!_p.hooked) {
      // add to target's animation queue
      var q = void 0;
      var tAni = _p.target._private.animation;
      if (_p.queue) {
        q = tAni.queue;
      } else {
        q = tAni.current;
      }
      q.push(this);

      // add to the animation loop pool
      if (is.elementOrCollection(_p.target)) {
        _p.target.cy().addToAnimationPool(_p.target);
      }

      _p.hooked = true;
    }

    return this;
  },

  play: function play() {
    var _p = this._private;

    // autorewind
    if (_p.progress === 1) {
      _p.progress = 0;
    }

    _p.playing = true;
    _p.started = false; // needs to be started by animation loop
    _p.stopped = false;

    this.hook();

    // the animation loop will start the animation...

    return this;
  },

  playing: function playing() {
    return this._private.playing;
  },

  apply: function apply() {
    var _p = this._private;

    _p.applying = true;
    _p.started = false; // needs to be started by animation loop
    _p.stopped = false;

    this.hook();

    // the animation loop will apply the animation at this progress

    return this;
  },

  applying: function applying() {
    return this._private.applying;
  },

  pause: function pause() {
    var _p = this._private;

    _p.playing = false;
    _p.started = false;

    return this;
  },

  stop: function stop() {
    var _p = this._private;

    _p.playing = false;
    _p.started = false;
    _p.stopped = true; // to be removed from animation queues

    return this;
  },

  rewind: function rewind() {
    return this.progress(0);
  },

  fastforward: function fastforward() {
    return this.progress(1);
  },

  time: function time(t) {
    var _p = this._private;

    if (t === undefined) {
      return _p.progress * _p.duration;
    } else {
      return this.progress(t / _p.duration);
    }
  },

  progress: function progress(p) {
    var _p = this._private;
    var wasPlaying = _p.playing;

    if (p === undefined) {
      return _p.progress;
    } else {
      if (wasPlaying) {
        this.pause();
      }

      _p.progress = p;
      _p.started = false;

      if (wasPlaying) {
        this.play();
      }
    }

    return this;
  },

  completed: function completed() {
    return this._private.progress === 1;
  },

  reverse: function reverse() {
    var _p = this._private;
    var wasPlaying = _p.playing;

    if (wasPlaying) {
      this.pause();
    }

    _p.progress = 1 - _p.progress;
    _p.started = false;

    var swap = function swap(a, b) {
      var _pa = _p[a];

      if (_pa == null) {
        return;
      }

      _p[a] = _p[b];
      _p[b] = _pa;
    };

    swap('zoom', 'startZoom');
    swap('pan', 'startPan');
    swap('position', 'startPosition');

    // swap styles
    if (_p.style) {
      for (var i = 0; i < _p.style.length; i++) {
        var prop = _p.style[i];
        var name = prop.name;
        var startStyleProp = _p.startStyle[name];

        _p.startStyle[name] = prop;
        _p.style[i] = startStyleProp;
      }
    }

    if (wasPlaying) {
      this.play();
    }

    return this;
  },

  promise: function promise(type) {
    var _p = this._private;

    var arr = void 0;

    switch (type) {
      case 'frame':
        arr = _p.frames;
        break;
      default:
      case 'complete':
      case 'completed':
        arr = _p.completes;
    }

    return new Promise(function (resolve, reject) {
      arr.push(function () {
        resolve();
      });
    });
  }

});

anifn.complete = anifn.completed;

module.exports = Animation;

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var util = __webpack_require__(1);
var is = __webpack_require__(0);

var define = {

  // access data field
  data: function data(params) {
    var defaults = {
      field: 'data',
      bindingEvent: 'data',
      allowBinding: false,
      allowSetting: false,
      allowGetting: false,
      settingEvent: 'data',
      settingTriggersEvent: false,
      triggerFnName: 'trigger',
      immutableKeys: {}, // key => true if immutable
      updateStyle: false,
      beforeGet: function beforeGet(self) {},
      beforeSet: function beforeSet(self, obj) {},
      onSet: function onSet(self) {},
      canSet: function canSet(self) {
        return true;
      }
    };
    params = util.extend({}, defaults, params);

    return function dataImpl(name, value) {
      var p = params;
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
      var single = selfIsArrayLike ? self[0] : self;

      // .data('foo', ...)
      if (is.string(name)) {
        // set or get property

        // .data('foo')
        if (p.allowGetting && value === undefined) {
          // get

          var ret = void 0;
          if (single) {
            p.beforeGet(single);

            ret = single._private[p.field][name];
          }
          return ret;

          // .data('foo', 'bar')
        } else if (p.allowSetting && value !== undefined) {
          // set
          var valid = !p.immutableKeys[name];
          if (valid) {
            var change = _defineProperty({}, name, value);

            p.beforeSet(self, change);

            for (var i = 0, l = all.length; i < l; i++) {
              var ele = all[i];

              if (p.canSet(ele)) {
                ele._private[p.field][name] = value;
              }
            }

            // update mappers if asked
            if (p.updateStyle) {
              self.updateStyle();
            }

            // call onSet callback
            p.onSet(self);

            if (p.settingTriggersEvent) {
              self[p.triggerFnName](p.settingEvent);
            }
          }
        }

        // .data({ 'foo': 'bar' })
      } else if (p.allowSetting && is.plainObject(name)) {
        // extend
        var obj = name;
        var k = void 0,
            v = void 0;
        var keys = Object.keys(obj);

        p.beforeSet(self, obj);

        for (var _i = 0; _i < keys.length; _i++) {
          k = keys[_i];
          v = obj[k];

          var _valid = !p.immutableKeys[k];
          if (_valid) {
            for (var j = 0; j < all.length; j++) {
              var _ele = all[j];

              if (p.canSet(_ele)) {
                _ele._private[p.field][k] = v;
              }
            }
          }
        }

        // update mappers if asked
        if (p.updateStyle) {
          self.updateStyle();
        }

        // call onSet callback
        p.onSet(self);

        if (p.settingTriggersEvent) {
          self[p.triggerFnName](p.settingEvent);
        }

        // .data(function(){ ... })
      } else if (p.allowBinding && is.fn(name)) {
        // bind to event
        var fn = name;
        self.on(p.bindingEvent, fn);

        // .data()
      } else if (p.allowGetting && name === undefined) {
        // get whole object
        var _ret = void 0;
        if (single) {
          p.beforeGet(single);

          _ret = single._private[p.field];
        }
        return _ret;
      }

      return self; // maintain chainability
    }; // function
  }, // data

  // remove data field
  removeData: function removeData(params) {
    var defaults = {
      field: 'data',
      event: 'data',
      triggerFnName: 'trigger',
      triggerEvent: false,
      immutableKeys: {} // key => true if immutable
    };
    params = util.extend({}, defaults, params);

    return function removeDataImpl(names) {
      var p = params;
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like

      // .removeData('foo bar')
      if (is.string(names)) {
        // then get the list of keys, and delete them
        var keys = names.split(/\s+/);
        var l = keys.length;

        for (var i = 0; i < l; i++) {
          // delete each non-empty key
          var key = keys[i];
          if (is.emptyString(key)) {
            continue;
          }

          var valid = !p.immutableKeys[key]; // not valid if immutable
          if (valid) {
            for (var i_a = 0, l_a = all.length; i_a < l_a; i_a++) {
              all[i_a]._private[p.field][key] = undefined;
            }
          }
        }

        if (p.triggerEvent) {
          self[p.triggerFnName](p.event);
        }

        // .removeData()
      } else if (names === undefined) {
        // then delete all keys

        for (var _i_a = 0, _l_a = all.length; _i_a < _l_a; _i_a++) {
          var _privateFields = all[_i_a]._private[p.field];
          var _keys = Object.keys(_privateFields);

          for (var _i2 = 0; _i2 < _keys.length; _i2++) {
            var _key = _keys[_i2];
            var validKeyToDelete = !p.immutableKeys[_key];

            if (validKeyToDelete) {
              _privateFields[_key] = undefined;
            }
          }
        }

        if (p.triggerEvent) {
          self[p.triggerFnName](p.event);
        }
      }

      return self; // maintain chaining
    }; // function
  } // removeData
}; // define

module.exports = define;

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Promise = __webpack_require__(5);

var define = {

  eventAliasesOn: function eventAliasesOn(proto) {
    var p = proto;

    p.addListener = p.listen = p.bind = p.on;
    p.unlisten = p.unbind = p.off = p.removeListener;
    p.trigger = p.emit;

    // this is just a wrapper alias of .on()
    p.pon = p.promiseOn = function (events, selector) {
      var self = this;
      var args = Array.prototype.slice.call(arguments, 0);

      return new Promise(function (resolve, reject) {
        var callback = function callback(e) {
          self.off.apply(self, offArgs);

          resolve(e);
        };

        var onArgs = args.concat([callback]);
        var offArgs = onArgs.concat([]);

        self.on.apply(self, onArgs);
      });
    };
  }

}; // define

module.exports = define;

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Set = __webpack_require__(8);

var elesfn = {
  classes: function classes(_classes) {
    _classes = (_classes || '').match(/\S+/g) || [];
    var self = this;
    var changed = [];
    var classesMap = new Set(_classes);

    // check and update each ele

    var _loop = function _loop(j) {
      var ele = self[j];
      var _p = ele._private;
      var eleClasses = _p.classes;
      var changedEle = false;

      // check if ele has all of the passed classes
      classesMap.forEach(function (cls) {
        var eleHasClass = eleClasses.has(cls);

        if (!eleHasClass) {
          changedEle = true;
        }
      });

      // check if ele has classes outside of those passed
      if (!changedEle) {
        eleClasses.forEach(function (eleCls) {
          var specdClass = classesMap.has(eleCls);

          if (!specdClass) {
            changedEle = true;
          }
        });
      }

      if (changedEle) {
        _p.classes = new Set(classesMap);

        changed.push(ele);
      }
    };

    for (var j = 0; j < self.length; j++) {
      _loop(j);
    }

    // trigger update style on those eles that had class changes
    if (changed.length > 0) {
      this.spawn(changed).updateStyle().emit('class');
    }

    return self;
  },

  addClass: function addClass(classes) {
    return this.toggleClass(classes, true);
  },

  hasClass: function hasClass(className) {
    var ele = this[0];
    return ele != null && ele._private.classes.has(className);
  },

  toggleClass: function toggleClass(classesStr, toggle) {
    var classes = classesStr.match(/\S+/g) || [];
    var self = this;
    var changed = []; // eles who had classes changed

    for (var i = 0, il = self.length; i < il; i++) {
      var _ele = self[i];
      var _changedEle = false;

      for (var j = 0; j < classes.length; j++) {
        var cls = classes[j];
        var _eleClasses = _ele._private.classes;
        var hasClass = _eleClasses.has(cls);
        var shouldAdd = toggle || toggle === undefined && !hasClass;

        if (shouldAdd) {
          _eleClasses.add(cls);

          if (!hasClass && !_changedEle) {
            changed.push(_ele);
            _changedEle = true;
          }
        } else {
          // then remove
          _eleClasses.delete(cls);

          if (hasClass && !_changedEle) {
            changed.push(_ele);
            _changedEle = true;
          }
        }
      } // for j classes
    } // for i eles

    // trigger update style on those eles that had class changes
    if (changed.length > 0) {
      this.spawn(changed).updateStyle().emit('class');
    }

    return self;
  },

  removeClass: function removeClass(classes) {
    return this.toggleClass(classes, false);
  },

  flashClass: function flashClass(classes, duration) {
    var self = this;

    if (duration == null) {
      duration = 250;
    } else if (duration === 0) {
      return self; // nothing to do really
    }

    self.addClass(classes);
    setTimeout(function () {
      self.removeClass(classes);
    }, duration);

    return self;
  }
};

module.exports = elesfn;

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);
var Selector = __webpack_require__(6);

var elesfn = {
  allAre: function allAre(selector) {
    var selObj = new Selector(selector);

    return this.every(function (ele) {
      return selObj.matches(ele);
    });
  },

  is: function is(selector) {
    var selObj = new Selector(selector);

    return this.some(function (ele) {
      return selObj.matches(ele);
    });
  },

  some: function some(fn, thisArg) {
    for (var i = 0; i < this.length; i++) {
      var ret = !thisArg ? fn(this[i], i, this) : fn.apply(thisArg, [this[i], i, this]);

      if (ret) {
        return true;
      }
    }

    return false;
  },

  every: function every(fn, thisArg) {
    for (var i = 0; i < this.length; i++) {
      var ret = !thisArg ? fn(this[i], i, this) : fn.apply(thisArg, [this[i], i, this]);

      if (!ret) {
        return false;
      }
    }

    return true;
  },

  same: function same(collection) {
    collection = this.cy().collection(collection);

    // cheap extra check
    if (this.length !== collection.length) {
      return false;
    }

    return this.every(function (ele) {
      return collection.hasElementWithId(ele.id());
    });
  },

  anySame: function anySame(collection) {
    collection = this.cy().collection(collection);

    return this.some(function (ele) {
      return collection.hasElementWithId(ele.id());
    });
  },

  allAreNeighbors: function allAreNeighbors(collection) {
    collection = this.cy().collection(collection);

    var nhood = this.neighborhood();

    return collection.every(function (ele) {
      return nhood.hasElementWithId(ele.id());
    });
  },

  contains: function contains(collection) {
    collection = this.cy().collection(collection);

    var self = this;

    return collection.every(function (ele) {
      return self.hasElementWithId(ele.id());
    });
  }
};

elesfn.allAreNeighbours = elesfn.allAreNeighbors;
elesfn.has = elesfn.contains;

module.exports = elesfn;

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);
var exprs = __webpack_require__(50);
var newQuery = __webpack_require__(10);

// of all the expressions, find the first match in the remaining text
var consumeExpr = function consumeExpr(remaining) {
  var expr = void 0;
  var match = void 0;
  var name = void 0;

  for (var j = 0; j < exprs.length; j++) {
    var e = exprs[j];
    var n = e.name;

    var m = remaining.match(e.regexObj);

    if (m != null) {
      match = m;
      expr = e;
      name = n;

      var consumed = m[0];
      remaining = remaining.substring(consumed.length);

      break; // we've consumed one expr, so we can return now
    }
  }

  return {
    expr: expr,
    match: match,
    name: name,
    remaining: remaining
  };
};

// consume all leading whitespace
var consumeWhitespace = function consumeWhitespace(remaining) {
  var match = remaining.match(/^\s+/);

  if (match) {
    var consumed = match[0];
    remaining = remaining.substring(consumed.length);
  }

  return remaining;
};

var parse = function parse(selector) {
  var self = this;

  var remaining = self._private.selectorText = selector;

  var currentQuery = self[0] = newQuery();
  self.length = 1;

  remaining = consumeWhitespace(remaining); // get rid of leading whitespace

  for (;;) {
    var check = consumeExpr(remaining);

    if (check.expr == null) {
      util.error('The selector `' + selector + '`is invalid');
      return false;
    } else {
      var args = check.match.slice(1);

      // let the token populate the selector object in currentQuery
      var ret = check.expr.populate(self, currentQuery, args);

      if (ret === false) {
        return false; // exit if population failed
      } else if (ret != null) {
        currentQuery = ret; // change the current query to be filled if the expr specifies
      }
    }

    remaining = check.remaining;

    // we're done when there's nothing left to parse
    if (remaining.match(/^\s*$/)) {
      break;
    }
  }

  // adjust references for subject
  for (var j = 0; j < self.length; j++) {
    var query = self[j];

    if (query.subject != null) {
      // go up the tree until we reach the subject
      for (;;) {
        if (query.subject === query) {
          break;
        } // done if subject is self

        if (query.parent != null) {
          // swap parent/child reference
          var parent = query.parent;
          var child = query;

          child.parent = null;
          parent.child = child;

          query = parent; // go up the tree
        } else if (query.ancestor != null) {
          // swap ancestor/descendant
          var ancestor = query.ancestor;
          var descendant = query;

          descendant.ancestor = null;
          ancestor.descendant = descendant;

          query = ancestor; // go up the tree
        } else if (query.source || query.target || query.connectedNodes) {
          util.error('The selector `' + self.text() + '` can not contain a subject selector that applies to the source or target of an edge selector');
          return false;
        } else {
          util.error('When adjusting references for the selector `' + self.text() + '`, neither parent nor ancestor was found');
          return false;
        }
      } // for

      self[j] = query.subject; // subject should be the root query
    } // if
  } // for

  return true; // success
};

module.exports = { parse: parse };

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _require = __webpack_require__(15),
    stateSelectorRegex = _require.stateSelectorRegex;

var tokens = __webpack_require__(51);
var util = __webpack_require__(1);
var newQuery = __webpack_require__(10);

// when a token like a variable has escaped meta characters, we need to clean the backslashes out
// so that values get compared properly in Selector.filter()
var cleanMetaChars = function cleanMetaChars(str) {
  return str.replace(new RegExp('\\\\(' + tokens.metaChar + ')', 'g'), function (match, $1) {
    return $1;
  });
};

var replaceLastQuery = function replaceLastQuery(selector, examiningQuery, replacementQuery) {
  if (examiningQuery === selector[selector.length - 1]) {
    selector[selector.length - 1] = replacementQuery;
  }
};

// NOTE: add new expression syntax here to have it recognised by the parser;
// - a query contains all adjacent (i.e. no separator in between) expressions;
// - the current query is stored in selector[i] --- you can use the reference to `this` in the populate function;
// - you need to check the query objects in Selector.filter() for it actually filter properly, but that's pretty straight forward
// - when you add something here, also add to Selector.toString()
var exprs = [{
  name: 'group',
  query: true,
  regex: '(' + tokens.group + ')',
  populate: function populate(selector, query, _ref) {
    var _ref2 = _slicedToArray(_ref, 1),
        group = _ref2[0];

    query.group = group === '*' ? group : group + 's';
  }
}, {
  name: 'state',
  query: true,
  regex: stateSelectorRegex,
  populate: function populate(selector, query, _ref3) {
    var _ref4 = _slicedToArray(_ref3, 1),
        state = _ref4[0];

    query.colonSelectors.push(state);
  }
}, {
  name: 'id',
  query: true,
  regex: '\\#(' + tokens.id + ')',
  populate: function populate(selector, query, _ref5) {
    var _ref6 = _slicedToArray(_ref5, 1),
        id = _ref6[0];

    query.ids.push(cleanMetaChars(id));
  }
}, {
  name: 'className',
  query: true,
  regex: '\\.(' + tokens.className + ')',
  populate: function populate(selector, query, _ref7) {
    var _ref8 = _slicedToArray(_ref7, 1),
        className = _ref8[0];

    query.classes.push(cleanMetaChars(className));
  }
}, {
  name: 'dataExists',
  query: true,
  regex: '\\[\\s*(' + tokens.variable + ')\\s*\\]',
  populate: function populate(selector, query, _ref9) {
    var _ref10 = _slicedToArray(_ref9, 1),
        variable = _ref10[0];

    query.data.push({
      field: cleanMetaChars(variable)
    });
  }
}, {
  name: 'dataCompare',
  query: true,
  regex: '\\[\\s*(' + tokens.variable + ')\\s*(' + tokens.comparatorOp + ')\\s*(' + tokens.value + ')\\s*\\]',
  populate: function populate(selector, query, _ref11) {
    var _ref12 = _slicedToArray(_ref11, 3),
        variable = _ref12[0],
        comparatorOp = _ref12[1],
        value = _ref12[2];

    var valueIsString = new RegExp('^' + tokens.string + '$').exec(value) != null;

    if (valueIsString) {
      value = value.substring(1, value.length - 1);
    } else {
      value = parseFloat(value);
    }

    query.data.push({
      field: cleanMetaChars(variable),
      operator: comparatorOp,
      value: value
    });
  }
}, {
  name: 'dataBool',
  query: true,
  regex: '\\[\\s*(' + tokens.boolOp + ')\\s*(' + tokens.variable + ')\\s*\\]',
  populate: function populate(selector, query, _ref13) {
    var _ref14 = _slicedToArray(_ref13, 2),
        boolOp = _ref14[0],
        variable = _ref14[1];

    query.data.push({
      field: cleanMetaChars(variable),
      operator: boolOp
    });
  }
}, {
  name: 'metaCompare',
  query: true,
  regex: '\\[\\[\\s*(' + tokens.meta + ')\\s*(' + tokens.comparatorOp + ')\\s*(' + tokens.number + ')\\s*\\]\\]',
  populate: function populate(selector, query, _ref15) {
    var _ref16 = _slicedToArray(_ref15, 3),
        meta = _ref16[0],
        comparatorOp = _ref16[1],
        number = _ref16[2];

    query.meta.push({
      field: cleanMetaChars(meta),
      operator: comparatorOp,
      value: parseFloat(number)
    });
  }
}, {
  name: 'nextQuery',
  separator: true,
  regex: tokens.separator,
  populate: function populate(selector) {
    // go on to next query
    var nextQuery = selector[selector.length++] = newQuery();
    selector.currentSubject = null;

    return nextQuery;
  }
}, {
  name: 'directedEdge',
  separator: true,
  regex: tokens.directedEdge,
  populate: function populate(selector, query) {
    var edgeQuery = newQuery();
    var source = query;
    var target = newQuery();

    edgeQuery.group = 'edges';
    edgeQuery.target = target;
    edgeQuery.source = source;
    edgeQuery.subject = selector.currentSubject;

    // the query in the selector should be the edge rather than the source
    replaceLastQuery(selector, query, edgeQuery);

    // we're now populating the target query with expressions that follow
    return target;
  }
}, {
  name: 'undirectedEdge',
  separator: true,
  regex: tokens.undirectedEdge,
  populate: function populate(selector, query) {
    var edgeQuery = newQuery();
    var source = query;
    var target = newQuery();

    edgeQuery.group = 'edges';
    edgeQuery.connectedNodes = [source, target];
    edgeQuery.subject = selector.currentSubject;

    // the query in the selector should be the edge rather than the source
    replaceLastQuery(selector, query, edgeQuery);

    // we're now populating the target query with expressions that follow
    return target;
  }
}, {
  name: 'child',
  separator: true,
  regex: tokens.child,
  populate: function populate(selector, query) {
    // this query is the parent of the following query
    var childQuery = newQuery();
    childQuery.parent = query;
    childQuery.subject = selector.currentSubject;

    // it's cheaper to compare children first and go up so replace the parent
    replaceLastQuery(selector, query, childQuery);

    // we're now populating the child query with expressions that follow
    return childQuery;
  }
}, {
  name: 'descendant',
  separator: true,
  regex: tokens.descendant,
  populate: function populate(selector, query) {
    // this query is the ancestor of the following query
    var descendantQuery = newQuery();
    descendantQuery.ancestor = query;
    descendantQuery.subject = selector.currentSubject;

    // it's cheaper to compare descendants first and go up so replace the ancestor
    replaceLastQuery(selector, query, descendantQuery);

    // we're now populating the descendant query with expressions that follow
    return descendantQuery;
  }
}, {
  name: 'subject',
  modifier: true,
  regex: tokens.subject,
  populate: function populate(selector, query) {
    if (selector.currentSubject != null && query.subject != query) {
      util.error('Redefinition of subject in selector `' + selector.toString() + '`');
      return false;
    }

    selector.currentSubject = query;
    query.subject = query;
    selector[selector.length - 1].subject = query;
  }
}];

exprs.forEach(function (e) {
  return e.regexObj = new RegExp('^' + e.regex);
});

module.exports = exprs;

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);

// tokens in the query language
var tokens = {
  metaChar: '[\\!\\"\\#\\$\\%\\&\\\'\\(\\)\\*\\+\\,\\.\\/\\:\\;\\<\\=\\>\\?\\@\\[\\]\\^\\`\\{\\|\\}\\~]', // chars we need to escape in let names, etc
  comparatorOp: '=|\\!=|>|>=|<|<=|\\$=|\\^=|\\*=', // binary comparison op (used in data selectors)
  boolOp: '\\?|\\!|\\^', // boolean (unary) operators (used in data selectors)
  string: '"(?:\\\\"|[^"])*"' + '|' + "'(?:\\\\'|[^'])*'", // string literals (used in data selectors) -- doublequotes | singlequotes
  number: util.regex.number, // number literal (used in data selectors) --- e.g. 0.1234, 1234, 12e123
  meta: 'degree|indegree|outdegree', // allowed metadata fields (i.e. allowed functions to use from Collection)
  separator: '\\s*,\\s*', // queries are separated by commas, e.g. edge[foo = 'bar'], node.someClass
  descendant: '\\s+',
  child: '\\s+>\\s+',
  subject: '\\$',
  group: 'node|edge|\\*',
  directedEdge: '\\s+->\\s+',
  undirectedEdge: '\\s+<->\\s+'
};
tokens.variable = '(?:[\\w-]|(?:\\\\' + tokens.metaChar + '))+'; // a variable name
tokens.value = tokens.string + '|' + tokens.number; // a value literal, either a string or number
tokens.className = tokens.variable; // a class name (follows variable conventions)
tokens.id = tokens.variable; // an element id (follows variable conventions)

(function () {
  var ops = void 0,
      op = void 0,
      i = void 0;

  // add @ variants to comparatorOp
  ops = tokens.comparatorOp.split('|');
  for (i = 0; i < ops.length; i++) {
    op = ops[i];
    tokens.comparatorOp += '|@' + op;
  }

  // add ! variants to comparatorOp
  ops = tokens.comparatorOp.split('|');
  for (i = 0; i < ops.length; i++) {
    op = ops[i];

    if (op.indexOf('!') >= 0) {
      continue;
    } // skip ops that explicitly contain !
    if (op === '=') {
      continue;
    } // skip = b/c != is explicitly defined

    tokens.comparatorOp += '|\\!' + op;
  }
})();

module.exports = tokens;

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _require = __webpack_require__(15),
    stateSelectorMatches = _require.stateSelectorMatches;

var is = __webpack_require__(0);

// generic checking for data/metadata
var operandsMatch = function operandsMatch(query, params) {
  var allDataMatches = true;
  for (var k = 0; k < query[params.name].length; k++) {
    var data = query[params.name][k];
    var operator = data.operator;
    var value = data.value;
    var field = data.field;
    var _matches = void 0;
    var fieldVal = params.fieldValue(field);

    if (operator != null && value != null) {
      var fieldStr = !is.string(fieldVal) && !is.number(fieldVal) ? '' : '' + fieldVal;
      var valStr = '' + value;

      var caseInsensitive = false;
      if (operator.indexOf('@') >= 0) {
        fieldStr = fieldStr.toLowerCase();
        valStr = valStr.toLowerCase();

        operator = operator.replace('@', '');
        caseInsensitive = true;
      }

      var notExpr = false;
      if (operator.indexOf('!') >= 0) {
        operator = operator.replace('!', '');
        notExpr = true;
      }

      // if we're doing a case insensitive comparison, then we're using a STRING comparison
      // even if we're comparing numbers
      if (caseInsensitive) {
        value = valStr.toLowerCase();
        fieldVal = fieldStr.toLowerCase();
      }

      var isIneqCmp = false;

      switch (operator) {
        case '*=':
          _matches = fieldStr.indexOf(valStr) >= 0;
          break;
        case '$=':
          _matches = fieldStr.indexOf(valStr, fieldStr.length - valStr.length) >= 0;
          break;
        case '^=':
          _matches = fieldStr.indexOf(valStr) === 0;
          break;
        case '=':
          _matches = fieldVal === value;
          break;
        case '>':
          isIneqCmp = true;
          _matches = fieldVal > value;
          break;
        case '>=':
          isIneqCmp = true;
          _matches = fieldVal >= value;
          break;
        case '<':
          isIneqCmp = true;
          _matches = fieldVal < value;
          break;
        case '<=':
          isIneqCmp = true;
          _matches = fieldVal <= value;
          break;
        default:
          _matches = false;
          break;
      }

      // apply the not op, but null vals for inequalities should always stay non-matching
      if (notExpr && (fieldVal != null || !isIneqCmp)) {
        _matches = !_matches;
      }
    } else if (operator != null) {
      switch (operator) {
        case '?':
          _matches = fieldVal ? true : false;
          break;
        case '!':
          _matches = fieldVal ? false : true;
          break;
        case '^':
          _matches = fieldVal === undefined;
          break;
      }
    } else {
      _matches = fieldVal !== undefined;
    }

    if (!_matches) {
      allDataMatches = false;
      break;
    }
  } // for

  return allDataMatches;
}; // operandsMatch

// check parent/child relations
var confirmRelations = function confirmRelations(query, isNecessary, eles) {
  if (query != null) {
    var _matches2 = false;

    if (!isNecessary) {
      return false;
    }

    eles = eles(); // save cycles if query == null

    // query must match for at least one element (may be recursive)
    for (var i = 0; i < eles.length; i++) {
      if (queryMatches(query, eles[i])) {
        _matches2 = true;
        break;
      }
    }

    return _matches2;
  } else {
    return true;
  }
};

var queryMatches = function queryMatches(query, ele) {
  // make single group-only selectors really cheap to check since they're the most common ones
  if (query.groupOnly) {
    return query.group === '*' || query.group === ele.group();
  }

  // check group
  if (query.group != null && query.group != '*' && query.group != ele.group()) {
    return false;
  }

  var cy = ele.cy();
  var k = void 0;

  // check colon selectors
  var allColonSelectorsMatch = true;
  for (k = 0; k < query.colonSelectors.length; k++) {
    var sel = query.colonSelectors[k];

    allColonSelectorsMatch = stateSelectorMatches(sel, ele);

    if (!allColonSelectorsMatch) break;
  }
  if (!allColonSelectorsMatch) return false;

  // check id
  var allIdsMatch = true;
  for (k = 0; k < query.ids.length; k++) {
    var id = query.ids[k];
    var actualId = ele.id();

    allIdsMatch = allIdsMatch && id == actualId;

    if (!allIdsMatch) break;
  }
  if (!allIdsMatch) return false;

  // check classes
  var allClassesMatch = true;
  for (k = 0; k < query.classes.length; k++) {
    var cls = query.classes[k];

    allClassesMatch = allClassesMatch && ele.hasClass(cls);

    if (!allClassesMatch) break;
  }
  if (!allClassesMatch) return false;

  // check data matches
  var allDataMatches = operandsMatch(query, {
    name: 'data',
    fieldValue: function fieldValue(field) {
      return ele.data(field);
    }
  });

  if (!allDataMatches) {
    return false;
  }

  // check metadata matches
  var allMetaMatches = operandsMatch(query, {
    name: 'meta',
    fieldValue: function fieldValue(field) {
      return ele[field]();
    }
  });

  if (!allMetaMatches) {
    return false;
  }

  // check collection
  if (query.collection != null) {
    var matchesAny = query.collection.hasElementWithId(ele.id());

    if (!matchesAny) {
      return false;
    }
  }

  // check filter function
  if (query.filter != null && ele.collection().some(query.filter)) {
    return false;
  }

  var isCompound = cy.hasCompoundNodes();
  var getSource = function getSource() {
    return ele.source();
  };
  var getTarget = function getTarget() {
    return ele.target();
  };

  if (!confirmRelations(query.parent, isCompound, function () {
    return ele.parent();
  })) {
    return false;
  }

  if (!confirmRelations(query.ancestor, isCompound, function () {
    return ele.parents();
  })) {
    return false;
  }

  if (!confirmRelations(query.child, isCompound, function () {
    return ele.children();
  })) {
    return false;
  }

  if (!confirmRelations(query.descendant, isCompound, function () {
    return ele.descendants();
  })) {
    return false;
  }

  if (!confirmRelations(query.source, true, getSource)) {
    return false;
  }

  if (!confirmRelations(query.target, true, getTarget)) {
    return false;
  }

  if (query.connectedNodes) {
    var q0 = query.connectedNodes[0];
    var q1 = query.connectedNodes[1];

    if (confirmRelations(q0, true, getSource) && confirmRelations(q1, true, getTarget)) {
      // match
    } else if (confirmRelations(q0, true, getTarget) && confirmRelations(q1, true, getSource)) {
      // match
    } else {
      return false;
    }
  }

  // we've reached the end, so we've matched everything for this query
  return true;
}; // queryMatches

// filter an existing collection
var filter = function filter(collection) {
  var self = this;
  var cy = collection.cy();

  // don't bother trying if it's invalid
  if (self.invalid()) {
    return cy.collection();
  }

  // for 1 id #foo queries, just get the element
  if (self.length === 1 && self[0].length === 1 && self[0].ids.length === 1) {
    return collection.getElementById(self[0].ids[0]).collection();
  }

  var selectorFunction = function selectorFunction(element) {
    for (var j = 0; j < self.length; j++) {
      var query = self[j];

      if (queryMatches(query, element)) {
        return true;
      }
    }

    return false;
  };

  if (self.text() == null) {
    selectorFunction = function selectorFunction() {
      return true;
    };
  }

  var filteredCollection = collection.filter(selectorFunction);

  return filteredCollection;
}; // filter

// does selector match a single element?
var matches = function matches(ele) {
  var self = this;

  // don't bother trying if it's invalid
  if (self.invalid()) {
    return false;
  }

  for (var j = 0; j < self.length; j++) {
    var query = self[j];

    if (queryMatches(query, ele)) {
      return true;
    }
  }

  return false;
}; // filter

module.exports = { matches: matches, filter: filter };

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Set = __webpack_require__(8);

var elesfn = {
  parent: function parent(selector) {
    var parents = [];

    // optimisation for single ele call
    if (this.length === 1) {
      var parent = this[0]._private.parent;

      if (parent) {
        return parent;
      }
    }

    for (var i = 0; i < this.length; i++) {
      var ele = this[i];
      var _parent = ele._private.parent;

      if (_parent) {
        parents.push(_parent);
      }
    }

    return this.spawn(parents, { unique: true }).filter(selector);
  },

  parents: function parents(selector) {
    var parents = [];

    var eles = this.parent();
    while (eles.nonempty()) {
      for (var i = 0; i < eles.length; i++) {
        var ele = eles[i];
        parents.push(ele);
      }

      eles = eles.parent();
    }

    return this.spawn(parents, { unique: true }).filter(selector);
  },

  commonAncestors: function commonAncestors(selector) {
    var ancestors = void 0;

    for (var i = 0; i < this.length; i++) {
      var ele = this[i];
      var parents = ele.parents();

      ancestors = ancestors || parents;

      ancestors = ancestors.intersect(parents); // current list must be common with current ele parents set
    }

    return ancestors.filter(selector);
  },

  orphans: function orphans(selector) {
    return this.stdFilter(function (ele) {
      return ele.isOrphan();
    }).filter(selector);
  },

  nonorphans: function nonorphans(selector) {
    return this.stdFilter(function (ele) {
      return ele.isChild();
    }).filter(selector);
  },

  children: function children(selector) {
    var children = [];

    for (var i = 0; i < this.length; i++) {
      var ele = this[i];
      children = children.concat(ele._private.children);
    }

    return this.spawn(children, { unique: true }).filter(selector);
  },

  siblings: function siblings(selector) {
    return this.parent().children().not(this).filter(selector);
  },

  isParent: function isParent() {
    var ele = this[0];

    if (ele) {
      return ele.isNode() && ele._private.children.length !== 0;
    }
  },

  isChildless: function isChildless() {
    var ele = this[0];

    if (ele) {
      return ele.isNode() && ele._private.children.length === 0;
    }
  },

  isChild: function isChild() {
    var ele = this[0];

    if (ele) {
      return ele.isNode() && ele._private.parent != null;
    }
  },

  isOrphan: function isOrphan() {
    var ele = this[0];

    if (ele) {
      return ele.isNode() && ele._private.parent == null;
    }
  },

  descendants: function descendants(selector) {
    var elements = [];

    function add(eles) {
      for (var i = 0; i < eles.length; i++) {
        var ele = eles[i];

        elements.push(ele);

        if (ele.children().nonempty()) {
          add(ele.children());
        }
      }
    }

    add(this.children());

    return this.spawn(elements, { unique: true }).filter(selector);
  }
};

function forEachCompound(eles, fn, includeSelf, recursiveStep) {
  var q = [];
  var did = new Set();
  var cy = eles.cy();
  var hasCompounds = cy.hasCompoundNodes();

  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];

    if (includeSelf) {
      q.push(ele);
    } else if (hasCompounds) {
      recursiveStep(q, did, ele);
    }
  }

  while (q.length > 0) {
    var _ele = q.shift();

    fn(_ele);

    did.add(_ele.id());

    if (hasCompounds) {
      recursiveStep(q, did, _ele);
    }
  }

  return eles;
}

function addChildren(q, did, ele) {
  if (ele.isParent()) {
    var children = ele._private.children;

    for (var i = 0; i < children.length; i++) {
      var child = children[i];

      if (!did.has(child.id())) {
        q.push(child);
      }
    }
  }
}

// very efficient version of eles.add( eles.descendants() ).forEach()
// for internal use
elesfn.forEachDown = function (fn) {
  var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

  return forEachCompound(this, fn, includeSelf, addChildren);
};

function addParent(q, did, ele) {
  if (ele.isChild()) {
    var parent = ele._private.parent;

    if (!did.has(parent.id())) {
      q.push(parent);
    }
  }
}

elesfn.forEachUp = function (fn) {
  var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

  return forEachCompound(this, fn, includeSelf, addParent);
};

function addParentAndChildren(q, did, ele) {
  addParent(q, did, ele);
  addChildren(q, did, ele);
}

elesfn.forEachUpAndDown = function (fn) {
  var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

  return forEachCompound(this, fn, includeSelf, addParentAndChildren);
};

// aliases
elesfn.ancestors = elesfn.parents;

module.exports = elesfn;

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var define = __webpack_require__(4);
var fn = void 0,
    elesfn = void 0;

fn = elesfn = {

  data: define.data({
    field: 'data',
    bindingEvent: 'data',
    allowBinding: true,
    allowSetting: true,
    settingEvent: 'data',
    settingTriggersEvent: true,
    triggerFnName: 'trigger',
    allowGetting: true,
    immutableKeys: {
      'id': true,
      'source': true,
      'target': true,
      'parent': true
    },
    updateStyle: true
  }),

  removeData: define.removeData({
    field: 'data',
    event: 'data',
    triggerFnName: 'trigger',
    triggerEvent: true,
    immutableKeys: {
      'id': true,
      'source': true,
      'target': true,
      'parent': true
    },
    updateStyle: true
  }),

  scratch: define.data({
    field: 'scratch',
    bindingEvent: 'scratch',
    allowBinding: true,
    allowSetting: true,
    settingEvent: 'scratch',
    settingTriggersEvent: true,
    triggerFnName: 'trigger',
    allowGetting: true,
    updateStyle: true
  }),

  removeScratch: define.removeData({
    field: 'scratch',
    event: 'scratch',
    triggerFnName: 'trigger',
    triggerEvent: true,
    updateStyle: true
  }),

  rscratch: define.data({
    field: 'rscratch',
    allowBinding: false,
    allowSetting: true,
    settingTriggersEvent: false,
    allowGetting: true
  }),

  removeRscratch: define.removeData({
    field: 'rscratch',
    triggerEvent: false
  }),

  id: function id() {
    var ele = this[0];

    if (ele) {
      return ele._private.data.id;
    }
  }

};

// aliases
fn.attr = fn.data;
fn.removeAttr = fn.removeData;

module.exports = elesfn;

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);

var elesfn = {};

function defineDegreeFunction(callback) {
  return function (includeLoops) {
    var self = this;

    if (includeLoops === undefined) {
      includeLoops = true;
    }

    if (self.length === 0) {
      return;
    }

    if (self.isNode() && !self.removed()) {
      var degree = 0;
      var node = self[0];
      var connectedEdges = node._private.edges;

      for (var i = 0; i < connectedEdges.length; i++) {
        var edge = connectedEdges[i];

        if (!includeLoops && edge.isLoop()) {
          continue;
        }

        degree += callback(node, edge);
      }

      return degree;
    } else {
      return;
    }
  };
}

util.extend(elesfn, {
  degree: defineDegreeFunction(function (node, edge) {
    if (edge.source().same(edge.target())) {
      return 2;
    } else {
      return 1;
    }
  }),

  indegree: defineDegreeFunction(function (node, edge) {
    if (edge.target().same(node)) {
      return 1;
    } else {
      return 0;
    }
  }),

  outdegree: defineDegreeFunction(function (node, edge) {
    if (edge.source().same(node)) {
      return 1;
    } else {
      return 0;
    }
  })
});

function defineDegreeBoundsFunction(degreeFn, callback) {
  return function (includeLoops) {
    var ret = void 0;
    var nodes = this.nodes();

    for (var i = 0; i < nodes.length; i++) {
      var ele = nodes[i];
      var degree = ele[degreeFn](includeLoops);
      if (degree !== undefined && (ret === undefined || callback(degree, ret))) {
        ret = degree;
      }
    }

    return ret;
  };
}

util.extend(elesfn, {
  minDegree: defineDegreeBoundsFunction('degree', function (degree, min) {
    return degree < min;
  }),

  maxDegree: defineDegreeBoundsFunction('degree', function (degree, max) {
    return degree > max;
  }),

  minIndegree: defineDegreeBoundsFunction('indegree', function (degree, min) {
    return degree < min;
  }),

  maxIndegree: defineDegreeBoundsFunction('indegree', function (degree, max) {
    return degree > max;
  }),

  minOutdegree: defineDegreeBoundsFunction('outdegree', function (degree, min) {
    return degree < min;
  }),

  maxOutdegree: defineDegreeBoundsFunction('outdegree', function (degree, max) {
    return degree > max;
  })
});

util.extend(elesfn, {
  totalDegree: function totalDegree(includeLoops) {
    var total = 0;
    var nodes = this.nodes();

    for (var i = 0; i < nodes.length; i++) {
      total += nodes[i].degree(includeLoops);
    }

    return total;
  }
});

module.exports = elesfn;

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);
var position = __webpack_require__(57);
var bounds = __webpack_require__(58);
var widthHeight = __webpack_require__(59);
var edgePoints = __webpack_require__(60);

module.exports = util.assign({}, position, bounds, widthHeight, edgePoints);

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var define = __webpack_require__(4);
var is = __webpack_require__(0);
var math = __webpack_require__(2);
var fn = void 0,
    elesfn = void 0;

var beforePositionSet = function beforePositionSet(eles, newPos) {
  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];

    if (ele.isParent() && !ele.locked()) {
      var oldPos = ele._private.position;
      var delta = {
        x: newPos.x - oldPos.x,
        y: newPos.y - oldPos.y
      };

      eles.children().shift(delta);
    }
  }
};

fn = elesfn = {

  position: define.data({
    field: 'position',
    bindingEvent: 'position',
    allowBinding: true,
    allowSetting: true,
    settingEvent: 'position',
    settingTriggersEvent: true,
    triggerFnName: 'emitAndNotify',
    allowGetting: true,
    validKeys: ['x', 'y'],
    beforeGet: function beforeGet(ele) {
      ele.updateCompoundBounds();
    },
    beforeSet: beforePositionSet,
    onSet: function onSet(eles) {
      eles.dirtyCompoundBoundsCache();
    },
    canSet: function canSet(ele) {
      return !ele.locked();
    }
  }),

  // position but no notification to renderer
  silentPosition: define.data({
    field: 'position',
    bindingEvent: 'position',
    allowBinding: false,
    allowSetting: true,
    settingEvent: 'position',
    settingTriggersEvent: false,
    triggerFnName: 'trigger',
    allowGetting: false,
    validKeys: ['x', 'y'],
    beforeSet: beforePositionSet,
    onSet: function onSet(eles) {
      eles.dirtyCompoundBoundsCache();
    },
    canSet: function canSet(ele) {
      return !ele.locked();
    }
  }),

  positions: function positions(pos, silent) {
    if (is.plainObject(pos)) {
      if (silent) {
        this.silentPosition(pos);
      } else {
        this.position(pos);
      }
    } else if (is.fn(pos)) {
      var _fn = pos;
      var cy = this.cy();

      cy.startBatch();

      for (var i = 0; i < this.length; i++) {
        var ele = this[i];
        var _pos = void 0;

        if (_pos = _fn(ele, i)) {
          if (silent) {
            ele.silentPosition(_pos);
          } else {
            ele.position(_pos);
          }
        }
      }

      cy.endBatch();
    }

    return this; // chaining
  },

  silentPositions: function silentPositions(pos) {
    return this.positions(pos, true);
  },

  shift: function shift(dim, val) {
    var delta = void 0;

    if (is.plainObject(dim)) {
      delta = dim;
    } else if (is.string(dim) && is.number(val)) {
      delta = { x: 0, y: 0 };

      delta[dim] = val;
    }

    if (delta != null) {
      for (var i = 0; i < this.length; i++) {
        var ele = this[i];
        var pos = ele.position();

        ele.position({
          x: pos.x + delta.x,
          y: pos.y + delta.y
        });
      }
    }

    return this;
  },

  // get/set the rendered (i.e. on screen) positon of the element
  renderedPosition: function renderedPosition(dim, val) {
    var ele = this[0];
    var cy = this.cy();
    var zoom = cy.zoom();
    var pan = cy.pan();
    var rpos = is.plainObject(dim) ? dim : undefined;
    var setting = rpos !== undefined || val !== undefined && is.string(dim);

    if (ele && ele.isNode()) {
      // must have an element and must be a node to return position
      if (setting) {
        for (var i = 0; i < this.length; i++) {
          var _ele = this[i];

          if (val !== undefined) {
            // set one dimension
            _ele.position(dim, (val - pan[dim]) / zoom);
          } else if (rpos !== undefined) {
            // set whole position
            _ele.position(math.renderedToModelPosition(rpos, zoom, pan));
          }
        }
      } else {
        // getting
        var pos = ele.position();
        rpos = math.modelToRenderedPosition(pos, zoom, pan);

        if (dim === undefined) {
          // then return the whole rendered position
          return rpos;
        } else {
          // then return the specified dimension
          return rpos[dim];
        }
      }
    } else if (!setting) {
      return undefined; // for empty collection case
    }

    return this; // chaining
  },

  // get/set the position relative to the parent
  relativePosition: function relativePosition(dim, val) {
    var ele = this[0];
    var cy = this.cy();
    var ppos = is.plainObject(dim) ? dim : undefined;
    var setting = ppos !== undefined || val !== undefined && is.string(dim);
    var hasCompoundNodes = cy.hasCompoundNodes();

    if (ele && ele.isNode()) {
      // must have an element and must be a node to return position
      if (setting) {
        for (var i = 0; i < this.length; i++) {
          var _ele2 = this[i];
          var parent = hasCompoundNodes ? _ele2.parent() : null;
          var hasParent = parent && parent.length > 0;
          var relativeToParent = hasParent;

          if (hasParent) {
            parent = parent[0];
          }

          var origin = relativeToParent ? parent.position() : { x: 0, y: 0 };

          if (val !== undefined) {
            // set one dimension
            _ele2.position(dim, val + origin[dim]);
          } else if (ppos !== undefined) {
            // set whole position
            _ele2.position({
              x: ppos.x + origin.x,
              y: ppos.y + origin.y
            });
          }
        }
      } else {
        // getting
        var pos = ele.position();
        var _parent = hasCompoundNodes ? ele.parent() : null;
        var _hasParent = _parent && _parent.length > 0;
        var _relativeToParent = _hasParent;

        if (_hasParent) {
          _parent = _parent[0];
        }

        var _origin = _relativeToParent ? _parent.position() : { x: 0, y: 0 };

        ppos = {
          x: pos.x - _origin.x,
          y: pos.y - _origin.y
        };

        if (dim === undefined) {
          // then return the whole rendered position
          return ppos;
        } else {
          // then return the specified dimension
          return ppos[dim];
        }
      }
    } else if (!setting) {
      return undefined; // for empty collection case
    }

    return this; // chaining
  }
};

// aliases
fn.modelPosition = fn.point = fn.position;
fn.modelPositions = fn.points = fn.positions;
fn.renderedPoint = fn.renderedPosition;
fn.relativePoint = fn.relativePosition;

module.exports = elesfn;

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);
var util = __webpack_require__(1);
var math = __webpack_require__(2);
var fn = void 0,
    elesfn = void 0;

fn = elesfn = {};

elesfn.renderedBoundingBox = function (options) {
  var bb = this.boundingBox(options);
  var cy = this.cy();
  var zoom = cy.zoom();
  var pan = cy.pan();

  var x1 = bb.x1 * zoom + pan.x;
  var x2 = bb.x2 * zoom + pan.x;
  var y1 = bb.y1 * zoom + pan.y;
  var y2 = bb.y2 * zoom + pan.y;

  return {
    x1: x1,
    x2: x2,
    y1: y1,
    y2: y2,
    w: x2 - x1,
    h: y2 - y1
  };
};

elesfn.dirtyCompoundBoundsCache = function () {
  var cy = this.cy();

  if (!cy.styleEnabled() || !cy.hasCompoundNodes()) {
    return this;
  }

  this.forEachUp(function (ele) {
    ele._private.compoundBoundsClean = false;

    if (ele.isParent()) {
      ele.emit('bounds');
    }
  });

  return this;
};

elesfn.updateCompoundBounds = function () {
  var cy = this.cy();

  // save cycles for non compound graphs or when style disabled
  if (!cy.styleEnabled() || !cy.hasCompoundNodes()) {
    return this;
  }

  // save cycles when batching -- but bounds will be stale (or not exist yet)
  if (cy.batching()) {
    return this;
  }

  var updated = [];

  function update(parent) {
    if (!parent.isParent()) {
      return;
    }

    var _p = parent._private;
    var children = parent.children();
    var includeLabels = parent.pstyle('compound-sizing-wrt-labels').value === 'include';

    var min = {
      width: {
        val: parent.pstyle('min-width').pfValue,
        left: parent.pstyle('min-width-bias-left'),
        right: parent.pstyle('min-width-bias-right')
      },
      height: {
        val: parent.pstyle('min-height').pfValue,
        top: parent.pstyle('min-height-bias-top'),
        bottom: parent.pstyle('min-height-bias-bottom')
      }
    };

    var bb = children.boundingBox({
      includeLabels: includeLabels,
      includeOverlays: false,

      // updating the compound bounds happens outside of the regular
      // cache cycle (i.e. before fired events)
      useCache: false
    });
    var pos = _p.position;

    // if children take up zero area then keep position and fall back on stylesheet w/h
    if (bb.w === 0 || bb.h === 0) {
      bb = {
        w: parent.pstyle('width').pfValue,
        h: parent.pstyle('height').pfValue
      };

      bb.x1 = pos.x - bb.w / 2;
      bb.x2 = pos.x + bb.w / 2;
      bb.y1 = pos.y - bb.h / 2;
      bb.y2 = pos.y + bb.h / 2;
    }

    function computeBiasValues(propDiff, propBias, propBiasComplement) {
      var biasDiff = 0;
      var biasComplementDiff = 0;
      var biasTotal = propBias + propBiasComplement;

      if (propDiff > 0 && biasTotal > 0) {
        biasDiff = propBias / biasTotal * propDiff;
        biasComplementDiff = propBiasComplement / biasTotal * propDiff;
      }
      return {
        biasDiff: biasDiff,
        biasComplementDiff: biasComplementDiff
      };
    }

    function computePaddingValues(width, height, paddingObject, relativeTo) {
      // Assuming percentage is number from 0 to 1
      if (paddingObject.units === '%') {
        switch (relativeTo) {
          case 'width':
            return width > 0 ? paddingObject.pfValue * width : 0;
          case 'height':
            return height > 0 ? paddingObject.pfValue * height : 0;
          case 'average':
            return width > 0 && height > 0 ? paddingObject.pfValue * (width + height) / 2 : 0;
          case 'min':
            return width > 0 && height > 0 ? width > height ? paddingObject.pfValue * height : paddingObject.pfValue * width : 0;
          case 'max':
            return width > 0 && height > 0 ? width > height ? paddingObject.pfValue * width : paddingObject.pfValue * height : 0;
          default:
            return 0;
        }
      } else if (paddingObject.units === 'px') {
        return paddingObject.pfValue;
      } else {
        return 0;
      }
    }

    var leftVal = min.width.left.value;
    if (min.width.left.units === 'px' && min.width.val > 0) {
      leftVal = leftVal * 100 / min.width.val;
    }
    var rightVal = min.width.right.value;
    if (min.width.right.units === 'px' && min.width.val > 0) {
      rightVal = rightVal * 100 / min.width.val;
    }

    var topVal = min.height.top.value;
    if (min.height.top.units === 'px' && min.height.val > 0) {
      topVal = topVal * 100 / min.height.val;
    }

    var bottomVal = min.height.bottom.value;
    if (min.height.bottom.units === 'px' && min.height.val > 0) {
      bottomVal = bottomVal * 100 / min.height.val;
    }

    var widthBiasDiffs = computeBiasValues(min.width.val - bb.w, leftVal, rightVal);
    var diffLeft = widthBiasDiffs.biasDiff;
    var diffRight = widthBiasDiffs.biasComplementDiff;

    var heightBiasDiffs = computeBiasValues(min.height.val - bb.h, topVal, bottomVal);
    var diffTop = heightBiasDiffs.biasDiff;
    var diffBottom = heightBiasDiffs.biasComplementDiff;

    _p.autoPadding = computePaddingValues(bb.w, bb.h, parent.pstyle('padding'), parent.pstyle('padding-relative-to').value);

    _p.autoWidth = Math.max(bb.w, min.width.val);
    pos.x = (-diffLeft + bb.x1 + bb.x2 + diffRight) / 2;

    _p.autoHeight = Math.max(bb.h, min.height.val);
    pos.y = (-diffTop + bb.y1 + bb.y2 + diffBottom) / 2;

    updated.push(parent);
  }

  for (var i = 0; i < this.length; i++) {
    var ele = this[i];
    var _p = ele._private;

    if (!_p.compoundBoundsClean) {
      update(ele);

      if (!cy._private.batchingStyle) {
        _p.compoundBoundsClean = true;
      }
    }
  }

  return this;
};

var noninf = function noninf(x) {
  if (x === Infinity || x === -Infinity) {
    return 0;
  }

  return x;
};

var updateBounds = function updateBounds(b, x1, y1, x2, y2) {
  // don't update with zero area boxes
  if (x2 - x1 === 0 || y2 - y1 === 0) {
    return;
  }

  // don't update with null dim
  if (x1 == null || y1 == null || x2 == null || y2 == null) {
    return;
  }

  b.x1 = x1 < b.x1 ? x1 : b.x1;
  b.x2 = x2 > b.x2 ? x2 : b.x2;
  b.y1 = y1 < b.y1 ? y1 : b.y1;
  b.y2 = y2 > b.y2 ? y2 : b.y2;
};

var updateBoundsFromBox = function updateBoundsFromBox(b, b2) {
  return updateBounds(b, b2.x1, b2.y1, b2.x2, b2.y2);
};

var prefixedProperty = function prefixedProperty(obj, field, prefix) {
  return util.getPrefixedProperty(obj, field, prefix);
};

var updateBoundsFromArrow = function updateBoundsFromArrow(bounds, ele, prefix) {
  if (ele.cy().headless()) {
    return;
  }

  var _p = ele._private;
  var rstyle = _p.rstyle;
  var halfArW = rstyle.arrowWidth / 2;
  var arrowType = ele.pstyle(prefix + '-arrow-shape').value;
  var x = void 0;
  var y = void 0;

  if (arrowType !== 'none') {
    if (prefix === 'source') {
      x = rstyle.srcX;
      y = rstyle.srcY;
    } else if (prefix === 'target') {
      x = rstyle.tgtX;
      y = rstyle.tgtY;
    } else {
      x = rstyle.midX;
      y = rstyle.midY;
    }

    updateBounds(bounds, x - halfArW, y - halfArW, x + halfArW, y + halfArW);
  }
};

var updateBoundsFromLabel = function updateBoundsFromLabel(bounds, ele, prefix) {
  if (ele.cy().headless()) {
    return;
  }

  var prefixDash = void 0;

  if (prefix) {
    prefixDash = prefix + '-';
  } else {
    prefixDash = '';
  }

  var _p = ele._private;
  var rstyle = _p.rstyle;
  var label = ele.pstyle(prefixDash + 'label').strValue;

  if (label) {
    var halign = ele.pstyle('text-halign');
    var valign = ele.pstyle('text-valign');
    var labelWidth = prefixedProperty(rstyle, 'labelWidth', prefix);
    var labelHeight = prefixedProperty(rstyle, 'labelHeight', prefix);
    var labelX = prefixedProperty(rstyle, 'labelX', prefix);
    var labelY = prefixedProperty(rstyle, 'labelY', prefix);
    var marginX = ele.pstyle(prefixDash + 'text-margin-x').pfValue;
    var marginY = ele.pstyle(prefixDash + 'text-margin-y').pfValue;
    var isEdge = ele.isEdge();
    var rotation = ele.pstyle(prefixDash + 'text-rotation');
    var outlineWidth = ele.pstyle('text-outline-width').pfValue;
    var borderWidth = ele.pstyle('text-border-width').pfValue;
    var halfBorderWidth = borderWidth / 2;
    var padding = ele.pstyle('text-background-padding').pfValue;

    var lh = labelHeight + 2 * padding;
    var lw = labelWidth + 2 * padding;
    var lw_2 = lw / 2;
    var lh_2 = lh / 2;
    var lx1 = void 0,
        lx2 = void 0,
        ly1 = void 0,
        ly2 = void 0;

    if (isEdge) {
      lx1 = labelX - lw_2;
      lx2 = labelX + lw_2;
      ly1 = labelY - lh_2;
      ly2 = labelY + lh_2;
    } else {
      switch (halign.value) {
        case 'left':
          lx1 = labelX - lw;
          lx2 = labelX;
          break;

        case 'center':
          lx1 = labelX - lw_2;
          lx2 = labelX + lw_2;
          break;

        case 'right':
          lx1 = labelX;
          lx2 = labelX + lw;
          break;
      }

      switch (valign.value) {
        case 'top':
          ly1 = labelY - lh;
          ly2 = labelY;
          break;

        case 'center':
          ly1 = labelY - lh_2;
          ly2 = labelY + lh_2;
          break;

        case 'bottom':
          ly1 = labelY;
          ly2 = labelY + lh;
          break;
      }
    }

    var isAutorotate = isEdge && rotation.strValue === 'autorotate';
    var isPfValue = rotation.pfValue != null && rotation.pfValue !== 0;

    if (isAutorotate || isPfValue) {
      var theta = isAutorotate ? prefixedProperty(_p.rstyle, 'labelAngle', prefix) : rotation.pfValue;
      var cos = Math.cos(theta);
      var sin = Math.sin(theta);

      var rotate = function rotate(x, y) {
        x = x - labelX;
        y = y - labelY;

        return {
          x: x * cos - y * sin + labelX,
          y: x * sin + y * cos + labelY
        };
      };

      var px1y1 = rotate(lx1, ly1);
      var px1y2 = rotate(lx1, ly2);
      var px2y1 = rotate(lx2, ly1);
      var px2y2 = rotate(lx2, ly2);

      lx1 = Math.min(px1y1.x, px1y2.x, px2y1.x, px2y2.x);
      lx2 = Math.max(px1y1.x, px1y2.x, px2y1.x, px2y2.x);
      ly1 = Math.min(px1y1.y, px1y2.y, px2y1.y, px2y2.y);
      ly2 = Math.max(px1y1.y, px1y2.y, px2y1.y, px2y2.y);
    }

    lx1 += marginX - Math.max(outlineWidth, halfBorderWidth);
    lx2 += marginX + Math.max(outlineWidth, halfBorderWidth);
    ly1 += marginY - Math.max(outlineWidth, halfBorderWidth);
    ly2 += marginY + Math.max(outlineWidth, halfBorderWidth);

    updateBounds(bounds, lx1, ly1, lx2, ly2);
  }

  return bounds;
};

// get the bounding box of the elements (in raw model position)
var boundingBoxImpl = function boundingBoxImpl(ele, options) {
  var cy = ele._private.cy;
  var styleEnabled = cy.styleEnabled();
  var headless = cy.headless();

  var bounds = {
    x1: Infinity,
    y1: Infinity,
    x2: -Infinity,
    y2: -Infinity
  };

  var _p = ele._private;
  var display = styleEnabled ? ele.pstyle('display').value : 'element';
  var isNode = ele.isNode();
  var isEdge = ele.isEdge();
  var ex1 = void 0,
      ex2 = void 0,
      ey1 = void 0,
      ey2 = void 0; // extrema of body / lines
  var x = void 0,
      y = void 0; // node pos
  var displayed = display !== 'none';

  if (displayed) {
    var overlayOpacity = 0;
    var overlayPadding = 0;

    if (styleEnabled && options.includeOverlays) {
      overlayOpacity = ele.pstyle('overlay-opacity').value;

      if (overlayOpacity !== 0) {
        overlayPadding = ele.pstyle('overlay-padding').value;
      }
    }

    var w = 0;
    var wHalf = 0;

    if (styleEnabled) {
      w = ele.pstyle('width').pfValue;
      wHalf = w / 2;
    }

    if (isNode && options.includeNodes) {
      var pos = ele.position();
      x = pos.x;
      y = pos.y;
      var _w = ele.outerWidth();
      var halfW = _w / 2;
      var h = ele.outerHeight();
      var halfH = h / 2;

      // handle node dimensions
      /////////////////////////

      ex1 = x - halfW - overlayPadding;
      ex2 = x + halfW + overlayPadding;
      ey1 = y - halfH - overlayPadding;
      ey2 = y + halfH + overlayPadding;

      updateBounds(bounds, ex1, ey1, ex2, ey2);
    } else if (isEdge && options.includeEdges) {
      var rstyle = _p.rstyle || {};

      // handle edge dimensions (rough box estimate)
      //////////////////////////////////////////////
      if (styleEnabled && !headless) {
        ex1 = Math.min(rstyle.srcX, rstyle.midX, rstyle.tgtX);
        ex2 = Math.max(rstyle.srcX, rstyle.midX, rstyle.tgtX);
        ey1 = Math.min(rstyle.srcY, rstyle.midY, rstyle.tgtY);
        ey2 = Math.max(rstyle.srcY, rstyle.midY, rstyle.tgtY);

        // take into account edge width
        ex1 -= wHalf;
        ex2 += wHalf;
        ey1 -= wHalf;
        ey2 += wHalf;

        updateBounds(bounds, ex1, ey1, ex2, ey2);
      }

      // precise haystacks
      ////////////////////
      if (styleEnabled && !headless && ele.pstyle('curve-style').strValue === 'haystack') {
        var hpts = rstyle.haystackPts || [];

        ex1 = hpts[0].x;
        ey1 = hpts[0].y;
        ex2 = hpts[1].x;
        ey2 = hpts[1].y;

        if (ex1 > ex2) {
          var temp = ex1;
          ex1 = ex2;
          ex2 = temp;
        }

        if (ey1 > ey2) {
          var _temp = ey1;
          ey1 = ey2;
          ey2 = _temp;
        }

        updateBounds(bounds, ex1 - wHalf, ey1 - wHalf, ex2 + wHalf, ey2 + wHalf);

        // handle points along edge
        ///////////////////////////
      } else {
        var pts = rstyle.bezierPts || rstyle.linePts || [];

        for (var j = 0; j < pts.length; j++) {
          var pt = pts[j];

          ex1 = pt.x - wHalf;
          ex2 = pt.x + wHalf;
          ey1 = pt.y - wHalf;
          ey2 = pt.y + wHalf;

          updateBounds(bounds, ex1, ey1, ex2, ey2);
        }

        // fallback on source and target positions
        //////////////////////////////////////////
        if (pts.length === 0) {
          var n1 = ele.source();
          var n1pos = n1.position();

          var n2 = ele.target();
          var n2pos = n2.position();

          ex1 = n1pos.x;
          ex2 = n2pos.x;
          ey1 = n1pos.y;
          ey2 = n2pos.y;

          if (ex1 > ex2) {
            var _temp2 = ex1;
            ex1 = ex2;
            ex2 = _temp2;
          }

          if (ey1 > ey2) {
            var _temp3 = ey1;
            ey1 = ey2;
            ey2 = _temp3;
          }

          // take into account edge width
          ex1 -= wHalf;
          ex2 += wHalf;
          ey1 -= wHalf;
          ey2 += wHalf;

          updateBounds(bounds, ex1, ey1, ex2, ey2);
        }
      }
    } // edges


    // handle edge arrow size
    /////////////////////////

    if (styleEnabled && options.includeEdges && isEdge) {
      updateBoundsFromArrow(bounds, ele, 'mid-source', options);
      updateBoundsFromArrow(bounds, ele, 'mid-target', options);
      updateBoundsFromArrow(bounds, ele, 'source', options);
      updateBoundsFromArrow(bounds, ele, 'target', options);
    }

    // ghost
    ////////

    if (styleEnabled) {
      var ghost = ele.pstyle('ghost').value === 'yes';

      if (ghost) {
        var gx = ele.pstyle('ghost-offset-x').pfValue;
        var gy = ele.pstyle('ghost-offset-y').pfValue;

        updateBounds(bounds, bounds.x1 + gx, bounds.y1 + gy, bounds.x2 + gx, bounds.y2 + gy);
      }
    }

    // overlay
    //////////

    if (styleEnabled) {

      ex1 = bounds.x1;
      ex2 = bounds.x2;
      ey1 = bounds.y1;
      ey2 = bounds.y2;

      updateBounds(bounds, ex1 - overlayPadding, ey1 - overlayPadding, ex2 + overlayPadding, ey2 + overlayPadding);
    }

    // handle label dimensions
    //////////////////////////

    if (styleEnabled && options.includeLabels) {
      updateBoundsFromLabel(bounds, ele, null, options);

      if (isEdge) {
        updateBoundsFromLabel(bounds, ele, 'source', options);
        updateBoundsFromLabel(bounds, ele, 'target', options);
      }
    } // style enabled for labels
  } // if displayed

  bounds.x1 = noninf(bounds.x1);
  bounds.y1 = noninf(bounds.y1);
  bounds.x2 = noninf(bounds.x2);
  bounds.y2 = noninf(bounds.y2);
  bounds.w = noninf(bounds.x2 - bounds.x1);
  bounds.h = noninf(bounds.y2 - bounds.y1);

  // expand bounds by 1 because antialiasing can increase the visual/effective size by 1 on all sides
  if (bounds.w > 0 && bounds.h > 0 && displayed) {
    math.expandBoundingBox(bounds, 1);
  }

  return bounds;
};

var tf = function tf(val) {
  if (val) {
    return 't';
  } else {
    return 'f';
  }
};

var getKey = function getKey(opts) {
  var key = '';

  key += tf(opts.incudeNodes);
  key += tf(opts.includeEdges);
  key += tf(opts.includeLabels);
  key += tf(opts.includeOverlays);

  return key;
};

var cachedBoundingBoxImpl = function cachedBoundingBoxImpl(ele, opts) {
  var _p = ele._private;
  var bb = void 0;
  var headless = ele.cy().headless();
  var key = opts === defBbOpts ? defBbOptsKey : getKey(opts);

  if (!opts.useCache || headless || !_p.bbCache || !_p.bbCache[key]) {
    bb = boundingBoxImpl(ele, opts);

    if (!headless) {
      _p.bbCache = _p.bbCache || {};
      _p.bbCache[key] = bb;
    }
  } else {
    bb = _p.bbCache[key];
  }

  return bb;
};

var defBbOpts = {
  includeNodes: true,
  includeEdges: true,
  includeLabels: true,
  includeOverlays: true,
  useCache: true
};

var defBbOptsKey = getKey(defBbOpts);

function filledBbOpts(options) {
  return {
    includeNodes: util.default(options.includeNodes, defBbOpts.includeNodes),
    includeEdges: util.default(options.includeEdges, defBbOpts.includeEdges),
    includeLabels: util.default(options.includeLabels, defBbOpts.includeLabels),
    includeOverlays: util.default(options.includeOverlays, defBbOpts.includeOverlays),
    useCache: util.default(options.useCache, defBbOpts.useCache)
  };
}

elesfn.boundingBox = function (options) {
  // the main usecase is ele.boundingBox() for a single element with no/def options
  // specified s.t. the cache is used, so check for this case to make it faster by
  // avoiding the overhead of the rest of the function
  if (this.length === 1 && this[0]._private.bbCache && (options === undefined || options.useCache === undefined || options.useCache === true)) {
    if (options === undefined) {
      options = defBbOpts;
    } else {
      options = filledBbOpts(options);
    }

    return cachedBoundingBoxImpl(this[0], options);
  }

  var bounds = {
    x1: Infinity,
    y1: Infinity,
    x2: -Infinity,
    y2: -Infinity
  };

  options = options || util.staticEmptyObject();

  var opts = filledBbOpts(options);

  var eles = this;
  var cy = eles.cy();
  var styleEnabled = cy.styleEnabled();

  if (styleEnabled) {
    this.recalculateRenderedStyle(opts.useCache);
  }

  this.updateCompoundBounds();

  var updatedEdge = {}; // use to avoid duplicated edge updates

  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];

    if (styleEnabled && ele.isEdge() && ele.pstyle('curve-style').strValue === 'bezier' && !updatedEdge[ele.id()]) {
      var edges = ele.parallelEdges();

      for (var j = 0; j < edges.length; j++) {
        // make all as updated
        updatedEdge[edges[j].id()] = true;
      }

      edges.recalculateRenderedStyle(opts.useCache); // n.b. ele.parallelEdges() single is cached
    }

    updateBoundsFromBox(bounds, cachedBoundingBoxImpl(ele, opts));
  }

  bounds.x1 = noninf(bounds.x1);
  bounds.y1 = noninf(bounds.y1);
  bounds.x2 = noninf(bounds.x2);
  bounds.y2 = noninf(bounds.y2);
  bounds.w = noninf(bounds.x2 - bounds.x1);
  bounds.h = noninf(bounds.y2 - bounds.y1);

  return bounds;
};

// private helper to get bounding box for custom node positions
// - good for perf in certain cases but currently requires dirtying the rendered style
// - would be better to not modify the nodes but the nodes are read directly everywhere in the renderer...
// - try to use for only things like discrete layouts where the node position would change anyway
elesfn.boundingBoxAt = function (fn) {
  var nodes = this.nodes();

  if (is.plainObject(fn)) {
    var obj = fn;

    fn = function fn() {
      return obj;
    };
  }

  // save the current position and set the new one, per node
  for (var i = 0; i < nodes.length; i++) {
    var n = nodes[i];
    var _p = n._private;
    var pos = _p.position;
    var newPos = fn.call(n, n, i);

    _p.bbAtOldPos = { x: pos.x, y: pos.y };

    if (newPos) {
      pos.x = newPos.x;
      pos.y = newPos.y;
    }
  }

  this.emit('dirty'); // let the renderer know we've manually dirtied rendered dim calcs

  nodes.dirtyCompoundBoundsCache().updateCompoundBounds();

  var bb = this.boundingBox({ useCache: false });

  // restore the original position, per node
  for (var _i = 0; _i < nodes.length; _i++) {
    var _n = nodes[_i];
    var _p2 = _n._private;
    var _pos = _n._private.position;
    var old = _p2.bbAtOldPos;

    _pos.x = old.x;
    _pos.y = old.y;
  }

  nodes.dirtyCompoundBoundsCache();

  this.emit('dirty'); // let the renderer know we've manually dirtied rendered dim calcs

  return bb;
};

fn.boundingbox = fn.boundingBox;
fn.renderedBoundingbox = fn.renderedBoundingBox;

module.exports = elesfn;

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);
var fn = void 0,
    elesfn = void 0;

fn = elesfn = {};

var defineDimFns = function defineDimFns(opts) {
  opts.uppercaseName = util.capitalize(opts.name);
  opts.autoName = 'auto' + opts.uppercaseName;
  opts.labelName = 'label' + opts.uppercaseName;
  opts.outerName = 'outer' + opts.uppercaseName;
  opts.uppercaseOuterName = util.capitalize(opts.outerName);

  fn[opts.name] = function dimImpl() {
    var ele = this[0];
    var _p = ele._private;
    var cy = _p.cy;
    var styleEnabled = cy._private.styleEnabled;

    if (ele) {
      if (styleEnabled) {
        if (ele.isParent()) {
          ele.updateCompoundBounds();

          return _p[opts.autoName] || 0;
        }

        var d = ele.pstyle(opts.name);

        switch (d.strValue) {
          case 'label':
            ele.recalculateRenderedStyle();

            return _p.rstyle[opts.labelName] || 0;

          default:
            return d.pfValue;
        }
      } else {
        return 1;
      }
    }
  };

  fn['outer' + opts.uppercaseName] = function outerDimImpl() {
    var ele = this[0];
    var _p = ele._private;
    var cy = _p.cy;
    var styleEnabled = cy._private.styleEnabled;

    if (ele) {
      if (styleEnabled) {
        var dim = ele[opts.name]();
        var border = ele.pstyle('border-width').pfValue; // n.b. 1/2 each side
        var padding = 2 * ele.padding();

        return dim + border + padding;
      } else {
        return 1;
      }
    }
  };

  fn['rendered' + opts.uppercaseName] = function renderedDimImpl() {
    var ele = this[0];

    if (ele) {
      var d = ele[opts.name]();
      return d * this.cy().zoom();
    }
  };

  fn['rendered' + opts.uppercaseOuterName] = function renderedOuterDimImpl() {
    var ele = this[0];

    if (ele) {
      var od = ele[opts.outerName]();
      return od * this.cy().zoom();
    }
  };
};

defineDimFns({
  name: 'width'
});

defineDimFns({
  name: 'height'
});

elesfn.padding = function () {
  var ele = this[0];
  var _p = ele._private;
  if (ele.isParent()) {
    ele.updateCompoundBounds();

    if (_p.autoPadding !== undefined) {
      return _p.autoPadding;
    } else {
      return ele.pstyle('padding').pfValue;
    }
  } else {
    return ele.pstyle('padding').pfValue;
  }
};

module.exports = elesfn;

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ifEdge = function ifEdge(self, then) {
  if (self.isEdge()) {
    return then(self.renderer());
  }
};

module.exports = {
  controlPoints: function controlPoints() {
    var _this = this;

    return ifEdge(this, function (renderer) {
      return renderer.getControlPoints(_this);
    });
  },
  segmentPoints: function segmentPoints() {
    var _this2 = this;

    return ifEdge(this, function (renderer) {
      return renderer.getSegmentPoints(_this2);
    });
  },
  sourceEndpoint: function sourceEndpoint() {
    var _this3 = this;

    return ifEdge(this, function (renderer) {
      return renderer.getSourceEndpoint(_this3);
    });
  },
  targetEndpoint: function targetEndpoint() {
    var _this4 = this;

    return ifEdge(this, function (renderer) {
      return renderer.getTargetEndpoint(_this4);
    });
  },
  midpoint: function midpoint() {
    var _this5 = this;

    return ifEdge(this, function (renderer) {
      return renderer.getEdgeMidpoint(_this5);
    });
  }
};

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Emitter = __webpack_require__(11);
var define = __webpack_require__(4);
var is = __webpack_require__(0);
var util = __webpack_require__(1);
var Selector = __webpack_require__(6);

var emitterOptions = {
  qualifierCompare: function qualifierCompare(selector1, selector2) {
    if (selector1 == null || selector2 == null) {
      return selector1 == null && selector2 == null;
    } else {
      return selector1.sameText(selector2);
    }
  },
  eventMatches: function eventMatches(ele, listener, eventObj) {
    var selector = listener.qualifier;

    if (selector != null) {
      return ele !== eventObj.target && is.element(eventObj.target) && selector.matches(eventObj.target);
    }

    return true;
  },
  eventFields: function eventFields(ele) {
    return {
      cy: ele.cy(),
      target: ele
    };
  },
  callbackContext: function callbackContext(ele, listener, eventObj) {
    return listener.qualifier != null ? eventObj.target : ele;
  },
  beforeEmit: function beforeEmit(context, listener /*, eventObj*/) {
    if (listener.conf && listener.conf.once) {
      listener.conf.onceCollection.removeListener(listener.event, listener.qualifier, listener.callback);
    }
  },
  bubble: function bubble() {
    return true;
  },
  parent: function parent(ele) {
    return ele.isChild() ? ele.parent() : ele.cy();
  }
};

var argSelector = function argSelector(arg) {
  if (is.string(arg)) {
    return new Selector(arg);
  } else {
    return arg;
  }
};

var elesfn = {
  createEmitter: function createEmitter() {
    for (var i = 0; i < this.length; i++) {
      var ele = this[i];
      var _p = ele._private;

      if (!_p.emitter) {
        _p.emitter = new Emitter(util.assign({
          context: ele
        }, emitterOptions));
      }
    }

    return this;
  },

  emitter: function emitter() {
    return this._private.emitter;
  },

  on: function on(events, selector, callback) {
    for (var i = 0; i < this.length; i++) {
      var ele = this[i];

      ele.emitter().on(events, argSelector(selector), callback);
    }

    return this;
  },

  removeListener: function removeListener(events, selector, callback) {
    for (var i = 0; i < this.length; i++) {
      var ele = this[i];

      ele.emitter().removeListener(events, argSelector(selector), callback);
    }

    return this;
  },

  one: function one(events, selector, callback) {
    for (var i = 0; i < this.length; i++) {
      var ele = this[i];

      ele.emitter().one(events, argSelector(selector), callback);
    }

    return this;
  },

  once: function once(events, selector, callback) {
    for (var i = 0; i < this.length; i++) {
      var ele = this[i];

      ele.emitter().on(events, argSelector(selector), callback, {
        once: true,
        onceCollection: this
      });
    }
  },

  emit: function emit(events, extraParams) {
    for (var i = 0; i < this.length; i++) {
      var ele = this[i];

      ele.emitter().emit(events, extraParams);
    }

    return this;
  },

  emitAndNotify: function emitAndNotify(event, extraParams) {
    // for internal use only
    if (this.length === 0) {
      return;
    } // empty collections don't need to notify anything

    // notify renderer
    this.cy().notify({
      type: event,
      eles: this
    });

    this.emit(event, extraParams);

    return this;
  }
};

define.eventAliasesOn(elesfn);

module.exports = elesfn;

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);
var Selector = __webpack_require__(6);

var elesfn = {
  nodes: function nodes(selector) {
    return this.filter(function (ele) {
      return ele.isNode();
    }).filter(selector);
  },

  edges: function edges(selector) {
    return this.filter(function (ele) {
      return ele.isEdge();
    }).filter(selector);
  },

  filter: function filter(_filter, thisArg) {
    if (_filter === undefined) {
      // check this first b/c it's the most common/performant case
      return this;
    } else if (is.string(_filter) || is.elementOrCollection(_filter)) {
      return new Selector(_filter).filter(this);
    } else if (is.fn(_filter)) {
      var filterEles = this.spawn();
      var eles = this;

      for (var i = 0; i < eles.length; i++) {
        var ele = eles[i];
        var include = thisArg ? _filter.apply(thisArg, [ele, i, eles]) : _filter(ele, i, eles);

        if (include) {
          filterEles.merge(ele);
        }
      }

      return filterEles;
    }

    return this.spawn(); // if not handled by above, give 'em an empty collection
  },

  not: function not(toRemove) {
    if (!toRemove) {
      return this;
    } else {

      if (is.string(toRemove)) {
        toRemove = this.filter(toRemove);
      }

      var elements = [];
      var rMap = toRemove._private.map;

      for (var i = 0; i < this.length; i++) {
        var element = this[i];

        var remove = rMap.has(element.id());
        if (!remove) {
          elements.push(element);
        }
      }

      return this.spawn(elements);
    }
  },

  absoluteComplement: function absoluteComplement() {
    var cy = this.cy();

    return cy.mutableElements().not(this);
  },

  intersect: function intersect(other) {
    // if a selector is specified, then filter by it instead
    if (is.string(other)) {
      var selector = other;
      return this.filter(selector);
    }

    var elements = [];
    var col1 = this;
    var col2 = other;
    var col1Smaller = this.length < other.length;
    var map2 = col1Smaller ? col2._private.map : col1._private.map;
    var col = col1Smaller ? col1 : col2;

    for (var i = 0; i < col.length; i++) {
      var id = col[i]._private.data.id;
      var entry = map2.get(id);

      if (entry) {
        elements.push(entry.ele);
      }
    }

    return this.spawn(elements);
  },

  xor: function xor(other) {
    var cy = this._private.cy;

    if (is.string(other)) {
      other = cy.$(other);
    }

    var elements = [];
    var col1 = this;
    var col2 = other;

    var add = function add(col, other) {
      for (var i = 0; i < col.length; i++) {
        var ele = col[i];
        var id = ele._private.data.id;
        var inOther = other.hasElementWithId(id);

        if (!inOther) {
          elements.push(ele);
        }
      }
    };

    add(col1, col2);
    add(col2, col1);

    return this.spawn(elements);
  },

  diff: function diff(other) {
    var cy = this._private.cy;

    if (is.string(other)) {
      other = cy.$(other);
    }

    var left = [];
    var right = [];
    var both = [];
    var col1 = this;
    var col2 = other;

    var add = function add(col, other, retEles) {

      for (var i = 0; i < col.length; i++) {
        var ele = col[i];
        var id = ele._private.data.id;
        var inOther = other.hasElementWithId(id);

        if (inOther) {
          both.push(ele);
        } else {
          retEles.push(ele);
        }
      }
    };

    add(col1, col2, left);
    add(col2, col1, right);

    return {
      left: this.spawn(left, { unique: true }),
      right: this.spawn(right, { unique: true }),
      both: this.spawn(both, { unique: true })
    };
  },

  add: function add(toAdd) {
    var cy = this._private.cy;

    if (!toAdd) {
      return this;
    }

    if (is.string(toAdd)) {
      var selector = toAdd;
      toAdd = cy.mutableElements().filter(selector);
    }

    var elements = [];

    for (var i = 0; i < this.length; i++) {
      elements.push(this[i]);
    }

    var map = this._private.map;

    for (var _i = 0; _i < toAdd.length; _i++) {

      var add = !map.has(toAdd[_i].id());
      if (add) {
        elements.push(toAdd[_i]);
      }
    }

    return this.spawn(elements);
  },

  // in place merge on calling collection
  merge: function merge(toAdd) {
    var _p = this._private;
    var cy = _p.cy;

    if (!toAdd) {
      return this;
    }

    if (toAdd && is.string(toAdd)) {
      var selector = toAdd;
      toAdd = cy.mutableElements().filter(selector);
    }

    var map = _p.map;

    for (var i = 0; i < toAdd.length; i++) {
      var toAddEle = toAdd[i];
      var id = toAddEle._private.data.id;
      var add = !map.has(id);

      if (add) {
        var index = this.length++;

        this[index] = toAddEle;

        map.set(id, { ele: toAddEle, index: index });
      } else {
        // replace
        var _index = map.get(id).index;

        this[_index] = toAddEle;
        map.set(id, { ele: toAddEle, index: _index });
      }
    }

    return this; // chaining
  },

  // remove single ele in place in calling collection
  unmergeOne: function unmergeOne(ele) {
    ele = ele[0];

    var _p = this._private;
    var id = ele._private.data.id;
    var map = _p.map;
    var entry = map.get(id);

    if (!entry) {
      return this; // no need to remove
    }

    var i = entry.index;

    // remove ele
    this[i] = undefined;
    map.delete(id);

    var unmergedLastEle = i === this.length - 1;

    // replace empty spot with last ele in collection
    if (this.length > 1 && !unmergedLastEle) {
      var lastEleI = this.length - 1;
      var lastEle = this[lastEleI];
      var lastEleId = lastEle._private.data.id;

      this[lastEleI] = undefined;
      this[i] = lastEle;
      map.set(lastEleId, { ele: lastEle, index: i });
    }

    // the collection is now 1 ele smaller
    this.length--;

    return this;
  },

  // remove eles in place on calling collection
  unmerge: function unmerge(toRemove) {
    var cy = this._private.cy;

    if (!toRemove) {
      return this;
    }

    if (toRemove && is.string(toRemove)) {
      var selector = toRemove;
      toRemove = cy.mutableElements().filter(selector);
    }

    for (var i = 0; i < toRemove.length; i++) {
      this.unmergeOne(toRemove[i]);
    }

    return this; // chaining
  },

  map: function map(mapFn, thisArg) {
    var arr = [];
    var eles = this;

    for (var i = 0; i < eles.length; i++) {
      var ele = eles[i];
      var ret = thisArg ? mapFn.apply(thisArg, [ele, i, eles]) : mapFn(ele, i, eles);

      arr.push(ret);
    }

    return arr;
  },

  reduce: function reduce(fn, initialValue) {
    var val = initialValue;
    var eles = this;

    for (var i = 0; i < eles.length; i++) {
      val = fn(val, eles[i], i, eles);
    }

    return val;
  },

  max: function max(valFn, thisArg) {
    var max = -Infinity;
    var maxEle = void 0;
    var eles = this;

    for (var i = 0; i < eles.length; i++) {
      var ele = eles[i];
      var val = thisArg ? valFn.apply(thisArg, [ele, i, eles]) : valFn(ele, i, eles);

      if (val > max) {
        max = val;
        maxEle = ele;
      }
    }

    return {
      value: max,
      ele: maxEle
    };
  },

  min: function min(valFn, thisArg) {
    var min = Infinity;
    var minEle = void 0;
    var eles = this;

    for (var i = 0; i < eles.length; i++) {
      var ele = eles[i];
      var val = thisArg ? valFn.apply(thisArg, [ele, i, eles]) : valFn(ele, i, eles);

      if (val < min) {
        min = val;
        minEle = ele;
      }
    }

    return {
      value: min,
      ele: minEle
    };
  }
};

// aliases
var fn = elesfn;
fn['u'] = fn['|'] = fn['+'] = fn.union = fn.or = fn.add;
fn['\\'] = fn['!'] = fn['-'] = fn.difference = fn.relativeComplement = fn.subtract = fn.not;
fn['n'] = fn['&'] = fn['.'] = fn.and = fn.intersection = fn.intersect;
fn['^'] = fn['(+)'] = fn['(-)'] = fn.symmetricDifference = fn.symdiff = fn.xor;
fn.fnFilter = fn.filterFn = fn.stdFilter = fn.filter;
fn.complement = fn.abscomp = fn.absoluteComplement;

module.exports = elesfn;

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var elesfn = {
  isNode: function isNode() {
    return this.group() === 'nodes';
  },

  isEdge: function isEdge() {
    return this.group() === 'edges';
  },

  isLoop: function isLoop() {
    return this.isEdge() && this.source().id() === this.target().id();
  },

  isSimple: function isSimple() {
    return this.isEdge() && this.source().id() !== this.target().id();
  },

  group: function group() {
    var ele = this[0];

    if (ele) {
      return ele._private.group;
    }
  }
};

module.exports = elesfn;

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);
var zIndexSort = __webpack_require__(17);
var util = __webpack_require__(1);

var elesfn = {
  forEach: function forEach(fn, thisArg) {
    if (is.fn(fn)) {

      for (var i = 0; i < this.length; i++) {
        var ele = this[i];
        var ret = thisArg ? fn.apply(thisArg, [ele, i, this]) : fn(ele, i, this);

        if (ret === false) {
          break;
        } // exit each early on return false
      }
    }

    return this;
  },

  toArray: function toArray() {
    var array = [];

    for (var i = 0; i < this.length; i++) {
      array.push(this[i]);
    }

    return array;
  },

  slice: function slice(start, end) {
    var array = [];
    var thisSize = this.length;

    if (end == null) {
      end = thisSize;
    }

    if (start == null) {
      start = 0;
    }

    if (start < 0) {
      start = thisSize + start;
    }

    if (end < 0) {
      end = thisSize + end;
    }

    for (var i = start; i >= 0 && i < end && i < thisSize; i++) {
      array.push(this[i]);
    }

    return this.spawn(array);
  },

  size: function size() {
    return this.length;
  },

  eq: function eq(i) {
    return this[i] || this.spawn();
  },

  first: function first() {
    return this[0] || this.spawn();
  },

  last: function last() {
    return this[this.length - 1] || this.spawn();
  },

  empty: function empty() {
    return this.length === 0;
  },

  nonempty: function nonempty() {
    return !this.empty();
  },

  sort: function sort(sortFn) {
    if (!is.fn(sortFn)) {
      return this;
    }

    var sorted = this.toArray().sort(sortFn);

    return this.spawn(sorted);
  },

  sortByZIndex: function sortByZIndex() {
    return this.sort(zIndexSort);
  },

  zDepth: function zDepth() {
    var ele = this[0];
    if (!ele) {
      return undefined;
    }

    // let cy = ele.cy();
    var _p = ele._private;
    var group = _p.group;

    if (group === 'nodes') {
      var depth = _p.data.parent ? ele.parents().size() : 0;

      if (!ele.isParent()) {
        return util.MAX_INT - 1; // childless nodes always on top
      }

      return depth;
    } else {
      var src = _p.source;
      var tgt = _p.target;
      var srcDepth = src.zDepth();
      var tgtDepth = tgt.zDepth();

      return Math.max(srcDepth, tgtDepth, 0); // depth of deepest parent
    }
  }
};

elesfn.each = elesfn.forEach;

module.exports = elesfn;

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);
var util = __webpack_require__(1);
var Promise = __webpack_require__(5);
var math = __webpack_require__(2);

var elesfn = {
  // Calculates and returns node dimensions { x, y } based on options given
  layoutDimensions: function layoutDimensions(options) {
    options = util.assign({
      nodeDimensionsIncludeLabels: true
    }, options);

    if (options.nodeDimensionsIncludeLabels) {
      var bbDim = this.boundingBox();
      return {
        w: bbDim.w,
        h: bbDim.h
      };
    } else {
      return {
        w: this.outerWidth(),
        h: this.outerHeight()
      };
    }
  },

  // using standard layout options, apply position function (w/ or w/o animation)
  layoutPositions: function layoutPositions(layout, options, fn) {
    var nodes = this.nodes();
    var cy = this.cy();
    var layoutEles = options.eles; // nodes & edges
    var getMemoizeKey = function getMemoizeKey(node, i) {
      return node.id() + '$' + i;
    };
    var fnMem = util.memoize(fn, getMemoizeKey); // memoized version of position function

    layout.emit({ type: 'layoutstart', layout: layout });

    layout.animations = [];

    var calculateSpacing = function calculateSpacing(spacing, nodesBb, pos) {
      var center = {
        x: nodesBb.x1 + nodesBb.w / 2,
        y: nodesBb.y1 + nodesBb.h / 2
      };

      var spacingVector = { // scale from center of bounding box (not necessarily 0,0)
        x: (pos.x - center.x) * spacing,
        y: (pos.y - center.y) * spacing
      };

      return {
        x: center.x + spacingVector.x,
        y: center.y + spacingVector.y
      };
    };

    var useSpacingFactor = options.spacingFactor && options.spacingFactor !== 1;

    var spacingBb = function spacingBb() {
      if (!useSpacingFactor) {
        return null;
      }

      var bb = math.makeBoundingBox();

      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        var pos = fnMem(node, i);

        math.expandBoundingBoxByPoint(bb, pos.x, pos.y);
      }

      return bb;
    };

    var bb = spacingBb();

    var getFinalPos = util.memoize(function (node, i) {
      var newPos = fnMem(node, i);
      var pos = node.position();

      if (!is.number(pos.x) || !is.number(pos.y)) {
        node.silentPosition({ x: 0, y: 0 });
      }

      if (useSpacingFactor) {
        var spacing = Math.abs(options.spacingFactor);

        newPos = calculateSpacing(spacing, bb, newPos);
      }

      if (options.transform != null) {
        newPos = options.transform(node, newPos);
      }

      return newPos;
    }, getMemoizeKey);

    if (options.animate) {
      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        var newPos = getFinalPos(node, i);
        var animateNode = options.animateFilter == null || options.animateFilter(node, i);

        if (animateNode) {
          var ani = node.animation({
            position: newPos,
            duration: options.animationDuration,
            easing: options.animationEasing
          });

          layout.animations.push(ani);

          ani.play();
        } else {
          node.position(newPos);
        }
      }

      if (options.fit) {
        var fitAni = cy.animation({
          fit: {
            boundingBox: layoutEles.boundingBoxAt(getFinalPos),
            padding: options.padding
          },
          duration: options.animationDuration,
          easing: options.animationEasing
        });

        layout.animations.push(fitAni);

        fitAni.play();
      } else if (options.zoom !== undefined && options.pan !== undefined) {
        var zoomPanAni = cy.animation({
          zoom: options.zoom,
          pan: options.pan,
          duration: options.animationDuration,
          easing: options.animationEasing
        });

        layout.animations.push(zoomPanAni);

        zoomPanAni.play();
      }

      layout.one('layoutready', options.ready);
      layout.emit({ type: 'layoutready', layout: layout });

      Promise.all(layout.animations.map(function (ani) {
        return ani.promise();
      })).then(function () {
        layout.one('layoutstop', options.stop);
        layout.emit({ type: 'layoutstop', layout: layout });
      });
    } else {

      nodes.positions(getFinalPos);

      if (options.fit) {
        cy.fit(options.eles, options.padding);
      }

      if (options.zoom != null) {
        cy.zoom(options.zoom);
      }

      if (options.pan) {
        cy.pan(options.pan);
      }

      layout.one('layoutready', options.ready);
      layout.emit({ type: 'layoutready', layout: layout });

      layout.one('layoutstop', options.stop);
      layout.emit({ type: 'layoutstop', layout: layout });
    }

    return this; // chaining
  },

  layout: function layout(options) {
    var cy = this.cy();

    return cy.makeLayout(util.extend({}, options, {
      eles: this
    }));
  }

};

// aliases:
elesfn.createLayout = elesfn.makeLayout = elesfn.layout;

module.exports = elesfn;

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);

function styleCache(key, fn, ele) {
  var _p = ele._private;
  var cache = _p.styleCache = _p.styleCache || {};
  var val;

  if ((val = cache[key]) != null) {
    return val;
  } else {
    val = cache[key] = fn(ele);

    return val;
  }
}

function cacheStyleFunction(key, fn) {
  return function cachedStyleFunction(ele) {
    return styleCache(key, fn, ele);
  };
}

function cachePrototypeStyleFunction(key, fn) {
  var selfFn = function selfFn(ele) {
    return fn.call(ele);
  };

  return function cachedPrototypeStyleFunction() {
    var ele = this[0];

    if (ele) {
      return styleCache(key, selfFn, ele);
    }
  };
}

var elesfn = {

  recalculateRenderedStyle: function recalculateRenderedStyle(useCache) {
    var cy = this.cy();
    var renderer = cy.renderer();
    var styleEnabled = cy.styleEnabled();

    if (renderer && styleEnabled) {
      renderer.recalculateRenderedStyle(this, useCache);
    }

    return this;
  },

  dirtyStyleCache: function dirtyStyleCache() {
    var cy = this.cy();
    var dirty = function dirty(ele) {
      return ele._private.styleCache = {};
    };

    if (cy.hasCompoundNodes()) {
      var eles = void 0;

      eles = this.spawnSelf().merge(this.descendants()).merge(this.parents());

      eles.merge(eles.connectedEdges());

      eles.forEach(dirty);
    } else {
      this.forEach(function (ele) {
        dirty(ele);

        ele.connectedEdges().forEach(dirty);
      });
    }

    return this;
  },

  // fully updates (recalculates) the style for the elements
  updateStyle: function updateStyle(notifyRenderer) {
    var cy = this._private.cy;

    if (!cy.styleEnabled()) {
      return this;
    }

    if (cy._private.batchingStyle) {
      var bEles = cy._private.batchStyleEles;

      bEles.merge(this);

      return this; // chaining and exit early when batching
    }

    var hasCompounds = cy.hasCompoundNodes();
    var style = cy.style();
    var updatedEles = this;

    notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;

    if (hasCompounds) {
      // then add everything up and down for compound selector checks
      updatedEles = this.spawnSelf().merge(this.descendants()).merge(this.parents());
    }

    var changedEles = style.apply(updatedEles);

    changedEles.dirtyStyleCache();
    changedEles.dirtyCompoundBoundsCache();

    if (notifyRenderer) {
      changedEles.emitAndNotify('style'); // let renderer know we changed style
    } else {
      changedEles.emit('style'); // just fire the event
    }

    return this; // chaining
  },

  // just update the mappers in the elements' styles; cheaper than eles.updateStyle()
  updateMappers: function updateMappers(notifyRenderer) {
    var cy = this._private.cy;
    var style = cy.style();
    notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;

    if (!cy.styleEnabled()) {
      return this;
    }

    var changedEles = style.updateMappers(this);

    changedEles.dirtyStyleCache();
    changedEles.dirtyCompoundBoundsCache();

    if (notifyRenderer) {
      changedEles.emitAndNotify('style'); // let renderer know we changed style
    } else {
      changedEles.emit('style'); // just fire the event
    }
    return this; // chaining
  },

  // get the internal parsed style object for the specified property
  parsedStyle: function parsedStyle(property) {
    var ele = this[0];
    var cy = ele.cy();

    if (!cy.styleEnabled()) {
      return;
    }

    if (ele) {
      return ele._private.style[property] || cy.style().getDefaultProperty(property);
    }
  },

  numericStyle: function numericStyle(property) {
    var ele = this[0];

    if (!ele.cy().styleEnabled()) {
      return;
    }

    if (ele) {
      var pstyle = ele.pstyle(property);

      return pstyle.pfValue !== undefined ? pstyle.pfValue : pstyle.value;
    }
  },

  numericStyleUnits: function numericStyleUnits(property) {
    var ele = this[0];

    if (!ele.cy().styleEnabled()) {
      return;
    }

    if (ele) {
      return ele.pstyle(property).units;
    }
  },

  // get the specified css property as a rendered value (i.e. on-screen value)
  // or get the whole rendered style if no property specified (NB doesn't allow setting)
  renderedStyle: function renderedStyle(property) {
    var cy = this.cy();
    if (!cy.styleEnabled()) {
      return this;
    }

    var ele = this[0];

    if (ele) {
      return cy.style().getRenderedStyle(ele, property);
    }
  },

  // read the calculated css style of the element or override the style (via a bypass)
  style: function style(name, value) {
    var cy = this.cy();

    if (!cy.styleEnabled()) {
      return this;
    }

    var updateTransitions = false;
    var style = cy.style();

    if (is.plainObject(name)) {
      // then extend the bypass
      var props = name;
      style.applyBypass(this, props, updateTransitions);

      this.dirtyStyleCache();
      this.dirtyCompoundBoundsCache();

      this.emitAndNotify('style'); // let the renderer know we've updated style
    } else if (is.string(name)) {

      if (value === undefined) {
        // then get the property from the style
        var ele = this[0];

        if (ele) {
          return style.getStylePropertyValue(ele, name);
        } else {
          // empty collection => can't get any value
          return;
        }
      } else {
        // then set the bypass with the property value
        style.applyBypass(this, name, value, updateTransitions);

        this.dirtyStyleCache();
        this.dirtyCompoundBoundsCache();

        this.emitAndNotify('style'); // let the renderer know we've updated style
      }
    } else if (name === undefined) {
      var _ele = this[0];

      if (_ele) {
        return style.getRawStyle(_ele);
      } else {
        // empty collection => can't get any value
        return;
      }
    }

    return this; // chaining
  },

  removeStyle: function removeStyle(names) {
    var cy = this.cy();

    if (!cy.styleEnabled()) {
      return this;
    }

    var updateTransitions = false;
    var style = cy.style();
    var eles = this;

    if (names === undefined) {
      for (var i = 0; i < eles.length; i++) {
        var ele = eles[i];

        style.removeAllBypasses(ele, updateTransitions);
      }
    } else {
      names = names.split(/\s+/);

      for (var _i = 0; _i < eles.length; _i++) {
        var _ele2 = eles[_i];

        style.removeBypasses(_ele2, names, updateTransitions);
      }
    }

    this.dirtyStyleCache();
    this.dirtyCompoundBoundsCache();

    this.emitAndNotify('style'); // let the renderer know we've updated style

    return this; // chaining
  },

  show: function show() {
    this.css('display', 'element');
    return this; // chaining
  },

  hide: function hide() {
    this.css('display', 'none');
    return this; // chaining
  },

  effectiveOpacity: function effectiveOpacity() {
    var cy = this.cy();
    if (!cy.styleEnabled()) {
      return 1;
    }

    var hasCompoundNodes = cy.hasCompoundNodes();
    var ele = this[0];

    if (ele) {
      var _p = ele._private;
      var parentOpacity = ele.pstyle('opacity').value;

      if (!hasCompoundNodes) {
        return parentOpacity;
      }

      var parents = !_p.data.parent ? null : ele.parents();

      if (parents) {
        for (var i = 0; i < parents.length; i++) {
          var parent = parents[i];
          var opacity = parent.pstyle('opacity').value;

          parentOpacity = opacity * parentOpacity;
        }
      }

      return parentOpacity;
    }
  },

  transparent: function transparent() {
    var cy = this.cy();
    if (!cy.styleEnabled()) {
      return false;
    }

    var ele = this[0];
    var hasCompoundNodes = ele.cy().hasCompoundNodes();

    if (ele) {
      if (!hasCompoundNodes) {
        return ele.pstyle('opacity').value === 0;
      } else {
        return ele.effectiveOpacity() === 0;
      }
    }
  },

  backgrounding: function backgrounding() {
    var cy = this.cy();
    if (!cy.styleEnabled()) {
      return false;
    }

    var ele = this[0];

    return ele._private.backgrounding ? true : false;
  }

};

function checkCompound(ele, parentOk) {
  var _p = ele._private;
  var parents = _p.data.parent ? ele.parents() : null;

  if (parents) {
    for (var i = 0; i < parents.length; i++) {
      var parent = parents[i];

      if (!parentOk(parent)) {
        return false;
      }
    }
  }

  return true;
}

function defineDerivedStateFunction(specs) {
  var ok = specs.ok;
  var edgeOkViaNode = specs.edgeOkViaNode || specs.ok;
  var parentOk = specs.parentOk || specs.ok;

  return function () {
    var cy = this.cy();
    if (!cy.styleEnabled()) {
      return true;
    }

    var ele = this[0];
    var hasCompoundNodes = cy.hasCompoundNodes();

    if (ele) {
      var _p = ele._private;

      if (!ok(ele)) {
        return false;
      }

      if (ele.isNode()) {
        return !hasCompoundNodes || checkCompound(ele, parentOk);
      } else {
        var src = _p.source;
        var tgt = _p.target;

        return edgeOkViaNode(src) && (!hasCompoundNodes || checkCompound(src, edgeOkViaNode)) && (src === tgt || edgeOkViaNode(tgt) && (!hasCompoundNodes || checkCompound(tgt, edgeOkViaNode)));
      }
    }
  };
}

var eleTakesUpSpace = cacheStyleFunction('eleTakesUpSpace', function (ele) {
  return ele.pstyle('display').value === 'element' && ele.width() !== 0 && (ele.isNode() ? ele.height() !== 0 : true);
});

elesfn.takesUpSpace = cachePrototypeStyleFunction('takesUpSpace', defineDerivedStateFunction({
  ok: eleTakesUpSpace
}));

var eleInteractive = cacheStyleFunction('eleInteractive', function (ele) {
  return ele.pstyle('events').value === 'yes' && ele.pstyle('visibility').value === 'visible' && eleTakesUpSpace(ele);
});

var parentInteractive = cacheStyleFunction('parentInteractive', function (parent) {
  return parent.pstyle('visibility').value === 'visible' && eleTakesUpSpace(parent);
});

elesfn.interactive = cachePrototypeStyleFunction('interactive', defineDerivedStateFunction({
  ok: eleInteractive,
  parentOk: parentInteractive,
  edgeOkViaNode: eleTakesUpSpace
}));

elesfn.noninteractive = function () {
  var ele = this[0];

  if (ele) {
    return !ele.interactive();
  }
};

var eleVisible = cacheStyleFunction('eleVisible', function (ele) {
  return ele.pstyle('visibility').value === 'visible' && ele.pstyle('opacity').pfValue !== 0 && eleTakesUpSpace(ele);
});

var edgeVisibleViaNode = eleTakesUpSpace;

elesfn.visible = cachePrototypeStyleFunction('visible', defineDerivedStateFunction({
  ok: eleVisible,
  edgeOkViaNode: edgeVisibleViaNode
}));

elesfn.hidden = function () {
  var ele = this[0];

  if (ele) {
    return !ele.visible();
  }
};

elesfn.bypass = elesfn.css = elesfn.style;
elesfn.renderedCss = elesfn.renderedStyle;
elesfn.removeBypass = elesfn.removeCss = elesfn.removeStyle;
elesfn.pstyle = elesfn.parsedStyle;

module.exports = elesfn;

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var elesfn = {};

function defineSwitchFunction(params) {
  return function () {
    var args = arguments;
    var changedEles = [];

    // e.g. cy.nodes().select( data, handler )
    if (args.length === 2) {
      var data = args[0];
      var handler = args[1];
      this.on(params.event, data, handler);
    }

    // e.g. cy.nodes().select( handler )
    else if (args.length === 1) {
        var _handler = args[0];
        this.on(params.event, _handler);
      }

      // e.g. cy.nodes().select()
      else if (args.length === 0) {
          for (var i = 0; i < this.length; i++) {
            var ele = this[i];
            var able = !params.ableField || ele._private[params.ableField];
            var changed = ele._private[params.field] != params.value;

            if (params.overrideAble) {
              var overrideAble = params.overrideAble(ele);

              if (overrideAble !== undefined) {
                able = overrideAble;

                if (!overrideAble) {
                  return this;
                } // to save cycles assume not able for all on override
              }
            }

            if (able) {
              ele._private[params.field] = params.value;

              if (changed) {
                changedEles.push(ele);
              }
            }
          }

          var changedColl = this.spawn(changedEles);
          changedColl.updateStyle(); // change of state => possible change of style
          changedColl.emit(params.event);
        }

    return this;
  };
}

function defineSwitchSet(params) {
  elesfn[params.field] = function () {
    var ele = this[0];

    if (ele) {
      if (params.overrideField) {
        var val = params.overrideField(ele);

        if (val !== undefined) {
          return val;
        }
      }

      return ele._private[params.field];
    }
  };

  elesfn[params.on] = defineSwitchFunction({
    event: params.on,
    field: params.field,
    ableField: params.ableField,
    overrideAble: params.overrideAble,
    value: true
  });

  elesfn[params.off] = defineSwitchFunction({
    event: params.off,
    field: params.field,
    ableField: params.ableField,
    overrideAble: params.overrideAble,
    value: false
  });
}

defineSwitchSet({
  field: 'locked',
  overrideField: function overrideField(ele) {
    return ele.cy().autolock() ? true : undefined;
  },
  on: 'lock',
  off: 'unlock'
});

defineSwitchSet({
  field: 'grabbable',
  overrideField: function overrideField(ele) {
    return ele.cy().autoungrabify() ? false : undefined;
  },
  on: 'grabify',
  off: 'ungrabify'
});

defineSwitchSet({
  field: 'selected',
  ableField: 'selectable',
  overrideAble: function overrideAble(ele) {
    return ele.cy().autounselectify() ? false : undefined;
  },
  on: 'select',
  off: 'unselect'
});

defineSwitchSet({
  field: 'selectable',
  overrideField: function overrideField(ele) {
    return ele.cy().autounselectify() ? false : undefined;
  },
  on: 'selectify',
  off: 'unselectify'
});

elesfn.deselect = elesfn.unselect;

elesfn.grabbed = function () {
  var ele = this[0];
  if (ele) {
    return ele._private.grabbed;
  }
};

defineSwitchSet({
  field: 'active',
  on: 'activate',
  off: 'unactivate'
});

elesfn.inactive = function () {
  var ele = this[0];
  if (ele) {
    return !ele._private.active;
  }
};

module.exports = elesfn;

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);
var is = __webpack_require__(0);

var elesfn = {};

var cache = function cache(fn, name) {
  return function traversalCache(arg1, arg2, arg3, arg4) {
    var selectorOrEles = arg1;
    var eles = this;
    var key = void 0;

    if (selectorOrEles == null) {
      key = 'null';
    } else if (is.elementOrCollection(selectorOrEles) && selectorOrEles.length === 1) {
      key = '#' + selectorOrEles.id();
    }

    if (eles.length === 1 && key) {
      var _p = eles[0]._private;
      var tch = _p.traversalCache = _p.traversalCache || {};
      var ch = tch[name] = tch[name] || {};
      var cacheHit = ch[key];

      if (cacheHit) {
        return cacheHit;
      } else {
        return ch[key] = fn.call(eles, arg1, arg2, arg3, arg4);
      }
    } else {
      return fn.call(eles, arg1, arg2, arg3, arg4);
    }
  };
};

// DAG functions
////////////////

var defineDagExtremity = function defineDagExtremity(params) {
  return function dagExtremityImpl(selector) {
    var eles = this;
    var ret = [];

    for (var i = 0; i < eles.length; i++) {
      var ele = eles[i];
      if (!ele.isNode()) {
        continue;
      }

      var disqualified = false;
      var edges = ele.connectedEdges();

      for (var j = 0; j < edges.length; j++) {
        var edge = edges[j];
        var src = edge.source();
        var tgt = edge.target();

        if (params.noIncomingEdges && tgt === ele && src !== ele || params.noOutgoingEdges && src === ele && tgt !== ele) {
          disqualified = true;
          break;
        }
      }

      if (!disqualified) {
        ret.push(ele);
      }
    }

    return this.spawn(ret, { unique: true }).filter(selector);
  };
};

var defineDagOneHop = function defineDagOneHop(params) {
  return function (selector) {
    var eles = this;
    var oEles = [];

    for (var i = 0; i < eles.length; i++) {
      var ele = eles[i];

      if (!ele.isNode()) {
        continue;
      }

      var edges = ele.connectedEdges();
      for (var j = 0; j < edges.length; j++) {
        var edge = edges[j];
        var src = edge.source();
        var tgt = edge.target();

        if (params.outgoing && src === ele) {
          oEles.push(edge);
          oEles.push(tgt);
        } else if (params.incoming && tgt === ele) {
          oEles.push(edge);
          oEles.push(src);
        }
      }
    }

    return this.spawn(oEles, { unique: true }).filter(selector);
  };
};

var defineDagAllHops = function defineDagAllHops(params) {
  return function (selector) {
    var eles = this;
    var sEles = [];
    var sElesIds = {};

    for (;;) {
      var next = params.outgoing ? eles.outgoers() : eles.incomers();

      if (next.length === 0) {
        break;
      } // done if none left

      var newNext = false;
      for (var i = 0; i < next.length; i++) {
        var n = next[i];
        var nid = n.id();

        if (!sElesIds[nid]) {
          sElesIds[nid] = true;
          sEles.push(n);
          newNext = true;
        }
      }

      if (!newNext) {
        break;
      } // done if touched all outgoers already

      eles = next;
    }

    return this.spawn(sEles, { unique: true }).filter(selector);
  };
};

elesfn.clearTraversalCache = function () {
  for (var i = 0; i < this.length; i++) {
    this[i]._private.traversalCache = null;
  }
};

util.extend(elesfn, {
  // get the root nodes in the DAG
  roots: defineDagExtremity({ noIncomingEdges: true }),

  // get the leaf nodes in the DAG
  leaves: defineDagExtremity({ noOutgoingEdges: true }),

  // normally called children in graph theory
  // these nodes =edges=> outgoing nodes
  outgoers: cache(defineDagOneHop({ outgoing: true }), 'outgoers'),

  // aka DAG descendants
  successors: defineDagAllHops({ outgoing: true }),

  // normally called parents in graph theory
  // these nodes <=edges= incoming nodes
  incomers: cache(defineDagOneHop({ incoming: true }), 'incomers'),

  // aka DAG ancestors
  predecessors: defineDagAllHops({ incoming: true })
});

// Neighbourhood functions
//////////////////////////

util.extend(elesfn, {
  neighborhood: cache(function (selector) {
    var elements = [];
    var nodes = this.nodes();

    for (var i = 0; i < nodes.length; i++) {
      // for all nodes
      var node = nodes[i];
      var connectedEdges = node.connectedEdges();

      // for each connected edge, add the edge and the other node
      for (var j = 0; j < connectedEdges.length; j++) {
        var edge = connectedEdges[j];
        var src = edge.source();
        var tgt = edge.target();
        var otherNode = node === src ? tgt : src;

        // need check in case of loop
        if (otherNode.length > 0) {
          elements.push(otherNode[0]); // add node 1 hop away
        }

        // add connected edge
        elements.push(edge[0]);
      }
    }

    return this.spawn(elements, { unique: true }).filter(selector);
  }, 'neighborhood'),

  closedNeighborhood: function closedNeighborhood(selector) {
    return this.neighborhood().add(this).filter(selector);
  },

  openNeighborhood: function openNeighborhood(selector) {
    return this.neighborhood(selector);
  }
});

// aliases
elesfn.neighbourhood = elesfn.neighborhood;
elesfn.closedNeighbourhood = elesfn.closedNeighborhood;
elesfn.openNeighbourhood = elesfn.openNeighborhood;

// Edge functions
/////////////////

util.extend(elesfn, {
  source: cache(function sourceImpl(selector) {
    var ele = this[0];
    var src = void 0;

    if (ele) {
      src = ele._private.source || ele.cy().collection();
    }

    return src && selector ? src.filter(selector) : src;
  }, 'source'),

  target: cache(function targetImpl(selector) {
    var ele = this[0];
    var tgt = void 0;

    if (ele) {
      tgt = ele._private.target || ele.cy().collection();
    }

    return tgt && selector ? tgt.filter(selector) : tgt;
  }, 'target'),

  sources: defineSourceFunction({
    attr: 'source'
  }),

  targets: defineSourceFunction({
    attr: 'target'
  })
});

function defineSourceFunction(params) {
  return function sourceImpl(selector) {
    var sources = [];

    for (var i = 0; i < this.length; i++) {
      var ele = this[i];
      var src = ele._private[params.attr];

      if (src) {
        sources.push(src);
      }
    }

    return this.spawn(sources, { unique: true }).filter(selector);
  };
}

util.extend(elesfn, {
  edgesWith: cache(defineEdgesWithFunction(), 'edgesWith'),

  edgesTo: cache(defineEdgesWithFunction({
    thisIsSrc: true
  }), 'edgesTo')
});

function defineEdgesWithFunction(params) {

  return function edgesWithImpl(otherNodes) {
    var elements = [];
    var cy = this._private.cy;
    var p = params || {};

    // get elements if a selector is specified
    if (is.string(otherNodes)) {
      otherNodes = cy.$(otherNodes);
    }

    for (var h = 0; h < otherNodes.length; h++) {
      var edges = otherNodes[h]._private.edges;

      for (var i = 0; i < edges.length; i++) {
        var edge = edges[i];
        var edgeData = edge._private.data;
        var thisToOther = this.hasElementWithId(edgeData.source) && otherNodes.hasElementWithId(edgeData.target);
        var otherToThis = otherNodes.hasElementWithId(edgeData.source) && this.hasElementWithId(edgeData.target);
        var edgeConnectsThisAndOther = thisToOther || otherToThis;

        if (!edgeConnectsThisAndOther) {
          continue;
        }

        if (p.thisIsSrc || p.thisIsTgt) {
          if (p.thisIsSrc && !thisToOther) {
            continue;
          }

          if (p.thisIsTgt && !otherToThis) {
            continue;
          }
        }

        elements.push(edge);
      }
    }

    return this.spawn(elements, { unique: true });
  };
}

util.extend(elesfn, {
  connectedEdges: cache(function (selector) {
    var retEles = [];

    var eles = this;
    for (var i = 0; i < eles.length; i++) {
      var node = eles[i];
      if (!node.isNode()) {
        continue;
      }

      var edges = node._private.edges;

      for (var j = 0; j < edges.length; j++) {
        var edge = edges[j];
        retEles.push(edge);
      }
    }

    return this.spawn(retEles, { unique: true }).filter(selector);
  }, 'connectedEdges'),

  connectedNodes: cache(function (selector) {
    var retEles = [];

    var eles = this;
    for (var i = 0; i < eles.length; i++) {
      var edge = eles[i];
      if (!edge.isEdge()) {
        continue;
      }

      retEles.push(edge.source()[0]);
      retEles.push(edge.target()[0]);
    }

    return this.spawn(retEles, { unique: true }).filter(selector);
  }, 'connectedNodes'),

  parallelEdges: cache(defineParallelEdgesFunction(), 'parallelEdges'),

  codirectedEdges: cache(defineParallelEdgesFunction({
    codirected: true
  }), 'codirectedEdges')
});

function defineParallelEdgesFunction(params) {
  var defaults = {
    codirected: false
  };
  params = util.extend({}, defaults, params);

  return function parallelEdgesImpl(selector) {
    // micro-optimised for renderer
    var elements = [];
    var edges = this.edges();
    var p = params;

    // look at all the edges in the collection
    for (var i = 0; i < edges.length; i++) {
      var edge1 = edges[i];
      var edge1_p = edge1._private;
      var src1 = edge1_p.source;
      var srcid1 = src1._private.data.id;
      var tgtid1 = edge1_p.data.target;
      var srcEdges1 = src1._private.edges;

      // look at edges connected to the src node of this edge
      for (var j = 0; j < srcEdges1.length; j++) {
        var edge2 = srcEdges1[j];
        var edge2data = edge2._private.data;
        var tgtid2 = edge2data.target;
        var srcid2 = edge2data.source;

        var codirected = tgtid2 === tgtid1 && srcid2 === srcid1;
        var oppdirected = srcid1 === tgtid2 && tgtid1 === srcid2;

        if (p.codirected && codirected || !p.codirected && (codirected || oppdirected)) {
          elements.push(edge2);
        }
      }
    }

    return this.spawn(elements, { unique: true }).filter(selector);
  };
}

// Misc functions
/////////////////

util.extend(elesfn, {
  components: function components() {
    var self = this;
    var cy = self.cy();
    var visited = self.spawn();
    var unvisited = self.nodes().spawnSelf();
    var components = [];

    var visitInComponent = function visitInComponent(node, component) {
      visited.merge(node);
      unvisited.unmerge(node);
      component.merge(node);
    };

    if (unvisited.empty()) {
      return self.spawn();
    }

    var _loop = function _loop() {
      var component = cy.collection();
      components.push(component);

      var root = unvisited[0];
      visitInComponent(root, component);

      self.bfs({
        directed: false,
        roots: root,
        visit: function visit(v, e, u, i, depth) {
          visitInComponent(v, component);
        }
      });
    };

    do {
      _loop();
    } while (unvisited.length > 0);

    return components.map(function (component) {
      var connectedEdges = component.connectedEdges().stdFilter(function (edge) {
        return component.anySame(edge.source()) && component.anySame(edge.target());
      });

      return component.union(connectedEdges);
    });
  }
});

module.exports = elesfn;

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);
var util = __webpack_require__(1);
var Collection = __webpack_require__(7);
var Element = __webpack_require__(14);

var corefn = {
  add: function add(opts) {

    var elements = void 0;
    var cy = this;

    // add the elements
    if (is.elementOrCollection(opts)) {
      var eles = opts;

      if (eles._private.cy === cy) {
        // same instance => just restore
        elements = eles.restore();
      } else {
        // otherwise, copy from json
        var jsons = [];

        for (var i = 0; i < eles.length; i++) {
          var ele = eles[i];
          jsons.push(ele.json());
        }

        elements = new Collection(cy, jsons);
      }
    }

    // specify an array of options
    else if (is.array(opts)) {
        var _jsons = opts;

        elements = new Collection(cy, _jsons);
      }

      // specify via opts.nodes and opts.edges
      else if (is.plainObject(opts) && (is.array(opts.nodes) || is.array(opts.edges))) {
          var elesByGroup = opts;
          var _jsons2 = [];

          var grs = ['nodes', 'edges'];
          for (var _i = 0, il = grs.length; _i < il; _i++) {
            var group = grs[_i];
            var elesArray = elesByGroup[group];

            if (is.array(elesArray)) {

              for (var j = 0, jl = elesArray.length; j < jl; j++) {
                var json = util.extend({ group: group }, elesArray[j]);

                _jsons2.push(json);
              }
            }
          }

          elements = new Collection(cy, _jsons2);
        }

        // specify options for one element
        else {
            var _json = opts;
            elements = new Element(cy, _json).collection();
          }

    return elements;
  },

  remove: function remove(collection) {
    if (is.elementOrCollection(collection)) {
      // already have right ref
    } else if (is.string(collection)) {
      var selector = collection;
      collection = this.$(selector);
    }

    return collection.remove();
  }
};

module.exports = corefn;

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var define = __webpack_require__(4);
var util = __webpack_require__(1);
var stepAll = __webpack_require__(71);

var corefn = {

  // pull in animation functions
  animate: define.animate(),
  animation: define.animation(),
  animated: define.animated(),
  clearQueue: define.clearQueue(),
  delay: define.delay(),
  delayAnimation: define.delayAnimation(),
  stop: define.stop(),

  addToAnimationPool: function addToAnimationPool(eles) {
    var cy = this;

    if (!cy.styleEnabled()) {
      return;
    } // save cycles when no style used

    cy._private.aniEles.merge(eles);
  },

  stopAnimationLoop: function stopAnimationLoop() {
    this._private.animationsRunning = false;
  },

  startAnimationLoop: function startAnimationLoop() {
    var cy = this;

    cy._private.animationsRunning = true;

    if (!cy.styleEnabled()) {
      return;
    } // save cycles when no style used

    // NB the animation loop will exec in headless environments if style enabled
    // and explicit cy.destroy() is necessary to stop the loop

    function headlessStep() {
      if (!cy._private.animationsRunning) {
        return;
      }

      util.requestAnimationFrame(function animationStep(now) {
        stepAll(now, cy);
        headlessStep();
      });
    }

    var renderer = cy.renderer();

    if (renderer && renderer.beforeRender) {
      // let the renderer schedule animations
      renderer.beforeRender(function rendererAnimationStep(willDraw, now) {
        stepAll(now, cy);
      }, renderer.beforeRenderPriorities.animations);
    } else {
      // manage the animation loop ourselves
      headlessStep(); // first call
    }
  }

};

module.exports = corefn;

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var step = __webpack_require__(72);
var startAnimation = __webpack_require__(77);

function stepAll(now, cy) {
  var eles = cy._private.aniEles;
  var doneEles = [];

  function stepOne(ele, isCore) {
    var _p = ele._private;
    var current = _p.animation.current;
    var queue = _p.animation.queue;
    var ranAnis = false;

    // cancel all animations on display:none ele
    if (!isCore && ele.pstyle('display').value === 'none') {
      // put all current and queue animations in this tick's current list
      // and empty the lists for the element
      current = current.splice(0, current.length).concat(queue.splice(0, queue.length));

      // stop all animations
      for (var i = 0; i < current.length; i++) {
        current[i].stop();
      }
    }

    // if nothing currently animating, get something from the queue
    if (current.length === 0) {
      var next = queue.shift();

      if (next) {
        current.push(next);
      }
    }

    var callbacks = function callbacks(_callbacks) {
      for (var j = _callbacks.length - 1; j >= 0; j--) {
        var cb = _callbacks[j];

        cb();
      }

      _callbacks.splice(0, _callbacks.length);
    };

    // step and remove if done
    for (var _i = current.length - 1; _i >= 0; _i--) {
      var ani = current[_i];
      var ani_p = ani._private;

      if (ani_p.stopped) {
        current.splice(_i, 1);

        ani_p.hooked = false;
        ani_p.playing = false;
        ani_p.started = false;

        callbacks(ani_p.frames);

        continue;
      }

      if (!ani_p.playing && !ani_p.applying) {
        continue;
      }

      // an apply() while playing shouldn't do anything
      if (ani_p.playing && ani_p.applying) {
        ani_p.applying = false;
      }

      if (!ani_p.started) {
        startAnimation(ele, ani, now, isCore);
      }

      step(ele, ani, now, isCore);

      if (ani_p.applying) {
        ani_p.applying = false;
      }

      callbacks(ani_p.frames);

      if (ani.completed()) {
        current.splice(_i, 1);

        ani_p.hooked = false;
        ani_p.playing = false;
        ani_p.started = false;

        callbacks(ani_p.completes);
      }

      ranAnis = true;
    }

    if (!isCore && current.length === 0 && queue.length === 0) {
      doneEles.push(ele);
    }

    return ranAnis;
  } // stepElement

  // handle all eles
  var ranEleAni = false;
  for (var e = 0; e < eles.length; e++) {
    var ele = eles[e];
    var handledThisEle = stepOne(ele);

    ranEleAni = ranEleAni || handledThisEle;
  } // each element

  var ranCoreAni = stepOne(cy, true);

  // notify renderer
  if (ranEleAni || ranCoreAni) {
    if (eles.length > 0) {
      eles.dirtyCompoundBoundsCache();

      cy.notify({
        type: 'draw',
        eles: eles
      });
    } else {
      cy.notify({
        type: 'draw'
      });
    }
  }

  // remove elements from list of currently animating if its queues are empty
  eles.unmerge(doneEles);

  cy.emit('step');
} // stepAll

module.exports = stepAll;

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var easings = __webpack_require__(73);
var ease = __webpack_require__(76);
var is = __webpack_require__(0);

function step(self, ani, now, isCore) {
  var isEles = !isCore;
  var _p = self._private;
  var ani_p = ani._private;
  var pEasing = ani_p.easing;
  var startTime = ani_p.startTime;
  var cy = isCore ? self : self.cy();
  var style = cy.style();

  if (!ani_p.easingImpl) {

    if (pEasing == null) {
      // use default
      ani_p.easingImpl = easings['linear'];
    } else {
      // then define w/ name
      var easingVals = void 0;

      if (is.string(pEasing)) {
        var easingProp = style.parse('transition-timing-function', pEasing);

        easingVals = easingProp.value;
      } else {
        // then assume preparsed array
        easingVals = pEasing;
      }

      var name = void 0,
          args = void 0;

      if (is.string(easingVals)) {
        name = easingVals;
        args = [];
      } else {
        name = easingVals[1];
        args = easingVals.slice(2).map(function (n) {
          return +n;
        });
      }

      if (args.length > 0) {
        // create with args
        if (name === 'spring') {
          args.push(ani_p.duration); // need duration to generate spring
        }

        ani_p.easingImpl = easings[name].apply(null, args);
      } else {
        // static impl by name
        ani_p.easingImpl = easings[name];
      }
    }
  }

  var easing = ani_p.easingImpl;
  var percent = void 0;

  if (ani_p.duration === 0) {
    percent = 1;
  } else {
    percent = (now - startTime) / ani_p.duration;
  }

  if (ani_p.applying) {
    percent = ani_p.progress;
  }

  if (percent < 0) {
    percent = 0;
  } else if (percent > 1) {
    percent = 1;
  }

  if (ani_p.delay == null) {
    // then update

    var startPos = ani_p.startPosition;
    var endPos = ani_p.position;

    if (endPos && isEles && !self.locked()) {
      var pos = self.position();

      if (valid(startPos.x, endPos.x)) {
        pos.x = ease(startPos.x, endPos.x, percent, easing);
      }

      if (valid(startPos.y, endPos.y)) {
        pos.y = ease(startPos.y, endPos.y, percent, easing);
      }

      self.emit('position');
    }

    var startPan = ani_p.startPan;
    var endPan = ani_p.pan;
    var pan = _p.pan;
    var animatingPan = endPan != null && isCore;
    if (animatingPan) {
      if (valid(startPan.x, endPan.x)) {
        pan.x = ease(startPan.x, endPan.x, percent, easing);
      }

      if (valid(startPan.y, endPan.y)) {
        pan.y = ease(startPan.y, endPan.y, percent, easing);
      }

      self.emit('pan');
    }

    var startZoom = ani_p.startZoom;
    var endZoom = ani_p.zoom;
    var animatingZoom = endZoom != null && isCore;
    if (animatingZoom) {
      if (valid(startZoom, endZoom)) {
        _p.zoom = ease(startZoom, endZoom, percent, easing);
      }

      self.emit('zoom');
    }

    if (animatingPan || animatingZoom) {
      self.emit('viewport');
    }

    var props = ani_p.style;
    if (props && props.length > 0 && isEles) {
      for (var i = 0; i < props.length; i++) {
        var prop = props[i];
        var _name = prop.name;
        var end = prop;
        var start = ani_p.startStyle[_name];
        var propSpec = style.properties[start.name];
        var easedVal = ease(start, end, percent, easing, propSpec);

        style.overrideBypass(self, _name, easedVal);
      } // for props

      self.emit('style');
    } // if
  }

  ani_p.progress = percent;

  return percent;
}

function valid(start, end) {
  if (start == null || end == null) {
    return false;
  }

  if (is.number(start) && is.number(end)) {
    return true;
  } else if (start && end) {
    return true;
  }

  return false;
}

module.exports = step;

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var generateCubicBezier = __webpack_require__(74);
var generateSpringRK4 = __webpack_require__(75);

var cubicBezier = function cubicBezier(t1, p1, t2, p2) {
  var bezier = generateCubicBezier(t1, p1, t2, p2);

  return function (start, end, percent) {
    return start + (end - start) * bezier(percent);
  };
};

var easings = {
  'linear': function linear(start, end, percent) {
    return start + (end - start) * percent;
  },

  // default easings
  'ease': cubicBezier(0.25, 0.1, 0.25, 1),
  'ease-in': cubicBezier(0.42, 0, 1, 1),
  'ease-out': cubicBezier(0, 0, 0.58, 1),
  'ease-in-out': cubicBezier(0.42, 0, 0.58, 1),

  // sine
  'ease-in-sine': cubicBezier(0.47, 0, 0.745, 0.715),
  'ease-out-sine': cubicBezier(0.39, 0.575, 0.565, 1),
  'ease-in-out-sine': cubicBezier(0.445, 0.05, 0.55, 0.95),

  // quad
  'ease-in-quad': cubicBezier(0.55, 0.085, 0.68, 0.53),
  'ease-out-quad': cubicBezier(0.25, 0.46, 0.45, 0.94),
  'ease-in-out-quad': cubicBezier(0.455, 0.03, 0.515, 0.955),

  // cubic
  'ease-in-cubic': cubicBezier(0.55, 0.055, 0.675, 0.19),
  'ease-out-cubic': cubicBezier(0.215, 0.61, 0.355, 1),
  'ease-in-out-cubic': cubicBezier(0.645, 0.045, 0.355, 1),

  // quart
  'ease-in-quart': cubicBezier(0.895, 0.03, 0.685, 0.22),
  'ease-out-quart': cubicBezier(0.165, 0.84, 0.44, 1),
  'ease-in-out-quart': cubicBezier(0.77, 0, 0.175, 1),

  // quint
  'ease-in-quint': cubicBezier(0.755, 0.05, 0.855, 0.06),
  'ease-out-quint': cubicBezier(0.23, 1, 0.32, 1),
  'ease-in-out-quint': cubicBezier(0.86, 0, 0.07, 1),

  // expo
  'ease-in-expo': cubicBezier(0.95, 0.05, 0.795, 0.035),
  'ease-out-expo': cubicBezier(0.19, 1, 0.22, 1),
  'ease-in-out-expo': cubicBezier(1, 0, 0, 1),

  // circ
  'ease-in-circ': cubicBezier(0.6, 0.04, 0.98, 0.335),
  'ease-out-circ': cubicBezier(0.075, 0.82, 0.165, 1),
  'ease-in-out-circ': cubicBezier(0.785, 0.135, 0.15, 0.86),

  // user param easings...

  'spring': function spring(tension, friction, duration) {
    if (duration === 0) {
      // can't get a spring w/ duration 0
      return easings.linear; // duration 0 => jump to end so impl doesn't matter
    }

    var spring = generateSpringRK4(tension, friction, duration);

    return function (start, end, percent) {
      return start + (end - start) * spring(percent);
    };
  },

  'cubic-bezier': cubicBezier
};

module.exports = easings;

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* global Float32Array */

/*! Bezier curve function generator. Copyright Gaetan Renaudeau. MIT License: http://en.wikipedia.org/wiki/MIT_License */
function generateCubicBezier(mX1, mY1, mX2, mY2) {
  var NEWTON_ITERATIONS = 4,
      NEWTON_MIN_SLOPE = 0.001,
      SUBDIVISION_PRECISION = 0.0000001,
      SUBDIVISION_MAX_ITERATIONS = 10,
      kSplineTableSize = 11,
      kSampleStepSize = 1.0 / (kSplineTableSize - 1.0),
      float32ArraySupported = typeof Float32Array !== 'undefined';

  /* Must contain four arguments. */
  if (arguments.length !== 4) {
    return false;
  }

  /* Arguments must be numbers. */
  for (var i = 0; i < 4; ++i) {
    if (typeof arguments[i] !== "number" || isNaN(arguments[i]) || !isFinite(arguments[i])) {
      return false;
    }
  }

  /* X values must be in the [0, 1] range. */
  mX1 = Math.min(mX1, 1);
  mX2 = Math.min(mX2, 1);
  mX1 = Math.max(mX1, 0);
  mX2 = Math.max(mX2, 0);

  var mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);

  function A(aA1, aA2) {
    return 1.0 - 3.0 * aA2 + 3.0 * aA1;
  }

  function B(aA1, aA2) {
    return 3.0 * aA2 - 6.0 * aA1;
  }

  function C(aA1) {
    return 3.0 * aA1;
  }

  function calcBezier(aT, aA1, aA2) {
    return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
  }

  function getSlope(aT, aA1, aA2) {
    return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
  }

  function newtonRaphsonIterate(aX, aGuessT) {
    for (var _i = 0; _i < NEWTON_ITERATIONS; ++_i) {
      var currentSlope = getSlope(aGuessT, mX1, mX2);

      if (currentSlope === 0.0) {
        return aGuessT;
      }

      var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
      aGuessT -= currentX / currentSlope;
    }

    return aGuessT;
  }

  function calcSampleValues() {
    for (var _i2 = 0; _i2 < kSplineTableSize; ++_i2) {
      mSampleValues[_i2] = calcBezier(_i2 * kSampleStepSize, mX1, mX2);
    }
  }

  function binarySubdivide(aX, aA, aB) {
    var currentX = void 0,
        currentT = void 0,
        i = 0;

    do {
      currentT = aA + (aB - aA) / 2.0;
      currentX = calcBezier(currentT, mX1, mX2) - aX;
      if (currentX > 0.0) {
        aB = currentT;
      } else {
        aA = currentT;
      }
    } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);

    return currentT;
  }

  function getTForX(aX) {
    var intervalStart = 0.0,
        currentSample = 1,
        lastSample = kSplineTableSize - 1;

    for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {
      intervalStart += kSampleStepSize;
    }

    --currentSample;

    var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]),
        guessForT = intervalStart + dist * kSampleStepSize,
        initialSlope = getSlope(guessForT, mX1, mX2);

    if (initialSlope >= NEWTON_MIN_SLOPE) {
      return newtonRaphsonIterate(aX, guessForT);
    } else if (initialSlope === 0.0) {
      return guessForT;
    } else {
      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize);
    }
  }

  var _precomputed = false;

  function precompute() {
    _precomputed = true;
    if (mX1 !== mY1 || mX2 !== mY2) {
      calcSampleValues();
    }
  }

  var f = function f(aX) {
    if (!_precomputed) {
      precompute();
    }
    if (mX1 === mY1 && mX2 === mY2) {
      return aX;
    }
    if (aX === 0) {
      return 0;
    }
    if (aX === 1) {
      return 1;
    }

    return calcBezier(getTForX(aX), mY1, mY2);
  };

  f.getControlPoints = function () {
    return [{
      x: mX1,
      y: mY1
    }, {
      x: mX2,
      y: mY2
    }];
  };

  var str = "generateBezier(" + [mX1, mY1, mX2, mY2] + ")";
  f.toString = function () {
    return str;
  };

  return f;
}

module.exports = generateCubicBezier;

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*! Runge-Kutta spring physics function generator. Adapted from Framer.js, copyright Koen Bok. MIT License: http://en.wikipedia.org/wiki/MIT_License */
/* Given a tension, friction, and duration, a simulation at 60FPS will first run without a defined duration in order to calculate the full path. A second pass
   then adjusts the time delta -- using the relation between actual time and duration -- to calculate the path for the duration-constrained animation. */
var generateSpringRK4 = function () {
  function springAccelerationForState(state) {
    return -state.tension * state.x - state.friction * state.v;
  }

  function springEvaluateStateWithDerivative(initialState, dt, derivative) {
    var state = {
      x: initialState.x + derivative.dx * dt,
      v: initialState.v + derivative.dv * dt,
      tension: initialState.tension,
      friction: initialState.friction
    };

    return { dx: state.v, dv: springAccelerationForState(state) };
  }

  function springIntegrateState(state, dt) {
    var a = {
      dx: state.v,
      dv: springAccelerationForState(state)
    },
        b = springEvaluateStateWithDerivative(state, dt * 0.5, a),
        c = springEvaluateStateWithDerivative(state, dt * 0.5, b),
        d = springEvaluateStateWithDerivative(state, dt, c),
        dxdt = 1.0 / 6.0 * (a.dx + 2.0 * (b.dx + c.dx) + d.dx),
        dvdt = 1.0 / 6.0 * (a.dv + 2.0 * (b.dv + c.dv) + d.dv);

    state.x = state.x + dxdt * dt;
    state.v = state.v + dvdt * dt;

    return state;
  }

  return function springRK4Factory(tension, friction, duration) {

    var initState = {
      x: -1,
      v: 0,
      tension: null,
      friction: null
    },
        path = [0],
        time_lapsed = 0,
        tolerance = 1 / 10000,
        DT = 16 / 1000,
        have_duration = void 0,
        dt = void 0,
        last_state = void 0;

    tension = parseFloat(tension) || 500;
    friction = parseFloat(friction) || 20;
    duration = duration || null;

    initState.tension = tension;
    initState.friction = friction;

    have_duration = duration !== null;

    /* Calculate the actual time it takes for this animation to complete with the provided conditions. */
    if (have_duration) {
      /* Run the simulation without a duration. */
      time_lapsed = springRK4Factory(tension, friction);
      /* Compute the adjusted time delta. */
      dt = time_lapsed / duration * DT;
    } else {
      dt = DT;
    }

    for (;;) {
      /* Next/step function .*/
      last_state = springIntegrateState(last_state || initState, dt);
      /* Store the position. */
      path.push(1 + last_state.x);
      time_lapsed += 16;
      /* If the change threshold is reached, break. */
      if (!(Math.abs(last_state.x) > tolerance && Math.abs(last_state.v) > tolerance)) {
        break;
      }
    }

    /* If duration is not defined, return the actual time required for completing this animation. Otherwise, return a closure that holds the
       computed path and returns a snapshot of the position according to a given percentComplete. */
    return !have_duration ? time_lapsed : function (percentComplete) {
      return path[percentComplete * (path.length - 1) | 0];
    };
  };
}();

module.exports = generateSpringRK4;

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);

function getEasedValue(type, start, end, percent, easingFn) {
  if (percent === 1) {
    return end;
  }

  var val = easingFn(start, end, percent);

  if (type == null) {
    return val;
  }

  if (type.roundValue || type.color) {
    val = Math.round(val);
  }

  if (type.min !== undefined) {
    val = Math.max(val, type.min);
  }

  if (type.max !== undefined) {
    val = Math.min(val, type.max);
  }

  return val;
}

function getValue(prop, spec) {
  if (prop.pfValue != null || prop.value != null) {
    if (prop.pfValue != null && (spec == null || spec.type.units !== '%')) {
      return prop.pfValue;
    } else {
      return prop.value;
    }
  } else {
    return prop;
  }
}

function ease(startProp, endProp, percent, easingFn, propSpec) {
  var type = propSpec != null ? propSpec.type : null;

  if (percent < 0) {
    percent = 0;
  } else if (percent > 1) {
    percent = 1;
  }

  var start = getValue(startProp, propSpec);
  var end = getValue(endProp, propSpec);

  if (is.number(start) && is.number(end)) {
    return getEasedValue(type, start, end, percent, easingFn);
  } else if (is.array(start) && is.array(end)) {
    var easedArr = [];

    for (var i = 0; i < end.length; i++) {
      var si = start[i];
      var ei = end[i];

      if (si != null && ei != null) {
        var val = getEasedValue(type, si, ei, percent, easingFn);

        easedArr.push(val);
      } else {
        easedArr.push(ei);
      }
    }

    return easedArr;
  }

  return undefined;
}

module.exports = ease;

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function startAnimation(self, ani, now, isCore) {
  var isEles = !isCore;
  var ele = self;
  var ani_p = ani._private;
  var cy = isCore ? self : self.cy();
  var style = cy.style();

  if (isEles) {
    var pos = ele.position();

    ani_p.startPosition = ani_p.startPosition || {
      x: pos.x,
      y: pos.y
    };

    ani_p.startStyle = ani_p.startStyle || style.getAnimationStartStyle(ele, ani_p.style);
  }

  if (isCore) {
    var pan = cy._private.pan;

    ani_p.startPan = ani_p.startPan || {
      x: pan.x,
      y: pan.y
    };

    ani_p.startZoom = ani_p.startZoom != null ? ani_p.startZoom : cy._private.zoom;
  }

  ani_p.started = true;
  ani_p.startTime = now - ani_p.progress * ani_p.duration;
}

module.exports = startAnimation;

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Emitter = __webpack_require__(11);
var define = __webpack_require__(4);
var is = __webpack_require__(0);
var util = __webpack_require__(1);
var Selector = __webpack_require__(6);

var emitterOptions = {
  qualifierCompare: function qualifierCompare(selector1, selector2) {
    if (selector1 == null || selector2 == null) {
      return selector1 == null && selector2 == null;
    } else {
      return selector1.sameText(selector2);
    }
  },
  eventMatches: function eventMatches(cy, listener, eventObj) {
    var selector = listener.qualifier;

    if (selector != null) {
      return cy !== eventObj.target && is.element(eventObj.target) && selector.matches(eventObj.target);
    }

    return true;
  },
  eventFields: function eventFields(cy) {
    return {
      cy: cy,
      target: cy
    };
  },
  callbackContext: function callbackContext(cy, listener, eventObj) {
    return listener.qualifier != null ? eventObj.target : cy;
  }
};

var argSelector = function argSelector(arg) {
  if (is.string(arg)) {
    return new Selector(arg);
  } else {
    return arg;
  }
};

var elesfn = {
  createEmitter: function createEmitter() {
    var _p = this._private;

    if (!_p.emitter) {
      _p.emitter = new Emitter(util.assign({
        context: this
      }, emitterOptions));
    }

    return this;
  },

  emitter: function emitter() {
    return this._private.emitter;
  },

  on: function on(events, selector, callback) {
    this.emitter().on(events, argSelector(selector), callback);

    return this;
  },

  removeListener: function removeListener(events, selector, callback) {
    this.emitter().removeListener(events, argSelector(selector), callback);

    return this;
  },

  one: function one(events, selector, callback) {
    this.emitter().one(events, argSelector(selector), callback);

    return this;
  },

  once: function once(events, selector, callback) {
    this.emitter().one(events, argSelector(selector), callback);

    return this;
  },

  emit: function emit(events, extraParams) {
    this.emitter().emit(events, extraParams);

    return this;
  }
};

define.eventAliasesOn(elesfn);

module.exports = elesfn;

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var corefn = {

  png: function png(options) {
    var renderer = this._private.renderer;
    options = options || {};

    return renderer.png(options);
  },

  jpg: function jpg(options) {
    var renderer = this._private.renderer;
    options = options || {};

    options.bg = options.bg || '#fff';

    return renderer.jpg(options);
  }

};

corefn.jpeg = corefn.jpg;

module.exports = corefn;

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);
var is = __webpack_require__(0);

var corefn = {

  layout: function layout(options) {
    var cy = this;

    if (options == null) {
      util.error('Layout options must be specified to make a layout');
      return;
    }

    if (options.name == null) {
      util.error('A `name` must be specified to make a layout');
      return;
    }

    var name = options.name;
    var Layout = cy.extension('layout', name);

    if (Layout == null) {
      util.error('Can not apply layout: No such layout `' + name + '` found; did you include its JS file?');
      return;
    }

    var eles = void 0;
    if (is.string(options.eles)) {
      eles = cy.$(options.eles);
    } else {
      eles = options.eles != null ? options.eles : cy.$();
    }

    var layout = new Layout(util.extend({}, options, {
      cy: cy,
      eles: eles
    }));

    return layout;
  }

};

corefn.createLayout = corefn.makeLayout = corefn.layout;

module.exports = corefn;

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var corefn = {
  notify: function notify(params) {
    var _p = this._private;

    if (_p.batchingNotify) {
      var bEles = _p.batchNotifyEles;
      var bTypes = _p.batchNotifyTypes;

      if (params.eles) {
        bEles.merge(params.eles);
      }

      if (!bTypes.ids[params.type]) {
        bTypes.push(params.type);
        bTypes.ids[params.type] = true;
      }

      return; // notifications are disabled during batching
    }

    if (!_p.notificationsEnabled) {
      return;
    } // exit on disabled

    var renderer = this.renderer();

    // exit if destroy() called on core or renderer in between frames #1499 #1528
    if (this.isDestroyed() || !renderer) {
      return;
    }

    renderer.notify(params);
  },

  notifications: function notifications(bool) {
    var p = this._private;

    if (bool === undefined) {
      return p.notificationsEnabled;
    } else {
      p.notificationsEnabled = bool ? true : false;
    }
  },

  noNotifications: function noNotifications(callback) {
    this.notifications(false);
    callback();
    this.notifications(true);
  },

  batching: function batching() {
    return this._private.batchCount > 0;
  },

  startBatch: function startBatch() {
    var _p = this._private;

    if (_p.batchCount == null) {
      _p.batchCount = 0;
    }

    if (_p.batchCount === 0) {
      _p.batchingStyle = _p.batchingNotify = true;
      _p.batchStyleEles = this.collection();
      _p.batchNotifyEles = this.collection();
      _p.batchNotifyTypes = [];
      _p.batchNotifyTypes.ids = {};
    }

    _p.batchCount++;

    return this;
  },

  endBatch: function endBatch() {
    var _p = this._private;

    _p.batchCount--;

    if (_p.batchCount === 0) {
      // update style for dirty eles
      _p.batchingStyle = false;
      _p.batchStyleEles.updateStyle();

      // notify the renderer of queued eles and event types
      _p.batchingNotify = false;
      this.notify({
        type: _p.batchNotifyTypes,
        eles: _p.batchNotifyEles
      });
    }

    return this;
  },

  batch: function batch(callback) {
    this.startBatch();
    callback();
    this.endBatch();

    return this;
  },

  // for backwards compatibility
  batchData: function batchData(map) {
    var cy = this;

    return this.batch(function () {
      var ids = Object.keys(map);

      for (var i = 0; i < ids.length; i++) {
        var id = ids[i];
        var data = map[id];
        var ele = cy.getElementById(id);

        ele.data(data);
      }
    });
  }
};

module.exports = corefn;

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);

var corefn = {

  renderTo: function renderTo(context, zoom, pan, pxRatio) {
    var r = this._private.renderer;

    r.renderTo(context, zoom, pan, pxRatio);
    return this;
  },

  renderer: function renderer() {
    return this._private.renderer;
  },

  forceRender: function forceRender() {
    this.notify({
      type: 'draw'
    });

    return this;
  },

  resize: function resize() {
    this.invalidateSize();

    this.notify({
      type: 'resize'
    });

    this.emit('resize');

    return this;
  },

  initRenderer: function initRenderer(options) {
    var cy = this;

    var RendererProto = cy.extension('renderer', options.name);
    if (RendererProto == null) {
      util.error('Can not initialise: No such renderer `%s` found; did you include its JS file?', options.name);
      return;
    }

    cy._private.renderer = new RendererProto(util.extend({}, options, { cy: cy }));

    this.notify({ type: 'init' });
  },

  destroyRenderer: function destroyRenderer() {
    var cy = this;

    cy.notify({ type: 'destroy' }); // destroy the renderer

    var domEle = cy.container();
    if (domEle) {
      domEle._cyreg = null;

      while (domEle.childNodes.length > 0) {
        domEle.removeChild(domEle.childNodes[0]);
      }
    }

    cy._private.renderer = null; // to be extra safe, remove the ref
  },

  onRender: function onRender(fn) {
    return this.on('render', fn);
  },

  offRender: function offRender(fn) {
    return this.off('render', fn);
  }

};

corefn.invalidateDimensions = corefn.resize;

module.exports = corefn;

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);
var Collection = __webpack_require__(7);

var corefn = {

  // get a collection
  // - empty collection on no args
  // - collection of elements in the graph on selector arg
  // - guarantee a returned collection when elements or collection specified
  collection: function collection(eles, opts) {

    if (is.string(eles)) {
      return this.$(eles);
    } else if (is.elementOrCollection(eles)) {
      return eles.collection();
    } else if (is.array(eles)) {
      return new Collection(this, eles, opts);
    }

    return new Collection(this);
  },

  nodes: function nodes(selector) {
    var nodes = this.$(function (ele) {
      return ele.isNode();
    });

    if (selector) {
      return nodes.filter(selector);
    }

    return nodes;
  },

  edges: function edges(selector) {
    var edges = this.$(function (ele) {
      return ele.isEdge();
    });

    if (selector) {
      return edges.filter(selector);
    }

    return edges;
  },

  // search the graph like jQuery
  $: function $(selector) {
    var eles = this._private.elements;

    if (selector) {
      return eles.filter(selector);
    } else {
      return eles.spawnSelf();
    }
  },

  mutableElements: function mutableElements() {
    return this._private.elements;
  }

};

// aliases
corefn.elements = corefn.filter = corefn.$;

module.exports = corefn;

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);
var Style = __webpack_require__(18);

var corefn = {

  style: function style(newStyle) {
    if (newStyle) {
      var s = this.setStyle(newStyle);

      s.update();
    }

    return this._private.style;
  },

  setStyle: function setStyle(style) {
    var _p = this._private;

    if (is.stylesheet(style)) {
      _p.style = style.generateStyle(this);
    } else if (is.array(style)) {
      _p.style = Style.fromJson(this, style);
    } else if (is.string(style)) {
      _p.style = Style.fromString(this, style);
    } else {
      _p.style = Style(this);
    }

    return _p.style;
  }
};

module.exports = corefn;

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);
var is = __webpack_require__(0);
var Promise = __webpack_require__(5);

var styfn = {};

// (potentially expensive calculation)
// apply the style to the element based on
// - its bypass
// - what selectors match it
styfn.apply = function (eles) {
  var self = this;
  var _p = self._private;
  var cy = _p.cy;
  var updatedEles = cy.collection();

  if (_p.newStyle) {
    // clear style caches
    _p.contextStyles = {};
    _p.propDiffs = {};

    self.cleanElements(eles, true);
  }

  for (var ie = 0; ie < eles.length; ie++) {
    var ele = eles[ie];

    var cxtMeta = self.getContextMeta(ele);

    if (cxtMeta.empty) {
      continue;
    } else {
      updatedEles.merge(ele);
    }

    var cxtStyle = self.getContextStyle(cxtMeta);
    var app = self.applyContextStyle(cxtMeta, cxtStyle, ele);

    if (!_p.newStyle) {
      self.updateTransitions(ele, app.diffProps);
    }

    self.updateStyleHints(ele);
  } // for elements

  _p.newStyle = false;

  return updatedEles;
};

styfn.getPropertiesDiff = function (oldCxtKey, newCxtKey) {
  var self = this;
  var cache = self._private.propDiffs = self._private.propDiffs || {};
  var dualCxtKey = oldCxtKey + '-' + newCxtKey;
  var cachedVal = cache[dualCxtKey];

  if (cachedVal) {
    return cachedVal;
  }

  var diffProps = [];
  var addedProp = {};

  for (var i = 0; i < self.length; i++) {
    var cxt = self[i];
    var oldHasCxt = oldCxtKey[i] === 't';
    var newHasCxt = newCxtKey[i] === 't';
    var cxtHasDiffed = oldHasCxt !== newHasCxt;
    var cxtHasMappedProps = cxt.mappedProperties.length > 0;

    if (cxtHasDiffed || cxtHasMappedProps) {
      var props = void 0;

      if (cxtHasDiffed && cxtHasMappedProps) {
        props = cxt.properties; // suffices b/c mappedProperties is a subset of properties
      } else if (cxtHasDiffed) {
        props = cxt.properties; // need to check them all
      } else if (cxtHasMappedProps) {
        props = cxt.mappedProperties; // only need to check mapped
      }

      for (var j = 0; j < props.length; j++) {
        var prop = props[j];
        var name = prop.name;

        // if a later context overrides this property, then the fact that this context has switched/diffed doesn't matter
        // (semi expensive check since it makes this function O(n^2) on context length, but worth it since overall result
        // is cached)
        var laterCxtOverrides = false;
        for (var k = i + 1; k < self.length; k++) {
          var laterCxt = self[k];
          var hasLaterCxt = newCxtKey[k] === 't';

          if (!hasLaterCxt) {
            continue;
          } // can't override unless the context is active

          laterCxtOverrides = laterCxt.properties[prop.name] != null;

          if (laterCxtOverrides) {
            break;
          } // exit early as long as one later context overrides
        }

        if (!addedProp[name] && !laterCxtOverrides) {
          addedProp[name] = true;
          diffProps.push(name);
        }
      } // for props
    } // if
  } // for contexts

  cache[dualCxtKey] = diffProps;
  return diffProps;
};

styfn.getContextMeta = function (ele) {
  var self = this;
  var cxtKey = '';
  var diffProps = void 0;
  var prevKey = ele._private.styleCxtKey || '';

  if (self._private.newStyle) {
    prevKey = ''; // since we need to apply all style if a fresh stylesheet
  }

  // get the cxt key
  for (var i = 0; i < self.length; i++) {
    var context = self[i];
    var contextSelectorMatches = context.selector && context.selector.matches(ele); // NB: context.selector may be null for 'core'

    if (contextSelectorMatches) {
      cxtKey += 't';
    } else {
      cxtKey += 'f';
    }
  } // for context

  diffProps = self.getPropertiesDiff(prevKey, cxtKey);

  ele._private.styleCxtKey = cxtKey;

  return {
    key: cxtKey,
    diffPropNames: diffProps,
    empty: diffProps.length === 0
  };
};

// gets a computed ele style object based on matched contexts
styfn.getContextStyle = function (cxtMeta) {
  var cxtKey = cxtMeta.key;
  var self = this;
  var cxtStyles = this._private.contextStyles = this._private.contextStyles || {};

  // if already computed style, returned cached copy
  if (cxtStyles[cxtKey]) {
    return cxtStyles[cxtKey];
  }

  var style = {
    _private: {
      key: cxtKey
    }
  };

  for (var i = 0; i < self.length; i++) {
    var cxt = self[i];
    var hasCxt = cxtKey[i] === 't';

    if (!hasCxt) {
      continue;
    }

    for (var j = 0; j < cxt.properties.length; j++) {
      var prop = cxt.properties[j];

      style[prop.name] = prop;
    }
  }

  cxtStyles[cxtKey] = style;
  return style;
};

styfn.applyContextStyle = function (cxtMeta, cxtStyle, ele) {
  var self = this;
  var diffProps = cxtMeta.diffPropNames;
  var retDiffProps = {};

  for (var i = 0; i < diffProps.length; i++) {
    var diffPropName = diffProps[i];
    var cxtProp = cxtStyle[diffPropName];
    var eleProp = ele.pstyle(diffPropName);

    if (!cxtProp) {
      // no context prop means delete
      if (!eleProp) {
        continue; // no existing prop means nothing needs to be removed
        // nb affects initial application on mapped values like control-point-distances
      } else if (eleProp.bypass) {
        cxtProp = { name: diffPropName, deleteBypassed: true };
      } else {
        cxtProp = { name: diffPropName, delete: true };
      }
    }

    // save cycles when the context prop doesn't need to be applied
    if (eleProp === cxtProp) {
      continue;
    }

    var retDiffProp = retDiffProps[diffPropName] = {
      prev: eleProp
    };

    self.applyParsedProperty(ele, cxtProp);

    retDiffProp.next = ele.pstyle(diffPropName);

    if (retDiffProp.next && retDiffProp.next.bypass) {
      retDiffProp.next = retDiffProp.next.bypassed;
    }
  }

  return {
    diffProps: retDiffProps
  };
};

styfn.updateStyleHints = function (ele) {
  var _p = ele._private;
  var self = this;

  if (ele.removed()) {
    return;
  }

  // set whether has pie or not; for greater efficiency
  var hasPie = false;
  if (_p.group === 'nodes') {
    for (var i = 1; i <= self.pieBackgroundN; i++) {
      // 1..N
      var _size = ele.pstyle('pie-' + i + '-background-size').value;

      if (_size > 0) {
        hasPie = true;
        break;
      }
    }
  }

  _p.hasPie = hasPie;

  var transform = ele.pstyle('text-transform').strValue;
  var content = ele.pstyle('label').strValue;
  var srcContent = ele.pstyle('source-label').strValue;
  var tgtContent = ele.pstyle('target-label').strValue;
  var fStyle = ele.pstyle('font-style').strValue;
  var size = ele.pstyle('font-size').pfValue + 'px';
  var family = ele.pstyle('font-family').strValue;
  // let letiant = style['font-letiant'].strValue;
  var weight = ele.pstyle('font-weight').strValue;
  var valign = ele.pstyle('text-valign').strValue;
  var halign = ele.pstyle('text-valign').strValue;
  var oWidth = ele.pstyle('text-outline-width').pfValue;
  var wrap = ele.pstyle('text-wrap').strValue;
  var wrapW = ele.pstyle('text-max-width').pfValue;
  var labelStyleKey = fStyle + '$' + size + '$' + family + '$' + weight + '$' + transform + '$' + valign + '$' + halign + '$' + oWidth + '$' + wrap + '$' + wrapW;
  _p.labelStyleKey = labelStyleKey;
  _p.sourceLabelKey = labelStyleKey + '$' + srcContent;
  _p.targetLabelKey = labelStyleKey + '$' + tgtContent;
  _p.labelKey = labelStyleKey + '$' + content;
  _p.fontKey = fStyle + '$' + weight + '$' + size + '$' + family;

  _p.styleKey = Date.now();
};

// apply a property to the style (for internal use)
// returns whether application was successful
//
// now, this function flattens the property, and here's how:
//
// for parsedProp:{ bypass: true, deleteBypass: true }
// no property is generated, instead the bypass property in the
// element's style is replaced by what's pointed to by the `bypassed`
// field in the bypass property (i.e. restoring the property the
// bypass was overriding)
//
// for parsedProp:{ mapped: truthy }
// the generated flattenedProp:{ mapping: prop }
//
// for parsedProp:{ bypass: true }
// the generated flattenedProp:{ bypassed: parsedProp }
styfn.applyParsedProperty = function (ele, parsedProp) {
  var self = this;
  var prop = parsedProp;
  var style = ele._private.style;
  var fieldVal = void 0,
      flatProp = void 0;
  var types = self.types;
  var type = self.properties[prop.name].type;
  var propIsBypass = prop.bypass;
  var origProp = style[prop.name];
  var origPropIsBypass = origProp && origProp.bypass;
  var _p = ele._private;
  var flatPropMapping = 'mapping';

  var checkZOrder = function checkZOrder() {
    self.checkZOrderTrigger(ele, prop.name, origProp ? origProp.value : null, prop.value);
  };

  // edges connected to compound nodes can not be haystacks
  if (parsedProp.name === 'curve-style' && parsedProp.value === 'haystack' && ele.isEdge() && (ele.isLoop() || ele.source().isParent() || ele.target().isParent())) {
    prop = parsedProp = this.parse(parsedProp.name, 'bezier', propIsBypass);
  }

  if (prop.delete) {
    // delete the property and use the default value on falsey value
    style[prop.name] = undefined;

    checkZOrder();

    return true;
  }

  if (prop.deleteBypassed) {
    // delete the property that the
    if (!origProp) {
      checkZOrder();

      return true; // can't delete if no prop
    } else if (origProp.bypass) {
      // delete bypassed
      origProp.bypassed = undefined;

      checkZOrder();

      return true;
    } else {
      return false; // we're unsuccessful deleting the bypassed
    }
  }

  // check if we need to delete the current bypass
  if (prop.deleteBypass) {
    // then this property is just here to indicate we need to delete
    if (!origProp) {
      checkZOrder();

      return true; // property is already not defined
    } else if (origProp.bypass) {
      // then replace the bypass property with the original
      // because the bypassed property was already applied (and therefore parsed), we can just replace it (no reapplying necessary)
      style[prop.name] = origProp.bypassed;

      checkZOrder();

      return true;
    } else {
      return false; // we're unsuccessful deleting the bypass
    }
  }

  var printMappingErr = function printMappingErr() {
    util.error('Do not assign mappings to elements without corresponding data (e.g. ele `' + ele.id() + '` for property `' + prop.name + '` with data field `' + prop.field + '`); try a `[' + prop.field + ']` selector to limit scope to elements with `' + prop.field + '` defined');
  };

  // put the property in the style objects
  switch (prop.mapped) {// flatten the property if mapped
    case types.mapData:
      {
        // flatten the field (e.g. data.foo.bar)
        var fields = prop.field.split('.');
        var _fieldVal = _p.data;

        for (var i = 0; i < fields.length && _fieldVal; i++) {
          var field = fields[i];
          _fieldVal = _fieldVal[field];
        }

        var percent = void 0;
        if (!is.number(_fieldVal)) {
          // then keep the mapping but assume 0% for now
          percent = 0;
        } else {
          percent = (_fieldVal - prop.fieldMin) / (prop.fieldMax - prop.fieldMin);
        }

        // make sure to bound percent value
        if (percent < 0) {
          percent = 0;
        } else if (percent > 1) {
          percent = 1;
        }

        if (type.color) {
          var r1 = prop.valueMin[0];
          var r2 = prop.valueMax[0];
          var g1 = prop.valueMin[1];
          var g2 = prop.valueMax[1];
          var b1 = prop.valueMin[2];
          var b2 = prop.valueMax[2];
          var a1 = prop.valueMin[3] == null ? 1 : prop.valueMin[3];
          var a2 = prop.valueMax[3] == null ? 1 : prop.valueMax[3];

          var clr = [Math.round(r1 + (r2 - r1) * percent), Math.round(g1 + (g2 - g1) * percent), Math.round(b1 + (b2 - b1) * percent), Math.round(a1 + (a2 - a1) * percent)];

          flatProp = { // colours are simple, so just create the flat property instead of expensive string parsing
            bypass: prop.bypass, // we're a bypass if the mapping property is a bypass
            name: prop.name,
            value: clr,
            strValue: 'rgb(' + clr[0] + ', ' + clr[1] + ', ' + clr[2] + ')'
          };
        } else if (type.number) {
          var calcValue = prop.valueMin + (prop.valueMax - prop.valueMin) * percent;
          flatProp = this.parse(prop.name, calcValue, prop.bypass, flatPropMapping);
        } else {
          return false; // can only map to colours and numbers
        }

        if (!flatProp) {
          // if we can't flatten the property, then use the origProp so we still keep the mapping itself
          flatProp = this.parse(prop.name, origProp.strValue, prop.bypass, flatPropMapping);
        }

        if (!flatProp) {
          printMappingErr();
        }
        flatProp.mapping = prop; // keep a reference to the mapping
        prop = flatProp; // the flattened (mapped) property is the one we want

        break;
      }

    // direct mapping
    case types.data:
      {
        // flatten the field (e.g. data.foo.bar)
        var _fields = prop.field.split('.');
        var _fieldVal2 = _p.data;

        if (_fieldVal2) {
          for (var _i = 0; _i < _fields.length; _i++) {
            var _field = _fields[_i];
            _fieldVal2 = _fieldVal2[_field];
          }
        }

        flatProp = this.parse(prop.name, _fieldVal2, prop.bypass, flatPropMapping);

        if (!flatProp) {
          // if we can't flatten the property, then use the origProp so we still keep the mapping itself
          var flatPropVal = origProp ? origProp.strValue : '';

          flatProp = this.parse(prop.name, flatPropVal, prop.bypass, flatPropMapping);
        }

        if (!flatProp) {
          printMappingErr();
        }
        flatProp.mapping = prop; // keep a reference to the mapping
        prop = flatProp; // the flattened (mapped) property is the one we want

        break;
      }

    case types.fn:
      {
        var fn = prop.value;
        var fnRetVal = fn(ele);

        flatProp = this.parse(prop.name, fnRetVal, prop.bypass, flatPropMapping);
        flatProp.mapping = prop; // keep a reference to the mapping
        prop = flatProp; // the flattened (mapped) property is the one we want

        break;
      }

    case undefined:
      break; // just set the property

    default:
      return false; // not a valid mapping
  }

  // if the property is a bypass property, then link the resultant property to the original one
  if (propIsBypass) {
    if (origPropIsBypass) {
      // then this bypass overrides the existing one
      prop.bypassed = origProp.bypassed; // steal bypassed prop from old bypass
    } else {
      // then link the orig prop to the new bypass
      prop.bypassed = origProp;
    }

    style[prop.name] = prop; // and set
  } else {
    // prop is not bypass
    if (origPropIsBypass) {
      // then keep the orig prop (since it's a bypass) and link to the new prop
      origProp.bypassed = prop;
    } else {
      // then just replace the old prop with the new one
      style[prop.name] = prop;
    }
  }

  checkZOrder();

  return true;
};

styfn.cleanElements = function (eles, keepBypasses) {
  var self = this;
  var props = self.properties;

  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];

    if (!keepBypasses) {
      ele._private.style = {};
    } else {
      var style = ele._private.style;

      for (var j = 0; j < props.length; j++) {
        var prop = props[j];
        var eleProp = style[prop.name];

        if (eleProp) {
          if (eleProp.bypass) {
            eleProp.bypassed = null;
          } else {
            style[prop.name] = null;
          }
        }
      }
    }
  }
};

// updates the visual style for all elements (useful for manual style modification after init)
styfn.update = function () {
  var cy = this._private.cy;
  var eles = cy.mutableElements();

  eles.updateStyle();
};

// just update the functional properties (i.e. mappings) in the elements'
// styles (less expensive than recalculation)
styfn.updateMappers = function (eles) {
  var self = this;
  var cy = this._private.cy;
  var updatedEles = cy.collection();

  for (var i = 0; i < eles.length; i++) {
    // for each ele
    var ele = eles[i];
    var style = ele._private.style;
    var updatedEle = false;

    for (var j = 0; j < self.properties.length; j++) {
      // for each prop
      var prop = self.properties[j];
      var propInStyle = style[prop.name];

      if (propInStyle && propInStyle.mapping) {
        var mapping = propInStyle.mapping;

        this.applyParsedProperty(ele, mapping); // reapply the mapping property

        updatedEle = true;
      }
    }

    if (updatedEle) {
      this.updateStyleHints(ele);

      updatedEles.merge(ele);
    }
  }

  return updatedEles;
};

// diffProps : { name => { prev, next } }
styfn.updateTransitions = function (ele, diffProps, isBypass) {
  var self = this;
  var _p = ele._private;
  var props = ele.pstyle('transition-property').value;
  var duration = ele.pstyle('transition-duration').pfValue;
  var delay = ele.pstyle('transition-delay').pfValue;

  if (props.length > 0 && duration > 0) {

    var style = {};

    // build up the style to animate towards
    var anyPrev = false;
    for (var i = 0; i < props.length; i++) {
      var prop = props[i];
      var styProp = ele.pstyle(prop);
      var diffProp = diffProps[prop];

      if (!diffProp) {
        continue;
      }

      var prevProp = diffProp.prev;
      var fromProp = prevProp;
      var toProp = diffProp.next != null ? diffProp.next : styProp;
      var diff = false;
      var initVal = void 0;
      var initDt = 0.000001; // delta time % value for initVal (allows animating out of init zero opacity)

      if (!fromProp) {
        continue;
      }

      // consider px values
      if (is.number(fromProp.pfValue) && is.number(toProp.pfValue)) {
        diff = toProp.pfValue - fromProp.pfValue; // nonzero is truthy
        initVal = fromProp.pfValue + initDt * diff;

        // consider numerical values
      } else if (is.number(fromProp.value) && is.number(toProp.value)) {
        diff = toProp.value - fromProp.value; // nonzero is truthy
        initVal = fromProp.value + initDt * diff;

        // consider colour values
      } else if (is.array(fromProp.value) && is.array(toProp.value)) {
        diff = fromProp.value[0] !== toProp.value[0] || fromProp.value[1] !== toProp.value[1] || fromProp.value[2] !== toProp.value[2];

        initVal = fromProp.strValue;
      }

      // the previous value is good for an animation only if it's different
      if (diff) {
        style[prop] = toProp.strValue; // to val
        this.applyBypass(ele, prop, initVal); // from val
        anyPrev = true;
      }
    } // end if props allow ani

    // can't transition if there's nothing previous to transition from
    if (!anyPrev) {
      return;
    }

    _p.transitioning = true;

    new Promise(function (resolve) {
      if (delay > 0) {
        ele.delayAnimation(delay).play().promise().then(resolve);
      } else {
        resolve();
      }
    }).then(function () {
      return ele.animation({
        style: style,
        duration: duration,
        easing: ele.pstyle('transition-timing-function').value,
        queue: false
      }).play().promise();
    }).then(function () {
      // if( !isBypass ){
      self.removeBypasses(ele, props);
      ele.emitAndNotify('style');
      // }

      _p.transitioning = false;
    });
  } else if (_p.transitioning) {
    this.removeBypasses(ele, props);
    ele.emitAndNotify('style');

    _p.transitioning = false;
  }
};

styfn.checkZOrderTrigger = function (ele, name, fromValue, toValue) {
  var prop = this.properties[name];

  if (prop.triggersZOrder != null && (fromValue == null || prop.triggersZOrder(fromValue, toValue))) {
    this._private.cy.notify({
      type: 'zorder',
      eles: ele
    });
  }
};

module.exports = styfn;

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);
var util = __webpack_require__(1);

var styfn = {};

// bypasses are applied to an existing style on an element, and just tacked on temporarily
// returns true iff application was successful for at least 1 specified property
styfn.applyBypass = function (eles, name, value, updateTransitions) {
  var self = this;
  var props = [];
  var isBypass = true;

  // put all the properties (can specify one or many) in an array after parsing them
  if (name === '*' || name === '**') {
    // apply to all property names

    if (value !== undefined) {
      for (var i = 0; i < self.properties.length; i++) {
        var prop = self.properties[i];
        var _name = prop.name;

        var parsedProp = this.parse(_name, value, true);

        if (parsedProp) {
          props.push(parsedProp);
        }
      }
    }
  } else if (is.string(name)) {
    // then parse the single property
    var _parsedProp = this.parse(name, value, true);

    if (_parsedProp) {
      props.push(_parsedProp);
    }
  } else if (is.plainObject(name)) {
    // then parse each property
    var specifiedProps = name;
    updateTransitions = value;

    var names = Object.keys(specifiedProps);

    for (var _i = 0; _i < names.length; _i++) {
      var _name2 = names[_i];
      var _prop = self.properties[_name2];
      var _value = specifiedProps[_name2];

      if (_value === undefined) {
        // try camel case name too
        _value = specifiedProps[util.dash2camel(_name2)];
      }

      if (_value !== undefined) {
        var _parsedProp2 = this.parse(_name2, _value, true);

        if (_parsedProp2) {
          props.push(_parsedProp2);
        }
      }
    }
  } else {
    // can't do anything without well defined properties
    return false;
  }

  // we've failed if there are no valid properties
  if (props.length === 0) {
    return false;
  }

  // now, apply the bypass properties on the elements
  var ret = false; // return true if at least one succesful bypass applied
  for (var _i2 = 0; _i2 < eles.length; _i2++) {
    // for each ele
    var ele = eles[_i2];
    var diffProps = {};
    var diffProp = void 0;

    for (var j = 0; j < props.length; j++) {
      // for each prop
      var _prop2 = props[j];

      if (updateTransitions) {
        var prevProp = ele.pstyle(_prop2.name);
        diffProp = diffProps[_prop2.name] = { prev: prevProp };
      }

      ret = this.applyParsedProperty(ele, _prop2) || ret;

      if (updateTransitions) {
        diffProp.next = ele.pstyle(_prop2.name);
      }
    } // for props

    if (ret) {
      this.updateStyleHints(ele);
    }

    if (updateTransitions) {
      this.updateTransitions(ele, diffProps, isBypass);
    }
  } // for eles

  return ret;
};

// only useful in specific cases like animation
styfn.overrideBypass = function (eles, name, value) {
  name = util.camel2dash(name);

  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];
    var prop = ele._private.style[name];
    var type = this.properties[name].type;
    var isColor = type.color;
    var isMulti = type.mutiple;

    if (!prop || !prop.bypass) {
      // need a bypass if one doesn't exist
      this.applyBypass(ele, name, value);
      continue;
    }

    var oldValue = prop.pfValue != null ? prop.pfValue : prop.value;

    prop.value = value;

    if (prop.pfValue != null) {
      prop.pfValue = value;
    }

    if (isColor) {
      prop.strValue = 'rgb(' + value.join(',') + ')';
    } else if (isMulti) {
      prop.strValue = value.join(' ');
    } else {
      prop.strValue = '' + value;
    }

    this.checkZOrderTrigger(ele, name, oldValue, value);
  }
};

styfn.removeAllBypasses = function (eles, updateTransitions) {
  return this.removeBypasses(eles, this.propertyNames, updateTransitions);
};

styfn.removeBypasses = function (eles, props, updateTransitions) {
  var isBypass = true;

  for (var j = 0; j < eles.length; j++) {
    var ele = eles[j];
    var diffProps = {};

    for (var i = 0; i < props.length; i++) {
      var name = props[i];
      var prop = this.properties[name];
      var prevProp = ele.pstyle(prop.name);

      if (!prevProp || !prevProp.bypass) {
        // if a bypass doesn't exist for the prop, nothing needs to be removed
        continue;
      }

      var value = ''; // empty => remove bypass
      var parsedProp = this.parse(name, value, true);
      var diffProp = diffProps[prop.name] = { prev: prevProp };

      this.applyParsedProperty(ele, parsedProp);

      diffProp.next = ele.pstyle(prop.name);
    } // for props

    this.updateStyleHints(ele);

    if (updateTransitions) {
      this.updateTransitions(ele, diffProps, isBypass);
    }
  } // for eles
};

module.exports = styfn;

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var window = __webpack_require__(3);

var styfn = {};

// gets what an em size corresponds to in pixels relative to a dom element
styfn.getEmSizeInPixels = function () {
  var px = this.containerCss('font-size');

  if (px != null) {
    return parseFloat(px);
  } else {
    return 1; // for headless
  }
};

// gets css property from the core container
styfn.containerCss = function (propName) {
  var cy = this._private.cy;
  var domElement = cy.container();

  if (window && domElement && window.getComputedStyle) {
    return window.getComputedStyle(domElement).getPropertyValue(propName);
  }
};

module.exports = styfn;

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);
var is = __webpack_require__(0);

var styfn = {};

// gets the rendered style for an element
styfn.getRenderedStyle = function (ele, prop) {
  if (prop) {
    return this.getStylePropertyValue(ele, prop, true);
  } else {
    return this.getRawStyle(ele, true);
  }
};

// gets the raw style for an element
styfn.getRawStyle = function (ele, isRenderedVal) {
  var self = this;

  ele = ele[0]; // insure it's an element

  if (ele) {
    var rstyle = {};

    for (var i = 0; i < self.properties.length; i++) {
      var prop = self.properties[i];
      var val = self.getStylePropertyValue(ele, prop.name, isRenderedVal);

      if (val != null) {
        rstyle[prop.name] = val;
        rstyle[util.dash2camel(prop.name)] = val;
      }
    }

    return rstyle;
  }
};

styfn.getIndexedStyle = function (ele, property, subproperty, index) {
  var pstyle = ele.pstyle(property)[subproperty][index];
  return pstyle != null ? pstyle : ele.cy().style().getDefaultProperty(property)[subproperty][0];
};

styfn.getStylePropertyValue = function (ele, propName, isRenderedVal) {
  var self = this;

  ele = ele[0]; // insure it's an element

  if (ele) {
    var prop = self.properties[propName];

    if (prop.alias) {
      prop = prop.pointsTo;
    }

    var type = prop.type;
    var styleProp = ele.pstyle(prop.name);
    var zoom = ele.cy().zoom();

    if (styleProp) {
      var units = styleProp.units ? type.implicitUnits || 'px' : null;
      var val = units ? [].concat(styleProp.pfValue).map(function (pfValue) {
        return pfValue * (isRenderedVal ? zoom : 1) + units;
      }).join(' ') : styleProp.strValue;

      return val;
    }
  }
};

styfn.getAnimationStartStyle = function (ele, aniProps) {
  var rstyle = {};

  for (var i = 0; i < aniProps.length; i++) {
    var aniProp = aniProps[i];
    var name = aniProp.name;

    var styleProp = ele.pstyle(name);

    if (styleProp !== undefined) {
      // then make a prop of it
      if (is.plainObject(styleProp)) {
        styleProp = this.parse(name, styleProp.strValue);
      } else {
        styleProp = this.parse(name, styleProp);
      }
    }

    if (styleProp) {
      rstyle[name] = styleProp;
    }
  }

  return rstyle;
};

styfn.getPropsList = function (propsObj) {
  var self = this;
  var rstyle = [];
  var style = propsObj;
  var props = self.properties;

  if (style) {
    var names = Object.keys(style);

    for (var i = 0; i < names.length; i++) {
      var name = names[i];
      var val = style[name];
      var prop = props[name] || props[util.camel2dash(name)];
      var styleProp = this.parse(prop.name, val);

      if (styleProp) {
        rstyle.push(styleProp);
      }
    }
  }

  return rstyle;
};

module.exports = styfn;

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var styfn = {};

styfn.appendFromJson = function (json) {
  var style = this;

  for (var i = 0; i < json.length; i++) {
    var context = json[i];
    var selector = context.selector;
    var props = context.style || context.css;
    var names = Object.keys(props);

    style.selector(selector); // apply selector

    for (var j = 0; j < names.length; j++) {
      var name = names[j];
      var value = props[name];

      style.css(name, value); // apply property
    }
  }

  return style;
};

// accessible cy.style() function
styfn.fromJson = function (json) {
  var style = this;

  style.resetToDefault();
  style.appendFromJson(json);

  return style;
};

// get json from cy.style() api
styfn.json = function () {
  var json = [];

  for (var i = this.defaultLength; i < this.length; i++) {
    var cxt = this[i];
    var selector = cxt.selector;
    var props = cxt.properties;
    var css = {};

    for (var j = 0; j < props.length; j++) {
      var prop = props[j];
      css[prop.name] = prop.strValue;
    }

    json.push({
      selector: !selector ? 'core' : selector.toString(),
      style: css
    });
  }

  return json;
};

module.exports = styfn;

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);
var Selector = __webpack_require__(6);

var styfn = {};

styfn.appendFromString = function (string) {
  var self = this;
  var style = this;
  var remaining = '' + string;
  var selAndBlockStr = void 0;
  var blockRem = void 0;
  var propAndValStr = void 0;

  // remove comments from the style string
  remaining = remaining.replace(/[/][*](\s|.)+?[*][/]/g, '');

  function removeSelAndBlockFromRemaining() {
    // remove the parsed selector and block from the remaining text to parse
    if (remaining.length > selAndBlockStr.length) {
      remaining = remaining.substr(selAndBlockStr.length);
    } else {
      remaining = '';
    }
  }

  function removePropAndValFromRem() {
    // remove the parsed property and value from the remaining block text to parse
    if (blockRem.length > propAndValStr.length) {
      blockRem = blockRem.substr(propAndValStr.length);
    } else {
      blockRem = '';
    }
  }

  while (true) {
    var nothingLeftToParse = remaining.match(/^\s*$/);
    if (nothingLeftToParse) {
      break;
    }

    var selAndBlock = remaining.match(/^\s*((?:.|\s)+?)\s*\{((?:.|\s)+?)\}/);

    if (!selAndBlock) {
      util.error('Halting stylesheet parsing: String stylesheet contains more to parse but no selector and block found in: ' + remaining);
      break;
    }

    selAndBlockStr = selAndBlock[0];

    // parse the selector
    var selectorStr = selAndBlock[1];
    if (selectorStr !== 'core') {
      var selector = new Selector(selectorStr);
      if (selector._private.invalid) {
        util.error('Skipping parsing of block: Invalid selector found in string stylesheet: ' + selectorStr);

        // skip this selector and block
        removeSelAndBlockFromRemaining();
        continue;
      }
    }

    // parse the block of properties and values
    var blockStr = selAndBlock[2];
    var invalidBlock = false;
    blockRem = blockStr;
    var props = [];

    while (true) {
      var _nothingLeftToParse = blockRem.match(/^\s*$/);
      if (_nothingLeftToParse) {
        break;
      }

      var propAndVal = blockRem.match(/^\s*(.+?)\s*:\s*(.+?)\s*;/);

      if (!propAndVal) {
        util.error('Skipping parsing of block: Invalid formatting of style property and value definitions found in:' + blockStr);
        invalidBlock = true;
        break;
      }

      propAndValStr = propAndVal[0];
      var propStr = propAndVal[1];
      var valStr = propAndVal[2];

      var prop = self.properties[propStr];
      if (!prop) {
        util.error('Skipping property: Invalid property name in: ' + propAndValStr);

        // skip this property in the block
        removePropAndValFromRem();
        continue;
      }

      var parsedProp = style.parse(propStr, valStr);

      if (!parsedProp) {
        util.error('Skipping property: Invalid property definition in: ' + propAndValStr);

        // skip this property in the block
        removePropAndValFromRem();
        continue;
      }

      props.push({
        name: propStr,
        val: valStr
      });
      removePropAndValFromRem();
    }

    if (invalidBlock) {
      removeSelAndBlockFromRemaining();
      break;
    }

    // put the parsed block in the style
    style.selector(selectorStr);
    for (var i = 0; i < props.length; i++) {
      var _prop = props[i];
      style.css(_prop.name, _prop.val);
    }

    removeSelAndBlockFromRemaining();
  }

  return style;
};

styfn.fromString = function (string) {
  var style = this;

  style.resetToDefault();
  style.appendFromString(string);

  return style;
};

module.exports = styfn;

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);
var is = __webpack_require__(0);

var styfn = {};

(function () {
  var number = util.regex.number;
  var rgba = util.regex.rgbaNoBackRefs;
  var hsla = util.regex.hslaNoBackRefs;
  var hex3 = util.regex.hex3;
  var hex6 = util.regex.hex6;
  var data = function data(prefix) {
    return '^' + prefix + '\\s*\\(\\s*([\\w\\.]+)\\s*\\)$';
  };
  var mapData = function mapData(prefix) {
    var mapArg = number + '|\\w+|' + rgba + '|' + hsla + '|' + hex3 + '|' + hex6;
    return '^' + prefix + '\\s*\\(([\\w\\.]+)\\s*\\,\\s*(' + number + ')\\s*\\,\\s*(' + number + ')\\s*,\\s*(' + mapArg + ')\\s*\\,\\s*(' + mapArg + ')\\)$';
  };
  var urlRegexes = ['^url\\s*\\(\\s*[\'"]?(.+?)[\'"]?\\s*\\)$', '^(none)$', '^(.+)$'];

  // each visual style property has a type and needs to be validated according to it
  styfn.types = {
    time: { number: true, min: 0, units: 's|ms', implicitUnits: 'ms' },
    percent: { number: true, min: 0, max: 100, units: '%', implicitUnits: '%' },
    zeroOneNumber: { number: true, min: 0, max: 1, unitless: true },
    zeroOneNumbers: { number: true, min: 0, max: 1, unitless: true, multiple: true },
    nOneOneNumber: { number: true, min: -1, max: 1, unitless: true },
    nonNegativeInt: { number: true, min: 0, integer: true, unitless: true },
    position: { enums: ['parent', 'origin'] },
    nodeSize: { number: true, min: 0, enums: ['label'] },
    number: { number: true, unitless: true },
    numbers: { number: true, unitless: true, multiple: true },
    positiveNumber: { number: true, unitless: true, min: 0, strictMin: true },
    size: { number: true, min: 0 },
    bidirectionalSize: { number: true }, // allows negative
    bidirectionalSizes: { number: true, multiple: true }, // allows negative
    sizeMaybePercent: { number: true, min: 0, allowPercent: true },
    paddingRelativeTo: { enums: ['width', 'height', 'average', 'min', 'max'] },
    bgWH: { number: true, min: 0, allowPercent: true, enums: ['auto'], multiple: true },
    bgPos: { number: true, allowPercent: true, multiple: true },
    bgRelativeTo: { enums: ['inner', 'include-padding'], multiple: true },
    bgRepeat: { enums: ['repeat', 'repeat-x', 'repeat-y', 'no-repeat'], multiple: true },
    bgFit: { enums: ['none', 'contain', 'cover'], multiple: true },
    bgCrossOrigin: { enums: ['anonymous', 'use-credentials'], multiple: true },
    bgClip: { enums: ['none', 'node'] },
    color: { color: true },
    bool: { enums: ['yes', 'no'] },
    lineStyle: { enums: ['solid', 'dotted', 'dashed'] },
    borderStyle: { enums: ['solid', 'dotted', 'dashed', 'double'] },
    curveStyle: { enums: ['bezier', 'unbundled-bezier', 'haystack', 'segments'] },
    fontFamily: { regex: '^([\\w- \\"]+(?:\\s*,\\s*[\\w- \\"]+)*)$' },
    fontletiant: { enums: ['small-caps', 'normal'] },
    fontStyle: { enums: ['italic', 'normal', 'oblique'] },
    fontWeight: { enums: ['normal', 'bold', 'bolder', 'lighter', '100', '200', '300', '400', '500', '600', '800', '900', 100, 200, 300, 400, 500, 600, 700, 800, 900] },
    textDecoration: { enums: ['none', 'underline', 'overline', 'line-through'] },
    textTransform: { enums: ['none', 'uppercase', 'lowercase'] },
    textWrap: { enums: ['none', 'wrap', 'ellipsis'] },
    textBackgroundShape: { enums: ['rectangle', 'roundrectangle'] },
    nodeShape: { enums: ['rectangle', 'roundrectangle', 'cutrectangle', 'bottomroundrectangle', 'barrel', 'ellipse', 'triangle', 'square', 'pentagon', 'hexagon', 'concavehexagon', 'heptagon', 'octagon', 'tag', 'star', 'diamond', 'vee', 'rhomboid', 'polygon'] },
    compoundIncludeLabels: { enums: ['include', 'exclude'] },
    arrowShape: { enums: ['tee', 'triangle', 'triangle-tee', 'triangle-cross', 'triangle-backcurve', 'half-triangle-overshot', 'vee', 'square', 'circle', 'diamond', 'none'] },
    arrowFill: { enums: ['filled', 'hollow'] },
    display: { enums: ['element', 'none'] },
    visibility: { enums: ['hidden', 'visible'] },
    zCompoundDepth: { enums: ['bottom', 'orphan', 'auto', 'top'] },
    zIndexCompare: { enums: ['auto', 'manual'] },
    valign: { enums: ['top', 'center', 'bottom'] },
    halign: { enums: ['left', 'center', 'right'] },
    text: { string: true },
    data: { mapping: true, regex: data('data') },
    layoutData: { mapping: true, regex: data('layoutData') },
    scratch: { mapping: true, regex: data('scratch') },
    mapData: { mapping: true, regex: mapData('mapData') },
    mapLayoutData: { mapping: true, regex: mapData('mapLayoutData') },
    mapScratch: { mapping: true, regex: mapData('mapScratch') },
    fn: { mapping: true, fn: true },
    url: { regexes: urlRegexes, singleRegexMatchValue: true },
    urls: { regexes: urlRegexes, singleRegexMatchValue: true, multiple: true },
    propList: { propList: true },
    angle: { number: true, units: 'deg|rad', implicitUnits: 'rad' },
    textRotation: { number: true, units: 'deg|rad', implicitUnits: 'rad', enums: ['none', 'autorotate'] },
    polygonPointList: { number: true, multiple: true, evenMultiple: true, min: -1, max: 1, unitless: true },
    edgeDistances: { enums: ['intersection', 'node-position'] },
    edgeEndpoint: {
      number: true, multiple: true, units: '%|px|em|deg|rad', implicitUnits: 'px',
      enums: ['inside-to-node', 'outside-to-node', 'outside-to-line'], singleEnum: true,
      validate: function validate(valArr, unitsArr) {
        switch (valArr.length) {
          case 2:
            // can be % or px only
            return unitsArr[0] !== 'deg' && unitsArr[0] !== 'rad' && unitsArr[1] !== 'deg' && unitsArr[1] !== 'rad';
          case 1:
            // can be enum, deg, or rad only
            return is.string(valArr[0]) || unitsArr[0] === 'deg' || unitsArr[0] === 'rad';
          default:
            return false;
        }
      }
    },
    easing: {
      regexes: ['^(spring)\\s*\\(\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*\\)$', '^(cubic-bezier)\\s*\\(\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*\\)$'],
      enums: ['linear', 'ease', 'ease-in', 'ease-out', 'ease-in-out', 'ease-in-sine', 'ease-out-sine', 'ease-in-out-sine', 'ease-in-quad', 'ease-out-quad', 'ease-in-out-quad', 'ease-in-cubic', 'ease-out-cubic', 'ease-in-out-cubic', 'ease-in-quart', 'ease-out-quart', 'ease-in-out-quart', 'ease-in-quint', 'ease-out-quint', 'ease-in-out-quint', 'ease-in-expo', 'ease-out-expo', 'ease-in-out-expo', 'ease-in-circ', 'ease-out-circ', 'ease-in-out-circ']
    }
  };

  var zOrderDiff = {
    zeroNonZero: function zeroNonZero(val1, val2) {
      if (val1 === 0 && val2 !== 0) {
        return true;
      } else if (val1 !== 0 && val2 === 0) {
        return true;
      } else {
        return false;
      }
    },
    anyDiff: function anyDiff(val1, val2) {
      return val1 !== val2;
    }
  };

  var zd = zOrderDiff;

  // define visual style properties
  var t = styfn.types;
  var props = styfn.properties = [
  // main label
  { name: 'label', type: t.text }, { name: 'text-rotation', type: t.textRotation }, { name: 'text-margin-x', type: t.bidirectionalSize }, { name: 'text-margin-y', type: t.bidirectionalSize },

  // source label
  { name: 'source-label', type: t.text }, { name: 'source-text-rotation', type: t.textRotation }, { name: 'source-text-margin-x', type: t.bidirectionalSize }, { name: 'source-text-margin-y', type: t.bidirectionalSize }, { name: 'source-text-offset', type: t.size },

  // target label
  { name: 'target-label', type: t.text }, { name: 'target-text-rotation', type: t.textRotation }, { name: 'target-text-margin-x', type: t.bidirectionalSize }, { name: 'target-text-margin-y', type: t.bidirectionalSize }, { name: 'target-text-offset', type: t.size },

  // common label style
  { name: 'text-valign', type: t.valign }, { name: 'text-halign', type: t.halign }, { name: 'color', type: t.color }, { name: 'text-outline-color', type: t.color }, { name: 'text-outline-width', type: t.size }, { name: 'text-outline-opacity', type: t.zeroOneNumber }, { name: 'text-opacity', type: t.zeroOneNumber }, { name: 'text-background-color', type: t.color }, { name: 'text-background-opacity', type: t.zeroOneNumber }, { name: 'text-background-padding', type: t.size }, { name: 'text-border-opacity', type: t.zeroOneNumber }, { name: 'text-border-color', type: t.color }, { name: 'text-border-width', type: t.size }, { name: 'text-border-style', type: t.borderStyle }, { name: 'text-background-shape', type: t.textBackgroundShape },
  // { name: 'text-decoration', type: t.textDecoration }, // not supported in canvas
  { name: 'text-transform', type: t.textTransform }, { name: 'text-wrap', type: t.textWrap }, { name: 'text-max-width', type: t.size }, { name: 'text-events', type: t.bool }, { name: 'font-family', type: t.fontFamily }, { name: 'font-style', type: t.fontStyle },
  // { name: 'font-letiant', type: t.fontletiant }, // not useful
  { name: 'font-weight', type: t.fontWeight }, { name: 'font-size', type: t.size }, { name: 'min-zoomed-font-size', type: t.size },

  // behaviour
  { name: 'events', type: t.bool },

  // visibility
  { name: 'display', type: t.display, triggersZOrder: zd.anyDiff }, { name: 'visibility', type: t.visibility, triggersZOrder: zd.anyDiff }, { name: 'opacity', type: t.zeroOneNumber, triggersZOrder: zd.zeroNonZero }, { name: 'z-compound-depth', type: t.zCompoundDepth, triggersZOrder: zd.anyDiff }, { name: 'z-index-compare', type: t.zIndexCompare, triggersZOrder: zd.anyDiff }, { name: 'z-index', type: t.nonNegativeInt, triggersZOrder: zd.anyDiff },

  // overlays
  { name: 'overlay-padding', type: t.size }, { name: 'overlay-color', type: t.color }, { name: 'overlay-opacity', type: t.zeroOneNumber },

  // transition anis
  { name: 'transition-property', type: t.propList }, { name: 'transition-duration', type: t.time }, { name: 'transition-delay', type: t.time }, { name: 'transition-timing-function', type: t.easing },

  // node body
  { name: 'height', type: t.nodeSize }, { name: 'width', type: t.nodeSize }, { name: 'shape', type: t.nodeShape }, { name: 'shape-polygon-points', type: t.polygonPointList }, { name: 'background-color', type: t.color }, { name: 'background-opacity', type: t.zeroOneNumber }, { name: 'background-blacken', type: t.nOneOneNumber }, { name: 'padding', type: t.sizeMaybePercent }, { name: 'padding-relative-to', type: t.paddingRelativeTo },

  // node border
  { name: 'border-color', type: t.color }, { name: 'border-opacity', type: t.zeroOneNumber }, { name: 'border-width', type: t.size }, { name: 'border-style', type: t.borderStyle },

  // node background images
  { name: 'background-image', type: t.urls }, { name: 'background-image-crossorigin', type: t.bgCrossOrigin }, { name: 'background-image-opacity', type: t.zeroOneNumbers }, { name: 'background-position-x', type: t.bgPos }, { name: 'background-position-y', type: t.bgPos }, { name: 'background-width-relative-to', type: t.bgRelativeTo }, { name: 'background-height-relative-to', type: t.bgRelativeTo }, { name: 'background-repeat', type: t.bgRepeat }, { name: 'background-fit', type: t.bgFit }, { name: 'background-clip', type: t.bgClip }, { name: 'background-width', type: t.bgWH }, { name: 'background-height', type: t.bgWH },

  // compound props
  { name: 'position', type: t.position }, { name: 'compound-sizing-wrt-labels', type: t.compoundIncludeLabels }, { name: 'min-width', type: t.size }, { name: 'min-width-bias-left', type: t.sizeMaybePercent }, { name: 'min-width-bias-right', type: t.sizeMaybePercent }, { name: 'min-height', type: t.size }, { name: 'min-height-bias-top', type: t.sizeMaybePercent }, { name: 'min-height-bias-bottom', type: t.sizeMaybePercent },

  // edge line
  { name: 'line-style', type: t.lineStyle }, { name: 'line-color', type: t.color }, { name: 'curve-style', type: t.curveStyle }, { name: 'haystack-radius', type: t.zeroOneNumber }, { name: 'source-endpoint', type: t.edgeEndpoint }, { name: 'target-endpoint', type: t.edgeEndpoint }, { name: 'control-point-step-size', type: t.size }, { name: 'control-point-distances', type: t.bidirectionalSizes }, { name: 'control-point-weights', type: t.numbers }, { name: 'segment-distances', type: t.bidirectionalSizes }, { name: 'segment-weights', type: t.numbers }, { name: 'edge-distances', type: t.edgeDistances }, { name: 'arrow-scale', type: t.positiveNumber }, { name: 'loop-direction', type: t.angle }, { name: 'loop-sweep', type: t.angle }, { name: 'source-distance-from-node', type: t.size }, { name: 'target-distance-from-node', type: t.size },

  // ghost properties
  { name: 'ghost', type: t.bool }, { name: 'ghost-offset-x', type: t.bidirectionalSize }, { name: 'ghost-offset-y', type: t.bidirectionalSize }, { name: 'ghost-opacity', type: t.zeroOneNumber },

  // these are just for the core
  { name: 'selection-box-color', type: t.color }, { name: 'selection-box-opacity', type: t.zeroOneNumber }, { name: 'selection-box-border-color', type: t.color }, { name: 'selection-box-border-width', type: t.size }, { name: 'active-bg-color', type: t.color }, { name: 'active-bg-opacity', type: t.zeroOneNumber }, { name: 'active-bg-size', type: t.size }, { name: 'outside-texture-bg-color', type: t.color }, { name: 'outside-texture-bg-opacity', type: t.zeroOneNumber }];

  // define aliases
  var aliases = styfn.aliases = [{ name: 'content', pointsTo: 'label' }, { name: 'control-point-distance', pointsTo: 'control-point-distances' }, { name: 'control-point-weight', pointsTo: 'control-point-weights' }, { name: 'edge-text-rotation', pointsTo: 'text-rotation' }, { name: 'padding-left', pointsTo: 'padding' }, { name: 'padding-right', pointsTo: 'padding' }, { name: 'padding-top', pointsTo: 'padding' }, { name: 'padding-bottom', pointsTo: 'padding' }];

  // pie backgrounds for nodes
  styfn.pieBackgroundN = 16; // because the pie properties are numbered, give access to a constant N (for renderer use)
  props.push({ name: 'pie-size', type: t.sizeMaybePercent });
  for (var i = 1; i <= styfn.pieBackgroundN; i++) {
    props.push({ name: 'pie-' + i + '-background-color', type: t.color });
    props.push({ name: 'pie-' + i + '-background-size', type: t.percent });
    props.push({ name: 'pie-' + i + '-background-opacity', type: t.zeroOneNumber });
  }

  // edge arrows
  var arrowPrefixes = styfn.arrowPrefixes = ['source', 'mid-source', 'target', 'mid-target'];
  [{ name: 'arrow-shape', type: t.arrowShape }, { name: 'arrow-color', type: t.color }, { name: 'arrow-fill', type: t.arrowFill }].forEach(function (prop) {
    arrowPrefixes.forEach(function (prefix) {
      var name = prefix + '-' + prop.name;
      var type = prop.type;

      props.push({ name: name, type: type });
    });
  }, {});

  // list of property names
  styfn.propertyNames = props.map(function (p) {
    return p.name;
  });

  // allow access of properties by name ( e.g. style.properties.height )
  for (var _i = 0; _i < props.length; _i++) {
    var prop = props[_i];

    props[prop.name] = prop; // allow lookup by name
  }

  // map aliases
  for (var _i2 = 0; _i2 < aliases.length; _i2++) {
    var alias = aliases[_i2];
    var pointsToProp = props[alias.pointsTo];
    var aliasProp = {
      name: alias.name,
      alias: true,
      pointsTo: pointsToProp
    };

    // add alias prop for parsing
    props.push(aliasProp);

    props[alias.name] = aliasProp; // allow lookup by name
  }
})();

styfn.getDefaultProperty = function (name) {
  return this.getDefaultProperties()[name];
};

styfn.getDefaultProperties = util.memoize(function () {
  var rawProps = util.extend({
    // common node/edge props
    'events': 'yes',
    'text-events': 'no',
    'text-valign': 'top',
    'text-halign': 'center',
    'color': '#000',
    'text-outline-color': '#000',
    'text-outline-width': 0,
    'text-outline-opacity': 1,
    'text-opacity': 1,
    'text-decoration': 'none',
    'text-transform': 'none',
    'text-wrap': 'none',
    'text-max-width': 9999,
    'text-background-color': '#000',
    'text-background-opacity': 0,
    'text-background-shape': 'rectangle',
    'text-background-padding': 0,
    'text-border-opacity': 0,
    'text-border-width': 0,
    'text-border-style': 'solid',
    'text-border-color': '#000',
    'font-family': 'Helvetica Neue, Helvetica, sans-serif',
    'font-style': 'normal',
    // 'font-letiant': fontletiant,
    'font-weight': 'normal',
    'font-size': 16,
    'min-zoomed-font-size': 0,
    'text-rotation': 'none',
    'source-text-rotation': 'none',
    'target-text-rotation': 'none',
    'visibility': 'visible',
    'display': 'element',
    'opacity': 1,
    'z-compound-depth': 'auto',
    'z-index-compare': 'auto',
    'z-index': 0,
    'label': '',
    'text-margin-x': 0,
    'text-margin-y': 0,
    'source-label': '',
    'source-text-offset': 0,
    'source-text-margin-x': 0,
    'source-text-margin-y': 0,
    'target-label': '',
    'target-text-offset': 0,
    'target-text-margin-x': 0,
    'target-text-margin-y': 0,
    'overlay-opacity': 0,
    'overlay-color': '#000',
    'overlay-padding': 10,
    'transition-property': 'none',
    'transition-duration': 0,
    'transition-delay': 0,
    'transition-timing-function': 'linear',

    // node props
    'background-blacken': 0,
    'background-color': '#999',
    'background-opacity': 1,
    'background-image': 'none',
    'background-image-crossorigin': 'anonymous',
    'background-image-opacity': 1,
    'background-position-x': '50%',
    'background-position-y': '50%',
    'background-width-relative-to': 'include-padding',
    'background-height-relative-to': 'include-padding',
    'background-repeat': 'no-repeat',
    'background-fit': 'none',
    'background-clip': 'node',
    'background-width': 'auto',
    'background-height': 'auto',
    'border-color': '#000',
    'border-opacity': 1,
    'border-width': 0,
    'border-style': 'solid',
    'height': 30,
    'width': 30,
    'shape': 'ellipse',
    'shape-polygon-points': '-1, -1,   1, -1,   1, 1,   -1, 1',

    // ghost props
    'ghost': 'no',
    'ghost-offset-y': 0,
    'ghost-offset-x': 0,
    'ghost-opacity': 0,

    // compound props
    'padding': 0,
    'padding-relative-to': 'width',
    'position': 'origin',
    'compound-sizing-wrt-labels': 'include',
    'min-width': 0,
    'min-width-bias-left': 0,
    'min-width-bias-right': 0,
    'min-height': 0,
    'min-height-bias-top': 0,
    'min-height-bias-bottom': 0
  }, {
    // node pie bg
    'pie-size': '100%'
  }, [{ name: 'pie-{{i}}-background-color', value: 'black' }, { name: 'pie-{{i}}-background-size', value: '0%' }, { name: 'pie-{{i}}-background-opacity', value: 1 }].reduce(function (css, prop) {
    for (var i = 1; i <= styfn.pieBackgroundN; i++) {
      var name = prop.name.replace('{{i}}', i);
      var val = prop.value;

      css[name] = val;
    }

    return css;
  }, {}), {
    // edge props
    'line-style': 'solid',
    'line-color': '#999',
    'control-point-step-size': 40,
    'control-point-weights': 0.5,
    'segment-weights': 0.5,
    'segment-distances': 20,
    'edge-distances': 'intersection',
    'curve-style': 'bezier',
    'haystack-radius': 0,
    'arrow-scale': 1,
    'loop-direction': '-45deg',
    'loop-sweep': '-90deg',
    'source-distance-from-node': 0,
    'target-distance-from-node': 0,
    'source-endpoint': 'outside-to-node',
    'target-endpoint': 'outside-to-node'
  }, [{ name: 'arrow-shape', value: 'none' }, { name: 'arrow-color', value: '#999' }, { name: 'arrow-fill', value: 'filled' }].reduce(function (css, prop) {
    styfn.arrowPrefixes.forEach(function (prefix) {
      var name = prefix + '-' + prop.name;
      var val = prop.value;

      css[name] = val;
    });

    return css;
  }, {}));

  var parsedProps = {};

  for (var i = 0; i < this.properties.length; i++) {
    var prop = this.properties[i];

    if (prop.pointsTo) {
      continue;
    }

    var name = prop.name;
    var val = rawProps[name];
    var parsedProp = this.parse(name, val);

    parsedProps[name] = parsedProp;
  }

  return parsedProps;
});

styfn.addDefaultStylesheet = function () {
  this.selector('$node > node') // compound (parent) node properties
  .css({
    'shape': 'rectangle',
    'padding': 10,
    'background-color': '#eee',
    'border-color': '#ccc',
    'border-width': 1
  }).selector('edge') // just edge properties
  .css({
    'width': 3,
    'curve-style': 'haystack'
  }).selector(':parent <-> node').css({
    'curve-style': 'bezier',
    'source-endpoint': 'outside-to-line',
    'target-endpoint': 'outside-to-line'
  }).selector(':selected').css({
    'background-color': '#0169D9',
    'line-color': '#0169D9',
    'source-arrow-color': '#0169D9',
    'target-arrow-color': '#0169D9',
    'mid-source-arrow-color': '#0169D9',
    'mid-target-arrow-color': '#0169D9'
  }).selector('node:parent:selected').css({
    'background-color': '#CCE1F9',
    'border-color': '#aec8e5'
  }).selector(':active').css({
    'overlay-color': 'black',
    'overlay-padding': 10,
    'overlay-opacity': 0.25
  }).selector('core') // just core properties
  .css({
    'selection-box-color': '#ddd',
    'selection-box-opacity': 0.65,
    'selection-box-border-color': '#aaa',
    'selection-box-border-width': 1,
    'active-bg-color': 'black',
    'active-bg-opacity': 0.15,
    'active-bg-size': 30,
    'outside-texture-bg-color': '#000',
    'outside-texture-bg-opacity': 0.125
  });

  this.defaultLength = this.length;
};

module.exports = styfn;

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);
var is = __webpack_require__(0);
var math = __webpack_require__(2);

var styfn = {};

// a caching layer for property parsing
styfn.parse = function (name, value, propIsBypass, propIsFlat) {
  var self = this;

  // function values can't be cached in all cases, and there isn't much benefit of caching them anyway
  if (is.fn(value)) {
    return self.parseImplWarn(name, value, propIsBypass, propIsFlat);
  }

  var flatKey = propIsFlat === 'mapping' || propIsFlat === true || propIsFlat === false || propIsFlat == null ? 'dontcare' : propIsFlat;
  var argHash = [name, value, propIsBypass, flatKey].join('$');
  var propCache = self.propCache = self.propCache || {};
  var ret = void 0;

  if (!(ret = propCache[argHash])) {
    ret = propCache[argHash] = self.parseImplWarn(name, value, propIsBypass, propIsFlat);
  }

  // - bypasses can't be shared b/c the value can be changed by animations or otherwise overridden
  // - mappings can't be shared b/c mappings are per-element
  if (propIsBypass || propIsFlat === 'mapping') {
    // need a copy since props are mutated later in their lifecycles
    ret = util.copy(ret);

    if (ret) {
      ret.value = util.copy(ret.value); // because it could be an array, e.g. colour
    }
  }

  return ret;
};

styfn.parseImplWarn = function (name, value, propIsBypass, propIsFlat) {
  var prop = this.parseImpl(name, value, propIsBypass, propIsFlat);

  if (!prop && value != null) {
    util.error('The style property `%s: %s` is invalid', name, value);
  }

  return prop;
};

// parse a property; return null on invalid; return parsed property otherwise
// fields :
// - name : the name of the property
// - value : the parsed, native-typed value of the property
// - strValue : a string value that represents the property value in valid css
// - bypass : true iff the property is a bypass property
styfn.parseImpl = function (name, value, propIsBypass, propIsFlat) {
  var self = this;

  name = util.camel2dash(name); // make sure the property name is in dash form (e.g. 'property-name' not 'propertyName')

  var property = self.properties[name];
  var passedValue = value;
  var types = self.types;

  if (!property) {
    return null;
  } // return null on property of unknown name
  if (value === undefined) {
    return null;
  } // can't assign undefined

  // the property may be an alias
  if (property.alias) {
    property = property.pointsTo;
    name = property.name;
  }

  var valueIsString = is.string(value);
  if (valueIsString) {
    // trim the value to make parsing easier
    value = value.trim();
  }

  var type = property.type;
  if (!type) {
    return null;
  } // no type, no luck

  // check if bypass is null or empty string (i.e. indication to delete bypass property)
  if (propIsBypass && (value === '' || value === null)) {
    return {
      name: name,
      value: value,
      bypass: true,
      deleteBypass: true
    };
  }

  // check if value is a function used as a mapper
  if (is.fn(value)) {
    return {
      name: name,
      value: value,
      strValue: 'fn',
      mapped: types.fn,
      bypass: propIsBypass
    };
  }

  // check if value is mapped
  var data = void 0,
      mapData = void 0;
  if (!valueIsString || propIsFlat) {
    // then don't bother to do the expensive regex checks

  } else if (data = new RegExp(types.data.regex).exec(value)) {
    if (propIsBypass) {
      return false;
    } // mappers not allowed in bypass

    var mapped = types.data;

    return {
      name: name,
      value: data,
      strValue: '' + value,
      mapped: mapped,
      field: data[1],
      bypass: propIsBypass
    };
  } else if (mapData = new RegExp(types.mapData.regex).exec(value)) {
    if (propIsBypass) {
      return false;
    } // mappers not allowed in bypass
    if (type.multiple) {
      return false;
    } // impossible to map to num

    var _mapped = types.mapData;

    // we can map only if the type is a colour or a number
    if (!(type.color || type.number)) {
      return false;
    }

    var valueMin = this.parse(name, mapData[4]); // parse to validate
    if (!valueMin || valueMin.mapped) {
      return false;
    } // can't be invalid or mapped

    var valueMax = this.parse(name, mapData[5]); // parse to validate
    if (!valueMax || valueMax.mapped) {
      return false;
    } // can't be invalid or mapped

    // check if valueMin and valueMax are the same
    if (valueMin.value === valueMax.value) {
      return false; // can't make much of a mapper without a range
    } else if (type.color) {
      var c1 = valueMin.value;
      var c2 = valueMax.value;

      var same = c1[0] === c2[0] // red
      && c1[1] === c2[1] // green
      && c1[2] === c2[2] // blue
      && ( // optional alpha
      c1[3] === c2[3] // same alpha outright
      || (c1[3] == null || c1[3] === 1) && ( // full opacity for colour 1?
      c2[3] == null || c2[3] === 1) // full opacity for colour 2?
      );

      if (same) {
        return false;
      } // can't make a mapper without a range
    }

    return {
      name: name,
      value: mapData,
      strValue: '' + value,
      mapped: _mapped,
      field: mapData[1],
      fieldMin: parseFloat(mapData[2]), // min & max are numeric
      fieldMax: parseFloat(mapData[3]),
      valueMin: valueMin.value,
      valueMax: valueMax.value,
      bypass: propIsBypass
    };
  }

  if (type.multiple && propIsFlat !== 'multiple') {
    var vals = void 0;

    if (valueIsString) {
      vals = value.split(/\s+/);
    } else if (is.array(value)) {
      vals = value;
    } else {
      vals = [value];
    }

    if (type.evenMultiple && vals.length % 2 !== 0) {
      return null;
    }

    var valArr = [];
    var unitsArr = [];
    var pfValArr = [];
    var hasEnum = false;

    for (var i = 0; i < vals.length; i++) {
      var p = self.parse(name, vals[i], propIsBypass, 'multiple');

      hasEnum = hasEnum || is.string(p.value);

      valArr.push(p.value);
      pfValArr.push(p.pfValue != null ? p.pfValue : p.value);
      unitsArr.push(p.units);
    }

    if (type.validate && !type.validate(valArr, unitsArr)) {
      return null;
    }

    if (type.singleEnum && hasEnum) {
      if (valArr.length === 1 && is.string(valArr[0])) {
        return {
          name: name,
          value: valArr[0],
          strValue: valArr[0],
          bypass: propIsBypass
        };
      } else {
        return null;
      }
    }

    return {
      name: name,
      value: valArr,
      pfValue: pfValArr,
      strValue: valArr.map(function (val, i) {
        return val + (unitsArr[i] || '');
      }).join(' '),
      bypass: propIsBypass,
      units: unitsArr
    };
  }

  // several types also allow enums
  var checkEnums = function checkEnums() {
    for (var _i = 0; _i < type.enums.length; _i++) {
      var en = type.enums[_i];

      if (en === value) {
        return {
          name: name,
          value: value,
          strValue: '' + value,
          bypass: propIsBypass
        };
      }
    }

    return null;
  };

  // check the type and return the appropriate object
  if (type.number) {
    var units = void 0;
    var implicitUnits = 'px'; // not set => px

    if (type.units) {
      // use specified units if set
      units = type.units;
    }

    if (type.implicitUnits) {
      implicitUnits = type.implicitUnits;
    }

    if (!type.unitless) {
      if (valueIsString) {
        var unitsRegex = 'px|em' + (type.allowPercent ? '|\\%' : '');
        if (units) {
          unitsRegex = units;
        } // only allow explicit units if so set
        var match = value.match('^(' + util.regex.number + ')(' + unitsRegex + ')?' + '$');

        if (match) {
          value = match[1];
          units = match[2] || implicitUnits;
        }
      } else if (!units || type.implicitUnits) {
        units = implicitUnits; // implicitly px if unspecified
      }
    }

    value = parseFloat(value);

    // if not a number and enums not allowed, then the value is invalid
    if (isNaN(value) && type.enums === undefined) {
      return null;
    }

    // check if this number type also accepts special keywords in place of numbers
    // (i.e. `left`, `auto`, etc)
    if (isNaN(value) && type.enums !== undefined) {
      value = passedValue;

      return checkEnums();
    }

    // check if value must be an integer
    if (type.integer && !is.integer(value)) {
      return null;
    }

    // check value is within range
    if (type.min !== undefined && (value < type.min || type.strictMin && value === type.min) || type.max !== undefined && (value > type.max || type.strictMax && value === type.max)) {
      return null;
    }

    var ret = {
      name: name,
      value: value,
      strValue: '' + value + (units ? units : ''),
      units: units,
      bypass: propIsBypass
    };

    // normalise value in pixels
    if (type.unitless || units !== 'px' && units !== 'em') {
      ret.pfValue = value;
    } else {
      ret.pfValue = units === 'px' || !units ? value : this.getEmSizeInPixels() * value;
    }

    // normalise value in ms
    if (units === 'ms' || units === 's') {
      ret.pfValue = units === 'ms' ? value : 1000 * value;
    }

    // normalise value in rad
    if (units === 'deg' || units === 'rad') {
      ret.pfValue = units === 'rad' ? value : math.deg2rad(value);
    }

    // normalize value in %
    if (units === '%') {
      ret.pfValue = value / 100;
    }

    return ret;
  } else if (type.propList) {

    var props = [];
    var propsStr = '' + value;

    if (propsStr === 'none') {
      // leave empty

    } else {
      // go over each prop

      var propsSplit = propsStr.split(',');
      for (var _i2 = 0; _i2 < propsSplit.length; _i2++) {
        var propName = propsSplit[_i2].trim();

        if (self.properties[propName]) {
          props.push(propName);
        }
      }

      if (props.length === 0) {
        return null;
      }
    }

    return {
      name: name,
      value: props,
      strValue: props.length === 0 ? 'none' : props.join(', '),
      bypass: propIsBypass
    };
  } else if (type.color) {
    var tuple = util.color2tuple(value);

    if (!tuple) {
      return null;
    }

    return {
      name: name,
      value: tuple,
      pfValue: tuple,
      strValue: '' + value,
      bypass: propIsBypass
    };
  } else if (type.regex || type.regexes) {

    // first check enums
    if (type.enums) {
      var enumProp = checkEnums();

      if (enumProp) {
        return enumProp;
      }
    }

    var regexes = type.regexes ? type.regexes : [type.regex];

    for (var _i3 = 0; _i3 < regexes.length; _i3++) {
      var regex = new RegExp(regexes[_i3]); // make a regex from the type string
      var m = regex.exec(value);

      if (m) {
        // regex matches
        return {
          name: name,
          value: type.singleRegexMatchValue ? m[1] : m,
          strValue: '' + value,
          bypass: propIsBypass
        };
      }
    }

    return null; // didn't match any
  } else if (type.string) {
    // just return
    return {
      name: name,
      value: '' + value,
      strValue: '' + value,
      bypass: propIsBypass
    };
  } else if (type.enums) {
    // check enums last because it's a combo type in others
    return checkEnums();
  } else {
    return null; // not a type we can handle
  }
};

module.exports = styfn;

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);
var window = __webpack_require__(3);
var math = __webpack_require__(2);

var corefn = {

  autolock: function autolock(bool) {
    if (bool !== undefined) {
      this._private.autolock = bool ? true : false;
    } else {
      return this._private.autolock;
    }

    return this; // chaining
  },

  autoungrabify: function autoungrabify(bool) {
    if (bool !== undefined) {
      this._private.autoungrabify = bool ? true : false;
    } else {
      return this._private.autoungrabify;
    }

    return this; // chaining
  },

  autounselectify: function autounselectify(bool) {
    if (bool !== undefined) {
      this._private.autounselectify = bool ? true : false;
    } else {
      return this._private.autounselectify;
    }

    return this; // chaining
  },

  panningEnabled: function panningEnabled(bool) {
    if (bool !== undefined) {
      this._private.panningEnabled = bool ? true : false;
    } else {
      return this._private.panningEnabled;
    }

    return this; // chaining
  },

  userPanningEnabled: function userPanningEnabled(bool) {
    if (bool !== undefined) {
      this._private.userPanningEnabled = bool ? true : false;
    } else {
      return this._private.userPanningEnabled;
    }

    return this; // chaining
  },

  zoomingEnabled: function zoomingEnabled(bool) {
    if (bool !== undefined) {
      this._private.zoomingEnabled = bool ? true : false;
    } else {
      return this._private.zoomingEnabled;
    }

    return this; // chaining
  },

  userZoomingEnabled: function userZoomingEnabled(bool) {
    if (bool !== undefined) {
      this._private.userZoomingEnabled = bool ? true : false;
    } else {
      return this._private.userZoomingEnabled;
    }

    return this; // chaining
  },

  boxSelectionEnabled: function boxSelectionEnabled(bool) {
    if (bool !== undefined) {
      this._private.boxSelectionEnabled = bool ? true : false;
    } else {
      return this._private.boxSelectionEnabled;
    }

    return this; // chaining
  },

  pan: function pan() {
    var args = arguments;
    var pan = this._private.pan;
    var dim = void 0,
        val = void 0,
        dims = void 0,
        x = void 0,
        y = void 0;

    switch (args.length) {
      case 0:
        // .pan()
        return pan;

      case 1:

        if (is.string(args[0])) {
          // .pan('x')
          dim = args[0];
          return pan[dim];
        } else if (is.plainObject(args[0])) {
          // .pan({ x: 0, y: 100 })
          if (!this._private.panningEnabled) {
            return this;
          }

          dims = args[0];
          x = dims.x;
          y = dims.y;

          if (is.number(x)) {
            pan.x = x;
          }

          if (is.number(y)) {
            pan.y = y;
          }

          this.emit('pan viewport');
        }
        break;

      case 2:
        // .pan('x', 100)
        if (!this._private.panningEnabled) {
          return this;
        }

        dim = args[0];
        val = args[1];

        if ((dim === 'x' || dim === 'y') && is.number(val)) {
          pan[dim] = val;
        }

        this.emit('pan viewport');
        break;

      default:
        break; // invalid
    }

    this.notify({ // notify the renderer that the viewport changed
      type: 'viewport'
    });

    return this; // chaining
  },

  panBy: function panBy(arg0, arg1) {
    var args = arguments;
    var pan = this._private.pan;
    var dim = void 0,
        val = void 0,
        dims = void 0,
        x = void 0,
        y = void 0;

    if (!this._private.panningEnabled) {
      return this;
    }

    switch (args.length) {
      case 1:

        if (is.plainObject(arg0)) {
          // .panBy({ x: 0, y: 100 })
          dims = args[0];
          x = dims.x;
          y = dims.y;

          if (is.number(x)) {
            pan.x += x;
          }

          if (is.number(y)) {
            pan.y += y;
          }

          this.emit('pan viewport');
        }
        break;

      case 2:
        // .panBy('x', 100)
        dim = arg0;
        val = arg1;

        if ((dim === 'x' || dim === 'y') && is.number(val)) {
          pan[dim] += val;
        }

        this.emit('pan viewport');
        break;

      default:
        break; // invalid
    }

    this.notify({ // notify the renderer that the viewport changed
      type: 'viewport'
    });

    return this; // chaining
  },

  fit: function fit(elements, padding) {
    var viewportState = this.getFitViewport(elements, padding);

    if (viewportState) {
      var _p = this._private;
      _p.zoom = viewportState.zoom;
      _p.pan = viewportState.pan;

      this.emit('pan zoom viewport');

      this.notify({ // notify the renderer that the viewport changed
        type: 'viewport'
      });
    }

    return this; // chaining
  },

  getFitViewport: function getFitViewport(elements, padding) {
    if (is.number(elements) && padding === undefined) {
      // elements is optional
      padding = elements;
      elements = undefined;
    }

    if (!this._private.panningEnabled || !this._private.zoomingEnabled) {
      return;
    }

    var bb = void 0;

    if (is.string(elements)) {
      var sel = elements;
      elements = this.$(sel);
    } else if (is.boundingBox(elements)) {
      // assume bb
      var bbe = elements;
      bb = {
        x1: bbe.x1,
        y1: bbe.y1,
        x2: bbe.x2,
        y2: bbe.y2
      };

      bb.w = bb.x2 - bb.x1;
      bb.h = bb.y2 - bb.y1;
    } else if (!is.elementOrCollection(elements)) {
      elements = this.mutableElements();
    }

    if (is.elementOrCollection(elements) && elements.empty()) {
      return;
    } // can't fit to nothing

    bb = bb || elements.boundingBox();

    var w = this.width();
    var h = this.height();
    var zoom = void 0;
    padding = is.number(padding) ? padding : 0;

    if (!isNaN(w) && !isNaN(h) && w > 0 && h > 0 && !isNaN(bb.w) && !isNaN(bb.h) && bb.w > 0 && bb.h > 0) {
      zoom = Math.min((w - 2 * padding) / bb.w, (h - 2 * padding) / bb.h);

      // crop zoom
      zoom = zoom > this._private.maxZoom ? this._private.maxZoom : zoom;
      zoom = zoom < this._private.minZoom ? this._private.minZoom : zoom;

      var pan = { // now pan to middle
        x: (w - zoom * (bb.x1 + bb.x2)) / 2,
        y: (h - zoom * (bb.y1 + bb.y2)) / 2
      };

      return {
        zoom: zoom,
        pan: pan
      };
    }

    return;
  },

  minZoom: function minZoom(zoom) {
    if (zoom === undefined) {
      return this._private.minZoom;
    } else if (is.number(zoom)) {
      this._private.minZoom = zoom;
    }

    return this;
  },

  maxZoom: function maxZoom(zoom) {
    if (zoom === undefined) {
      return this._private.maxZoom;
    } else if (is.number(zoom)) {
      this._private.maxZoom = zoom;
    }

    return this;
  },

  getZoomedViewport: function getZoomedViewport(params) {
    var _p = this._private;
    var currentPan = _p.pan;
    var currentZoom = _p.zoom;
    var pos = void 0; // in rendered px
    var zoom = void 0;
    var bail = false;

    if (!_p.zoomingEnabled) {
      // zooming disabled
      bail = true;
    }

    if (is.number(params)) {
      // then set the zoom
      zoom = params;
    } else if (is.plainObject(params)) {
      // then zoom about a point
      zoom = params.level;

      if (params.position != null) {
        pos = math.modelToRenderedPosition(params.position, currentZoom, currentPan);
      } else if (params.renderedPosition != null) {
        pos = params.renderedPosition;
      }

      if (pos != null && !_p.panningEnabled) {
        // panning disabled
        bail = true;
      }
    }

    // crop zoom
    zoom = zoom > _p.maxZoom ? _p.maxZoom : zoom;
    zoom = zoom < _p.minZoom ? _p.minZoom : zoom;

    // can't zoom with invalid params
    if (bail || !is.number(zoom) || zoom === currentZoom || pos != null && (!is.number(pos.x) || !is.number(pos.y))) {
      return null;
    }

    if (pos != null) {
      // set zoom about position
      var pan1 = currentPan;
      var zoom1 = currentZoom;
      var zoom2 = zoom;

      var pan2 = {
        x: -zoom2 / zoom1 * (pos.x - pan1.x) + pos.x,
        y: -zoom2 / zoom1 * (pos.y - pan1.y) + pos.y
      };

      return {
        zoomed: true,
        panned: true,
        zoom: zoom2,
        pan: pan2
      };
    } else {
      // just set the zoom
      return {
        zoomed: true,
        panned: false,
        zoom: zoom,
        pan: currentPan
      };
    }
  },

  zoom: function zoom(params) {
    if (params === undefined) {
      // get
      return this._private.zoom;
    } else {
      // set
      var vp = this.getZoomedViewport(params);
      var _p = this._private;

      if (vp == null || !vp.zoomed) {
        return this;
      }

      _p.zoom = vp.zoom;

      if (vp.panned) {
        _p.pan.x = vp.pan.x;
        _p.pan.y = vp.pan.y;
      }

      this.emit('zoom' + (vp.panned ? ' pan' : '') + ' viewport');

      this.notify({ // notify the renderer that the viewport changed
        type: 'viewport'
      });

      return this; // chaining
    }
  },

  viewport: function viewport(opts) {
    var _p = this._private;
    var zoomDefd = true;
    var panDefd = true;
    var events = []; // to trigger
    var zoomFailed = false;
    var panFailed = false;

    if (!opts) {
      return this;
    }
    if (!is.number(opts.zoom)) {
      zoomDefd = false;
    }
    if (!is.plainObject(opts.pan)) {
      panDefd = false;
    }
    if (!zoomDefd && !panDefd) {
      return this;
    }

    if (zoomDefd) {
      var z = opts.zoom;

      if (z < _p.minZoom || z > _p.maxZoom || !_p.zoomingEnabled) {
        zoomFailed = true;
      } else {
        _p.zoom = z;

        events.push('zoom');
      }
    }

    if (panDefd && (!zoomFailed || !opts.cancelOnFailedZoom) && _p.panningEnabled) {
      var p = opts.pan;

      if (is.number(p.x)) {
        _p.pan.x = p.x;
        panFailed = false;
      }

      if (is.number(p.y)) {
        _p.pan.y = p.y;
        panFailed = false;
      }

      if (!panFailed) {
        events.push('pan');
      }
    }

    if (events.length > 0) {
      events.push('viewport');
      this.emit(events.join(' '));

      this.notify({
        type: 'viewport'
      });
    }

    return this; // chaining
  },

  center: function center(elements) {
    var pan = this.getCenterPan(elements);

    if (pan) {
      this._private.pan = pan;

      this.emit('pan viewport');

      this.notify({ // notify the renderer that the viewport changed
        type: 'viewport'
      });
    }

    return this; // chaining
  },

  getCenterPan: function getCenterPan(elements, zoom) {
    if (!this._private.panningEnabled) {
      return;
    }

    if (is.string(elements)) {
      var selector = elements;
      elements = this.mutableElements().filter(selector);
    } else if (!is.elementOrCollection(elements)) {
      elements = this.mutableElements();
    }

    if (elements.length === 0) {
      return;
    } // can't centre pan to nothing

    var bb = elements.boundingBox();
    var w = this.width();
    var h = this.height();
    zoom = zoom === undefined ? this._private.zoom : zoom;

    var pan = { // middle
      x: (w - zoom * (bb.x1 + bb.x2)) / 2,
      y: (h - zoom * (bb.y1 + bb.y2)) / 2
    };

    return pan;
  },

  reset: function reset() {
    if (!this._private.panningEnabled || !this._private.zoomingEnabled) {
      return this;
    }

    this.viewport({
      pan: { x: 0, y: 0 },
      zoom: 1
    });

    return this; // chaining
  },

  invalidateSize: function invalidateSize() {
    this._private.sizeCache = null;
  },

  size: function size() {
    var _p = this._private;
    var container = _p.container;

    return _p.sizeCache = _p.sizeCache || (container ? function () {
      var style = window.getComputedStyle(container);
      var val = function val(name) {
        return parseFloat(style.getPropertyValue(name));
      };

      return {
        width: container.clientWidth - val('padding-left') - val('padding-right'),
        height: container.clientHeight - val('padding-top') - val('padding-bottom')
      };
    }() : { // fallback if no container (not 0 b/c can be used for dividing etc)
      width: 1,
      height: 1
    });
  },

  width: function width() {
    return this.size().width;
  },

  height: function height() {
    return this.size().height;
  },

  extent: function extent() {
    var pan = this._private.pan;
    var zoom = this._private.zoom;
    var rb = this.renderedExtent();

    var b = {
      x1: (rb.x1 - pan.x) / zoom,
      x2: (rb.x2 - pan.x) / zoom,
      y1: (rb.y1 - pan.y) / zoom,
      y2: (rb.y2 - pan.y) / zoom
    };

    b.w = b.x2 - b.x1;
    b.h = b.y2 - b.y1;

    return b;
  },

  renderedExtent: function renderedExtent() {
    var width = this.width();
    var height = this.height();

    return {
      x1: 0,
      y1: 0,
      x2: width,
      y2: height,
      w: width,
      h: height
    };
  }
};

// aliases
corefn.centre = corefn.center;

// backwards compatibility
corefn.autolockNodes = corefn.autolock;
corefn.autoungrabifyNodes = corefn.autoungrabify;

module.exports = corefn;

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);
var define = __webpack_require__(4);
var Collection = __webpack_require__(7);
var Core = __webpack_require__(12);
var incExts = __webpack_require__(95);
var is = __webpack_require__(0);
var Emitter = __webpack_require__(11);

// registered extensions to cytoscape, indexed by name
var extensions = {};

// registered modules for extensions, indexed by name
var modules = {};

function setExtension(type, name, registrant) {

  var ext = registrant;

  var overrideErr = function overrideErr(field) {
    util.error('Can not register `' + name + '` for `' + type + '` since `' + field + '` already exists in the prototype and can not be overridden');
  };

  if (type === 'core') {
    if (Core.prototype[name]) {
      return overrideErr(name);
    } else {
      Core.prototype[name] = registrant;
    }
  } else if (type === 'collection') {
    if (Collection.prototype[name]) {
      return overrideErr(name);
    } else {
      Collection.prototype[name] = registrant;
    }
  } else if (type === 'layout') {
    // fill in missing layout functions in the prototype

    var Layout = function Layout(options) {
      this.options = options;

      registrant.call(this, options);

      // make sure layout has _private for use w/ std apis like .on()
      if (!is.plainObject(this._private)) {
        this._private = {};
      }

      this._private.cy = options.cy;
      this._private.listeners = [];

      this.createEmitter();
    };

    var layoutProto = Layout.prototype = Object.create(registrant.prototype);

    var optLayoutFns = [];

    for (var i = 0; i < optLayoutFns.length; i++) {
      var fnName = optLayoutFns[i];

      layoutProto[fnName] = layoutProto[fnName] || function () {
        return this;
      };
    }

    // either .start() or .run() is defined, so autogen the other
    if (layoutProto.start && !layoutProto.run) {
      layoutProto.run = function () {
        this.start();return this;
      };
    } else if (!layoutProto.start && layoutProto.run) {
      layoutProto.start = function () {
        this.run();return this;
      };
    }

    var regStop = registrant.prototype.stop;
    layoutProto.stop = function () {
      var opts = this.options;

      if (opts && opts.animate) {
        var anis = this.animations;

        if (anis) {
          for (var _i = 0; _i < anis.length; _i++) {
            anis[_i].stop();
          }
        }
      }

      if (regStop) {
        regStop.call(this);
      } else {
        this.emit('layoutstop');
      }

      return this;
    };

    if (!layoutProto.destroy) {
      layoutProto.destroy = function () {
        return this;
      };
    }

    layoutProto.cy = function () {
      return this._private.cy;
    };

    var getCy = function getCy(layout) {
      return layout._private.cy;
    };

    util.assign(layoutProto, {
      createEmitter: function createEmitter() {
        this._private.emitter = new Emitter({
          eventFields: function eventFields(layout) {
            return {
              layout: layout,
              cy: getCy(layout),
              target: layout
            };
          },
          bubble: function bubble() {
            return true;
          },
          parent: function parent(layout) {
            return getCy(layout);
          },
          context: this
        });

        return this;
      },
      emitter: function emitter() {
        return this._private.emitter;
      },
      on: function on(evt, cb) {
        this.emitter().on(evt, cb);return this;
      },
      one: function one(evt, cb) {
        this.emitter().one(evt, cb);return this;
      },
      once: function once(evt, cb) {
        this.emitter().one(evt, cb);return this;
      },
      removeListener: function removeListener(evt, cb) {
        this.emitter().removeListener(evt, cb);return this;
      },
      emit: function emit(evt, params) {
        this.emitter().emit(evt, params);return this;
      }
    });

    define.eventAliasesOn(layoutProto);

    ext = Layout; // replace with our wrapped layout
  } else if (type === 'renderer' && name !== 'null' && name !== 'base') {
    // user registered renderers inherit from base

    var BaseRenderer = getExtension('renderer', 'base');
    var bProto = BaseRenderer.prototype;
    var RegistrantRenderer = registrant;
    var rProto = registrant.prototype;

    var Renderer = function Renderer() {
      BaseRenderer.apply(this, arguments);
      RegistrantRenderer.apply(this, arguments);
    };

    var proto = Renderer.prototype;

    for (var pName in bProto) {
      var pVal = bProto[pName];
      var existsInR = rProto[pName] != null;

      if (existsInR) {
        return overrideErr(pName);
      }

      proto[pName] = pVal; // take impl from base
    }

    for (var _pName in rProto) {
      proto[_pName] = rProto[_pName]; // take impl from registrant
    }

    bProto.clientFunctions.forEach(function (name) {
      proto[name] = proto[name] || function () {
        util.error('Renderer does not implement `renderer.' + name + '()` on its prototype');
      };
    });

    ext = Renderer;
  }

  return util.setMap({
    map: extensions,
    keys: [type, name],
    value: ext
  });
}

function getExtension(type, name) {
  return util.getMap({
    map: extensions,
    keys: [type, name]
  });
}

function setModule(type, name, moduleType, moduleName, registrant) {
  return util.setMap({
    map: modules,
    keys: [type, name, moduleType, moduleName],
    value: registrant
  });
}

function getModule(type, name, moduleType, moduleName) {
  return util.getMap({
    map: modules,
    keys: [type, name, moduleType, moduleName]
  });
}

var extension = function extension() {
  // e.g. extension('renderer', 'svg')
  if (arguments.length === 2) {
    return getExtension.apply(null, arguments);
  }

  // e.g. extension('renderer', 'svg', { ... })
  else if (arguments.length === 3) {
      return setExtension.apply(null, arguments);
    }

    // e.g. extension('renderer', 'svg', 'nodeShape', 'ellipse')
    else if (arguments.length === 4) {
        return getModule.apply(null, arguments);
      }

      // e.g. extension('renderer', 'svg', 'nodeShape', 'ellipse', { ... })
      else if (arguments.length === 5) {
          return setModule.apply(null, arguments);
        } else {
          util.error('Invalid extension access syntax');
        }
};

// allows a core instance to access extensions internally
Core.prototype.extension = extension;

// included extensions
incExts.forEach(function (group) {
  group.extensions.forEach(function (ext) {
    setExtension(group.type, ext.name, ext.impl);
  });
});

module.exports = extension;

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = [{
  type: 'layout',
  extensions: __webpack_require__(96)
}, {
  type: 'renderer',
  extensions: __webpack_require__(105)
}];

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = [{ name: 'breadthfirst', impl: __webpack_require__(97) }, { name: 'circle', impl: __webpack_require__(98) }, { name: 'concentric', impl: __webpack_require__(99) }, { name: 'cose', impl: __webpack_require__(100) }, { name: 'grid', impl: __webpack_require__(101) }, { name: 'null', impl: __webpack_require__(102) }, { name: 'preset', impl: __webpack_require__(103) }, { name: 'random', impl: __webpack_require__(104) }];

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);
var math = __webpack_require__(2);
var is = __webpack_require__(0);

var defaults = {
  fit: true, // whether to fit the viewport to the graph
  directed: false, // whether the tree is directed downwards (or edges can point in any direction if false)
  padding: 30, // padding on fit
  circle: false, // put depths in concentric circles if true, put depths top down if false
  spacingFactor: 1.75, // positive spacing factor, larger => more space between nodes (N.B. n/a if causes overlap)
  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
  nodeDimensionsIncludeLabels: false, // Excludes the label when calculating node bounding boxes for the layout algorithm
  roots: undefined, // the roots of the trees
  maximalAdjustments: 0, // how many times to try to position the nodes in a maximal way (i.e. no backtracking)
  animate: false, // whether to transition the node positions
  animationDuration: 500, // duration of animation in ms if enabled
  animationEasing: undefined, // easing of animation if enabled,
  animateFilter: function animateFilter(node, i) {
    return true;
  }, // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
  ready: undefined, // callback on layoutready
  stop: undefined, // callback on layoutstop
  transform: function transform(node, position) {
    return position;
  } // transform a given node position. Useful for changing flow direction in discrete layouts
};

function BreadthFirstLayout(options) {
  this.options = util.extend({}, defaults, options);
}

BreadthFirstLayout.prototype.run = function () {
  var params = this.options;
  var options = params;

  var cy = params.cy;
  var eles = options.eles;
  var nodes = eles.nodes().not(':parent');
  var graph = eles;

  var bb = math.makeBoundingBox(options.boundingBox ? options.boundingBox : {
    x1: 0, y1: 0, w: cy.width(), h: cy.height()
  });

  var roots = void 0;
  if (is.elementOrCollection(options.roots)) {
    roots = options.roots;
  } else if (is.array(options.roots)) {
    var rootsArray = [];

    for (var i = 0; i < options.roots.length; i++) {
      var id = options.roots[i];
      var ele = cy.getElementById(id);
      rootsArray.push(ele);
    }

    roots = cy.collection(rootsArray);
  } else if (is.string(options.roots)) {
    roots = cy.$(options.roots);
  } else {
    if (options.directed) {
      roots = nodes.roots();
    } else {
      var components = [];
      var unhandledNodes = nodes;

      var _loop = function _loop() {
        var currComp = cy.collection();

        eles.bfs({
          roots: unhandledNodes[0],
          visit: function visit(node, edge, pNode, i, depth) {
            currComp = currComp.add(node);
          },
          directed: false
        });

        unhandledNodes = unhandledNodes.not(currComp);
        components.push(currComp);
      };

      while (unhandledNodes.length > 0) {
        _loop();
      }

      roots = cy.collection();

      var _loop2 = function _loop2(_i) {
        var comp = components[_i];
        var maxDegree = comp.maxDegree(false);
        var compRoots = comp.filter(function (ele) {
          return ele.degree(false) === maxDegree;
        });

        roots = roots.add(compRoots);
      };

      for (var _i = 0; _i < components.length; _i++) {
        _loop2(_i);
      }
    }
  }

  var depths = [];
  var foundByBfs = {};
  var id2depth = {};
  var prevNode = {};
  var prevEdge = {};
  var successors = {};

  // find the depths of the nodes
  graph.bfs({
    roots: roots,
    directed: options.directed,
    visit: function visit(node, edge, pNode, i, depth) {
      var ele = node[0];
      var id = ele.id();

      if (!depths[depth]) {
        depths[depth] = [];
      }

      depths[depth].push(ele);
      foundByBfs[id] = true;
      id2depth[id] = depth;
      prevNode[id] = pNode;
      prevEdge[id] = edge;

      if (pNode) {
        var prevId = pNode.id();
        var succ = successors[prevId] = successors[prevId] || [];

        succ.push(node);
      }
    }
  });

  // check for nodes not found by bfs
  var orphanNodes = [];
  for (var _i2 = 0; _i2 < nodes.length; _i2++) {
    var _ele = nodes[_i2];

    if (foundByBfs[_ele.id()]) {
      continue;
    } else {
      orphanNodes.push(_ele);
    }
  }

  // assign orphan nodes a depth from their neighborhood
  var maxChecks = orphanNodes.length * 3;
  var checks = 0;
  while (orphanNodes.length !== 0 && checks < maxChecks) {
    var node = orphanNodes.shift();
    var neighbors = node.neighborhood().nodes();
    var assignedDepth = false;

    for (var _i3 = 0; _i3 < neighbors.length; _i3++) {
      var depth = id2depth[neighbors[_i3].id()];

      if (depth !== undefined) {
        depths[depth].push(node);
        assignedDepth = true;
        break;
      }
    }

    if (!assignedDepth) {
      orphanNodes.push(node);
    }

    checks++;
  }

  // assign orphan nodes that are still left to the depth of their subgraph
  while (orphanNodes.length !== 0) {
    var _node = orphanNodes.shift();
    //let subgraph = graph.bfs( node ).path;
    var _assignedDepth = false;

    // for( let i = 0; i < subgraph.length; i++ ){
    //   let depth = id2depth[ subgraph[i].id() ];

    //   if( depth !== undefined ){
    //     depths[depth].push( node );
    //     assignedDepth = true;
    //     break;
    //   }
    // }

    if (!_assignedDepth) {
      // worst case if the graph really isn't tree friendly, then just dump it in 0
      if (depths.length === 0) {
        depths.push([]);
      }

      depths[0].push(_node);
    }
  }

  // assign the nodes a depth and index
  var assignDepthsToEles = function assignDepthsToEles() {
    for (var _i4 = 0; _i4 < depths.length; _i4++) {
      var _eles = depths[_i4];

      for (var j = 0; j < _eles.length; j++) {
        var _ele2 = _eles[j];

        if (_ele2 == null) {
          _eles.splice(j, 1);
          j--;
          continue;
        }

        _ele2._private.scratch.breadthfirst = {
          depth: _i4,
          index: j
        };
      }
    }
  };
  assignDepthsToEles();

  var intersectsDepth = function intersectsDepth(node) {
    // returns true if has edges pointing in from a higher depth
    var edges = node.connectedEdges(function (ele) {
      return ele.data('target') === node.id();
    });
    var thisInfo = node._private.scratch.breadthfirst;
    var highestDepthOfOther = 0;
    var highestOther = void 0;
    for (var _i5 = 0; _i5 < edges.length; _i5++) {
      var edge = edges[_i5];
      var otherNode = edge.source()[0];
      var otherInfo = otherNode._private.scratch.breadthfirst;

      if (thisInfo.depth <= otherInfo.depth && highestDepthOfOther < otherInfo.depth) {
        highestDepthOfOther = otherInfo.depth;
        highestOther = otherNode;
      }
    }

    return highestOther;
  };

  // make maximal if so set by adjusting depths
  for (var adj = 0; adj < options.maximalAdjustments; adj++) {

    var nDepths = depths.length;
    var elesToMove = [];
    for (var _i6 = 0; _i6 < nDepths; _i6++) {
      var _depth = depths[_i6];

      var nDepth = _depth.length;
      for (var j = 0; j < nDepth; j++) {
        var _ele3 = _depth[j];
        var info = _ele3._private.scratch.breadthfirst;
        var intEle = intersectsDepth(_ele3);

        if (intEle) {
          info.intEle = intEle;
          elesToMove.push(_ele3);
        }
      }
    }

    for (var _i7 = 0; _i7 < elesToMove.length; _i7++) {
      var _ele4 = elesToMove[_i7];
      var _info = _ele4._private.scratch.breadthfirst;
      var _intEle = _info.intEle;
      var intInfo = _intEle._private.scratch.breadthfirst;

      depths[_info.depth][_info.index] = null; // remove from old depth & index (create hole to be cleaned)

      // add to end of new depth
      var newDepth = intInfo.depth + 1;
      while (newDepth > depths.length - 1) {
        depths.push([]);
      }
      depths[newDepth].push(_ele4);

      _info.depth = newDepth;
      _info.index = depths[newDepth].length - 1;
    }

    assignDepthsToEles();
  }

  // find min distance we need to leave between nodes
  var minDistance = 0;
  if (options.avoidOverlap) {
    for (var _i8 = 0; _i8 < nodes.length; _i8++) {
      var n = nodes[_i8];
      var nbb = n.layoutDimensions(options);
      var w = nbb.w;
      var h = nbb.h;

      minDistance = Math.max(minDistance, w, h);
    }
  }

  // get the weighted percent for an element based on its connectivity to other levels
  var cachedWeightedPercent = {};
  var getWeightedPercent = function getWeightedPercent(ele) {
    if (cachedWeightedPercent[ele.id()]) {
      return cachedWeightedPercent[ele.id()];
    }

    var eleDepth = ele._private.scratch.breadthfirst.depth;
    var neighbors = ele.neighborhood().nodes().not(':parent').intersection(nodes);
    var percent = 0;
    var samples = 0;

    for (var _i9 = 0; _i9 < neighbors.length; _i9++) {
      var neighbor = neighbors[_i9];
      var bf = neighbor._private.scratch.breadthfirst;
      var index = bf.index;
      var _depth2 = bf.depth;
      var _nDepth = depths[_depth2].length;

      if (eleDepth > _depth2 || eleDepth === 0) {
        // only get influenced by elements above
        percent += index / _nDepth;
        samples++;
      }
    }

    samples = Math.max(1, samples);
    percent = percent / samples;

    if (samples === 0) {
      // so lone nodes have a "don't care" state in sorting
      percent = undefined;
    }

    cachedWeightedPercent[ele.id()] = percent;
    return percent;
  };

  // rearrange the indices in each depth level based on connectivity

  var sortFn = function sortFn(a, b) {
    var apct = getWeightedPercent(a);
    var bpct = getWeightedPercent(b);

    return apct - bpct;
  };

  for (var times = 0; times < 3; times++) {
    // do it a few times b/c the depths are dynamic and we want a more stable result

    for (var _i10 = 0; _i10 < depths.length; _i10++) {
      depths[_i10] = depths[_i10].sort(sortFn);
    }
    assignDepthsToEles(); // and update
  }

  var biggestDepthSize = 0;
  for (var _i11 = 0; _i11 < depths.length; _i11++) {
    biggestDepthSize = Math.max(depths[_i11].length, biggestDepthSize);
  }

  var center = {
    x: bb.x1 + bb.w / 2,
    y: bb.x1 + bb.h / 2
  };

  var getPosition = function getPosition(ele, isBottomDepth) {
    var info = ele._private.scratch.breadthfirst;
    var depth = info.depth;
    var index = info.index;
    var depthSize = depths[depth].length;

    var distanceX = Math.max(bb.w / (depthSize + 1), minDistance);
    var distanceY = Math.max(bb.h / (depths.length + 1), minDistance);
    var radiusStepSize = Math.min(bb.w / 2 / depths.length, bb.h / 2 / depths.length);
    radiusStepSize = Math.max(radiusStepSize, minDistance);

    if (!options.circle) {

      var epos = {
        x: center.x + (index + 1 - (depthSize + 1) / 2) * distanceX,
        y: (depth + 1) * distanceY
      };

      if (isBottomDepth) {
        return epos;
      }

      // let succs = successors[ ele.id() ];
      // if( succs ){
      //   epos.x = 0;
      //
      //   for( let i = 0 ; i < succs.length; i++ ){
      //     let spos = pos[ succs[i].id() ];
      //
      //     epos.x += spos.x;
      //   }
      //
      //   epos.x /= succs.length;
      // } else {
      //   //debugger;
      // }

      return epos;
    } else {
      if (options.circle) {
        var radius = radiusStepSize * depth + radiusStepSize - (depths.length > 0 && depths[0].length <= 3 ? radiusStepSize / 2 : 0);
        var theta = 2 * Math.PI / depths[depth].length * index;

        if (depth === 0 && depths[0].length === 1) {
          radius = 1;
        }

        return {
          x: center.x + radius * Math.cos(theta),
          y: center.y + radius * Math.sin(theta)
        };
      } else {
        return {
          x: center.x + (index + 1 - (depthSize + 1) / 2) * distanceX,
          y: (depth + 1) * distanceY
        };
      }
    }
  };

  // get positions in reverse depth order
  var pos = {};
  for (var _i12 = depths.length - 1; _i12 >= 0; _i12--) {
    var _depth3 = depths[_i12];

    for (var _j = 0; _j < _depth3.length; _j++) {
      var _node2 = _depth3[_j];

      pos[_node2.id()] = getPosition(_node2, _i12 === depths.length - 1);
    }
  }

  nodes.layoutPositions(this, options, function (node) {
    return pos[node.id()];
  });

  return this; // chaining
};

module.exports = BreadthFirstLayout;

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);
var math = __webpack_require__(2);
var is = __webpack_require__(0);

var defaults = {
  fit: true, // whether to fit the viewport to the graph
  padding: 30, // the padding on fit
  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  avoidOverlap: true, // prevents node overlap, may overflow boundingBox and radius if not enough space
  nodeDimensionsIncludeLabels: false, // Excludes the label when calculating node bounding boxes for the layout algorithm
  spacingFactor: undefined, // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
  radius: undefined, // the radius of the circle
  startAngle: 3 / 2 * Math.PI, // where nodes start in radians
  sweep: undefined, // how many radians should be between the first and last node (defaults to full circle)
  clockwise: true, // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)
  sort: undefined, // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }
  animate: false, // whether to transition the node positions
  animationDuration: 500, // duration of animation in ms if enabled
  animationEasing: undefined, // easing of animation if enabled
  animateFilter: function animateFilter(node, i) {
    return true;
  }, // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
  ready: undefined, // callback on layoutready
  stop: undefined, // callback on layoutstop
  transform: function transform(node, position) {
    return position;
  } // transform a given node position. Useful for changing flow direction in discrete layouts 

};

function CircleLayout(options) {
  this.options = util.extend({}, defaults, options);
}

CircleLayout.prototype.run = function () {
  var params = this.options;
  var options = params;

  var cy = params.cy;
  var eles = options.eles;

  var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;

  var nodes = eles.nodes().not(':parent');

  if (options.sort) {
    nodes = nodes.sort(options.sort);
  }

  var bb = math.makeBoundingBox(options.boundingBox ? options.boundingBox : {
    x1: 0, y1: 0, w: cy.width(), h: cy.height()
  });

  var center = {
    x: bb.x1 + bb.w / 2,
    y: bb.y1 + bb.h / 2
  };

  var sweep = options.sweep === undefined ? 2 * Math.PI - 2 * Math.PI / nodes.length : options.sweep;
  var dTheta = sweep / Math.max(1, nodes.length - 1);
  var r = void 0;

  var minDistance = 0;
  for (var i = 0; i < nodes.length; i++) {
    var n = nodes[i];
    var nbb = n.layoutDimensions(options);
    var w = nbb.w;
    var h = nbb.h;

    minDistance = Math.max(minDistance, w, h);
  }

  if (is.number(options.radius)) {
    r = options.radius;
  } else if (nodes.length <= 1) {
    r = 0;
  } else {
    r = Math.min(bb.h, bb.w) / 2 - minDistance;
  }

  // calculate the radius
  if (nodes.length > 1 && options.avoidOverlap) {
    // but only if more than one node (can't overlap)
    minDistance *= 1.75; // just to have some nice spacing

    var dcos = Math.cos(dTheta) - Math.cos(0);
    var dsin = Math.sin(dTheta) - Math.sin(0);
    var rMin = Math.sqrt(minDistance * minDistance / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping
    r = Math.max(rMin, r);
  }

  var getPos = function getPos(ele, i) {
    var theta = options.startAngle + i * dTheta * (clockwise ? 1 : -1);

    var rx = r * Math.cos(theta);
    var ry = r * Math.sin(theta);
    var pos = {
      x: center.x + rx,
      y: center.y + ry
    };

    return pos;
  };

  nodes.layoutPositions(this, options, getPos);

  return this; // chaining
};

module.exports = CircleLayout;

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);
var math = __webpack_require__(2);

var defaults = {
  fit: true, // whether to fit the viewport to the graph
  padding: 30, // the padding on fit
  startAngle: 3 / 2 * Math.PI, // where nodes start in radians
  sweep: undefined, // how many radians should be between the first and last node (defaults to full circle)
  clockwise: true, // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)
  equidistant: false, // whether levels have an equal radial distance betwen them, may cause bounding box overflow
  minNodeSpacing: 10, // min spacing between outside of nodes (used for radius adjustment)
  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
  nodeDimensionsIncludeLabels: false, // Excludes the label when calculating node bounding boxes for the layout algorithm
  height: undefined, // height of layout area (overrides container height)
  width: undefined, // width of layout area (overrides container width)
  spacingFactor: undefined, // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
  concentric: function concentric(node) {
    // returns numeric value for each node, placing higher nodes in levels towards the centre
    return node.degree();
  },
  levelWidth: function levelWidth(nodes) {
    // the letiation of concentric values in each level
    return nodes.maxDegree() / 4;
  },
  animate: false, // whether to transition the node positions
  animationDuration: 500, // duration of animation in ms if enabled
  animationEasing: undefined, // easing of animation if enabled
  animateFilter: function animateFilter(node, i) {
    return true;
  }, // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
  ready: undefined, // callback on layoutready
  stop: undefined, // callback on layoutstop
  transform: function transform(node, position) {
    return position;
  } // transform a given node position. Useful for changing flow direction in discrete layouts 
};

function ConcentricLayout(options) {
  this.options = util.extend({}, defaults, options);
}

ConcentricLayout.prototype.run = function () {
  var params = this.options;
  var options = params;

  var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;

  var cy = params.cy;

  var eles = options.eles;
  var nodes = eles.nodes().not(':parent');

  var bb = math.makeBoundingBox(options.boundingBox ? options.boundingBox : {
    x1: 0, y1: 0, w: cy.width(), h: cy.height()
  });

  var center = {
    x: bb.x1 + bb.w / 2,
    y: bb.y1 + bb.h / 2
  };

  var nodeValues = []; // { node, value }
  var theta = options.startAngle;
  var maxNodeSize = 0;

  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    var value = void 0;

    // calculate the node value
    value = options.concentric(node);
    nodeValues.push({
      value: value,
      node: node
    });

    // for style mapping
    node._private.scratch.concentric = value;
  }

  // in case we used the `concentric` in style
  nodes.updateStyle();

  // calculate max size now based on potentially updated mappers
  for (var _i = 0; _i < nodes.length; _i++) {
    var _node = nodes[_i];
    var nbb = _node.layoutDimensions(options);

    maxNodeSize = Math.max(maxNodeSize, nbb.w, nbb.h);
  }

  // sort node values in descreasing order
  nodeValues.sort(function (a, b) {
    return b.value - a.value;
  });

  var levelWidth = options.levelWidth(nodes);

  // put the values into levels
  var levels = [[]];
  var currentLevel = levels[0];
  for (var _i2 = 0; _i2 < nodeValues.length; _i2++) {
    var val = nodeValues[_i2];

    if (currentLevel.length > 0) {
      var diff = Math.abs(currentLevel[0].value - val.value);

      if (diff >= levelWidth) {
        currentLevel = [];
        levels.push(currentLevel);
      }
    }

    currentLevel.push(val);
  }

  // create positions from levels

  var minDist = maxNodeSize + options.minNodeSpacing; // min dist between nodes

  if (!options.avoidOverlap) {
    // then strictly constrain to bb
    var firstLvlHasMulti = levels.length > 0 && levels[0].length > 1;
    var maxR = Math.min(bb.w, bb.h) / 2 - minDist;
    var rStep = maxR / (levels.length + firstLvlHasMulti ? 1 : 0);

    minDist = Math.min(minDist, rStep);
  }

  // find the metrics for each level
  var r = 0;
  for (var _i3 = 0; _i3 < levels.length; _i3++) {
    var level = levels[_i3];
    var sweep = options.sweep === undefined ? 2 * Math.PI - 2 * Math.PI / level.length : options.sweep;
    var dTheta = level.dTheta = sweep / Math.max(1, level.length - 1);

    // calculate the radius
    if (level.length > 1 && options.avoidOverlap) {
      // but only if more than one node (can't overlap)
      var dcos = Math.cos(dTheta) - Math.cos(0);
      var dsin = Math.sin(dTheta) - Math.sin(0);
      var rMin = Math.sqrt(minDist * minDist / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping

      r = Math.max(rMin, r);
    }

    level.r = r;

    r += minDist;
  }

  if (options.equidistant) {
    var rDeltaMax = 0;
    var _r = 0;

    for (var _i4 = 0; _i4 < levels.length; _i4++) {
      var _level = levels[_i4];
      var rDelta = _level.r - _r;

      rDeltaMax = Math.max(rDeltaMax, rDelta);
    }

    _r = 0;
    for (var _i5 = 0; _i5 < levels.length; _i5++) {
      var _level2 = levels[_i5];

      if (_i5 === 0) {
        _r = _level2.r;
      }

      _level2.r = _r;

      _r += rDeltaMax;
    }
  }

  // calculate the node positions
  var pos = {}; // id => position
  for (var _i6 = 0; _i6 < levels.length; _i6++) {
    var _level3 = levels[_i6];
    var _dTheta = _level3.dTheta;
    var _r2 = _level3.r;

    for (var j = 0; j < _level3.length; j++) {
      var _val = _level3[j];
      var _theta = options.startAngle + (clockwise ? 1 : -1) * _dTheta * j;

      var p = {
        x: center.x + _r2 * Math.cos(_theta),
        y: center.y + _r2 * Math.sin(_theta)
      };

      pos[_val.node.id()] = p;
    }
  }

  // position the nodes
  nodes.layoutPositions(this, options, function (ele) {
    var id = ele.id();

    return pos[id];
  });

  return this; // chaining
};

module.exports = ConcentricLayout;

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
The CoSE layout was written by Gerardo Huck.
https://www.linkedin.com/in/gerardohuck/

Based on the following article:
http://dl.acm.org/citation.cfm?id=1498047

Modifications tracked on Github.
*/

var util = __webpack_require__(1);
var math = __webpack_require__(2);
var is = __webpack_require__(0);
var Promise = __webpack_require__(5);

var DEBUG;

/**
 * @brief :  default layout options
 */
var defaults = {
  // Called on `layoutready`
  ready: function ready() {},

  // Called on `layoutstop`
  stop: function stop() {},

  // Whether to animate while running the layout
  // true : Animate continuously as the layout is running
  // false : Just show the end result
  // 'end' : Animate with the end result, from the initial positions to the end positions
  animate: true,

  // Easing of the animation for animate:'end'
  animationEasing: undefined,

  // The duration of the animation for animate:'end'
  animationDuration: undefined,

  // A function that determines whether the node should be animated
  // All nodes animated by default on animate enabled
  // Non-animated nodes are positioned immediately when the layout starts
  animateFilter: function animateFilter(node, i) {
    return true;
  },

  // The layout animates only after this many milliseconds for animate:true
  // (prevents flashing on fast runs)
  animationThreshold: 250,

  // Number of iterations between consecutive screen positions update
  // (0 -> only updated on the end)
  refresh: 20,

  // Whether to fit the network view after when done
  fit: true,

  // Padding on fit
  padding: 30,

  // Constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  boundingBox: undefined,

  // Excludes the label when calculating node bounding boxes for the layout algorithm
  nodeDimensionsIncludeLabels: false,

  // Randomize the initial positions of the nodes (true) or use existing positions (false)
  randomize: false,

  // Extra spacing between components in non-compound graphs
  componentSpacing: 40,

  // Node repulsion (non overlapping) multiplier
  nodeRepulsion: function nodeRepulsion(node) {
    return 2048;
  },

  // Node repulsion (overlapping) multiplier
  nodeOverlap: 4,

  // Ideal edge (non nested) length
  idealEdgeLength: function idealEdgeLength(edge) {
    return 32;
  },

  // Divisor to compute edge forces
  edgeElasticity: function edgeElasticity(edge) {
    return 32;
  },

  // Nesting factor (multiplier) to compute ideal edge length for nested edges
  nestingFactor: 1.2,

  // Gravity force (constant)
  gravity: 1,

  // Maximum number of iterations to perform
  numIter: 1000,

  // Initial temperature (maximum node displacement)
  initialTemp: 1000,

  // Cooling factor (how the temperature is reduced between consecutive iterations
  coolingFactor: 0.99,

  // Lower temperature threshold (below this point the layout will end)
  minTemp: 1.0,

  // Pass a reference to weaver to use threads for calculations
  weaver: false
};

/**
 * @brief       : constructor
 * @arg options : object containing layout options
 */
function CoseLayout(options) {
  this.options = util.extend({}, defaults, options);

  this.options.layout = this;
}

/**
 * @brief : runs the layout
 */
CoseLayout.prototype.run = function () {
  var options = this.options;
  var cy = options.cy;
  var layout = this;
  var thread = this.thread;
  var Thread = options.weaver ? options.weaver.Thread : null;

  var falseThread = { // use false thread as polyfill
    listeners: [],
    on: function on(e, cb) {
      this.listeners.push({ event: e, callback: cb });

      return this;
    },
    trigger: function trigger(e) {
      if (is.string(e)) {
        e = { type: e };
      }

      var matchesEvent = function matchesEvent(l) {
        return l.event === e.type;
      };
      var trigger = function trigger(l) {
        l.callback(e);
      };

      this.listeners.filter(matchesEvent).forEach(trigger);

      return this;
    },
    pass: function pass(data) {
      this.pass = data;

      return this;
    },
    run: function run(cb) {
      var pass = this.pass;

      return new Promise(function (resolve) {
        resolve(cb(pass));
      });
    },
    stop: function stop() {
      return this;
    },
    stopped: function stopped() {
      return true;
    }
  };

  function broadcast(message) {
    // for false thread
    var e = { type: 'message', message: message };

    falseThread.trigger(e);
  }

  if (!thread || thread.stopped()) {
    thread = this.thread = Thread ? new Thread() : falseThread;
  }

  layout.stopped = false;

  if (options.animate === true || options.animate === false) {
    layout.emit({ type: 'layoutstart', layout: layout });
  }

  // Set DEBUG - Global variable
  if (true === options.debug) {
    DEBUG = true;
  } else {
    DEBUG = false;
  }

  // Initialize layout info
  var layoutInfo = createLayoutInfo(cy, layout, options);

  // Show LayoutInfo contents if debugging
  if (DEBUG) {
    printLayoutInfo(layoutInfo);
  }

  // If required, randomize node positions
  if (options.randomize) {
    randomizePositions(layoutInfo, cy);
  }

  var startTime = Date.now();
  var refreshRequested = false;
  var refresh = function refresh(rOpts) {
    rOpts = rOpts || {};

    if (refreshRequested && !rOpts.next) {
      return;
    }

    if (!rOpts.force && Date.now() - startTime < options.animationThreshold) {
      return;
    }

    refreshRequested = true;

    util.requestAnimationFrame(function () {
      refreshPositions(layoutInfo, cy, options);

      // Fit the graph if necessary
      if (true === options.fit) {
        cy.fit(options.padding);
      }

      refreshRequested = false;

      if (rOpts.next) {
        rOpts.next();
      }
    });
  };

  thread.on('message', function (e) {
    var layoutNodes = e.message;

    layoutInfo.layoutNodes = layoutNodes;
    refresh();
  });

  thread.pass({
    layoutInfo: layoutInfo,
    options: {
      animate: options.animate,
      refresh: options.refresh,
      componentSpacing: options.componentSpacing,
      nodeOverlap: options.nodeOverlap,
      nestingFactor: options.nestingFactor,
      gravity: options.gravity,
      numIter: options.numIter,
      initialTemp: options.initialTemp,
      coolingFactor: options.coolingFactor,
      minTemp: options.minTemp
    }
  }).run(function (pass) {
    var layoutInfo = pass.layoutInfo;
    var options = pass.options;
    var stopped = false;

    /**
     * @brief          : Performs one iteration of the physical simulation
     * @arg layoutInfo : LayoutInfo object already initialized
     * @arg cy         : Cytoscape object
     * @arg options    : Layout options
     */
    var step = function step(layoutInfo, options, _step) {
      // var s = "\n\n###############################";
      // s += "\nSTEP: " + step;
      // s += "\n###############################\n";
      // logDebug(s);

      // Calculate node repulsions
      calculateNodeForces(layoutInfo, options);
      // Calculate edge forces
      calculateEdgeForces(layoutInfo, options);
      // Calculate gravity forces
      calculateGravityForces(layoutInfo, options);
      // Propagate forces from parent to child
      propagateForces(layoutInfo, options);
      // Update positions based on calculated forces
      updatePositions(layoutInfo, options);
    };

    /**
     * @brief : Computes the node repulsion forces
     */
    var calculateNodeForces = function calculateNodeForces(layoutInfo, options) {
      // Go through each of the graphs in graphSet
      // Nodes only repel each other if they belong to the same graph
      // var s = 'calculateNodeForces';
      // logDebug(s);
      for (var i = 0; i < layoutInfo.graphSet.length; i++) {
        var graph = layoutInfo.graphSet[i];
        var numNodes = graph.length;

        // s = "Set: " + graph.toString();
        // logDebug(s);

        // Now get all the pairs of nodes
        // Only get each pair once, (A, B) = (B, A)
        for (var j = 0; j < numNodes; j++) {
          var node1 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]];

          for (var k = j + 1; k < numNodes; k++) {
            var node2 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[k]]];

            nodeRepulsion(node1, node2, layoutInfo, options);
          }
        }
      }
    };

    var randomDistance = function randomDistance(max) {
      return -max + 2 * max * Math.random();
    };

    /**
     * @brief : Compute the node repulsion forces between a pair of nodes
     */
    var nodeRepulsion = function nodeRepulsion(node1, node2, layoutInfo, options) {
      // var s = "Node repulsion. Node1: " + node1.id + " Node2: " + node2.id;

      var cmptId1 = node1.cmptId;
      var cmptId2 = node2.cmptId;

      if (cmptId1 !== cmptId2 && !layoutInfo.isCompound) {
        return;
      }

      // Get direction of line connecting both node centers
      var directionX = node2.positionX - node1.positionX;
      var directionY = node2.positionY - node1.positionY;
      var maxRandDist = 1;
      // s += "\ndirectionX: " + directionX + ", directionY: " + directionY;

      // If both centers are the same, apply a random force
      if (0 === directionX && 0 === directionY) {
        directionX = randomDistance(maxRandDist);
        directionY = randomDistance(maxRandDist);
      }

      var overlap = nodesOverlap(node1, node2, directionX, directionY);

      if (overlap > 0) {
        // s += "\nNodes DO overlap.";
        // s += "\nOverlap: " + overlap;
        // If nodes overlap, repulsion force is proportional
        // to the overlap
        var force = options.nodeOverlap * overlap;

        // Compute the module and components of the force vector
        var distance = Math.sqrt(directionX * directionX + directionY * directionY);
        // s += "\nDistance: " + distance;
        var forceX = force * directionX / distance;
        var forceY = force * directionY / distance;
      } else {
        // s += "\nNodes do NOT overlap.";
        // If there's no overlap, force is inversely proportional
        // to squared distance

        // Get clipping points for both nodes
        var point1 = findClippingPoint(node1, directionX, directionY);
        var point2 = findClippingPoint(node2, -1 * directionX, -1 * directionY);

        // Use clipping points to compute distance
        var distanceX = point2.x - point1.x;
        var distanceY = point2.y - point1.y;
        var distanceSqr = distanceX * distanceX + distanceY * distanceY;
        var distance = Math.sqrt(distanceSqr);
        // s += "\nDistance: " + distance;

        // Compute the module and components of the force vector
        var force = (node1.nodeRepulsion + node2.nodeRepulsion) / distanceSqr;
        var forceX = force * distanceX / distance;
        var forceY = force * distanceY / distance;
      }

      // Apply force
      if (!node1.isLocked) {
        node1.offsetX -= forceX;
        node1.offsetY -= forceY;
      }

      if (!node2.isLocked) {
        node2.offsetX += forceX;
        node2.offsetY += forceY;
      }

      // s += "\nForceX: " + forceX + " ForceY: " + forceY;
      // logDebug(s);

      return;
    };

    /**
     * @brief  : Determines whether two nodes overlap or not
     * @return : Amount of overlapping (0 => no overlap)
     */
    var nodesOverlap = function nodesOverlap(node1, node2, dX, dY) {

      if (dX > 0) {
        var overlapX = node1.maxX - node2.minX;
      } else {
        var overlapX = node2.maxX - node1.minX;
      }

      if (dY > 0) {
        var overlapY = node1.maxY - node2.minY;
      } else {
        var overlapY = node2.maxY - node1.minY;
      }

      if (overlapX >= 0 && overlapY >= 0) {
        return Math.sqrt(overlapX * overlapX + overlapY * overlapY);
      } else {
        return 0;
      }
    };

    /**
     * @brief : Finds the point in which an edge (direction dX, dY) intersects
     *          the rectangular bounding box of it's source/target node
     */
    var findClippingPoint = function findClippingPoint(node, dX, dY) {

      // Shorcuts
      var X = node.positionX;
      var Y = node.positionY;
      var H = node.height || 1;
      var W = node.width || 1;
      var dirSlope = dY / dX;
      var nodeSlope = H / W;

      // var s = 'Computing clipping point of node ' + node.id +
      //   " . Height:  " + H + ", Width: " + W +
      //   "\nDirection " + dX + ", " + dY;
      //
      // Compute intersection
      var res = {};

      // Case: Vertical direction (up)
      if (0 === dX && 0 < dY) {
        res.x = X;
        // s += "\nUp direction";
        res.y = Y + H / 2;

        return res;
      }

      // Case: Vertical direction (down)
      if (0 === dX && 0 > dY) {
        res.x = X;
        res.y = Y + H / 2;
        // s += "\nDown direction";

        return res;
      }

      // Case: Intersects the right border
      if (0 < dX && -1 * nodeSlope <= dirSlope && dirSlope <= nodeSlope) {
        res.x = X + W / 2;
        res.y = Y + W * dY / 2 / dX;
        // s += "\nRightborder";

        return res;
      }

      // Case: Intersects the left border
      if (0 > dX && -1 * nodeSlope <= dirSlope && dirSlope <= nodeSlope) {
        res.x = X - W / 2;
        res.y = Y - W * dY / 2 / dX;
        // s += "\nLeftborder";

        return res;
      }

      // Case: Intersects the top border
      if (0 < dY && (dirSlope <= -1 * nodeSlope || dirSlope >= nodeSlope)) {
        res.x = X + H * dX / 2 / dY;
        res.y = Y + H / 2;
        // s += "\nTop border";

        return res;
      }

      // Case: Intersects the bottom border
      if (0 > dY && (dirSlope <= -1 * nodeSlope || dirSlope >= nodeSlope)) {
        res.x = X - H * dX / 2 / dY;
        res.y = Y - H / 2;
        // s += "\nBottom border";

        return res;
      }

      // s += "\nClipping point found at " + res.x + ", " + res.y;
      // logDebug(s);
      return res;
    };

    /**
     * @brief : Calculates all edge forces
     */
    var calculateEdgeForces = function calculateEdgeForces(layoutInfo, options) {
      // Iterate over all edges
      for (var i = 0; i < layoutInfo.edgeSize; i++) {
        // Get edge, source & target nodes
        var edge = layoutInfo.layoutEdges[i];
        var sourceIx = layoutInfo.idToIndex[edge.sourceId];
        var source = layoutInfo.layoutNodes[sourceIx];
        var targetIx = layoutInfo.idToIndex[edge.targetId];
        var target = layoutInfo.layoutNodes[targetIx];

        // Get direction of line connecting both node centers
        var directionX = target.positionX - source.positionX;
        var directionY = target.positionY - source.positionY;

        // If both centers are the same, do nothing.
        // A random force has already been applied as node repulsion
        if (0 === directionX && 0 === directionY) {
          continue;
        }

        // Get clipping points for both nodes
        var point1 = findClippingPoint(source, directionX, directionY);
        var point2 = findClippingPoint(target, -1 * directionX, -1 * directionY);

        var lx = point2.x - point1.x;
        var ly = point2.y - point1.y;
        var l = Math.sqrt(lx * lx + ly * ly);

        var force = Math.pow(edge.idealLength - l, 2) / edge.elasticity;

        if (0 !== l) {
          var forceX = force * lx / l;
          var forceY = force * ly / l;
        } else {
          var forceX = 0;
          var forceY = 0;
        }

        // Add this force to target and source nodes
        if (!source.isLocked) {
          source.offsetX += forceX;
          source.offsetY += forceY;
        }

        if (!target.isLocked) {
          target.offsetX -= forceX;
          target.offsetY -= forceY;
        }

        // var s = 'Edge force between nodes ' + source.id + ' and ' + target.id;
        // s += "\nDistance: " + l + " Force: (" + forceX + ", " + forceY + ")";
        // logDebug(s);
      }
    };

    /**
     * @brief : Computes gravity forces for all nodes
     */
    var calculateGravityForces = function calculateGravityForces(layoutInfo, options) {
      var distThreshold = 1;

      // var s = 'calculateGravityForces';
      // logDebug(s);
      for (var i = 0; i < layoutInfo.graphSet.length; i++) {
        var graph = layoutInfo.graphSet[i];
        var numNodes = graph.length;

        // s = "Set: " + graph.toString();
        // logDebug(s);

        // Compute graph center
        if (0 === i) {
          var centerX = layoutInfo.clientHeight / 2;
          var centerY = layoutInfo.clientWidth / 2;
        } else {
          // Get Parent node for this graph, and use its position as center
          var temp = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[0]]];
          var parent = layoutInfo.layoutNodes[layoutInfo.idToIndex[temp.parentId]];
          var centerX = parent.positionX;
          var centerY = parent.positionY;
        }
        // s = "Center found at: " + centerX + ", " + centerY;
        // logDebug(s);

        // Apply force to all nodes in graph
        for (var j = 0; j < numNodes; j++) {
          var node = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]];
          // s = "Node: " + node.id;

          if (node.isLocked) {
            continue;
          }

          var dx = centerX - node.positionX;
          var dy = centerY - node.positionY;
          var d = Math.sqrt(dx * dx + dy * dy);
          if (d > distThreshold) {
            var fx = options.gravity * dx / d;
            var fy = options.gravity * dy / d;
            node.offsetX += fx;
            node.offsetY += fy;
            // s += ": Applied force: " + fx + ", " + fy;
          } else {}
            // s += ": skypped since it's too close to center";

            // logDebug(s);
        }
      }
    };

    /**
     * @brief          : This function propagates the existing offsets from
     *                   parent nodes to its descendents.
     * @arg layoutInfo : layoutInfo Object
     * @arg cy         : cytoscape Object
     * @arg options    : Layout options
     */
    var propagateForces = function propagateForces(layoutInfo, options) {
      // Inline implementation of a queue, used for traversing the graph in BFS order
      var queue = [];
      var start = 0; // Points to the start the queue
      var end = -1; // Points to the end of the queue

      // logDebug('propagateForces');

      // Start by visiting the nodes in the root graph
      queue.push.apply(queue, layoutInfo.graphSet[0]);
      end += layoutInfo.graphSet[0].length;

      // Traverse the graph, level by level,
      while (start <= end) {
        // Get the node to visit and remove it from queue
        var nodeId = queue[start++];
        var nodeIndex = layoutInfo.idToIndex[nodeId];
        var node = layoutInfo.layoutNodes[nodeIndex];
        var children = node.children;

        // We only need to process the node if it's compound
        if (0 < children.length && !node.isLocked) {
          var offX = node.offsetX;
          var offY = node.offsetY;

          // var s = "Propagating offset from parent node : " + node.id +
          //   ". OffsetX: " + offX + ". OffsetY: " + offY;
          // s += "\n Children: " + children.toString();
          // logDebug(s);

          for (var i = 0; i < children.length; i++) {
            var childNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[children[i]]];
            // Propagate offset
            childNode.offsetX += offX;
            childNode.offsetY += offY;
            // Add children to queue to be visited
            queue[++end] = children[i];
          }

          // Reset parent offsets
          node.offsetX = 0;
          node.offsetY = 0;
        }
      }
    };

    /**
     * @brief : Updates the layout model positions, based on
     *          the accumulated forces
     */
    var updatePositions = function updatePositions(layoutInfo, options) {
      // var s = 'Updating positions';
      // logDebug(s);

      // Reset boundaries for compound nodes
      for (var i = 0; i < layoutInfo.nodeSize; i++) {
        var n = layoutInfo.layoutNodes[i];
        if (0 < n.children.length) {
          // logDebug("Resetting boundaries of compound node: " + n.id);
          n.maxX = undefined;
          n.minX = undefined;
          n.maxY = undefined;
          n.minY = undefined;
        }
      }

      for (var i = 0; i < layoutInfo.nodeSize; i++) {
        var n = layoutInfo.layoutNodes[i];
        if (0 < n.children.length || n.isLocked) {
          // No need to set compound or locked node position
          // logDebug("Skipping position update of node: " + n.id);
          continue;
        }
        // s = "Node: " + n.id + " Previous position: (" +
        // n.positionX + ", " + n.positionY + ").";

        // Limit displacement in order to improve stability
        var tempForce = limitForce(n.offsetX, n.offsetY, layoutInfo.temperature);
        n.positionX += tempForce.x;
        n.positionY += tempForce.y;
        n.offsetX = 0;
        n.offsetY = 0;
        n.minX = n.positionX - n.width;
        n.maxX = n.positionX + n.width;
        n.minY = n.positionY - n.height;
        n.maxY = n.positionY + n.height;
        // s += " New Position: (" + n.positionX + ", " + n.positionY + ").";
        // logDebug(s);

        // Update ancestry boudaries
        updateAncestryBoundaries(n, layoutInfo);
      }

      // Update size, position of compund nodes
      for (var i = 0; i < layoutInfo.nodeSize; i++) {
        var n = layoutInfo.layoutNodes[i];
        if (0 < n.children.length && !n.isLocked) {
          n.positionX = (n.maxX + n.minX) / 2;
          n.positionY = (n.maxY + n.minY) / 2;
          n.width = n.maxX - n.minX;
          n.height = n.maxY - n.minY;
          // s = "Updating position, size of compound node " + n.id;
          // s += "\nPositionX: " + n.positionX + ", PositionY: " + n.positionY;
          // s += "\nWidth: " + n.width + ", Height: " + n.height;
          // logDebug(s);
        }
      }
    };

    /**
     * @brief : Limits a force (forceX, forceY) to be not
     *          greater (in modulo) than max.
     8          Preserves force direction.
     */
    var limitForce = function limitForce(forceX, forceY, max) {
      // var s = "Limiting force: (" + forceX + ", " + forceY + "). Max: " + max;
      var force = Math.sqrt(forceX * forceX + forceY * forceY);

      if (force > max) {
        var res = {
          x: max * forceX / force,
          y: max * forceY / force
        };
      } else {
        var res = {
          x: forceX,
          y: forceY
        };
      }

      // s += ".\nResult: (" + res.x + ", " + res.y + ")";
      // logDebug(s);

      return res;
    };

    /**
     * @brief : Function used for keeping track of compound node
     *          sizes, since they should bound all their subnodes.
     */
    var updateAncestryBoundaries = function updateAncestryBoundaries(node, layoutInfo) {
      // var s = "Propagating new position/size of node " + node.id;
      var parentId = node.parentId;
      if (null == parentId) {
        // If there's no parent, we are done
        // s += ". No parent node.";
        // logDebug(s);
        return;
      }

      // Get Parent Node
      var p = layoutInfo.layoutNodes[layoutInfo.idToIndex[parentId]];
      var flag = false;

      // MaxX
      if (null == p.maxX || node.maxX + p.padRight > p.maxX) {
        p.maxX = node.maxX + p.padRight;
        flag = true;
        // s += "\nNew maxX for parent node " + p.id + ": " + p.maxX;
      }

      // MinX
      if (null == p.minX || node.minX - p.padLeft < p.minX) {
        p.minX = node.minX - p.padLeft;
        flag = true;
        // s += "\nNew minX for parent node " + p.id + ": " + p.minX;
      }

      // MaxY
      if (null == p.maxY || node.maxY + p.padBottom > p.maxY) {
        p.maxY = node.maxY + p.padBottom;
        flag = true;
        // s += "\nNew maxY for parent node " + p.id + ": " + p.maxY;
      }

      // MinY
      if (null == p.minY || node.minY - p.padTop < p.minY) {
        p.minY = node.minY - p.padTop;
        flag = true;
        // s += "\nNew minY for parent node " + p.id + ": " + p.minY;
      }

      // If updated boundaries, propagate changes upward
      if (flag) {
        // logDebug(s);
        return updateAncestryBoundaries(p, layoutInfo);
      }

      // s += ". No changes in boundaries/position of parent node " + p.id;
      // logDebug(s);
      return;
    };

    var separateComponents = function separateComponents(layutInfo, options) {
      var nodes = layoutInfo.layoutNodes;
      var components = [];

      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        var cid = node.cmptId;
        var component = components[cid] = components[cid] || [];

        component.push(node);
      }

      var totalA = 0;

      for (var i = 0; i < components.length; i++) {
        var c = components[i];

        if (!c) {
          continue;
        }

        c.x1 = Infinity;
        c.x2 = -Infinity;
        c.y1 = Infinity;
        c.y2 = -Infinity;

        for (var j = 0; j < c.length; j++) {
          var n = c[j];

          c.x1 = Math.min(c.x1, n.positionX - n.width / 2);
          c.x2 = Math.max(c.x2, n.positionX + n.width / 2);
          c.y1 = Math.min(c.y1, n.positionY - n.height / 2);
          c.y2 = Math.max(c.y2, n.positionY + n.height / 2);
        }

        c.w = c.x2 - c.x1;
        c.h = c.y2 - c.y1;

        totalA += c.w * c.h;
      }

      components.sort(function (c1, c2) {
        return c2.w * c2.h - c1.w * c1.h;
      });

      var x = 0;
      var y = 0;
      var usedW = 0;
      var rowH = 0;
      var maxRowW = Math.sqrt(totalA) * layoutInfo.clientWidth / layoutInfo.clientHeight;

      for (var i = 0; i < components.length; i++) {
        var c = components[i];

        if (!c) {
          continue;
        }

        for (var j = 0; j < c.length; j++) {
          var n = c[j];

          if (!n.isLocked) {
            n.positionX += x;
            n.positionY += y;
          }
        }

        x += c.w + options.componentSpacing;
        usedW += c.w + options.componentSpacing;
        rowH = Math.max(rowH, c.h);

        if (usedW > maxRowW) {
          y += rowH + options.componentSpacing;
          x = 0;
          usedW = 0;
          rowH = 0;
        }
      }
    };

    var mainLoop = function mainLoop(i) {
      if (stopped) {
        // logDebug("Layout manually stopped. Stopping computation in step " + i);
        return false;
      }

      // Do one step in the phisical simulation
      step(layoutInfo, options, i);

      // Update temperature
      layoutInfo.temperature = layoutInfo.temperature * options.coolingFactor;
      // logDebug("New temperature: " + layoutInfo.temperature);

      if (layoutInfo.temperature < options.minTemp) {
        // logDebug("Temperature drop below minimum threshold. Stopping computation in step " + i);
        return false;
      }

      return true;
    };

    var i = 0;
    var loopRet;

    do {
      var f = 0;

      while (f < options.refresh && i < options.numIter) {
        var loopRet = mainLoop(i);
        if (!loopRet) {
          break;
        }

        f++;
        i++;
      }

      if (options.animate === true) {
        broadcast(layoutInfo.layoutNodes); // eslint-disable-line no-undef
      }
    } while (loopRet && i + 1 < options.numIter);

    separateComponents(layoutInfo, options);

    return layoutInfo;
  }).then(function (layoutInfoUpdated) {
    layoutInfo.layoutNodes = layoutInfoUpdated.layoutNodes; // get the positions

    thread.stop();
    done();
  });

  var done = function done() {
    if (options.animate === true || options.animate === false) {
      refresh({
        force: true,
        next: function next() {
          // Layout has finished
          layout.one('layoutstop', options.stop);
          layout.emit({ type: 'layoutstop', layout: layout });
        }
      });
    } else {
      options.eles.nodes().layoutPositions(layout, options, function (node) {
        var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[node.data('id')]];

        return { x: lnode.positionX, y: lnode.positionY };
      });
    }
  };

  return this; // chaining
};

/**
 * @brief : called on continuous layouts to stop them before they finish
 */
CoseLayout.prototype.stop = function () {
  this.stopped = true;

  if (this.thread) {
    this.thread.stop();
  }

  this.emit('layoutstop');

  return this; // chaining
};

CoseLayout.prototype.destroy = function () {
  if (this.thread) {
    this.thread.stop();
  }

  return this; // chaining
};

/**
 * @brief     : Creates an object which is contains all the data
 *              used in the layout process
 * @arg cy    : cytoscape.js object
 * @return    : layoutInfo object initialized
 */
var createLayoutInfo = function createLayoutInfo(cy, layout, options) {
  // Shortcut
  var edges = options.eles.edges();
  var nodes = options.eles.nodes();

  var layoutInfo = {
    isCompound: cy.hasCompoundNodes(),
    layoutNodes: [],
    idToIndex: {},
    nodeSize: nodes.size(),
    graphSet: [],
    indexToGraph: [],
    layoutEdges: [],
    edgeSize: edges.size(),
    temperature: options.initialTemp,
    clientWidth: cy.width(),
    clientHeight: cy.width(),
    boundingBox: math.makeBoundingBox(options.boundingBox ? options.boundingBox : {
      x1: 0, y1: 0, w: cy.width(), h: cy.height()
    })
  };

  var components = options.eles.components();
  var id2cmptId = {};

  for (var i = 0; i < components.length; i++) {
    var component = components[i];

    for (var j = 0; j < component.length; j++) {
      var node = component[j];

      id2cmptId[node.id()] = i;
    }
  }

  // Iterate over all nodes, creating layout nodes
  for (var i = 0; i < layoutInfo.nodeSize; i++) {
    var n = nodes[i];
    var nbb = n.layoutDimensions(options);

    var tempNode = {};
    tempNode.isLocked = n.locked();
    tempNode.id = n.data('id');
    tempNode.parentId = n.data('parent');
    tempNode.cmptId = id2cmptId[n.id()];
    tempNode.children = [];
    tempNode.positionX = n.position('x');
    tempNode.positionY = n.position('y');
    tempNode.offsetX = 0;
    tempNode.offsetY = 0;
    tempNode.height = nbb.w;
    tempNode.width = nbb.h;
    tempNode.maxX = tempNode.positionX + tempNode.width / 2;
    tempNode.minX = tempNode.positionX - tempNode.width / 2;
    tempNode.maxY = tempNode.positionY + tempNode.height / 2;
    tempNode.minY = tempNode.positionY - tempNode.height / 2;
    tempNode.padLeft = parseFloat(n.style('padding'));
    tempNode.padRight = parseFloat(n.style('padding'));
    tempNode.padTop = parseFloat(n.style('padding'));
    tempNode.padBottom = parseFloat(n.style('padding'));

    // forces
    tempNode.nodeRepulsion = is.fn(options.nodeRepulsion) ? options.nodeRepulsion(n) : options.nodeRepulsion;

    // Add new node
    layoutInfo.layoutNodes.push(tempNode);
    // Add entry to id-index map
    layoutInfo.idToIndex[tempNode.id] = i;
  }

  // Inline implementation of a queue, used for traversing the graph in BFS order
  var queue = [];
  var start = 0; // Points to the start the queue
  var end = -1; // Points to the end of the queue

  var tempGraph = [];

  // Second pass to add child information and
  // initialize queue for hierarchical traversal
  for (var i = 0; i < layoutInfo.nodeSize; i++) {
    var n = layoutInfo.layoutNodes[i];
    var p_id = n.parentId;
    // Check if node n has a parent node
    if (null != p_id) {
      // Add node Id to parent's list of children
      layoutInfo.layoutNodes[layoutInfo.idToIndex[p_id]].children.push(n.id);
    } else {
      // If a node doesn't have a parent, then it's in the root graph
      queue[++end] = n.id;
      tempGraph.push(n.id);
    }
  }

  // Add root graph to graphSet
  layoutInfo.graphSet.push(tempGraph);

  // Traverse the graph, level by level,
  while (start <= end) {
    // Get the node to visit and remove it from queue
    var node_id = queue[start++];
    var node_ix = layoutInfo.idToIndex[node_id];
    var node = layoutInfo.layoutNodes[node_ix];
    var children = node.children;
    if (children.length > 0) {
      // Add children nodes as a new graph to graph set
      layoutInfo.graphSet.push(children);
      // Add children to que queue to be visited
      for (var i = 0; i < children.length; i++) {
        queue[++end] = children[i];
      }
    }
  }

  // Create indexToGraph map
  for (var i = 0; i < layoutInfo.graphSet.length; i++) {
    var graph = layoutInfo.graphSet[i];
    for (var j = 0; j < graph.length; j++) {
      var index = layoutInfo.idToIndex[graph[j]];
      layoutInfo.indexToGraph[index] = i;
    }
  }

  // Iterate over all edges, creating Layout Edges
  for (var i = 0; i < layoutInfo.edgeSize; i++) {
    var e = edges[i];
    var tempEdge = {};
    tempEdge.id = e.data('id');
    tempEdge.sourceId = e.data('source');
    tempEdge.targetId = e.data('target');

    // Compute ideal length
    var idealLength = is.fn(options.idealEdgeLength) ? options.idealEdgeLength(e) : options.idealEdgeLength;
    var elasticity = is.fn(options.edgeElasticity) ? options.edgeElasticity(e) : options.edgeElasticity;

    // Check if it's an inter graph edge
    var sourceIx = layoutInfo.idToIndex[tempEdge.sourceId];
    var targetIx = layoutInfo.idToIndex[tempEdge.targetId];
    var sourceGraph = layoutInfo.indexToGraph[sourceIx];
    var targetGraph = layoutInfo.indexToGraph[targetIx];

    if (sourceGraph != targetGraph) {
      // Find lowest common graph ancestor
      var lca = findLCA(tempEdge.sourceId, tempEdge.targetId, layoutInfo);

      // Compute sum of node depths, relative to lca graph
      var lcaGraph = layoutInfo.graphSet[lca];
      var depth = 0;

      // Source depth
      var tempNode = layoutInfo.layoutNodes[sourceIx];
      while (-1 === lcaGraph.indexOf(tempNode.id)) {
        tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];
        depth++;
      }

      // Target depth
      tempNode = layoutInfo.layoutNodes[targetIx];
      while (-1 === lcaGraph.indexOf(tempNode.id)) {
        tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];
        depth++;
      }

      // logDebug('LCA of nodes ' + tempEdge.sourceId + ' and ' + tempEdge.targetId +
      //  ". Index: " + lca + " Contents: " + lcaGraph.toString() +
      //  ". Depth: " + depth);

      // Update idealLength
      idealLength *= depth * options.nestingFactor;
    }

    tempEdge.idealLength = idealLength;
    tempEdge.elasticity = elasticity;

    layoutInfo.layoutEdges.push(tempEdge);
  }

  // Finally, return layoutInfo object
  return layoutInfo;
};

/**
 * @brief : This function finds the index of the lowest common
 *          graph ancestor between 2 nodes in the subtree
 *          (from the graph hierarchy induced tree) whose
 *          root is graphIx
 *
 * @arg node1: node1's ID
 * @arg node2: node2's ID
 * @arg layoutInfo: layoutInfo object
 *
 */
var findLCA = function findLCA(node1, node2, layoutInfo) {
  // Find their common ancester, starting from the root graph
  var res = findLCA_aux(node1, node2, 0, layoutInfo);
  if (2 > res.count) {
    // If aux function couldn't find the common ancester,
    // then it is the root graph
    return 0;
  } else {
    return res.graph;
  }
};

/**
 * @brief          : Auxiliary function used for LCA computation
 *
 * @arg node1      : node1's ID
 * @arg node2      : node2's ID
 * @arg graphIx    : subgraph index
 * @arg layoutInfo : layoutInfo object
 *
 * @return         : object of the form {count: X, graph: Y}, where:
 *                   X is the number of ancesters (max: 2) found in
 *                   graphIx (and it's subgraphs),
 *                   Y is the graph index of the lowest graph containing
 *                   all X nodes
 */
var findLCA_aux = function findLCA_aux(node1, node2, graphIx, layoutInfo) {
  var graph = layoutInfo.graphSet[graphIx];
  // If both nodes belongs to graphIx
  if (-1 < graph.indexOf(node1) && -1 < graph.indexOf(node2)) {
    return { count: 2, graph: graphIx };
  }

  // Make recursive calls for all subgraphs
  var c = 0;
  for (var i = 0; i < graph.length; i++) {
    var nodeId = graph[i];
    var nodeIx = layoutInfo.idToIndex[nodeId];
    var children = layoutInfo.layoutNodes[nodeIx].children;

    // If the node has no child, skip it
    if (0 === children.length) {
      continue;
    }

    var childGraphIx = layoutInfo.indexToGraph[layoutInfo.idToIndex[children[0]]];
    var result = findLCA_aux(node1, node2, childGraphIx, layoutInfo);
    if (0 === result.count) {
      // Neither node1 nor node2 are present in this subgraph
      continue;
    } else if (1 === result.count) {
      // One of (node1, node2) is present in this subgraph
      c++;
      if (2 === c) {
        // We've already found both nodes, no need to keep searching
        break;
      }
    } else {
      // Both nodes are present in this subgraph
      return result;
    }
  }

  return { count: c, graph: graphIx };
};

/**
 * @brief: printsLayoutInfo into js console
 *         Only used for debbuging
 */
var printLayoutInfo = function printLayoutInfo(layoutInfo) {
  /* eslint-disable */

  if (!DEBUG) {
    return;
  }
  console.debug('layoutNodes:');
  for (var i = 0; i < layoutInfo.nodeSize; i++) {
    var n = layoutInfo.layoutNodes[i];
    var s = '\nindex: ' + i + '\nId: ' + n.id + '\nChildren: ' + n.children.toString() + '\nparentId: ' + n.parentId + '\npositionX: ' + n.positionX + '\npositionY: ' + n.positionY + '\nOffsetX: ' + n.offsetX + '\nOffsetY: ' + n.offsetY + '\npadLeft: ' + n.padLeft + '\npadRight: ' + n.padRight + '\npadTop: ' + n.padTop + '\npadBottom: ' + n.padBottom;

    console.debug(s);
  }

  console.debug('idToIndex');
  for (var i in layoutInfo.idToIndex) {
    console.debug('Id: ' + i + '\nIndex: ' + layoutInfo.idToIndex[i]);
  }

  console.debug('Graph Set');
  var set = layoutInfo.graphSet;
  for (var i = 0; i < set.length; i++) {
    console.debug('Set : ' + i + ': ' + set[i].toString());
  }

  var s = 'IndexToGraph';
  for (var i = 0; i < layoutInfo.indexToGraph.length; i++) {
    s += '\nIndex : ' + i + ' Graph: ' + layoutInfo.indexToGraph[i];
  }
  console.debug(s);

  s = 'Layout Edges';
  for (var i = 0; i < layoutInfo.layoutEdges.length; i++) {
    var e = layoutInfo.layoutEdges[i];
    s += '\nEdge Index: ' + i + ' ID: ' + e.id + ' SouceID: ' + e.sourceId + ' TargetId: ' + e.targetId + ' Ideal Length: ' + e.idealLength;
  }
  console.debug(s);

  s = 'nodeSize: ' + layoutInfo.nodeSize;
  s += '\nedgeSize: ' + layoutInfo.edgeSize;
  s += '\ntemperature: ' + layoutInfo.temperature;
  console.debug(s);

  return;
  /* eslint-enable */
};

/**
 * @brief : Randomizes the position of all nodes
 */
var randomizePositions = function randomizePositions(layoutInfo, cy) {
  var width = layoutInfo.clientWidth;
  var height = layoutInfo.clientHeight;

  for (var i = 0; i < layoutInfo.nodeSize; i++) {
    var n = layoutInfo.layoutNodes[i];

    // No need to randomize compound nodes or locked nodes
    if (0 === n.children.length && !n.isLocked) {
      n.positionX = Math.random() * width;
      n.positionY = Math.random() * height;
    }
  }
};

/**
 * @brief          : Updates the positions of nodes in the network
 * @arg layoutInfo : LayoutInfo object
 * @arg cy         : Cytoscape object
 * @arg options    : Layout options
 */
var refreshPositions = function refreshPositions(layoutInfo, cy, options) {
  // var s = 'Refreshing positions';
  // logDebug(s);

  var layout = options.layout;
  var nodes = options.eles.nodes();
  var bb = layoutInfo.boundingBox;
  var coseBB = { x1: Infinity, x2: -Infinity, y1: Infinity, y2: -Infinity };

  if (options.boundingBox) {
    nodes.forEach(function (node) {
      var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[node.data('id')]];

      coseBB.x1 = Math.min(coseBB.x1, lnode.positionX);
      coseBB.x2 = Math.max(coseBB.x2, lnode.positionX);

      coseBB.y1 = Math.min(coseBB.y1, lnode.positionY);
      coseBB.y2 = Math.max(coseBB.y2, lnode.positionY);
    });

    coseBB.w = coseBB.x2 - coseBB.x1;
    coseBB.h = coseBB.y2 - coseBB.y1;
  }

  nodes.positions(function (ele, i) {
    var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[ele.data('id')]];
    // s = "Node: " + lnode.id + ". Refreshed position: (" +
    // lnode.positionX + ", " + lnode.positionY + ").";
    // logDebug(s);

    if (options.boundingBox) {
      // then add extra bounding box constraint
      var pctX = (lnode.positionX - coseBB.x1) / coseBB.w;
      var pctY = (lnode.positionY - coseBB.y1) / coseBB.h;

      return {
        x: bb.x1 + pctX * bb.w,
        y: bb.y1 + pctY * bb.h
      };
    } else {
      return {
        x: lnode.positionX,
        y: lnode.positionY
      };
    }
  });

  // Trigger layoutReady only on first call
  if (true !== layoutInfo.ready) {
    // s = 'Triggering layoutready';
    // logDebug(s);
    layoutInfo.ready = true;
    layout.one('layoutready', options.ready);
    layout.emit({ type: 'layoutready', layout: this });
  }
};

/**
 * @brief : Logs a debug message in JS console, if DEBUG is ON
 */
// var logDebug = function(text) {
//   if (DEBUG) {
//     console.debug(text);
//   }
// };

module.exports = CoseLayout;

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);
var math = __webpack_require__(2);

var defaults = {
  fit: true, // whether to fit the viewport to the graph
  padding: 30, // padding used on fit
  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
  avoidOverlapPadding: 10, // extra spacing around nodes when avoidOverlap: true
  nodeDimensionsIncludeLabels: false, // Excludes the label when calculating node bounding boxes for the layout algorithm
  spacingFactor: undefined, // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
  condense: false, // uses all available space on false, uses minimal space on true
  rows: undefined, // force num of rows in the grid
  cols: undefined, // force num of columns in the grid
  position: function position(node) {}, // returns { row, col } for element
  sort: undefined, // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }
  animate: false, // whether to transition the node positions
  animationDuration: 500, // duration of animation in ms if enabled
  animationEasing: undefined, // easing of animation if enabled
  animateFilter: function animateFilter(node, i) {
    return true;
  }, // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
  ready: undefined, // callback on layoutready
  stop: undefined, // callback on layoutstop
  transform: function transform(node, position) {
    return position;
  } // transform a given node position. Useful for changing flow direction in discrete layouts 
};

function GridLayout(options) {
  this.options = util.extend({}, defaults, options);
}

GridLayout.prototype.run = function () {
  var params = this.options;
  var options = params;

  var cy = params.cy;
  var eles = options.eles;
  var nodes = eles.nodes().not(':parent');

  if (options.sort) {
    nodes = nodes.sort(options.sort);
  }

  var bb = math.makeBoundingBox(options.boundingBox ? options.boundingBox : {
    x1: 0, y1: 0, w: cy.width(), h: cy.height()
  });

  if (bb.h === 0 || bb.w === 0) {
    nodes.layoutPositions(this, options, function (ele) {
      return { x: bb.x1, y: bb.y1 };
    });
  } else {

    // width/height * splits^2 = cells where splits is number of times to split width
    var cells = nodes.size();
    var splits = Math.sqrt(cells * bb.h / bb.w);
    var rows = Math.round(splits);
    var cols = Math.round(bb.w / bb.h * splits);

    var small = function small(val) {
      if (val == null) {
        return Math.min(rows, cols);
      } else {
        var min = Math.min(rows, cols);
        if (min == rows) {
          rows = val;
        } else {
          cols = val;
        }
      }
    };

    var large = function large(val) {
      if (val == null) {
        return Math.max(rows, cols);
      } else {
        var max = Math.max(rows, cols);
        if (max == rows) {
          rows = val;
        } else {
          cols = val;
        }
      }
    };

    var oRows = options.rows;
    var oCols = options.cols != null ? options.cols : options.columns;

    // if rows or columns were set in options, use those values
    if (oRows != null && oCols != null) {
      rows = oRows;
      cols = oCols;
    } else if (oRows != null && oCols == null) {
      rows = oRows;
      cols = Math.ceil(cells / rows);
    } else if (oRows == null && oCols != null) {
      cols = oCols;
      rows = Math.ceil(cells / cols);
    }

    // otherwise use the automatic values and adjust accordingly

    // if rounding was up, see if we can reduce rows or columns
    else if (cols * rows > cells) {
        var sm = small();
        var lg = large();

        // reducing the small side takes away the most cells, so try it first
        if ((sm - 1) * lg >= cells) {
          small(sm - 1);
        } else if ((lg - 1) * sm >= cells) {
          large(lg - 1);
        }
      } else {

        // if rounding was too low, add rows or columns
        while (cols * rows < cells) {
          var _sm = small();
          var _lg = large();

          // try to add to larger side first (adds less in multiplication)
          if ((_lg + 1) * _sm >= cells) {
            large(_lg + 1);
          } else {
            small(_sm + 1);
          }
        }
      }

    var cellWidth = bb.w / cols;
    var cellHeight = bb.h / rows;

    if (options.condense) {
      cellWidth = 0;
      cellHeight = 0;
    }

    if (options.avoidOverlap) {
      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        var pos = node._private.position;

        if (pos.x == null || pos.y == null) {
          // for bb
          pos.x = 0;
          pos.y = 0;
        }

        var nbb = node.layoutDimensions(options);
        var p = options.avoidOverlapPadding;

        var w = nbb.w + p;
        var h = nbb.h + p;

        cellWidth = Math.max(cellWidth, w);
        cellHeight = Math.max(cellHeight, h);
      }
    }

    var cellUsed = {}; // e.g. 'c-0-2' => true

    var used = function used(row, col) {
      return cellUsed['c-' + row + '-' + col] ? true : false;
    };

    var use = function use(row, col) {
      cellUsed['c-' + row + '-' + col] = true;
    };

    // to keep track of current cell position
    var row = 0;
    var col = 0;
    var moveToNextCell = function moveToNextCell() {
      col++;
      if (col >= cols) {
        col = 0;
        row++;
      }
    };

    // get a cache of all the manual positions
    var id2manPos = {};
    for (var _i = 0; _i < nodes.length; _i++) {
      var _node = nodes[_i];
      var rcPos = options.position(_node);

      if (rcPos && (rcPos.row !== undefined || rcPos.col !== undefined)) {
        // must have at least row or col def'd
        var _pos = {
          row: rcPos.row,
          col: rcPos.col
        };

        if (_pos.col === undefined) {
          // find unused col
          _pos.col = 0;

          while (used(_pos.row, _pos.col)) {
            _pos.col++;
          }
        } else if (_pos.row === undefined) {
          // find unused row
          _pos.row = 0;

          while (used(_pos.row, _pos.col)) {
            _pos.row++;
          }
        }

        id2manPos[_node.id()] = _pos;
        use(_pos.row, _pos.col);
      }
    }

    var getPos = function getPos(element, i) {
      var x = void 0,
          y = void 0;

      if (element.locked() || element.isParent()) {
        return false;
      }

      // see if we have a manual position set
      var rcPos = id2manPos[element.id()];
      if (rcPos) {
        x = rcPos.col * cellWidth + cellWidth / 2 + bb.x1;
        y = rcPos.row * cellHeight + cellHeight / 2 + bb.y1;
      } else {
        // otherwise set automatically

        while (used(row, col)) {
          moveToNextCell();
        }

        x = col * cellWidth + cellWidth / 2 + bb.x1;
        y = row * cellHeight + cellHeight / 2 + bb.y1;
        use(row, col);

        moveToNextCell();
      }

      return { x: x, y: y };
    };

    nodes.layoutPositions(this, options, getPos);
  }

  return this; // chaining
};

module.exports = GridLayout;

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);

// default layout options
var defaults = {
  ready: function ready() {}, // on layoutready
  stop: function stop() {} // on layoutstop
};

// constructor
// options : object containing layout options
function NullLayout(options) {
  this.options = util.extend({}, defaults, options);
}

// runs the layout
NullLayout.prototype.run = function () {
  var options = this.options;
  var eles = options.eles; // elements to consider in the layout
  var layout = this;

  // cy is automatically populated for us in the constructor
  var cy = options.cy; // jshint ignore:line

  layout.emit('layoutstart');

  // puts all nodes at (0, 0)
  eles.nodes().positions(function () {
    return {
      x: 0,
      y: 0
    };
  });

  // trigger layoutready when each node has had its position set at least once
  layout.one('layoutready', options.ready);
  layout.emit('layoutready');

  // trigger layoutstop when the layout stops (e.g. finishes)
  layout.one('layoutstop', options.stop);
  layout.emit('layoutstop');

  return this; // chaining
};

// called on continuous layouts to stop them before they finish
NullLayout.prototype.stop = function () {
  return this; // chaining
};

module.exports = NullLayout;

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);
var is = __webpack_require__(0);

var defaults = {
  positions: undefined, // map of (node id) => (position obj); or function(node){ return somPos; }
  zoom: undefined, // the zoom level to set (prob want fit = false if set)
  pan: undefined, // the pan level to set (prob want fit = false if set)
  fit: true, // whether to fit to viewport
  padding: 30, // padding on fit
  animate: false, // whether to transition the node positions
  animationDuration: 500, // duration of animation in ms if enabled
  animationEasing: undefined, // easing of animation if enabled
  animateFilter: function animateFilter(node, i) {
    return true;
  }, // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
  ready: undefined, // callback on layoutready
  stop: undefined, // callback on layoutstop
  transform: function transform(node, position) {
    return position;
  } // transform a given node position. Useful for changing flow direction in discrete layouts 
};

function PresetLayout(options) {
  this.options = util.extend({}, defaults, options);
}

PresetLayout.prototype.run = function () {
  var options = this.options;
  var eles = options.eles;

  var nodes = eles.nodes();
  var posIsFn = is.fn(options.positions);

  function getPosition(node) {
    if (options.positions == null) {
      return null;
    }

    if (posIsFn) {
      return options.positions(node);
    }

    var pos = options.positions[node._private.data.id];

    if (pos == null) {
      return null;
    }

    return pos;
  }

  nodes.layoutPositions(this, options, function (node, i) {
    var position = getPosition(node);

    if (node.locked() || position == null) {
      return false;
    }

    return position;
  });

  return this; // chaining
};

module.exports = PresetLayout;

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);
var math = __webpack_require__(2);

var defaults = {
  fit: true, // whether to fit to viewport
  padding: 30, // fit padding
  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  animate: false, // whether to transition the node positions
  animationDuration: 500, // duration of animation in ms if enabled
  animationEasing: undefined, // easing of animation if enabled
  animateFilter: function animateFilter(node, i) {
    return true;
  }, // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
  ready: undefined, // callback on layoutready
  stop: undefined, // callback on layoutstop
  transform: function transform(node, position) {
    return position;
  } // transform a given node position. Useful for changing flow direction in discrete layouts 
};

function RandomLayout(options) {
  this.options = util.extend({}, defaults, options);
}

RandomLayout.prototype.run = function () {
  var options = this.options;
  var cy = options.cy;
  var eles = options.eles;
  var nodes = eles.nodes().not(':parent');

  var bb = math.makeBoundingBox(options.boundingBox ? options.boundingBox : {
    x1: 0, y1: 0, w: cy.width(), h: cy.height()
  });

  var getPos = function getPos(node, i) {
    return {
      x: bb.x1 + Math.round(Math.random() * bb.w),
      y: bb.y1 + Math.round(Math.random() * bb.h)
    };
  };

  nodes.layoutPositions(this, options, getPos);

  return this; // chaining
};

module.exports = RandomLayout;

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = [{ name: 'null', impl: __webpack_require__(106) }, { name: 'base', impl: __webpack_require__(107) }, { name: 'canvas', impl: __webpack_require__(123) }];

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function NullRenderer(options) {
  this.options = options;
  this.notifications = 0; // for testing
}

var noop = function noop() {};

NullRenderer.prototype = {
  recalculateRenderedStyle: noop,
  notify: function notify() {
    this.notifications++;
  },
  init: noop
};

module.exports = NullRenderer;

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);
var util = __webpack_require__(1);
var window = __webpack_require__(3);

var BaseRenderer = function BaseRenderer(options) {
  this.init(options);
};
var BR = BaseRenderer;
var BRp = BR.prototype;

BRp.clientFunctions = ['redrawHint', 'render', 'renderTo', 'matchCanvasSize', 'nodeShapeImpl', 'arrowShapeImpl'];

BRp.init = function (options) {
  var r = this;

  r.options = options;

  r.cy = options.cy;

  var ctr = r.container = options.cy.container();

  // prepend a stylesheet in the head such that
  if (window) {
    var document = window.document;
    var head = document.head;
    var stylesheetId = '__________cytoscape_stylesheet';
    var className = '__________cytoscape_container';
    var stylesheetAlreadyExists = document.getElementById(stylesheetId) != null;

    if (ctr.className.indexOf(className) < 0) {
      ctr.className = (ctr.className || '') + ' ' + className;
    }

    if (!stylesheetAlreadyExists) {
      var stylesheet = document.createElement('style');

      stylesheet.id = stylesheetId;
      stylesheet.innerHTML = '.' + className + ' { position: relative; }';

      head.insertBefore(stylesheet, head.children[0]); // first so lowest priority
    }

    var computedStyle = window.getComputedStyle(ctr);
    var position = computedStyle.getPropertyValue('position');

    if (position === 'static') {
      util.error('A Cytoscape container has style position:static and so can not use UI extensions properly');
    }
  }

  r.selection = [undefined, undefined, undefined, undefined, 0]; // Coordinates for selection box, plus enabled flag

  r.bezierProjPcts = [0.05, 0.225, 0.4, 0.5, 0.6, 0.775, 0.95];

  //--Pointer-related data
  r.hoverData = { down: null, last: null,
    downTime: null, triggerMode: null,
    dragging: false,
    initialPan: [null, null], capture: false };

  r.dragData = { possibleDragElements: [] };

  r.touchData = {
    start: null, capture: false,

    // These 3 fields related to tap, taphold events
    startPosition: [null, null, null, null, null, null],
    singleTouchStartTime: null,
    singleTouchMoved: true,

    now: [null, null, null, null, null, null],
    earlier: [null, null, null, null, null, null]
  };

  r.redraws = 0;
  r.showFps = options.showFps;
  r.debug = options.debug;

  r.hideEdgesOnViewport = options.hideEdgesOnViewport;
  r.hideLabelsOnViewport = options.hideLabelsOnViewport;
  r.textureOnViewport = options.textureOnViewport;
  r.wheelSensitivity = options.wheelSensitivity;
  r.motionBlurEnabled = options.motionBlur; // on by default
  r.forcedPixelRatio = options.pixelRatio;
  r.motionBlur = options.motionBlur; // for initial kick off
  r.motionBlurOpacity = options.motionBlurOpacity;
  r.motionBlurTransparency = 1 - r.motionBlurOpacity;
  r.motionBlurPxRatio = 1;
  r.mbPxRBlurry = 1; //0.8;
  r.minMbLowQualFrames = 4;
  r.fullQualityMb = false;
  r.clearedForMotionBlur = [];
  r.desktopTapThreshold = options.desktopTapThreshold;
  r.desktopTapThreshold2 = options.desktopTapThreshold * options.desktopTapThreshold;
  r.touchTapThreshold = options.touchTapThreshold;
  r.touchTapThreshold2 = options.touchTapThreshold * options.touchTapThreshold;
  r.tapholdDuration = 500;

  r.bindings = [];
  r.beforeRenderCallbacks = [];
  r.beforeRenderPriorities = { // higher priority execs before lower one
    animations: 400,
    eleCalcs: 300,
    eleTxrDeq: 200,
    lyrTxrDeq: 100
  };

  r.registerNodeShapes();
  r.registerArrowShapes();
  r.registerCalculationListeners();
};

BRp.notify = function (params) {
  var types;
  var r = this;

  // the renderer can't be notified after it's destroyed
  if (this.destroyed) {
    return;
  }

  if (is.array(params.type)) {
    types = params.type;
  } else {
    types = [params.type];
  }

  var has = {};
  for (var i = 0; i < types.length; i++) {
    var type = types[i];

    has[type] = true;
  } // for

  if (has['init']) {
    r.load();
    return;
  }

  if (has['destroy']) {
    r.destroy();
    return;
  }

  if (has['add'] || has['remove'] || has['load'] || has['zorder']) {
    r.invalidateCachedZSortedEles();
  }

  if (has['viewport']) {
    r.redrawHint('select', true);
  }

  if (has['load'] || has['resize']) {
    r.invalidateContainerClientCoordsCache();
    r.matchCanvasSize(r.container);
  }

  r.redrawHint('eles', true);
  r.redrawHint('drag', true);

  this.startRenderLoop();

  this.redraw();
};

BRp.destroy = function () {
  var r = this;

  r.destroyed = true;

  r.cy.stopAnimationLoop();

  for (var i = 0; i < r.bindings.length; i++) {
    var binding = r.bindings[i];
    var b = binding;
    var tgt = b.target;

    (tgt.off || tgt.removeEventListener).apply(tgt, b.args);
  }

  r.bindings = [];
  r.beforeRenderCallbacks = [];
  r.onUpdateEleCalcsFns = [];

  if (r.removeObserver) {
    r.removeObserver.disconnect();
  }

  if (r.styleObserver) {
    r.styleObserver.disconnect();
  }

  if (r.labelCalcDiv) {
    try {
      document.body.removeChild(r.labelCalcDiv); // eslint-disable-line no-undef
    } catch (e) {
      // ie10 issue #1014
    }
  }
};

[__webpack_require__(108), __webpack_require__(109), __webpack_require__(119), __webpack_require__(120), __webpack_require__(121), __webpack_require__(122)].forEach(function (props) {
  util.extend(BRp, props);
});

module.exports = BR;

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var math = __webpack_require__(2);
var is = __webpack_require__(0);
var util = __webpack_require__(1);

var BRp = {};

BRp.arrowShapeWidth = 0.3;

BRp.registerArrowShapes = function () {
  var arrowShapes = this.arrowShapes = {};
  var renderer = this;

  // Contract for arrow shapes:
  // 0, 0 is arrow tip
  // (0, 1) is direction towards node
  // (1, 0) is right
  //
  // functional api:
  // collide: check x, y in shape
  // roughCollide: called before collide, no false negatives
  // draw: draw
  // spacing: dist(arrowTip, nodeBoundary)
  // gap: dist(edgeTip, nodeBoundary), edgeTip may != arrowTip

  var bbCollide = function bbCollide(x, y, size, angle, translation, edgeWidth, padding) {
    var x1 = translation.x - size / 2 - padding;
    var x2 = translation.x + size / 2 + padding;
    var y1 = translation.y - size / 2 - padding;
    var y2 = translation.y + size / 2 + padding;

    var inside = x1 <= x && x <= x2 && y1 <= y && y <= y2;

    return inside;
  };

  var transform = function transform(x, y, size, angle, translation) {
    var xRotated = x * Math.cos(angle) - y * Math.sin(angle);
    var yRotated = x * Math.sin(angle) + y * Math.cos(angle);

    var xScaled = xRotated * size;
    var yScaled = yRotated * size;

    var xTranslated = xScaled + translation.x;
    var yTranslated = yScaled + translation.y;

    return {
      x: xTranslated,
      y: yTranslated
    };
  };

  var transformPoints = function transformPoints(pts, size, angle, translation) {
    var retPts = [];

    for (var i = 0; i < pts.length; i += 2) {
      var x = pts[i];
      var y = pts[i + 1];

      retPts.push(transform(x, y, size, angle, translation));
    }

    return retPts;
  };

  var pointsToArr = function pointsToArr(pts) {
    var ret = [];

    for (var i = 0; i < pts.length; i++) {
      var p = pts[i];

      ret.push(p.x, p.y);
    }

    return ret;
  };

  var standardGap = function standardGap(edge) {
    return edge.pstyle('width').pfValue * edge.pstyle('arrow-scale').pfValue * 2;
  };

  var defineArrowShape = function defineArrowShape(name, defn) {
    if (is.string(defn)) {
      defn = arrowShapes[defn];
    }

    arrowShapes[name] = util.extend({
      name: name,

      points: [-0.15, -0.3, 0.15, -0.3, 0.15, 0.3, -0.15, 0.3],

      collide: function collide(x, y, size, angle, translation, padding) {
        var points = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));
        var inside = math.pointInsidePolygonPoints(x, y, points);

        return inside;
      },

      roughCollide: bbCollide,

      draw: function draw(context, size, angle, translation) {
        var points = transformPoints(this.points, size, angle, translation);

        renderer.arrowShapeImpl('polygon')(context, points);
      },

      spacing: function spacing(edge) {
        return 0;
      },

      gap: standardGap
    }, defn);
  };

  defineArrowShape('none', {
    collide: util.falsify,

    roughCollide: util.falsify,

    draw: util.noop,

    spacing: util.zeroify,

    gap: util.zeroify
  });

  defineArrowShape('triangle', {
    points: [-0.15, -0.3, 0, 0, 0.15, -0.3]
  });

  defineArrowShape('arrow', 'triangle');

  defineArrowShape('triangle-backcurve', {
    points: arrowShapes['triangle'].points,

    controlPoint: [0, -0.15],

    roughCollide: bbCollide,

    draw: function draw(context, size, angle, translation, edgeWidth) {
      var ptsTrans = transformPoints(this.points, size, angle, translation);
      var ctrlPt = this.controlPoint;
      var ctrlPtTrans = transform(ctrlPt[0], ctrlPt[1], size, angle, translation);

      renderer.arrowShapeImpl(this.name)(context, ptsTrans, ctrlPtTrans);
    },

    gap: function gap(edge) {
      return standardGap(edge) * 0.8;
    }
  });

  defineArrowShape('triangle-tee', {
    points: [-0.15, -0.3, 0, 0, 0.15, -0.3, -0.15, -0.3],

    pointsTee: [-0.15, -0.4, -0.15, -0.5, 0.15, -0.5, 0.15, -0.4],

    collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {
      var triPts = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));
      var teePts = pointsToArr(transformPoints(this.pointsTee, size + 2 * padding, angle, translation));

      var inside = math.pointInsidePolygonPoints(x, y, triPts) || math.pointInsidePolygonPoints(x, y, teePts);

      return inside;
    },

    draw: function draw(context, size, angle, translation, edgeWidth) {
      var triPts = transformPoints(this.points, size, angle, translation);
      var teePts = transformPoints(this.pointsTee, size, angle, translation);

      renderer.arrowShapeImpl(this.name)(context, triPts, teePts);
    }
  });

  defineArrowShape('triangle-cross', {
    points: [-0.15, -0.3, 0, 0, 0.15, -0.3, -0.15, -0.3],

    baseCrossLinePts: [-0.15, -0.4, // first half of the rectangle
    -0.15, -0.4, 0.15, -0.4, // second half of the rectangle
    0.15, -0.4],

    crossLinePts: function crossLinePts(size, edgeWidth) {
      // shift points so that the distance between the cross points matches edge width
      var p = this.baseCrossLinePts.slice();
      var shiftFactor = edgeWidth / size;
      var y0 = 3;
      var y1 = 5;

      p[y0] = p[y0] - shiftFactor;
      p[y1] = p[y1] - shiftFactor;

      return p;
    },

    collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {
      var triPts = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));
      var teePts = pointsToArr(transformPoints(this.crossLinePts(size, edgeWidth), size + 2 * padding, angle, translation));
      var inside = math.pointInsidePolygonPoints(x, y, triPts) || math.pointInsidePolygonPoints(x, y, teePts);

      return inside;
    },

    draw: function draw(context, size, angle, translation, edgeWidth) {
      var triPts = transformPoints(this.points, size, angle, translation);
      var crossLinePts = transformPoints(this.crossLinePts(size, edgeWidth), size, angle, translation);

      renderer.arrowShapeImpl(this.name)(context, triPts, crossLinePts);
    }
  });

  defineArrowShape('vee', {
    points: [-0.15, -0.3, 0, 0, 0.15, -0.3, 0, -0.15],

    gap: function gap(edge) {
      return standardGap(edge) * 0.525;
    }
  });

  defineArrowShape('circle', {
    radius: 0.15,

    collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {
      var t = translation;
      var inside = Math.pow(t.x - x, 2) + Math.pow(t.y - y, 2) <= Math.pow((size + 2 * padding) * this.radius, 2);

      return inside;
    },

    draw: function draw(context, size, angle, translation, edgeWidth) {
      renderer.arrowShapeImpl(this.name)(context, translation.x, translation.y, this.radius * size);
    },

    spacing: function spacing(edge) {
      return renderer.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.radius;
    }
  });

  defineArrowShape('tee', {
    points: [-0.15, 0, -0.15, -0.1, 0.15, -0.1, 0.15, 0],

    spacing: function spacing(edge) {
      return 1;
    },

    gap: function gap(edge) {
      return 1;
    }
  });

  defineArrowShape('square', {
    points: [-0.15, 0.00, 0.15, 0.00, 0.15, -0.3, -0.15, -0.3]
  });

  defineArrowShape('diamond', {
    points: [-0.15, -0.15, 0, -0.3, 0.15, -0.15, 0, 0],

    gap: function gap(edge) {
      return edge.pstyle('width').pfValue * edge.pstyle('arrow-scale').value;
    }
  });
};

module.exports = BRp;

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);

var BRp = {};

[__webpack_require__(110), __webpack_require__(111), __webpack_require__(112), __webpack_require__(113), __webpack_require__(114), __webpack_require__(115), __webpack_require__(116), __webpack_require__(117), __webpack_require__(118)].forEach(function (props) {
  util.extend(BRp, props);
});

module.exports = BRp;

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var window = __webpack_require__(3);
var math = __webpack_require__(2);
var util = __webpack_require__(1);
var window = __webpack_require__(3);

var BRp = {};

// Project mouse
BRp.projectIntoViewport = function (clientX, clientY) {
  var cy = this.cy;
  var offsets = this.findContainerClientCoords();
  var offsetLeft = offsets[0];
  var offsetTop = offsets[1];
  var scale = offsets[4];
  var pan = cy.pan();
  var zoom = cy.zoom();

  var x = ((clientX - offsetLeft) / scale - pan.x) / zoom;
  var y = ((clientY - offsetTop) / scale - pan.y) / zoom;

  return [x, y];
};

BRp.findContainerClientCoords = function () {
  if (this.containerBB) {
    return this.containerBB;
  }

  var container = this.container;
  var rect = container.getBoundingClientRect();
  var style = window.getComputedStyle(container);
  var styleValue = function styleValue(name) {
    return parseFloat(style.getPropertyValue(name));
  };

  var padding = {
    left: styleValue('padding-left'),
    right: styleValue('padding-right'),
    top: styleValue('padding-top'),
    bottom: styleValue('padding-bottom')
  };

  var border = {
    left: styleValue('border-left-width'),
    right: styleValue('border-right-width'),
    top: styleValue('border-top-width'),
    bottom: styleValue('border-bottom-width')
  };

  var clientWidth = container.clientWidth;
  var clientHeight = container.clientHeight;

  var paddingHor = padding.left + padding.right;
  var paddingVer = padding.top + padding.bottom;

  var borderHor = border.left + border.right;
  var borderVer = border.top + border.bottom;

  var scale = rect.width / (clientWidth + borderHor);

  var unscaledW = clientWidth - paddingHor;
  var unscaledH = clientHeight - paddingVer;

  var scaledW = rect.width - (paddingHor + borderHor) * scale;
  var scaledH = rect.height - (paddingVer + borderVer) * scale;

  var left = rect.left + padding.left + border.left;
  var top = rect.top + padding.top + border.top;

  return this.containerBB = [left, top, unscaledW, unscaledH, scale];
};

BRp.invalidateContainerClientCoordsCache = function () {
  this.containerBB = null;
};

BRp.findNearestElement = function (x, y, interactiveElementsOnly, isTouch) {
  return this.findNearestElements(x, y, interactiveElementsOnly, isTouch)[0];
};

BRp.findNearestElements = function (x, y, interactiveElementsOnly, isTouch) {
  var self = this;
  var r = this;
  var eles = r.getCachedZSortedEles();
  var near = []; // 1 node max, 1 edge max
  var zoom = r.cy.zoom();
  var hasCompounds = r.cy.hasCompoundNodes();
  var edgeThreshold = (isTouch ? 24 : 8) / zoom;
  var nodeThreshold = (isTouch ? 8 : 2) / zoom;
  var labelThreshold = (isTouch ? 8 : 2) / zoom;
  var minSqDist = Infinity;
  var nearEdge;
  var nearNode;

  if (interactiveElementsOnly) {
    eles = eles.interactive;
  }

  function addEle(ele, sqDist) {
    if (ele.isNode()) {
      if (nearNode) {
        return; // can't replace node
      } else {
        nearNode = ele;
        near.push(ele);
      }
    }

    if (ele.isEdge() && (sqDist == null || sqDist < minSqDist)) {
      if (nearEdge) {
        // then replace existing edge
        // can replace only if same z-index
        if (nearEdge.pstyle('z-compound-depth').value === ele.pstyle('z-compound-depth').value && nearEdge.pstyle('z-compound-depth').value === ele.pstyle('z-compound-depth').value) {
          for (var i = 0; i < near.length; i++) {
            if (near[i].isEdge()) {
              near[i] = ele;
              nearEdge = ele;
              minSqDist = sqDist != null ? sqDist : minSqDist;
              break;
            }
          }
        }
      } else {
        near.push(ele);
        nearEdge = ele;
        minSqDist = sqDist != null ? sqDist : minSqDist;
      }
    }
  }

  function checkNode(node) {
    var width = node.outerWidth() + 2 * nodeThreshold;
    var height = node.outerHeight() + 2 * nodeThreshold;
    var hw = width / 2;
    var hh = height / 2;
    var pos = node.position();

    if (pos.x - hw <= x && x <= pos.x + hw // bb check x
    && pos.y - hh <= y && y <= pos.y + hh // bb check y
    ) {
        var shape = r.nodeShapes[self.getNodeShape(node)];

        if (shape.checkPoint(x, y, 0, width, height, pos.x, pos.y)) {
          addEle(node, 0);
          return true;
        }
      }
  }

  function checkEdge(edge) {
    var _p = edge._private;

    var rs = _p.rscratch;
    var styleWidth = edge.pstyle('width').pfValue;
    var scale = edge.pstyle('arrow-scale').value;
    var width = styleWidth / 2 + edgeThreshold; // more like a distance radius from centre
    var widthSq = width * width;
    var width2 = width * 2;
    var src = _p.source;
    var tgt = _p.target;
    var inEdgeBB = false;
    var sqDist;

    if (rs.edgeType === 'segments' || rs.edgeType === 'straight' || rs.edgeType === 'haystack') {
      var pts = rs.allpts;

      for (var i = 0; i + 3 < pts.length; i += 2) {
        if ((inEdgeBB = math.inLineVicinity(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], width2)) && widthSq > (sqDist = math.sqdistToFiniteLine(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3]))) {
          addEle(edge, sqDist);
          return true;
        }
      }
    } else if (rs.edgeType === 'bezier' || rs.edgeType === 'multibezier' || rs.edgeType === 'self' || rs.edgeType === 'compound') {
      var pts = rs.allpts;
      for (var i = 0; i + 5 < rs.allpts.length; i += 4) {
        if ((inEdgeBB = math.inBezierVicinity(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], pts[i + 4], pts[i + 5], width2)) && widthSq > (sqDist = math.sqdistToQuadraticBezier(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], pts[i + 4], pts[i + 5]))) {
          addEle(edge, sqDist);
          return true;
        }
      }
    }

    // if we're close to the edge but didn't hit it, maybe we hit its arrows

    var src = src || _p.source;
    var tgt = tgt || _p.target;

    var arSize = self.getArrowWidth(styleWidth, scale);

    var arrows = [{ name: 'source', x: rs.arrowStartX, y: rs.arrowStartY, angle: rs.srcArrowAngle }, { name: 'target', x: rs.arrowEndX, y: rs.arrowEndY, angle: rs.tgtArrowAngle }, { name: 'mid-source', x: rs.midX, y: rs.midY, angle: rs.midsrcArrowAngle }, { name: 'mid-target', x: rs.midX, y: rs.midY, angle: rs.midtgtArrowAngle }];

    for (var i = 0; i < arrows.length; i++) {
      var ar = arrows[i];
      var shape = r.arrowShapes[edge.pstyle(ar.name + '-arrow-shape').value];
      var edgeWidth = edge.pstyle('width').pfValue;
      if (shape.roughCollide(x, y, arSize, ar.angle, { x: ar.x, y: ar.y }, edgeWidth, edgeThreshold) && shape.collide(x, y, arSize, ar.angle, { x: ar.x, y: ar.y }, edgeWidth, edgeThreshold)) {
        addEle(edge);
        return true;
      }
    }

    // for compound graphs, hitting edge may actually want a connected node instead (b/c edge may have greater z-index precedence)
    if (hasCompounds && near.length > 0) {
      checkNode(src);
      checkNode(tgt);
    }
  }

  function preprop(obj, name, pre) {
    return util.getPrefixedProperty(obj, name, pre);
  }

  function checkLabel(ele, prefix) {
    var _p = ele._private;
    var th = labelThreshold;

    var prefixDash;
    if (prefix) {
      prefixDash = prefix + '-';
    } else {
      prefixDash = '';
    }

    var text = ele.pstyle(prefixDash + 'label').value;
    var eventsEnabled = ele.pstyle('text-events').strValue === 'yes';

    if (!eventsEnabled || !text) {
      return;
    }

    var rstyle = _p.rstyle;
    var bw = ele.pstyle('text-border-width').pfValue;
    var pw = ele.pstyle('text-background-padding').pfValue;
    var lw = preprop(rstyle, 'labelWidth', prefix) + bw + 2 * th + 2 * pw;
    var lh = preprop(rstyle, 'labelHeight', prefix) + bw + 2 * th + 2 * pw;
    var lx = preprop(rstyle, 'labelX', prefix);
    var ly = preprop(rstyle, 'labelY', prefix);

    var theta = preprop(_p.rscratch, 'labelAngle', prefix);

    var lx1 = lx - lw / 2;
    var lx2 = lx + lw / 2;
    var ly1 = ly - lh / 2;
    var ly2 = ly + lh / 2;

    if (theta) {
      var cos = Math.cos(theta);
      var sin = Math.sin(theta);

      var rotate = function rotate(x, y) {
        x = x - lx;
        y = y - ly;

        return {
          x: x * cos - y * sin + lx,
          y: x * sin + y * cos + ly
        };
      };

      var px1y1 = rotate(lx1, ly1);
      var px1y2 = rotate(lx1, ly2);
      var px2y1 = rotate(lx2, ly1);
      var px2y2 = rotate(lx2, ly2);

      var points = [px1y1.x, px1y1.y, px2y1.x, px2y1.y, px2y2.x, px2y2.y, px1y2.x, px1y2.y];

      if (math.pointInsidePolygonPoints(x, y, points)) {
        addEle(ele);
        return true;
      }
    } else {
      // do a cheaper bb check
      var bb = {
        w: lw,
        h: lh,
        x1: lx1,
        x2: lx2,
        y1: ly1,
        y2: ly2
      };

      if (math.inBoundingBox(bb, x, y)) {
        addEle(ele);
        return true;
      }
    }
  }

  for (var i = eles.length - 1; i >= 0; i--) {
    // reverse order for precedence
    var ele = eles[i];

    if (ele.isNode()) {
      checkNode(ele) || checkLabel(ele);
    } else {
      // then edge
      checkEdge(ele) || checkLabel(ele) || checkLabel(ele, 'source') || checkLabel(ele, 'target');
    }
  }

  return near;
};

// 'Give me everything from this box'
BRp.getAllInBox = function (x1, y1, x2, y2) {
  var eles = this.getCachedZSortedEles().interactive;
  var box = [];

  var x1c = Math.min(x1, x2);
  var x2c = Math.max(x1, x2);
  var y1c = Math.min(y1, y2);
  var y2c = Math.max(y1, y2);

  x1 = x1c;
  x2 = x2c;
  y1 = y1c;
  y2 = y2c;

  var boxBb = math.makeBoundingBox({
    x1: x1, y1: y1,
    x2: x2, y2: y2
  });

  for (var e = 0; e < eles.length; e++) {
    var ele = eles[e];

    if (ele.isNode()) {
      var node = ele;
      var nodeBb = node.boundingBox({
        includeNodes: true,
        includeEdges: false,
        includeLabels: false
      });

      if (math.boundingBoxesIntersect(boxBb, nodeBb) && !math.boundingBoxInBoundingBox(nodeBb, boxBb)) {
        box.push(node);
      }
    } else {
      var edge = ele;
      var _p = edge._private;
      var rs = _p.rscratch;

      if (rs.startX != null && rs.startY != null && !math.inBoundingBox(boxBb, rs.startX, rs.startY)) {
        continue;
      }
      if (rs.endX != null && rs.endY != null && !math.inBoundingBox(boxBb, rs.endX, rs.endY)) {
        continue;
      }

      if (rs.edgeType === 'bezier' || rs.edgeType === 'multibezier' || rs.edgeType === 'self' || rs.edgeType === 'compound' || rs.edgeType === 'segments' || rs.edgeType === 'haystack') {

        var pts = _p.rstyle.bezierPts || _p.rstyle.linePts || _p.rstyle.haystackPts;
        var allInside = true;

        for (var i = 0; i < pts.length; i++) {
          if (!math.pointInBoundingBox(boxBb, pts[i])) {
            allInside = false;
            break;
          }
        }

        if (allInside) {
          box.push(edge);
        }
      } else if (rs.edgeType === 'haystack' || rs.edgeType === 'straight') {
        box.push(edge);
      }
    }
  }

  return box;
};

module.exports = BRp;

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var math = __webpack_require__(2);

var BRp = {};

BRp.calculateArrowAngles = function (edge) {
  var rs = edge._private.rscratch;
  var isHaystack = rs.edgeType === 'haystack';
  var isBezier = rs.edgeType === 'bezier';
  var isMultibezier = rs.edgeType === 'multibezier';
  var isSegments = rs.edgeType === 'segments';
  var isCompound = rs.edgeType === 'compound';
  var isSelf = rs.edgeType === 'self';

  // Displacement gives direction for arrowhead orientation
  var dispX, dispY;
  var startX, startY, endX, endY, midX, midY;

  if (isHaystack) {
    startX = rs.haystackPts[0];
    startY = rs.haystackPts[1];
    endX = rs.haystackPts[2];
    endY = rs.haystackPts[3];
  } else {
    startX = rs.arrowStartX;
    startY = rs.arrowStartY;
    endX = rs.arrowEndX;
    endY = rs.arrowEndY;
  }

  midX = rs.midX;
  midY = rs.midY;

  // source
  //

  if (isSegments) {
    dispX = startX - rs.segpts[0];
    dispY = startY - rs.segpts[1];
  } else if (isMultibezier || isCompound || isSelf || isBezier) {
    var pts = rs.allpts;
    var bX = math.qbezierAt(pts[0], pts[2], pts[4], 0.1);
    var bY = math.qbezierAt(pts[1], pts[3], pts[5], 0.1);

    dispX = startX - bX;
    dispY = startY - bY;
  } else {
    dispX = startX - midX;
    dispY = startY - midY;
  }

  rs.srcArrowAngle = math.getAngleFromDisp(dispX, dispY);

  // mid target
  //

  var midX = rs.midX;
  var midY = rs.midY;

  if (isHaystack) {
    midX = (startX + endX) / 2;
    midY = (startY + endY) / 2;
  }

  dispX = endX - startX;
  dispY = endY - startY;

  if (isSegments) {
    var pts = rs.allpts;

    if (pts.length / 2 % 2 === 0) {
      var i2 = pts.length / 2;
      var i1 = i2 - 2;

      dispX = pts[i2] - pts[i1];
      dispY = pts[i2 + 1] - pts[i1 + 1];
    } else {
      var i2 = pts.length / 2 - 1;
      var i1 = i2 - 2;
      var i3 = i2 + 2;

      dispX = pts[i2] - pts[i1];
      dispY = pts[i2 + 1] - pts[i1 + 1];
    }
  } else if (isMultibezier || isCompound || isSelf) {
    var pts = rs.allpts;
    var cpts = rs.ctrlpts;
    var bp0x, bp0y;
    var bp1x, bp1y;

    if (cpts.length / 2 % 2 === 0) {
      var p0 = pts.length / 2 - 1; // startpt
      var ic = p0 + 2;
      var p1 = ic + 2;

      bp0x = math.qbezierAt(pts[p0], pts[ic], pts[p1], 0.0);
      bp0y = math.qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.0);

      bp1x = math.qbezierAt(pts[p0], pts[ic], pts[p1], 0.0001);
      bp1y = math.qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.0001);
    } else {
      var ic = pts.length / 2 - 1; // ctrpt
      var p0 = ic - 2; // startpt
      var p1 = ic + 2; // endpt

      bp0x = math.qbezierAt(pts[p0], pts[ic], pts[p1], 0.4999);
      bp0y = math.qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.4999);

      bp1x = math.qbezierAt(pts[p0], pts[ic], pts[p1], 0.5);
      bp1y = math.qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.5);
    }

    dispX = bp1x - bp0x;
    dispY = bp1y - bp0y;
  }

  rs.midtgtArrowAngle = math.getAngleFromDisp(dispX, dispY);

  rs.midDispX = dispX;
  rs.midDispY = dispY;

  // mid source
  //

  dispX *= -1;
  dispY *= -1;

  if (isSegments) {
    var pts = rs.allpts;

    if (pts.length / 2 % 2 === 0) {
      // already ok
    } else {
      var i2 = pts.length / 2 - 1;
      var i3 = i2 + 2;

      dispX = -(pts[i3] - pts[i2]);
      dispY = -(pts[i3 + 1] - pts[i2 + 1]);
    }
  }

  rs.midsrcArrowAngle = math.getAngleFromDisp(dispX, dispY);

  // target
  //

  if (isSegments) {
    dispX = endX - rs.segpts[rs.segpts.length - 2];
    dispY = endY - rs.segpts[rs.segpts.length - 1];
  } else if (isMultibezier || isCompound || isSelf || isBezier) {
    var pts = rs.allpts;
    var l = pts.length;
    var bX = math.qbezierAt(pts[l - 6], pts[l - 4], pts[l - 2], 0.9);
    var bY = math.qbezierAt(pts[l - 5], pts[l - 3], pts[l - 1], 0.9);

    dispX = endX - bX;
    dispY = endY - bY;
  } else {
    dispX = endX - midX;
    dispY = endY - midY;
  }

  rs.tgtArrowAngle = math.getAngleFromDisp(dispX, dispY);
};

BRp.getArrowWidth = BRp.getArrowHeight = function (edgeWidth, scale) {
  var cache = this.arrowWidthCache = this.arrowWidthCache || {};

  var cachedVal = cache[edgeWidth + ', ' + scale];
  if (cachedVal) {
    return cachedVal;
  }

  cachedVal = Math.max(Math.pow(edgeWidth * 13.37, 0.9), 29) * scale;
  cache[edgeWidth + ', ' + scale] = cachedVal;

  return cachedVal;
};

module.exports = BRp;

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var math = __webpack_require__(2);
var is = __webpack_require__(0);

var BRp = {};

BRp.findEdgeControlPoints = function (edges) {
  if (!edges || edges.length === 0) {
    return;
  }

  var r = this;
  var cy = r.cy;
  var hasCompounds = cy.hasCompoundNodes();
  var hashTable = {};
  var pairIds = [];
  var haystackEdges = [];

  // create a table of edge (src, tgt) => list of edges between them
  var pairId;
  for (var i = 0; i < edges.length; i++) {
    var edge = edges[i];
    var _p = edge._private;
    var data = _p.data;
    var curveStyle = edge.pstyle('curve-style').value;
    var edgeIsUnbundled = curveStyle === 'unbundled-bezier' || curveStyle === 'segments';
    var edgeIsBezier = curveStyle === 'unbundled-bezier' || curveStyle === 'bezier';

    // ignore edges who are not to be displayed
    // they shouldn't take up space
    if (edge.pstyle('display').value === 'none') {
      continue;
    }

    if (curveStyle === 'haystack') {
      haystackEdges.push(edge);
      continue;
    }

    var srcId = data.source;
    var tgtId = data.target;

    pairId = srcId > tgtId ? tgtId + '$-$' + srcId : srcId + '$-$' + tgtId;

    if (edgeIsUnbundled) {
      pairId = 'unbundled' + '$-$' + data.id;
    }

    var tableEntry = hashTable[pairId];

    if (tableEntry == null) {
      tableEntry = hashTable[pairId] = [];
      pairIds.push(pairId);
    }

    tableEntry.push(edge);

    if (edgeIsUnbundled) {
      tableEntry.hasUnbundled = true;
    }

    if (edgeIsBezier) {
      tableEntry.hasBezier = true;
    }
  }

  var src, tgt, srcPos, tgtPos, srcW, srcH, tgtW, tgtH, srcShape, tgtShape;
  var vectorNormInverse;
  var badBezier;

  // for each pair (src, tgt), create the ctrl pts
  // Nested for loop is OK; total number of iterations for both loops = edgeCount
  for (var p = 0; p < pairIds.length; p++) {
    pairId = pairIds[p];
    var pairEdges = hashTable[pairId];

    // for each pair id, the edges should be sorted by index
    pairEdges.sort(function (edge1, edge2) {
      return edge1.poolIndex() - edge2.poolIndex();
    });

    src = pairEdges[0]._private.source;
    tgt = pairEdges[0]._private.target;

    // make sure src/tgt distinction is consistent for bundled edges
    if (!pairEdges.hasUnbundled && src.id() > tgt.id()) {
      var temp = src;
      src = tgt;
      tgt = temp;
    }

    srcPos = src.position();
    tgtPos = tgt.position();

    srcW = src.outerWidth();
    srcH = src.outerHeight();

    tgtW = tgt.outerWidth();
    tgtH = tgt.outerHeight();

    srcShape = r.nodeShapes[this.getNodeShape(src)];
    tgtShape = r.nodeShapes[this.getNodeShape(tgt)];

    badBezier = false;

    var edge;
    var edge_p;
    var rs;

    var dirCounts = {
      'north': 0,
      'west': 0,
      'south': 0,
      'east': 0,
      'northwest': 0,
      'southwest': 0,
      'northeast': 0,
      'southeast': 0
    };

    var srcX2 = srcPos.x;
    var srcY2 = srcPos.y;
    var srcW2 = srcW;
    var srcH2 = srcH;

    var tgtX2 = tgtPos.x;
    var tgtY2 = tgtPos.y;
    var tgtW2 = tgtW;
    var tgtH2 = tgtH;

    var numEdges2 = pairEdges.length;

    for (var i = 0; i < pairEdges.length; i++) {
      edge = pairEdges[i];
      edge_p = edge._private;
      rs = edge_p.rscratch;

      var edgeIndex1 = rs.lastEdgeIndex;
      var edgeIndex2 = i;

      var numEdges1 = rs.lastNumEdges;

      var curveStyle = edge.pstyle('curve-style').value;

      var edgeIsUnbundled = curveStyle === 'unbundled-bezier' || curveStyle === 'segments';

      // whether the normalised pair order is the reverse of the edge's src-tgt order
      var edgeIsSwapped = src.id() !== edge.source().id();

      var ctrlptDists = edge.pstyle('control-point-distances');
      var loopDir = edge.pstyle('loop-direction').pfValue;
      var loopSwp = edge.pstyle('loop-sweep').pfValue;
      var ctrlptWs = edge.pstyle('control-point-weights');
      var bezierN = ctrlptDists && ctrlptWs ? Math.min(ctrlptDists.value.length, ctrlptWs.value.length) : 1;
      var stepSize = edge.pstyle('control-point-step-size').pfValue;
      var ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : undefined;
      var ctrlptWeight = ctrlptWs.value[0];
      var edgeDistances = edge.pstyle('edge-distances').value;
      var srcDistFNode = edge.pstyle('source-distance-from-node').pfValue;
      var tgtDistFNode = edge.pstyle('target-distance-from-node').pfValue;
      var segmentWs = edge.pstyle('segment-weights');
      var segmentDs = edge.pstyle('segment-distances');
      var segmentsN = Math.min(segmentWs.pfValue.length, segmentDs.pfValue.length);
      var srcEndpt = edge.pstyle('source-endpoint').value;
      var tgtEndpt = edge.pstyle('target-endpoint').value;
      var srcArrShape = edge.pstyle('source-arrow-shape').value;
      var tgtArrShape = edge.pstyle('target-arrow-shape').value;
      var arrowScale = edge.pstyle('arrow-scale').value;
      var lineWidth = edge.pstyle('width').pfValue;

      var srcX1 = rs.lastSrcCtlPtX;
      var srcY1 = rs.lastSrcCtlPtY;
      var srcW1 = rs.lastSrcCtlPtW;
      var srcH1 = rs.lastSrcCtlPtH;

      var tgtX1 = rs.lastTgtCtlPtX;
      var tgtY1 = rs.lastTgtCtlPtY;
      var tgtW1 = rs.lastTgtCtlPtW;
      var tgtH1 = rs.lastTgtCtlPtH;

      var curveStyle1 = rs.lastCurveStyle;
      var curveStyle2 = curveStyle;

      var ctrlptDists1 = rs.lastCtrlptDists;
      var ctrlptDists2 = ctrlptDists ? ctrlptDists.strValue : null;

      var ctrlptWs1 = rs.lastCtrlptWs;
      var ctrlptWs2 = ctrlptWs.strValue;

      var segmentWs1 = rs.lastSegmentWs;
      var segmentWs2 = segmentWs.strValue;

      var segmentDs1 = rs.lastSegmentDs;
      var segmentDs2 = segmentDs.strValue;

      var stepSize1 = rs.lastStepSize;
      var stepSize2 = stepSize;

      var loopDir1 = rs.lastLoopDir;
      var loopDir2 = loopDir;

      var loopSwp1 = rs.lastLoopSwp;
      var loopSwp2 = loopSwp;

      var edgeDistances1 = rs.lastEdgeDistances;
      var edgeDistances2 = edgeDistances;

      var srcDistFNode1 = rs.lastSrcDistFNode;
      var srcDistFNode2 = srcDistFNode;

      var tgtDistFNode1 = rs.lastTgtDistFNode;
      var tgtDistFNode2 = tgtDistFNode;

      var srcEndpt1 = rs.lastSrcEndpt;
      var srcEndpt2 = srcEndpt;

      var tgtEndpt1 = rs.lastTgtEndpt;
      var tgtEndpt2 = tgtEndpt;

      var srcArr1 = rs.lastSrcArr;
      var srcArr2 = srcArrShape;

      var tgtArr1 = rs.lastTgtArr;
      var tgtArr2 = tgtArrShape;

      var lineW1 = rs.lastLineW;
      var lineW2 = lineWidth;

      var arrScl1 = rs.lastArrScl;
      var arrScl2 = arrowScale;

      if (badBezier) {
        rs.badBezier = true;
      } else {
        rs.badBezier = false;
      }

      var ptCacheHit;

      if (srcX1 === srcX2 && srcY1 === srcY2 && srcW1 === srcW2 && srcH1 === srcH2 && tgtX1 === tgtX2 && tgtY1 === tgtY2 && tgtW1 === tgtW2 && tgtH1 === tgtH2 && curveStyle1 === curveStyle2 && ctrlptDists1 === ctrlptDists2 && ctrlptWs1 === ctrlptWs2 && segmentWs1 === segmentWs2 && segmentDs1 === segmentDs2 && stepSize1 === stepSize2 && loopDir1 === loopDir2 && loopSwp1 === loopSwp2 && edgeDistances1 === edgeDistances2 && srcDistFNode1 === srcDistFNode2 && tgtDistFNode1 === tgtDistFNode2 && srcEndpt1 === srcEndpt2 && tgtEndpt1 === tgtEndpt2 && srcArr1 === srcArr2 && tgtArr1 === tgtArr2 && lineW1 === lineW2 && arrScl1 === arrScl2 && (edgeIndex1 === edgeIndex2 && numEdges1 === numEdges2 || edgeIsUnbundled)) {
        ptCacheHit = true; // then the control points haven't changed and we can skip calculating them
      } else {
        ptCacheHit = false;

        rs.lastSrcCtlPtX = srcX2;
        rs.lastSrcCtlPtY = srcY2;
        rs.lastSrcCtlPtW = srcW2;
        rs.lastSrcCtlPtH = srcH2;
        rs.lastTgtCtlPtX = tgtX2;
        rs.lastTgtCtlPtY = tgtY2;
        rs.lastTgtCtlPtW = tgtW2;
        rs.lastTgtCtlPtH = tgtH2;
        rs.lastEdgeIndex = edgeIndex2;
        rs.lastNumEdges = numEdges2;
        rs.lastCurveStyle = curveStyle2;
        rs.lastCtrlptDists = ctrlptDists2;
        rs.lastCtrlptWs = ctrlptWs2;
        rs.lastSegmentDs = segmentDs2;
        rs.lastSegmentWs = segmentWs2;
        rs.lastStepSize = stepSize2;
        rs.lastLoopDir = loopDir2;
        rs.lastLoopSwp = loopSwp2;
        rs.lastEdgeDistances = edgeDistances2;
        rs.lastSrcDistFNode = srcDistFNode2;
        rs.lastTgtDistFNode = tgtDistFNode2;
        rs.lastSrcEndpt = srcEndpt2;
        rs.lastTgtEndpt = tgtEndpt2;
        rs.lastSrcArr = srcArr2;
        rs.lastTgtArr = tgtArr2;
        rs.lastLineW = lineW2;
        rs.lastArrScl = arrScl2;
      }

      if (!ptCacheHit) {

        if (!pairEdges.calculatedIntersection && src !== tgt && (pairEdges.hasBezier || pairEdges.hasUnbundled)) {

          pairEdges.calculatedIntersection = true;

          // pt outside src shape to calc distance/displacement from src to tgt
          var srcOutside = srcShape.intersectLine(srcPos.x, srcPos.y, srcW, srcH, tgtPos.x, tgtPos.y, 0);

          pairEdges.srcIntn = srcOutside;

          // pt outside tgt shape to calc distance/displacement from src to tgt
          var tgtOutside = tgtShape.intersectLine(tgtPos.x, tgtPos.y, tgtW, tgtH, srcPos.x, srcPos.y, 0);

          pairEdges.tgtIntn = tgtOutside;

          var midptSrcPts = {
            x1: srcOutside[0],
            x2: tgtOutside[0],
            y1: srcOutside[1],
            y2: tgtOutside[1]
          };

          var posPts = {
            x1: srcPos.x,
            x2: tgtPos.x,
            y1: srcPos.y,
            y2: tgtPos.y
          };

          var dy = tgtOutside[1] - srcOutside[1];
          var dx = tgtOutside[0] - srcOutside[0];
          var l = Math.sqrt(dx * dx + dy * dy);

          var vector = {
            x: dx,
            y: dy
          };

          var vectorNorm = {
            x: vector.x / l,
            y: vector.y / l
          };
          vectorNormInverse = {
            x: -vectorNorm.y,
            y: vectorNorm.x
          };

          // if node shapes overlap, then no ctrl pts to draw
          if (tgtShape.checkPoint(srcOutside[0], srcOutside[1], 0, tgtW, tgtH, tgtPos.x, tgtPos.y) && srcShape.checkPoint(tgtOutside[0], tgtOutside[1], 0, srcW, srcH, srcPos.x, srcPos.y)) {
            vectorNormInverse = {};
            badBezier = true;
          }
        }

        if (!edgeIsSwapped) {
          rs.srcIntn = pairEdges.srcIntn;
          rs.tgtIntn = pairEdges.tgtIntn;
        } else {
          // ensure that the per-edge cached value for intersections are correct for swapped bundled edges
          rs.srcIntn = pairEdges.tgtIntn;
          rs.tgtIntn = pairEdges.srcIntn;
        }

        if (src === tgt) {
          // Self-edge

          rs.edgeType = 'self';

          var j = i;
          var loopDist = stepSize;

          if (edgeIsUnbundled) {
            j = 0;
            loopDist = ctrlptDist;
          }

          var loopAngle = loopDir - Math.PI / 2;
          var outAngle = loopAngle - loopSwp / 2;
          var inAngle = loopAngle + loopSwp / 2;

          // increase by step size for overlapping loops, keyed on direction and sweep values
          var dc = String(loopDir + '_' + loopSwp);
          j = dirCounts[dc] === undefined ? dirCounts[dc] = 0 : ++dirCounts[dc];

          rs.ctrlpts = [srcPos.x + Math.cos(outAngle) * 1.4 * loopDist * (j / 3 + 1), srcPos.y + Math.sin(outAngle) * 1.4 * loopDist * (j / 3 + 1), srcPos.x + Math.cos(inAngle) * 1.4 * loopDist * (j / 3 + 1), srcPos.y + Math.sin(inAngle) * 1.4 * loopDist * (j / 3 + 1)];
        } else if (hasCompounds && (src.isParent() || src.isChild() || tgt.isParent() || tgt.isChild()) && (src.parents().anySame(tgt) || tgt.parents().anySame(src))) {
          // Compound edge

          rs.edgeType = 'compound';

          // because the line approximation doesn't apply for compound beziers
          // (loop/self edges are already elided b/c of cheap src==tgt check)
          rs.badBezier = false;

          var j = i;
          var loopDist = stepSize;

          if (edgeIsUnbundled) {
            j = 0;
            loopDist = ctrlptDist;
          }

          var loopW = 50;

          var loopaPos = {
            x: srcPos.x - srcW / 2,
            y: srcPos.y - srcH / 2
          };

          var loopbPos = {
            x: tgtPos.x - tgtW / 2,
            y: tgtPos.y - tgtH / 2
          };

          var loopPos = {
            x: Math.min(loopaPos.x, loopbPos.x),
            y: Math.min(loopaPos.y, loopbPos.y)
          };

          // avoids cases with impossible beziers
          var minCompoundStretch = 0.5;
          var compoundStretchA = Math.max(minCompoundStretch, Math.log(srcW * 0.01));
          var compoundStretchB = Math.max(minCompoundStretch, Math.log(tgtW * 0.01));

          rs.ctrlpts = [loopPos.x, loopPos.y - (1 + Math.pow(loopW, 1.12) / 100) * loopDist * (j / 3 + 1) * compoundStretchA, loopPos.x - (1 + Math.pow(loopW, 1.12) / 100) * loopDist * (j / 3 + 1) * compoundStretchB, loopPos.y];
        } else if (curveStyle === 'segments') {
          // Segments (multiple straight lines)

          rs.edgeType = 'segments';
          rs.segpts = [];

          for (var s = 0; s < segmentsN; s++) {
            var w = segmentWs.pfValue[s];
            var d = segmentDs.pfValue[s];

            var w1 = 1 - w;
            var w2 = w;

            var midptPts = edgeDistances === 'node-position' ? posPts : midptSrcPts;

            var adjustedMidpt = {
              x: midptPts.x1 * w1 + midptPts.x2 * w2,
              y: midptPts.y1 * w1 + midptPts.y2 * w2
            };

            rs.segpts.push(adjustedMidpt.x + vectorNormInverse.x * d, adjustedMidpt.y + vectorNormInverse.y * d);
          }

          // Straight edge
        } else if (pairEdges.length % 2 === 1 && i === Math.floor(pairEdges.length / 2) && !edgeIsUnbundled) {

          rs.edgeType = 'straight';
        } else {
          // (Multi)bezier

          var multi = edgeIsUnbundled;

          rs.edgeType = multi ? 'multibezier' : 'bezier';
          rs.ctrlpts = [];

          for (var b = 0; b < bezierN; b++) {
            var normctrlptDist = (0.5 - pairEdges.length / 2 + i) * stepSize;
            var manctrlptDist;
            var sign = math.signum(normctrlptDist);

            if (multi) {
              ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[b] : stepSize; // fall back on step size
              ctrlptWeight = ctrlptWs.value[b];
            }

            if (edgeIsUnbundled) {
              // multi or single unbundled
              manctrlptDist = ctrlptDist;
            } else {
              manctrlptDist = ctrlptDist !== undefined ? sign * ctrlptDist : undefined;
            }

            var distanceFromMidpoint = manctrlptDist !== undefined ? manctrlptDist : normctrlptDist;

            var w1 = 1 - ctrlptWeight;
            var w2 = ctrlptWeight;

            if (edgeIsSwapped) {
              var temp = w1;
              w1 = w2;
              w2 = temp;
            }

            var midptPts = edgeDistances === 'node-position' ? posPts : midptSrcPts;

            var adjustedMidpt = {
              x: midptPts.x1 * w1 + midptPts.x2 * w2,
              y: midptPts.y1 * w1 + midptPts.y2 * w2
            };

            rs.ctrlpts.push(adjustedMidpt.x + vectorNormInverse.x * distanceFromMidpoint, adjustedMidpt.y + vectorNormInverse.y * distanceFromMidpoint);
          }
        }

        // find endpts for edge
        this.findEndpoints(edge);

        var badStart = !is.number(rs.startX) || !is.number(rs.startY);
        var badAStart = !is.number(rs.arrowStartX) || !is.number(rs.arrowStartY);
        var badEnd = !is.number(rs.endX) || !is.number(rs.endY);
        var badAEnd = !is.number(rs.arrowEndX) || !is.number(rs.arrowEndY);

        var minCpADistFactor = 3;
        var arrowW = this.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.arrowShapeWidth;
        var minCpADist = minCpADistFactor * arrowW;

        if (rs.edgeType === 'bezier') {
          var startACpDist = math.dist({ x: rs.ctrlpts[0], y: rs.ctrlpts[1] }, { x: rs.startX, y: rs.startY });
          var closeStartACp = startACpDist < minCpADist;
          var endACpDist = math.dist({ x: rs.ctrlpts[0], y: rs.ctrlpts[1] }, { x: rs.endX, y: rs.endY });
          var closeEndACp = endACpDist < minCpADist;

          var overlapping = false;

          if (badStart || badAStart || closeStartACp) {
            overlapping = true;

            // project control point along line from src centre to outside the src shape
            // (otherwise intersection will yield nothing)
            var cpD = { // delta
              x: rs.ctrlpts[0] - srcPos.x,
              y: rs.ctrlpts[1] - srcPos.y
            };
            var cpL = Math.sqrt(cpD.x * cpD.x + cpD.y * cpD.y); // length of line
            var cpM = { // normalised delta
              x: cpD.x / cpL,
              y: cpD.y / cpL
            };
            var radius = Math.max(srcW, srcH);
            var cpProj = { // *2 radius guarantees outside shape
              x: rs.ctrlpts[0] + cpM.x * 2 * radius,
              y: rs.ctrlpts[1] + cpM.y * 2 * radius
            };

            var srcCtrlPtIntn = srcShape.intersectLine(srcPos.x, srcPos.y, srcW, srcH, cpProj.x, cpProj.y, 0);

            if (closeStartACp) {
              rs.ctrlpts[0] = rs.ctrlpts[0] + cpM.x * (minCpADist - startACpDist);
              rs.ctrlpts[1] = rs.ctrlpts[1] + cpM.y * (minCpADist - startACpDist);
            } else {
              rs.ctrlpts[0] = srcCtrlPtIntn[0] + cpM.x * minCpADist;
              rs.ctrlpts[1] = srcCtrlPtIntn[1] + cpM.y * minCpADist;
            }
          }

          if (badEnd || badAEnd || closeEndACp) {
            overlapping = true;

            // project control point along line from tgt centre to outside the tgt shape
            // (otherwise intersection will yield nothing)
            var cpD = { // delta
              x: rs.ctrlpts[0] - tgtPos.x,
              y: rs.ctrlpts[1] - tgtPos.y
            };
            var cpL = Math.sqrt(cpD.x * cpD.x + cpD.y * cpD.y); // length of line
            var cpM = { // normalised delta
              x: cpD.x / cpL,
              y: cpD.y / cpL
            };
            var radius = Math.max(srcW, srcH);
            var cpProj = { // *2 radius guarantees outside shape
              x: rs.ctrlpts[0] + cpM.x * 2 * radius,
              y: rs.ctrlpts[1] + cpM.y * 2 * radius
            };

            var tgtCtrlPtIntn = tgtShape.intersectLine(tgtPos.x, tgtPos.y, tgtW, tgtH, cpProj.x, cpProj.y, 0);

            if (closeEndACp) {
              rs.ctrlpts[0] = rs.ctrlpts[0] + cpM.x * (minCpADist - endACpDist);
              rs.ctrlpts[1] = rs.ctrlpts[1] + cpM.y * (minCpADist - endACpDist);
            } else {
              rs.ctrlpts[0] = tgtCtrlPtIntn[0] + cpM.x * minCpADist;
              rs.ctrlpts[1] = tgtCtrlPtIntn[1] + cpM.y * minCpADist;
            }
          }

          if (overlapping) {
            // recalc endpts
            this.findEndpoints(edge);
          }
        }

        if (rs.edgeType === 'multibezier' || rs.edgeType === 'bezier' || rs.edgeType === 'self' || rs.edgeType === 'compound') {
          rs.allpts = [];

          rs.allpts.push(rs.startX, rs.startY);

          for (var b = 0; b + 1 < rs.ctrlpts.length; b += 2) {
            // ctrl pt itself
            rs.allpts.push(rs.ctrlpts[b], rs.ctrlpts[b + 1]);

            // the midpt between ctrlpts as intermediate destination pts
            if (b + 3 < rs.ctrlpts.length) {
              rs.allpts.push((rs.ctrlpts[b] + rs.ctrlpts[b + 2]) / 2, (rs.ctrlpts[b + 1] + rs.ctrlpts[b + 3]) / 2);
            }
          }

          rs.allpts.push(rs.endX, rs.endY);

          var m, mt;
          if (rs.ctrlpts.length / 2 % 2 === 0) {
            m = rs.allpts.length / 2 - 1;

            rs.midX = rs.allpts[m];
            rs.midY = rs.allpts[m + 1];
          } else {
            m = rs.allpts.length / 2 - 3;
            mt = 0.5;

            rs.midX = math.qbezierAt(rs.allpts[m], rs.allpts[m + 2], rs.allpts[m + 4], mt);
            rs.midY = math.qbezierAt(rs.allpts[m + 1], rs.allpts[m + 3], rs.allpts[m + 5], mt);
          }
        } else if (rs.edgeType === 'straight') {
          // need to calc these after endpts
          rs.allpts = [rs.startX, rs.startY, rs.endX, rs.endY];

          // default midpt for labels etc
          rs.midX = (rs.startX + rs.endX + rs.arrowStartX + rs.arrowEndX) / 4;
          rs.midY = (rs.startY + rs.endY + rs.arrowStartY + rs.arrowEndY) / 4;
        } else if (rs.edgeType === 'segments') {
          rs.allpts = [];
          rs.allpts.push(rs.startX, rs.startY);
          rs.allpts.push.apply(rs.allpts, rs.segpts);
          rs.allpts.push(rs.endX, rs.endY);

          if (rs.segpts.length % 4 === 0) {
            var i2 = rs.segpts.length / 2;
            var i1 = i2 - 2;

            rs.midX = (rs.segpts[i1] + rs.segpts[i2]) / 2;
            rs.midY = (rs.segpts[i1 + 1] + rs.segpts[i2 + 1]) / 2;
          } else {
            var i1 = rs.segpts.length / 2 - 1;

            rs.midX = rs.segpts[i1];
            rs.midY = rs.segpts[i1 + 1];
          }
        }

        this.storeEdgeProjections(edge);
        this.calculateArrowAngles(edge);
      } // if point cache miss

      this.recalculateEdgeLabelProjections(edge);
      this.calculateLabelAngles(edge);
    } // for pair edges
  } // for pair ids

  for (var i = 0; i < haystackEdges.length; i++) {
    var edge = haystackEdges[i];
    var _p = edge._private;
    var rscratch = _p.rscratch;
    var rs = rscratch;

    if (!rscratch.haystack) {
      var angle = Math.random() * 2 * Math.PI;

      rscratch.source = {
        x: Math.cos(angle),
        y: Math.sin(angle)
      };

      var angle = Math.random() * 2 * Math.PI;

      rscratch.target = {
        x: Math.cos(angle),
        y: Math.sin(angle)
      };
    }

    var src = _p.source;
    var tgt = _p.target;
    var srcPos = src.position();
    var tgtPos = tgt.position();
    var srcW = src.width();
    var tgtW = tgt.width();
    var srcH = src.height();
    var tgtH = tgt.height();
    var radius = edge.pstyle('haystack-radius').value;
    var halfRadius = radius / 2; // b/c have to half width/height

    rs.haystackPts = rs.allpts = [rs.source.x * srcW * halfRadius + srcPos.x, rs.source.y * srcH * halfRadius + srcPos.y, rs.target.x * tgtW * halfRadius + tgtPos.x, rs.target.y * tgtH * halfRadius + tgtPos.y];

    rs.midX = (rs.allpts[0] + rs.allpts[2]) / 2;
    rs.midY = (rs.allpts[1] + rs.allpts[3]) / 2;

    // always override as haystack in case set to different type previously
    rscratch.edgeType = rscratch.lastCurveStyle = 'haystack';
    rscratch.haystack = true;

    this.storeEdgeProjections(edge);
    this.calculateArrowAngles(edge);
    this.recalculateEdgeLabelProjections(edge);
    this.calculateLabelAngles(edge);
  }
};

function getPts(pts) {
  var retPts = [];

  if (pts == null) {
    return;
  }

  for (var i = 0; i < pts.length; i += 2) {
    var x = pts[i];
    var y = pts[i + 1];

    retPts.push({ x: x, y: y });
  }

  return retPts;
}

BRp.getSegmentPoints = function (edge) {
  var rs = edge[0]._private.rscratch;
  var type = rs.edgeType;

  if (type === 'segments') {
    return getPts(rs.segpts);
  }
};

BRp.getControlPoints = function (edge) {
  var rs = edge[0]._private.rscratch;
  var type = rs.edgeType;

  if (type === 'bezier' || type === 'multibezier' || type === 'self' || type === 'compound') {
    return getPts(rs.ctrlpts);
  }
};

BRp.getEdgeMidpoint = function (edge) {
  var rs = edge[0]._private.rscratch;

  return {
    x: rs.midX,
    y: rs.midY
  };
};

module.exports = BRp;

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var math = __webpack_require__(2);
var is = __webpack_require__(0);

var BRp = {};

BRp.manualEndptToPx = function (node, prop) {
  var r = this;
  var npos = node.position();
  var w = node.outerWidth();
  var h = node.outerHeight();

  if (prop.value.length === 2) {
    var p = [prop.pfValue[0], prop.pfValue[1]];

    if (prop.units[0] === '%') {
      p[0] = p[0] * w;
    }

    if (prop.units[1] === '%') {
      p[1] = p[1] * h;
    }

    p[0] += npos.x;
    p[1] += npos.y;

    return p;
  } else {
    var angle = prop.pfValue[0];

    angle = -Math.PI / 2 + angle; // start at 12 o'clock

    var l = 2 * Math.max(w, h);

    var _p = [npos.x + Math.cos(angle) * l, npos.y + Math.sin(angle) * l];

    return r.nodeShapes[this.getNodeShape(node)].intersectLine(npos.x, npos.y, w, h, _p[0], _p[1], 0);
  }
};

BRp.findEndpoints = function (edge) {
  var r = this;
  var intersect = void 0;

  var source = edge.source()[0];
  var target = edge.target()[0];

  var srcPos = source.position();
  var tgtPos = target.position();

  var tgtArShape = edge.pstyle('target-arrow-shape').value;
  var srcArShape = edge.pstyle('source-arrow-shape').value;

  var tgtDist = edge.pstyle('target-distance-from-node').pfValue;
  var srcDist = edge.pstyle('source-distance-from-node').pfValue;

  var rs = edge._private.rscratch;

  var et = rs.edgeType;
  var self = et === 'self' || et === 'compound';
  var bezier = et === 'bezier' || et === 'multibezier' || self;
  var multi = et !== 'bezier';
  var lines = et === 'straight' || et === 'segments';
  var segments = et === 'segments';
  var hasEndpts = bezier || multi || lines;
  var srcManEndpt = edge.pstyle('source-endpoint');
  var srcManEndptVal = self ? 'outside-to-node' : srcManEndpt.value;
  var tgtManEndpt = edge.pstyle('target-endpoint');
  var tgtManEndptVal = self ? 'outside-to-node' : tgtManEndpt.value;

  rs.srcManEndpt = srcManEndpt;
  rs.tgtManEndpt = tgtManEndpt;

  var p1 = void 0; // last known point of edge on target side
  var p2 = void 0; // last known point of edge on source side

  var p1_i = void 0; // point to intersect with target shape
  var p2_i = void 0; // point to intersect with source shape

  if (bezier) {
    var cpStart = [rs.ctrlpts[0], rs.ctrlpts[1]];
    var cpEnd = multi ? [rs.ctrlpts[rs.ctrlpts.length - 2], rs.ctrlpts[rs.ctrlpts.length - 1]] : cpStart;

    p1 = cpEnd;
    p2 = cpStart;
  } else if (lines) {
    var srcArrowFromPt = !segments ? [tgtPos.x, tgtPos.y] : rs.segpts.slice(0, 2);
    var tgtArrowFromPt = !segments ? [srcPos.x, srcPos.y] : rs.segpts.slice(rs.segpts.length - 2);

    p1 = tgtArrowFromPt;
    p2 = srcArrowFromPt;
  }

  if (tgtManEndptVal === 'inside-to-node') {
    intersect = [tgtPos.x, tgtPos.y];
  } else if (tgtManEndpt.units) {
    intersect = this.manualEndptToPx(target, tgtManEndpt);
  } else if (tgtManEndptVal === 'outside-to-line') {
    intersect = rs.tgtIntn; // use cached value from ctrlpt calc
  } else {
    if (tgtManEndptVal === 'outside-to-node') {
      p1_i = p1;
    } else if (tgtManEndptVal === 'outside-to-line') {
      p1_i = [srcPos.x, srcPos.y];
    }

    intersect = r.nodeShapes[this.getNodeShape(target)].intersectLine(tgtPos.x, tgtPos.y, target.outerWidth(), target.outerHeight(), p1_i[0], p1_i[1], 0);
  }

  var arrowEnd = math.shortenIntersection(intersect, p1, r.arrowShapes[tgtArShape].spacing(edge) + tgtDist);
  var edgeEnd = math.shortenIntersection(intersect, p1, r.arrowShapes[tgtArShape].gap(edge) + tgtDist);

  rs.endX = edgeEnd[0];
  rs.endY = edgeEnd[1];

  rs.arrowEndX = arrowEnd[0];
  rs.arrowEndY = arrowEnd[1];

  if (srcManEndptVal === 'inside-to-node') {
    intersect = [srcPos.x, srcPos.y];
  } else if (srcManEndpt.units) {
    intersect = this.manualEndptToPx(source, srcManEndpt);
  } else if (srcManEndptVal === 'outside-to-line') {
    intersect = rs.srcIntn; // use cached value from ctrlpt calc
  } else {
    if (srcManEndptVal === 'outside-to-node') {
      p2_i = p2;
    } else if (srcManEndptVal === 'outside-to-line') {
      p2_i = [tgtPos.x, tgtPos.y];
    }

    intersect = r.nodeShapes[this.getNodeShape(source)].intersectLine(srcPos.x, srcPos.y, source.outerWidth(), source.outerHeight(), p2_i[0], p2_i[1], 0);
  }

  var arrowStart = math.shortenIntersection(intersect, p2, r.arrowShapes[srcArShape].spacing(edge) + srcDist);
  var edgeStart = math.shortenIntersection(intersect, p2, r.arrowShapes[srcArShape].gap(edge) + srcDist);

  rs.startX = edgeStart[0];
  rs.startY = edgeStart[1];

  rs.arrowStartX = arrowStart[0];
  rs.arrowStartY = arrowStart[1];

  if (hasEndpts) {
    if (!is.number(rs.startX) || !is.number(rs.startY) || !is.number(rs.endX) || !is.number(rs.endY)) {
      rs.badLine = true;
    } else {
      rs.badLine = false;
    }
  }
};

BRp.getSourceEndpoint = function (edge) {
  var rs = edge[0]._private.rscratch;

  switch (rs.edgeType) {
    case 'haystack':
      return {
        x: rs.haystackPts[0],
        y: rs.haystackPts[1]
      };
    default:
      return {
        x: rs.arrowStartX,
        y: rs.arrowStartY
      };
  }
};

BRp.getTargetEndpoint = function (edge) {
  var rs = edge[0]._private.rscratch;

  switch (rs.edgeType) {
    case 'haystack':
      return {
        x: rs.haystackPts[2],
        y: rs.haystackPts[3]
      };
    default:
      return {
        x: rs.arrowEndX,
        y: rs.arrowEndY
      };
  }
};

module.exports = BRp;

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var math = __webpack_require__(2);

var BRp = {};

function pushBezierPts(r, edge, pts) {
  var qbezierAt = function qbezierAt(p1, p2, p3, t) {
    return math.qbezierAt(p1, p2, p3, t);
  };
  var _p = edge._private;
  var bpts = _p.rstyle.bezierPts;

  for (var i = 0; i < r.bezierProjPcts.length; i++) {
    var p = r.bezierProjPcts[i];

    bpts.push({
      x: qbezierAt(pts[0], pts[2], pts[4], p),
      y: qbezierAt(pts[1], pts[3], pts[5], p)
    });
  }
}

BRp.storeEdgeProjections = function (edge) {
  var _p = edge._private;
  var rs = _p.rscratch;
  var et = rs.edgeType;

  // clear the cached points state
  _p.rstyle.bezierPts = null;
  _p.rstyle.linePts = null;
  _p.rstyle.haystackPts = null;

  if (et === 'multibezier' || et === 'bezier' || et === 'self' || et === 'compound') {
    var bpts = _p.rstyle.bezierPts = []; // jshint ignore:line

    for (var i = 0; i + 5 < rs.allpts.length; i += 4) {
      pushBezierPts(this, edge, rs.allpts.slice(i, i + 6));
    }
  } else if (et === 'segments') {
    var lpts = _p.rstyle.linePts = [];

    for (var i = 0; i + 1 < rs.allpts.length; i += 2) {
      lpts.push({
        x: rs.allpts[i],
        y: rs.allpts[i + 1]
      });
    }
  } else if (et === 'haystack') {
    var hpts = rs.haystackPts;

    _p.rstyle.haystackPts = [{ x: hpts[0], y: hpts[1] }, { x: hpts[2], y: hpts[3] }];
  }

  _p.rstyle.arrowWidth = this.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.arrowShapeWidth;
};

BRp.recalculateEdgeProjections = function (edges) {
  this.findEdgeControlPoints(edges);
};

module.exports = BRp;

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var math = __webpack_require__(2);
var is = __webpack_require__(0);
var util = __webpack_require__(1);

var BRp = {};

BRp.recalculateNodeLabelProjection = function (node) {
  var content = node.pstyle('label').strValue;

  if (is.emptyString(content)) {
    return;
  }

  var textX, textY;
  var _p = node._private;
  var nodeWidth = node.width();
  var nodeHeight = node.height();
  var padding = node.padding();
  var nodePos = node.position();
  var textHalign = node.pstyle('text-halign').strValue;
  var textValign = node.pstyle('text-valign').strValue;
  var rs = _p.rscratch;
  var rstyle = _p.rstyle;

  switch (textHalign) {
    case 'left':
      textX = nodePos.x - nodeWidth / 2 - padding;
      break;

    case 'right':
      textX = nodePos.x + nodeWidth / 2 + padding;
      break;

    default:
      // e.g. center
      textX = nodePos.x;
  }

  switch (textValign) {
    case 'top':
      textY = nodePos.y - nodeHeight / 2 - padding;
      break;

    case 'bottom':
      textY = nodePos.y + nodeHeight / 2 + padding;
      break;

    default:
      // e.g. middle
      textY = nodePos.y;
  }

  rs.labelX = textX;
  rs.labelY = textY;
  rstyle.labelX = textX;
  rstyle.labelY = textY;

  this.applyLabelDimensions(node);
};

var lineAngleFromDelta = function lineAngleFromDelta(dx, dy) {
  var angle = Math.atan(dy / dx);

  if (dx === 0 && angle < 0) {
    angle = angle * -1;
  }

  return angle;
};

var lineAngle = function lineAngle(p0, p1) {
  var dx = p1.x - p0.x;
  var dy = p1.y - p0.y;

  return lineAngleFromDelta(dx, dy);
};

var bezierAngle = function bezierAngle(p0, p1, p2, t) {
  var t0 = math.bound(0, t - 0.001, 1);
  var t1 = math.bound(0, t + 0.001, 1);

  var lp0 = math.qbezierPtAt(p0, p1, p2, t0);
  var lp1 = math.qbezierPtAt(p0, p1, p2, t1);

  return lineAngle(lp0, lp1);
};

BRp.recalculateEdgeLabelProjections = function (edge) {
  var p;
  var _p = edge._private;
  var rs = _p.rscratch;
  var r = this;
  var content = {
    mid: edge.pstyle('label').strValue,
    source: edge.pstyle('source-label').strValue,
    target: edge.pstyle('target-label').strValue
  };

  if (content.mid || content.source || content.target) {
    // then we have to calculate...
  } else {
      return; // no labels => no calcs
    }

  // add center point to style so bounding box calculations can use it
  //
  p = {
    x: rs.midX,
    y: rs.midY
  };

  var setRs = function setRs(propName, prefix, value) {
    util.setPrefixedProperty(_p.rscratch, propName, prefix, value);
    util.setPrefixedProperty(_p.rstyle, propName, prefix, value);
  };

  setRs('labelX', null, p.x);
  setRs('labelY', null, p.y);

  var midAngle = lineAngleFromDelta(rs.midDispX, rs.midDispY);
  setRs('labelAutoAngle', null, midAngle);

  var createControlPointInfo = function createControlPointInfo() {
    if (createControlPointInfo.cache) {
      return createControlPointInfo.cache;
    } // use cache so only 1x per edge

    var ctrlpts = [];

    // store each ctrlpt info init
    for (var i = 0; i + 5 < rs.allpts.length; i += 4) {
      var p0 = { x: rs.allpts[i], y: rs.allpts[i + 1] };
      var p1 = { x: rs.allpts[i + 2], y: rs.allpts[i + 3] }; // ctrlpt
      var p2 = { x: rs.allpts[i + 4], y: rs.allpts[i + 5] };

      ctrlpts.push({
        p0: p0,
        p1: p1,
        p2: p2,
        startDist: 0,
        length: 0,
        segments: []
      });
    }

    var bpts = _p.rstyle.bezierPts;
    var nProjs = r.bezierProjPcts.length;

    function addSegment(cp, p0, p1, t0, t1) {
      var length = math.dist(p0, p1);
      var prevSegment = cp.segments[cp.segments.length - 1];
      var segment = {
        p0: p0,
        p1: p1,
        t0: t0,
        t1: t1,
        startDist: prevSegment ? prevSegment.startDist + prevSegment.length : 0,
        length: length
      };

      cp.segments.push(segment);

      cp.length += length;
    }

    // update each ctrlpt with segment info
    for (var i = 0; i < ctrlpts.length; i++) {
      var cp = ctrlpts[i];
      var prevCp = ctrlpts[i - 1];

      if (prevCp) {
        cp.startDist = prevCp.startDist + prevCp.length;
      }

      addSegment(cp, cp.p0, bpts[i * nProjs], 0, r.bezierProjPcts[0]); // first

      for (var j = 0; j < nProjs - 1; j++) {
        addSegment(cp, bpts[i * nProjs + j], bpts[i * nProjs + j + 1], r.bezierProjPcts[j], r.bezierProjPcts[j + 1]);
      }

      addSegment(cp, bpts[i * nProjs + nProjs - 1], cp.p2, r.bezierProjPcts[nProjs - 1], 1); // last
    }

    return createControlPointInfo.cache = ctrlpts;
  };

  var calculateEndProjection = function calculateEndProjection(prefix) {
    var angle;
    var isSrc = prefix === 'source';

    if (!content[prefix]) {
      return;
    }

    var offset = edge.pstyle(prefix + '-text-offset').pfValue;

    switch (rs.edgeType) {
      case 'self':
      case 'compound':
      case 'bezier':
      case 'multibezier':
        var cps = createControlPointInfo();
        var selected;
        var startDist = 0;
        var totalDist = 0;

        // find the segment we're on
        for (var i = 0; i < cps.length; i++) {
          var cp = cps[isSrc ? i : cps.length - 1 - i];

          for (var j = 0; j < cp.segments.length; j++) {
            var seg = cp.segments[isSrc ? j : cp.segments.length - 1 - j];
            var lastSeg = i === cps.length - 1 && j === cp.segments.length - 1;

            startDist = totalDist;
            totalDist += seg.length;

            if (totalDist >= offset || lastSeg) {
              selected = { cp: cp, segment: seg };
              break;
            }
          }

          if (selected) {
            break;
          }
        }

        var cp = selected.cp;
        var seg = selected.segment;
        var tSegment = (offset - startDist) / seg.length;
        var segDt = seg.t1 - seg.t0;
        var t = isSrc ? seg.t0 + segDt * tSegment : seg.t1 - segDt * tSegment;

        t = math.bound(0, t, 1);
        p = math.qbezierPtAt(cp.p0, cp.p1, cp.p2, t);
        angle = bezierAngle(cp.p0, cp.p1, cp.p2, t, p);

        break;

      case 'straight':
      case 'segments':
      case 'haystack':
        var d = 0,
            di,
            d0;
        var p0, p1;
        var l = rs.allpts.length;

        for (var i = 0; i + 3 < l; i += 2) {
          if (isSrc) {
            p0 = { x: rs.allpts[i], y: rs.allpts[i + 1] };
            p1 = { x: rs.allpts[i + 2], y: rs.allpts[i + 3] };
          } else {
            p0 = { x: rs.allpts[l - 2 - i], y: rs.allpts[l - 1 - i] };
            p1 = { x: rs.allpts[l - 4 - i], y: rs.allpts[l - 3 - i] };
          }

          di = math.dist(p0, p1);
          d0 = d;
          d += di;

          if (d >= offset) {
            break;
          }
        }

        var pD = offset - d0;
        var t = pD / di;

        t = math.bound(0, t, 1);
        p = math.lineAt(p0, p1, t);
        angle = lineAngle(p0, p1);

        break;
    }

    setRs('labelX', prefix, p.x);
    setRs('labelY', prefix, p.y);
    setRs('labelAutoAngle', prefix, angle);
  };

  calculateEndProjection('source');
  calculateEndProjection('target');

  this.applyLabelDimensions(edge);
};

BRp.applyLabelDimensions = function (ele) {
  this.applyPrefixedLabelDimensions(ele);

  if (ele.isEdge()) {
    this.applyPrefixedLabelDimensions(ele, 'source');
    this.applyPrefixedLabelDimensions(ele, 'target');
  }
};

BRp.applyPrefixedLabelDimensions = function (ele, prefix) {
  var _p = ele._private;

  var text = this.getLabelText(ele, prefix);
  var labelDims = this.calculateLabelDimensions(ele, text);

  util.setPrefixedProperty(_p.rstyle, 'labelWidth', prefix, labelDims.width);
  util.setPrefixedProperty(_p.rscratch, 'labelWidth', prefix, labelDims.width);

  util.setPrefixedProperty(_p.rstyle, 'labelHeight', prefix, labelDims.height);
  util.setPrefixedProperty(_p.rscratch, 'labelHeight', prefix, labelDims.height);
};

BRp.getLabelText = function (ele, prefix) {
  var _p = ele._private;
  var pfd = prefix ? prefix + '-' : '';
  var text = ele.pstyle(pfd + 'label').strValue;
  var textTransform = ele.pstyle('text-transform').value;
  var rscratch = function rscratch(propName, value) {
    if (value) {
      util.setPrefixedProperty(_p.rscratch, propName, prefix, value);
      return value;
    } else {
      return util.getPrefixedProperty(_p.rscratch, propName, prefix);
    }
  };

  // for empty text, skip all processing
  if (!text) {
    return '';
  }

  if (textTransform == 'none') {
    // passthrough
  } else if (textTransform == 'uppercase') {
    text = text.toUpperCase();
  } else if (textTransform == 'lowercase') {
    text = text.toLowerCase();
  }

  var wrapStyle = ele.pstyle('text-wrap').value;

  if (wrapStyle === 'wrap') {
    //console.log('wrap');

    var labelKey = rscratch('labelKey');

    // save recalc if the label is the same as before
    if (labelKey && rscratch('labelWrapKey') === labelKey) {
      // console.log('wrap cache hit');
      return rscratch('labelWrapCachedText');
    }
    // console.log('wrap cache miss');

    var lines = text.split('\n');
    var maxW = ele.pstyle('text-max-width').pfValue;
    var wrappedLines = [];

    for (var l = 0; l < lines.length; l++) {
      var line = lines[l];
      var lineDims = this.calculateLabelDimensions(ele, line, 'line=' + line);
      var lineW = lineDims.width;

      if (lineW > maxW) {
        // line is too long
        var words = line.split(/\s+/); // NB: assume collapsed whitespace into single space
        var subline = '';

        for (var w = 0; w < words.length; w++) {
          var word = words[w];
          var testLine = subline.length === 0 ? word : subline + ' ' + word;
          var testDims = this.calculateLabelDimensions(ele, testLine, 'testLine=' + testLine);
          var testW = testDims.width;

          if (testW <= maxW) {
            // word fits on current line
            subline += word + ' ';
          } else {
            // word starts new line
            wrappedLines.push(subline);
            subline = word + ' ';
          }
        }

        // if there's remaining text, put it in a wrapped line
        if (!subline.match(/^\s+$/)) {
          wrappedLines.push(subline);
        }
      } else {
        // line is already short enough
        wrappedLines.push(line);
      }
    } // for

    rscratch('labelWrapCachedLines', wrappedLines);
    text = rscratch('labelWrapCachedText', wrappedLines.join('\n'));
    rscratch('labelWrapKey', labelKey);

    // console.log(text)
  } else if (wrapStyle === 'ellipsis') {
    var maxW = ele.pstyle('text-max-width').pfValue;
    var ellipsized = '';
    var ellipsis = '\u2026';
    var incLastCh = false;

    for (var i = 0; i < text.length; i++) {
      var widthWithNextCh = this.calculateLabelDimensions(ele, ellipsized + text[i] + ellipsis).width;

      if (widthWithNextCh > maxW) {
        break;
      }

      ellipsized += text[i];

      if (i === text.length - 1) {
        incLastCh = true;
      }
    }

    if (!incLastCh) {
      ellipsized += ellipsis;
    }

    return ellipsized;
  } // if ellipsize

  return text;
};

BRp.calculateLabelDimensions = function (ele, text, extraKey) {
  var r = this;

  var cacheKey = ele._private.labelStyleKey + '$@$' + text;

  if (extraKey) {
    cacheKey += '$@$' + extraKey;
  }

  var cache = r.labelDimCache || (r.labelDimCache = {});

  if (cache[cacheKey]) {
    return cache[cacheKey];
  }

  var sizeMult = 1; // increase the scale to increase accuracy w.r.t. zoomed text
  var fStyle = ele.pstyle('font-style').strValue;
  var size = sizeMult * ele.pstyle('font-size').pfValue + 'px';
  var family = ele.pstyle('font-family').strValue;
  var weight = ele.pstyle('font-weight').strValue;

  var div = this.labelCalcDiv;

  if (!div) {
    div = this.labelCalcDiv = document.createElement('div'); // eslint-disable-line no-undef
    document.body.appendChild(div); // eslint-disable-line no-undef
  }

  var ds = div.style;

  // from ele style
  ds.fontFamily = family;
  ds.fontStyle = fStyle;
  ds.fontSize = size;
  ds.fontWeight = weight;

  // forced style
  ds.position = 'absolute';
  ds.left = '-9999px';
  ds.top = '-9999px';
  ds.zIndex = '-1';
  ds.visibility = 'hidden';
  ds.pointerEvents = 'none';
  ds.padding = '0';
  ds.lineHeight = '1';

  if (ele.pstyle('text-wrap').value === 'wrap') {
    ds.whiteSpace = 'pre'; // so newlines are taken into account
  } else {
    ds.whiteSpace = 'normal';
  }

  // put label content in div
  div.textContent = text;

  cache[cacheKey] = {
    width: Math.ceil(div.clientWidth / sizeMult),
    height: Math.ceil(div.clientHeight / sizeMult)
  };

  return cache[cacheKey];
};

BRp.calculateLabelAngles = function (ele) {
  var _p = ele._private;
  var rs = _p.rscratch;
  var isEdge = ele.isEdge();
  var rot = ele.pstyle('text-rotation');
  var rotStr = rot.strValue;

  if (rotStr === 'none') {
    rs.labelAngle = rs.sourceLabelAngle = rs.targetLabelAngle = 0;
  } else if (isEdge && rotStr === 'autorotate') {
    rs.labelAngle = rs.labelAutoAngle;
    rs.sourceLabelAngle = rs.sourceLabelAutoAngle;
    rs.targetLabelAngle = rs.targetLabelAutoAngle;
  } else if (rotStr === 'autorotate') {
    rs.labelAngle = rs.sourceLabelAngle = rs.targetLabelAngle = 0;
  } else {
    rs.labelAngle = rs.sourceLabelAngle = rs.targetLabelAngle = rot.pfValue;
  }
};

module.exports = BRp;

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BRp = {};

BRp.getNodeShape = function (node) {
  var r = this;
  var shape = node.pstyle('shape').value;

  if (node.isParent()) {
    if (shape === 'rectangle' || shape === 'roundrectangle' || shape === 'cutrectangle' || shape === 'barrel') {
      return shape;
    } else {
      return 'rectangle';
    }
  }

  if (shape === 'polygon') {
    var points = node.pstyle('shape-polygon-points').value;

    return r.nodeShapes.makePolygon(points).name;
  }

  return shape;
};

module.exports = BRp;

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BRp = {};

BRp.registerCalculationListeners = function () {
  var cy = this.cy;
  var elesToUpdate = cy.collection();
  var r = this;

  var enqueue = function enqueue(eles, e) {
    var dirtyStyleCaches = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

    elesToUpdate.merge(eles);

    for (var i = 0; i < eles.length; i++) {
      var ele = eles[i];
      var _p = ele._private;
      var rstyle = _p.rstyle;

      if (dirtyStyleCaches) {
        rstyle.clean = false;
        _p.bbCache = null;
      }

      var evts = rstyle.dirtyEvents = rstyle.dirtyEvents || { length: 0 };

      if (!evts[e.type]) {
        evts[e.type] = true;
        evts.length++;
      }
    }
  };

  r.binder(cy)
  // nodes

  .on('position.* style.* free.* bounds.*', 'node', function onDirtyModNode(e) {
    var node = e.target;

    enqueue(node, e);
    enqueue(node.connectedEdges(), e);
  }).on('add.*', 'node', function onDirtyAddNode(e) {
    var ele = e.target;

    enqueue(ele, e);
  }).on('background.*', 'node', function onDirtyBgNode(e) {
    var ele = e.target;

    enqueue(ele, e, false);
  })

  // edges

  .on('add.* style.*', 'edge', function onDirtyEdge(e) {
    var edge = e.target;

    enqueue(edge, e);
    enqueue(edge.parallelEdges(), e);
  }).on('remove.*', 'edge', function onDirtyRemoveEdge(e) {
    var edge = e.target;
    var pEdges = edge.parallelEdges();

    for (var i = 0; i < pEdges.length; i++) {
      var pEdge = pEdges[i];

      if (!pEdge.removed()) {
        enqueue(pEdge, e);
      }
    }
  })

  // manual dirtying

  .on('dirty.*', 'node', function onDirtyEle(e) {
    var ele = e.target;

    enqueue(ele, e);
  });

  var updateEleCalcs = function updateEleCalcs(willDraw) {
    if (willDraw) {
      var fns = r.onUpdateEleCalcsFns;

      if (fns) {
        for (var i = 0; i < fns.length; i++) {
          var fn = fns[i];

          fn(willDraw, elesToUpdate);
        }
      }

      r.recalculateRenderedStyle(elesToUpdate, false);

      for (var i = 0; i < elesToUpdate.length; i++) {
        elesToUpdate[i]._private.rstyle.dirtyEvents = null;
      }

      elesToUpdate = cy.collection();
    }
  };

  r.beforeRender(updateEleCalcs, r.beforeRenderPriorities.eleCalcs);
};

BRp.onUpdateEleCalcs = function (fn) {
  var fns = this.onUpdateEleCalcsFns = this.onUpdateEleCalcsFns || [];

  fns.push(fn);
};

BRp.recalculateRenderedStyle = function (eles, useCache) {
  var edges = [];
  var nodes = [];

  // the renderer can't be used for calcs when destroyed, e.g. ele.boundingBox()
  if (this.destroyed) {
    return;
  }

  // use cache by default for perf
  if (useCache === undefined) {
    useCache = true;
  }

  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];
    var _p = ele._private;
    var rstyle = _p.rstyle;

    // only update if dirty and in graph
    if (useCache && rstyle.clean || ele.removed()) {
      continue;
    }

    // only update if not display: none
    if (ele.pstyle('display').value === 'none') {
      continue;
    }

    if (_p.group === 'nodes') {
      nodes.push(ele);
    } else {
      // edges
      edges.push(ele);
    }

    rstyle.clean = true;
    // rstyle.dirtyEvents = null;
  }

  // update node data from projections
  for (var i = 0; i < nodes.length; i++) {
    var ele = nodes[i];
    var _p = ele._private;
    var rstyle = _p.rstyle;
    var pos = ele.position();

    this.recalculateNodeLabelProjection(ele);

    rstyle.nodeX = pos.x;
    rstyle.nodeY = pos.y;
    rstyle.nodeW = ele.pstyle('width').pfValue;
    rstyle.nodeH = ele.pstyle('height').pfValue;
  }

  this.recalculateEdgeProjections(edges);

  // update edge data from projections
  for (var i = 0; i < edges.length; i++) {
    var ele = edges[i];
    var _p = ele._private;
    var rstyle = _p.rstyle;
    var rs = _p.rscratch;

    this.recalculateEdgeLabelProjections(ele);

    // update rstyle positions
    rstyle.srcX = rs.arrowStartX;
    rstyle.srcY = rs.arrowStartY;
    rstyle.tgtX = rs.arrowEndX;
    rstyle.tgtY = rs.arrowEndY;
    rstyle.midX = rs.midX;
    rstyle.midY = rs.midY;
    rstyle.labelAngle = rs.labelAngle;
    rstyle.sourceLabelAngle = rs.sourceLabelAngle;
    rstyle.targetLabelAngle = rs.targetLabelAngle;
  }
};

module.exports = BRp;

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var zIndexSort = __webpack_require__(17);

var BRp = {};

BRp.updateCachedGrabbedEles = function () {
  var eles = this.cachedZSortedEles;

  if (!eles) {
    // just let this be recalculated on the next z sort tick
    return;
  }

  eles.drag = [];
  eles.nondrag = [];

  var grabTargets = [];

  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];
    var rs = ele._private.rscratch;

    if (ele.grabbed() && !ele.isParent()) {
      grabTargets.push(ele);
    } else if (rs.inDragLayer) {
      eles.drag.push(ele);
    } else {
      eles.nondrag.push(ele);
    }
  }

  // put the grab target nodes last so it's on top of its neighbourhood
  for (var i = 0; i < grabTargets.length; i++) {
    var ele = grabTargets[i];

    eles.drag.push(ele);
  }
};

BRp.invalidateCachedZSortedEles = function () {
  this.cachedZSortedEles = null;
};

BRp.getCachedZSortedEles = function (forceRecalc) {
  if (forceRecalc || !this.cachedZSortedEles) {
    //console.time('cachezorder')

    var eles = this.cy.mutableElements().toArray();

    eles.sort(zIndexSort);

    eles.interactive = eles.filter(function (ele) {
      return ele.interactive();
    });

    this.cachedZSortedEles = eles;

    this.updateCachedGrabbedEles();
  } else {
    eles = this.cachedZSortedEles;
  }

  return eles;
};

module.exports = BRp;

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BRp = {};

BRp.getCachedImage = function (url, crossOrigin, onLoad) {
  var r = this;
  var imageCache = r.imageCache = r.imageCache || {};
  var cache = imageCache[url];

  if (cache) {
    if (!cache.image.complete) {
      cache.image.addEventListener('load', onLoad);
    }

    return cache.image;
  } else {
    cache = imageCache[url] = imageCache[url] || {};

    var image = cache.image = new Image(); // eslint-disable-line no-undef

    image.addEventListener('load', onLoad);
    image.addEventListener('error', function () {
      image.error = true;
    });

    // #1582 safari doesn't load data uris with crossOrigin properly
    // https://bugs.webkit.org/show_bug.cgi?id=123978
    var dataUriPrefix = 'data:';
    var isDataUri = url.substring(0, dataUriPrefix.length).toLowerCase() === dataUriPrefix;
    if (!isDataUri) {
      image.crossOrigin = crossOrigin; // prevent tainted canvas
    }

    image.src = url;

    return image;
  }
};

module.exports = BRp;

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);
var util = __webpack_require__(1);
var math = __webpack_require__(2);
var Event = __webpack_require__(16);

var BRp = {};

BRp.registerBinding = function (target, event, handler, useCapture) {
  var args = Array.prototype.slice.apply(arguments, [1]); // copy
  var b = this.binder(target);

  return b.on.apply(b, args);
};

BRp.binder = function (tgt) {
  var r = this;

  var tgtIsDom = tgt === window || tgt === document || tgt === document.body || is.domElement(tgt);

  if (r.supportsPassiveEvents == null) {

    // from https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection
    var supportsPassive = false;
    try {
      var opts = Object.defineProperty({}, 'passive', {
        get: function get() {
          supportsPassive = true;
        }
      });

      window.addEventListener('test', null, opts);
    } catch (err) {}

    r.supportsPassiveEvents = supportsPassive;
  }

  var on = function on(event, handler, useCapture) {
    var args = Array.prototype.slice.call(arguments);

    if (tgtIsDom && r.supportsPassiveEvents) {
      // replace useCapture w/ opts obj
      args[2] = {
        capture: useCapture != null ? useCapture : false,
        passive: false,
        once: false
      };
    }

    r.bindings.push({
      target: tgt,
      args: args
    });

    (tgt.addEventListener || tgt.on).apply(tgt, args);

    return this;
  };

  return {
    on: on,
    addEventListener: on,
    addListener: on,
    bind: on
  };
};

BRp.nodeIsDraggable = function (node) {
  return node && node.isNode() && !node.locked() && node.grabbable();
};

BRp.nodeIsGrabbable = function (node) {
  return this.nodeIsDraggable(node) && node.interactive();
};

BRp.load = function () {
  var r = this;

  var triggerEvents = function triggerEvents(target, names, e, props) {
    if (target == null) {
      target = r.cy;
    }

    for (var i = 0; i < names.length; i++) {
      var name = names[i];

      target.emit(util.extend({ originalEvent: e, type: name }, props));
    }
  };

  var isMultSelKeyDown = function isMultSelKeyDown(e) {
    return e.shiftKey || e.metaKey || e.ctrlKey; // maybe e.altKey
  };

  var allowPanningPassthrough = function allowPanningPassthrough(down, downs) {
    var allowPassthrough = true;

    if (r.cy.hasCompoundNodes() && down && down.isEdge()) {
      // a compound node below the edge => no passthrough panning
      for (var i = 0; downs && i < downs.length; i++) {
        var down = downs[i];

        if (down.isNode() && down.isParent()) {
          allowPassthrough = false;
          break;
        }
      }
    } else {
      allowPassthrough = true;
    }

    return allowPassthrough;
  };

  var getDragListIds = function getDragListIds(opts) {
    var listHasId;

    if (opts.addToList && r.cy.hasCompoundNodes()) {
      // only needed for compound graphs
      if (!opts.addToList.hasId) {
        // build ids lookup if doesn't already exist
        opts.addToList.hasId = {};

        for (var i = 0; i < opts.addToList.length; i++) {
          var ele = opts.addToList[i];

          opts.addToList.hasId[ele.id()] = true;
        }
      }

      listHasId = opts.addToList.hasId;
    }

    return listHasId || {};
  };

  var setGrabbed = function setGrabbed(ele) {
    ele[0]._private.grabbed = true;
  };

  var setFreed = function setFreed(ele) {
    ele[0]._private.grabbed = false;
  };

  var setInDragLayer = function setInDragLayer(ele) {
    ele[0]._private.rscratch.inDragLayer = true;
  };

  var setOutDragLayer = function setOutDragLayer(ele) {
    ele[0]._private.rscratch.inDragLayer = false;
  };

  var setGrabTarget = function setGrabTarget(ele) {
    ele[0]._private.rscratch.isGrabTarget = true;
  };

  var removeGrabTarget = function removeGrabTarget(ele) {
    ele[0]._private.rscratch.isGrabTarget = false;
  };

  var addToDragList = function addToDragList(ele, opts) {
    var listHasId = getDragListIds(opts);

    if (!listHasId[ele.id()]) {
      opts.addToList.push(ele);
      listHasId[ele.id()] = true;

      setGrabbed(ele);
    }
  };

  // helper function to determine which child nodes and inner edges
  // of a compound node to be dragged as well as the grabbed and selected nodes
  var addDescendantsToDrag = function addDescendantsToDrag(node, opts) {
    if (!node.cy().hasCompoundNodes()) {
      return;
    }

    if (opts.inDragLayer == null && opts.addToList == null) {
      return;
    } // nothing to do

    var innerNodes = node.descendants();

    if (opts.inDragLayer) {
      innerNodes.forEach(setInDragLayer);
      innerNodes.connectedEdges().forEach(setInDragLayer);
    }

    if (opts.addToList) {
      innerNodes.forEach(function (ele) {
        addToDragList(ele, opts);
      });
    }
  };

  // adds the given nodes and its neighbourhood to the drag layer
  var addNodesToDrag = function addNodesToDrag(nodes, opts) {
    opts = opts || {};

    var hasCompoundNodes = nodes.cy().hasCompoundNodes();

    if (opts.inDragLayer) {
      nodes.forEach(setInDragLayer);

      nodes.neighborhood().stdFilter(function (ele) {
        return !hasCompoundNodes || ele.isEdge();
      }).forEach(setInDragLayer);
    }

    if (opts.addToList) {
      nodes.forEach(function (ele) {
        addToDragList(ele, opts);
      });
    }

    addDescendantsToDrag(nodes, opts); // always add to drag

    // also add nodes and edges related to the topmost ancestor
    updateAncestorsInDragLayer(nodes, {
      inDragLayer: opts.inDragLayer
    });

    r.updateCachedGrabbedEles();
  };

  var addNodeToDrag = addNodesToDrag;

  var freeDraggedElements = function freeDraggedElements(grabbedEles) {
    if (!grabbedEles) {
      return;
    }

    grabbedEles.hasId = {}; // clear the id list

    // just go over all elements rather than doing a bunch of (possibly expensive) traversals
    r.getCachedZSortedEles().forEach(function (ele) {
      setFreed(ele);
      setOutDragLayer(ele);
      removeGrabTarget(ele);
    });

    r.updateCachedGrabbedEles();
  };

  // helper function to determine which ancestor nodes and edges should go
  // to the drag layer (or should be removed from drag layer).
  var updateAncestorsInDragLayer = function updateAncestorsInDragLayer(node, opts) {

    if (opts.inDragLayer == null && opts.addToList == null) {
      return;
    } // nothing to do

    if (!node.cy().hasCompoundNodes()) {
      return;
    }

    // find top-level parent
    var parent = node.ancestors().orphans();

    // no parent node: no nodes to add to the drag layer
    if (parent.same(node)) {
      return;
    }

    var nodes = parent.descendants().spawnSelf().merge(parent).unmerge(node).unmerge(node.descendants());

    var edges = nodes.connectedEdges();

    if (opts.inDragLayer) {
      edges.forEach(setInDragLayer);
      nodes.forEach(setInDragLayer);
    }

    if (opts.addToList) {
      nodes.forEach(function (ele) {
        addToDragList(ele, opts);
      });
    }
  };

  var blurActiveDomElement = function blurActiveDomElement() {
    if (document.activeElement != null && document.activeElement.blur != null) {
      document.activeElement.blur();
    }
  };

  var haveMutationsApi = typeof MutationObserver !== 'undefined';

  // watch for when the cy container is removed from the dom
  if (haveMutationsApi) {
    r.removeObserver = new MutationObserver(function (mutns) {
      // eslint-disable-line no-undef
      for (var i = 0; i < mutns.length; i++) {
        var mutn = mutns[i];
        var rNodes = mutn.removedNodes;

        if (rNodes) {
          for (var j = 0; j < rNodes.length; j++) {
            var rNode = rNodes[j];

            if (rNode === r.container) {
              r.destroy();
              break;
            }
          }
        }
      }
    });

    if (r.container.parentNode) {
      r.removeObserver.observe(r.container.parentNode, { childList: true });
    }
  } else {
    r.registerBinding(r.container, 'DOMNodeRemoved', function (e) {
      r.destroy();
    });
  }

  var onResize = util.debounce(function () {
    r.cy.resize();
  }, 100);

  if (haveMutationsApi) {
    r.styleObserver = new MutationObserver(onResize); // eslint-disable-line no-undef

    r.styleObserver.observe(r.container, { attributes: true });
  }

  // auto resize
  r.registerBinding(window, 'resize', onResize); // eslint-disable-line no-undef

  var forEachUp = function forEachUp(domEle, fn) {
    while (domEle != null) {
      fn(domEle);

      domEle = domEle.parentNode;
    }
  };

  var invalidateCoords = function invalidateCoords() {
    r.invalidateContainerClientCoordsCache();
  };

  forEachUp(r.container, function (domEle) {
    r.registerBinding(domEle, 'transitionend', invalidateCoords);
    r.registerBinding(domEle, 'animationend', invalidateCoords);
    r.registerBinding(domEle, 'scroll', invalidateCoords);
  });

  // stop right click menu from appearing on cy
  r.registerBinding(r.container, 'contextmenu', function (e) {
    e.preventDefault();
  });

  var inBoxSelection = function inBoxSelection() {
    return r.selection[4] !== 0;
  };

  var eventInContainer = function eventInContainer(e) {
    // save cycles if mouse events aren't to be captured
    var containerPageCoords = r.findContainerClientCoords();
    var x = containerPageCoords[0];
    var y = containerPageCoords[1];
    var width = containerPageCoords[2];
    var height = containerPageCoords[3];

    var positions = e.touches ? e.touches : [e];
    var atLeastOnePosInside = false;

    for (var i = 0; i < positions.length; i++) {
      var p = positions[i];

      if (x <= p.clientX && p.clientX <= x + width && y <= p.clientY && p.clientY <= y + height) {
        atLeastOnePosInside = true;
        break;
      }
    }

    if (!atLeastOnePosInside) {
      return false;
    }

    var container = r.container;
    var target = e.target;
    var tParent = target.parentNode;
    var containerIsTarget = false;

    while (tParent) {
      if (tParent === container) {
        containerIsTarget = true;
        break;
      }

      tParent = tParent.parentNode;
    }

    if (!containerIsTarget) {
      return false;
    } // if target is outisde cy container, then this event is not for us

    return true;
  };

  // Primary key
  r.registerBinding(r.container, 'mousedown', function mousedownHandler(e) {
    if (!eventInContainer(e)) {
      return;
    }

    e.preventDefault();

    blurActiveDomElement();

    r.hoverData.capture = true;
    r.hoverData.which = e.which;

    var cy = r.cy;
    var gpos = [e.clientX, e.clientY];
    var pos = r.projectIntoViewport(gpos[0], gpos[1]);
    var select = r.selection;
    var nears = r.findNearestElements(pos[0], pos[1], true, false);
    var near = nears[0];
    var draggedElements = r.dragData.possibleDragElements;

    r.hoverData.mdownPos = pos;
    r.hoverData.mdownGPos = gpos;

    var checkForTaphold = function checkForTaphold() {
      r.hoverData.tapholdCancelled = false;

      clearTimeout(r.hoverData.tapholdTimeout);

      r.hoverData.tapholdTimeout = setTimeout(function () {

        if (r.hoverData.tapholdCancelled) {
          return;
        } else {
          var ele = r.hoverData.down;

          if (ele) {
            ele.emit({
              originalEvent: e,
              type: 'taphold',
              position: { x: pos[0], y: pos[1] }
            });
          } else {
            cy.emit({
              originalEvent: e,
              type: 'taphold',
              position: { x: pos[0], y: pos[1] }
            });
          }
        }
      }, r.tapholdDuration);
    };

    // Right click button
    if (e.which == 3) {

      r.hoverData.cxtStarted = true;

      var cxtEvt = {
        originalEvent: e,
        type: 'cxttapstart',
        position: { x: pos[0], y: pos[1] }
      };

      if (near) {
        near.activate();
        near.emit(cxtEvt);

        r.hoverData.down = near;
      } else {
        cy.emit(cxtEvt);
      }

      r.hoverData.downTime = new Date().getTime();
      r.hoverData.cxtDragged = false;

      // Primary button
    } else if (e.which == 1) {

      if (near) {
        near.activate();
      }

      // Element dragging
      {
        // If something is under the cursor and it is draggable, prepare to grab it
        if (near != null) {

          if (r.nodeIsGrabbable(near)) {

            var makeEvent = function makeEvent(type) {
              return {
                originalEvent: e,
                type: type,
                position: { x: pos[0], y: pos[1] }
              };
            };

            var triggerGrab = function triggerGrab(ele) {
              ele.emit(makeEvent('grab'));
            };

            setGrabTarget(near);

            if (!near.selected()) {

              draggedElements = r.dragData.possibleDragElements = [];
              addNodeToDrag(near, { addToList: draggedElements });

              near.emit(makeEvent('grabon')).emit(makeEvent('grab'));
            } else {
              draggedElements = r.dragData.possibleDragElements = [];

              var selectedNodes = cy.$(function (ele) {
                return ele.isNode() && ele.selected() && r.nodeIsGrabbable(ele);
              });

              addNodesToDrag(selectedNodes, { addToList: draggedElements });

              near.emit(makeEvent('grabon'));

              selectedNodes.forEach(triggerGrab);
            }

            r.redrawHint('eles', true);
            r.redrawHint('drag', true);
          }
        }

        r.hoverData.down = near;
        r.hoverData.downs = nears;
        r.hoverData.downTime = new Date().getTime();
      }

      triggerEvents(near, ['mousedown', 'tapstart', 'vmousedown'], e, {
        position: { x: pos[0], y: pos[1] }
      });

      if (near == null) {
        select[4] = 1;

        r.data.bgActivePosistion = {
          x: pos[0],
          y: pos[1]
        };

        r.redrawHint('select', true);

        r.redraw();
      } else if (near.isEdge()) {
        select[4] = 1; // for future pan
      }

      checkForTaphold();
    }

    // Initialize selection box coordinates
    select[0] = select[2] = pos[0];
    select[1] = select[3] = pos[1];
  }, false);

  r.registerBinding(window, 'mousemove', function mousemoveHandler(e) {
    // eslint-disable-line no-undef
    var capture = r.hoverData.capture;

    if (!capture && !eventInContainer(e)) {
      return;
    }

    var preventDefault = false;
    var cy = r.cy;
    var zoom = cy.zoom();
    var gpos = [e.clientX, e.clientY];
    var pos = r.projectIntoViewport(gpos[0], gpos[1]);
    var mdownPos = r.hoverData.mdownPos;
    var mdownGPos = r.hoverData.mdownGPos;
    var select = r.selection;

    var near = null;
    if (!r.hoverData.draggingEles && !r.hoverData.dragging && !r.hoverData.selecting) {
      near = r.findNearestElement(pos[0], pos[1], true, false);
    }
    var last = r.hoverData.last;
    var down = r.hoverData.down;

    var disp = [pos[0] - select[2], pos[1] - select[3]];

    var draggedElements = r.dragData.possibleDragElements;

    var isOverThresholdDrag;

    if (mdownGPos) {
      var dx = gpos[0] - mdownGPos[0];
      var dx2 = dx * dx;
      var dy = gpos[1] - mdownGPos[1];
      var dy2 = dy * dy;
      var dist2 = dx2 + dy2;

      r.hoverData.isOverThresholdDrag = isOverThresholdDrag = dist2 >= r.desktopTapThreshold2;
    }

    var multSelKeyDown = isMultSelKeyDown(e);

    if (isOverThresholdDrag) {
      r.hoverData.tapholdCancelled = true;
    }

    var updateDragDelta = function updateDragDelta() {
      var dragDelta = r.hoverData.dragDelta = r.hoverData.dragDelta || [];

      if (dragDelta.length === 0) {
        dragDelta.push(disp[0]);
        dragDelta.push(disp[1]);
      } else {
        dragDelta[0] += disp[0];
        dragDelta[1] += disp[1];
      }
    };

    preventDefault = true;

    triggerEvents(near, ['mousemove', 'vmousemove', 'tapdrag'], e, {
      position: { x: pos[0], y: pos[1] }
    });

    var goIntoBoxMode = function goIntoBoxMode() {
      r.data.bgActivePosistion = undefined;

      if (!r.hoverData.selecting) {
        cy.emit('boxstart');
      }

      select[4] = 1;
      r.hoverData.selecting = true;

      r.redrawHint('select', true);
      r.redraw();
    };

    // trigger context drag if rmouse down
    if (r.hoverData.which === 3) {
      // but only if over threshold
      if (isOverThresholdDrag) {
        var cxtEvt = {
          originalEvent: e,
          type: 'cxtdrag',
          position: { x: pos[0], y: pos[1] }
        };

        if (down) {
          down.emit(cxtEvt);
        } else {
          cy.emit(cxtEvt);
        }

        r.hoverData.cxtDragged = true;

        if (!r.hoverData.cxtOver || near !== r.hoverData.cxtOver) {

          if (r.hoverData.cxtOver) {
            r.hoverData.cxtOver.emit({
              originalEvent: e,
              type: 'cxtdragout',
              position: { x: pos[0], y: pos[1] }
            });
          }

          r.hoverData.cxtOver = near;

          if (near) {
            near.emit({
              originalEvent: e,
              type: 'cxtdragover',
              position: { x: pos[0], y: pos[1] }
            });
          }
        }
      }

      // Check if we are drag panning the entire graph
    } else if (r.hoverData.dragging) {
      preventDefault = true;

      if (cy.panningEnabled() && cy.userPanningEnabled()) {
        var deltaP;

        if (r.hoverData.justStartedPan) {
          var mdPos = r.hoverData.mdownPos;

          deltaP = {
            x: (pos[0] - mdPos[0]) * zoom,
            y: (pos[1] - mdPos[1]) * zoom
          };

          r.hoverData.justStartedPan = false;
        } else {
          deltaP = {
            x: disp[0] * zoom,
            y: disp[1] * zoom
          };
        }

        cy.panBy(deltaP);

        r.hoverData.dragged = true;
      }

      // Needs reproject due to pan changing viewport
      pos = r.projectIntoViewport(e.clientX, e.clientY);

      // Checks primary button down & out of time & mouse not moved much
    } else if (select[4] == 1 && (down == null || down.isEdge())) {

      if (isOverThresholdDrag) {

        if (!r.hoverData.dragging && cy.boxSelectionEnabled() && (multSelKeyDown || !cy.panningEnabled() || !cy.userPanningEnabled())) {
          goIntoBoxMode();
        } else if (!r.hoverData.selecting && cy.panningEnabled() && cy.userPanningEnabled()) {
          var allowPassthrough = allowPanningPassthrough(down, r.hoverData.downs);

          if (allowPassthrough) {
            r.hoverData.dragging = true;
            r.hoverData.justStartedPan = true;
            select[4] = 0;

            r.data.bgActivePosistion = math.array2point(mdownPos);

            r.redrawHint('select', true);
            r.redraw();
          }
        }

        if (down && down.isEdge() && down.active()) {
          down.unactivate();
        }
      }
    } else {
      if (down && down.isEdge() && down.active()) {
        down.unactivate();
      }

      if ((!down || !down.grabbed()) && near != last) {

        if (last) {
          triggerEvents(last, ['mouseout', 'tapdragout'], e, {
            position: { x: pos[0], y: pos[1] }
          });
        }

        if (near) {
          triggerEvents(near, ['mouseover', 'tapdragover'], e, {
            position: { x: pos[0], y: pos[1] }
          });
        }

        r.hoverData.last = near;
      }

      if (down) {

        if (isOverThresholdDrag) {
          // then we can take action

          if (cy.boxSelectionEnabled() && multSelKeyDown) {
            // then selection overrides
            if (down && down.grabbed()) {
              freeDraggedElements(draggedElements);

              down.emit('free');
            }

            goIntoBoxMode();
          } else if (down && down.grabbed() && r.nodeIsDraggable(down)) {
            // drag node
            var justStartedDrag = !r.dragData.didDrag;

            if (justStartedDrag) {
              r.redrawHint('eles', true);
            }

            r.dragData.didDrag = true; // indicate that we actually did drag the node

            var toTrigger = [];

            // now, add the elements to the drag layer if not done already
            if (!r.hoverData.draggingEles) {
              addNodesToDrag(cy.collection(draggedElements), { inDragLayer: true });
            }

            for (var i = 0; i < draggedElements.length; i++) {
              var dEle = draggedElements[i];

              // Locked nodes not draggable, as well as non-visible nodes
              if (r.nodeIsDraggable(dEle) && dEle.grabbed()) {
                var dPos = dEle.position();

                toTrigger.push(dEle);

                if (is.number(disp[0]) && is.number(disp[1])) {
                  dPos.x += disp[0];
                  dPos.y += disp[1];

                  if (justStartedDrag) {
                    var dragDelta = r.hoverData.dragDelta;

                    if (dragDelta && is.number(dragDelta[0]) && is.number(dragDelta[1])) {
                      dPos.x += dragDelta[0];
                      dPos.y += dragDelta[1];
                    }
                  }
                }
              }
            }

            r.hoverData.draggingEles = true;

            var tcol = cy.collection(toTrigger);

            tcol.dirtyCompoundBoundsCache();
            tcol.emit('position drag');

            r.redrawHint('drag', true);
            r.redraw();
          }
        } else {
          // otherwise save drag delta for when we actually start dragging so the relative grab pos is constant
          updateDragDelta();
        }
      }

      // prevent the dragging from triggering text selection on the page
      preventDefault = true;
    }

    select[2] = pos[0];select[3] = pos[1];

    if (preventDefault) {
      if (e.stopPropagation) e.stopPropagation();
      if (e.preventDefault) e.preventDefault();
      return false;
    }
  }, false);

  r.registerBinding(window, 'mouseup', function mouseupHandler(e) {
    // eslint-disable-line no-undef
    var capture = r.hoverData.capture;
    if (!capture) {
      return;
    }
    r.hoverData.capture = false;

    var cy = r.cy;var pos = r.projectIntoViewport(e.clientX, e.clientY);var select = r.selection;
    var near = r.findNearestElement(pos[0], pos[1], true, false);
    var draggedElements = r.dragData.possibleDragElements;var down = r.hoverData.down;
    var multSelKeyDown = isMultSelKeyDown(e);

    if (r.data.bgActivePosistion) {
      r.redrawHint('select', true);
      r.redraw();
    }

    r.hoverData.tapholdCancelled = true;

    r.data.bgActivePosistion = undefined; // not active bg now

    if (down) {
      down.unactivate();
    }

    if (r.hoverData.which === 3) {
      var cxtEvt = {
        originalEvent: e,
        type: 'cxttapend',
        position: { x: pos[0], y: pos[1] }
      };

      if (down) {
        down.emit(cxtEvt);
      } else {
        cy.emit(cxtEvt);
      }

      if (!r.hoverData.cxtDragged) {
        var cxtTap = {
          originalEvent: e,
          type: 'cxttap',
          position: { x: pos[0], y: pos[1] }
        };

        if (down) {
          down.emit(cxtTap);
        } else {
          cy.emit(cxtTap);
        }
      }

      r.hoverData.cxtDragged = false;
      r.hoverData.which = null;
    } else if (r.hoverData.which === 1) {

      // Deselect all elements if nothing is currently under the mouse cursor and we aren't dragging something
      if (down == null && // not mousedown on node
      !r.dragData.didDrag // didn't move the node around
      && !r.hoverData.selecting // not box selection
      && !r.hoverData.dragged // didn't pan
      && !isMultSelKeyDown(e)) {

        cy.$(function (ele) {
          return ele.selected();
        }).unselect();

        if (draggedElements.length > 0) {
          r.redrawHint('eles', true);
        }

        r.dragData.possibleDragElements = draggedElements = [];
      }

      triggerEvents(near, ['mouseup', 'tapend', 'vmouseup'], e, {
        position: { x: pos[0], y: pos[1] }
      });

      if (!r.dragData.didDrag // didn't move a node around
      && !r.hoverData.dragged // didn't pan
      && !r.hoverData.selecting // not box selection
      && !r.hoverData.isOverThresholdDrag // didn't move too much
      ) {
          triggerEvents(down, ['click', 'tap', 'vclick'], e, {
            position: { x: pos[0], y: pos[1] }
          });
        }

      // Single selection
      if (near == down && !r.dragData.didDrag && !r.hoverData.selecting) {
        if (near != null && near._private.selectable) {

          if (r.hoverData.dragging) {
            // if panning, don't change selection state
          } else if (cy.selectionType() === 'additive' || multSelKeyDown) {
            if (near.selected()) {
              near.unselect();
            } else {
              near.select();
            }
          } else {
            if (!multSelKeyDown) {
              cy.$(':selected').unmerge(near).unselect();
              near.select();
            }
          }

          r.redrawHint('eles', true);
        }
      }

      if (r.hoverData.selecting) {
        var box = cy.collection(r.getAllInBox(select[0], select[1], select[2], select[3]));

        r.redrawHint('select', true);

        if (box.length > 0) {
          r.redrawHint('eles', true);
        }

        cy.emit('boxend');

        var eleWouldBeSelected = function eleWouldBeSelected(ele) {
          return ele.selectable() && !ele.selected();
        };

        if (cy.selectionType() === 'additive') {
          box.emit('box').stdFilter(eleWouldBeSelected).select().emit('boxselect');
        } else {
          if (!multSelKeyDown) {
            cy.$(':selected').unmerge(box).unselect();
          }

          box.emit('box').stdFilter(eleWouldBeSelected).select().emit('boxselect');
        }

        // always need redraw in case eles unselectable
        r.redraw();
      }

      // Cancel drag pan
      if (r.hoverData.dragging) {
        r.hoverData.dragging = false;

        r.redrawHint('select', true);
        r.redrawHint('eles', true);

        r.redraw();
      }

      if (!select[4]) {
        r.redrawHint('drag', true);
        r.redrawHint('eles', true);

        var downWasGrabbed = down && down.grabbed();

        freeDraggedElements(draggedElements);

        if (downWasGrabbed) {
          down.emit('free');
        }
      }
    } // else not right mouse

    select[4] = 0;r.hoverData.down = null;

    r.hoverData.cxtStarted = false;
    r.hoverData.draggingEles = false;
    r.hoverData.selecting = false;
    r.hoverData.isOverThresholdDrag = false;
    r.dragData.didDrag = false;
    r.hoverData.dragged = false;
    r.hoverData.dragDelta = [];
    r.hoverData.mdownPos = null;
    r.hoverData.mdownGPos = null;
  }, false);

  var wheelHandler = function wheelHandler(e) {

    if (r.scrollingPage) {
      return;
    } // while scrolling, ignore wheel-to-zoom

    var cy = r.cy;
    var pos = r.projectIntoViewport(e.clientX, e.clientY);
    var rpos = [pos[0] * cy.zoom() + cy.pan().x, pos[1] * cy.zoom() + cy.pan().y];

    if (r.hoverData.draggingEles || r.hoverData.dragging || r.hoverData.cxtStarted || inBoxSelection()) {
      // if pan dragging or cxt dragging, wheel movements make no zoom
      e.preventDefault();
      return;
    }

    if (cy.panningEnabled() && cy.userPanningEnabled() && cy.zoomingEnabled() && cy.userZoomingEnabled()) {
      e.preventDefault();

      r.data.wheelZooming = true;
      clearTimeout(r.data.wheelTimeout);
      r.data.wheelTimeout = setTimeout(function () {
        r.data.wheelZooming = false;

        r.redrawHint('eles', true);
        r.redraw();
      }, 150);

      var diff;

      if (e.deltaY != null) {
        diff = e.deltaY / -250;
      } else if (e.wheelDeltaY != null) {
        diff = e.wheelDeltaY / 1000;
      } else {
        diff = e.wheelDelta / 1000;
      }

      diff = diff * r.wheelSensitivity;

      var needsWheelFix = e.deltaMode === 1;
      if (needsWheelFix) {
        // fixes slow wheel events on ff/linux and ff/windows
        diff *= 33;
      }

      cy.zoom({
        level: cy.zoom() * Math.pow(10, diff),
        renderedPosition: { x: rpos[0], y: rpos[1] }
      });
    }
  };

  // Functions to help with whether mouse wheel should trigger zooming
  // --
  r.registerBinding(r.container, 'wheel', wheelHandler, true);

  // disable nonstandard wheel events
  // r.registerBinding(r.container, 'mousewheel', wheelHandler, true);
  // r.registerBinding(r.container, 'DOMMouseScroll', wheelHandler, true);
  // r.registerBinding(r.container, 'MozMousePixelScroll', wheelHandler, true); // older firefox

  r.registerBinding(window, 'scroll', function scrollHandler(e) {
    // eslint-disable-line no-undef
    r.scrollingPage = true;

    clearTimeout(r.scrollingPageTimeout);
    r.scrollingPageTimeout = setTimeout(function () {
      r.scrollingPage = false;
    }, 250);
  }, true);

  // Functions to help with handling mouseout/mouseover on the Cytoscape container
  // Handle mouseout on Cytoscape container
  r.registerBinding(r.container, 'mouseout', function mouseOutHandler(e) {
    var pos = r.projectIntoViewport(e.clientX, e.clientY);

    r.cy.emit({
      originalEvent: e,
      type: 'mouseout',
      position: { x: pos[0], y: pos[1] }
    });
  }, false);

  r.registerBinding(r.container, 'mouseover', function mouseOverHandler(e) {
    var pos = r.projectIntoViewport(e.clientX, e.clientY);

    r.cy.emit({
      originalEvent: e,
      type: 'mouseover',
      position: { x: pos[0], y: pos[1] }
    });
  }, false);

  var f1x1, f1y1, f2x1, f2y1; // starting points for pinch-to-zoom
  var distance1, distance1Sq; // initial distance between finger 1 and finger 2 for pinch-to-zoom
  var center1, modelCenter1; // center point on start pinch to zoom
  var offsetLeft, offsetTop;
  var containerWidth, containerHeight;
  var twoFingersStartInside;

  var distance = function distance(x1, y1, x2, y2) {
    return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
  };

  var distanceSq = function distanceSq(x1, y1, x2, y2) {
    return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
  };

  var touchstartHandler;
  r.registerBinding(r.container, 'touchstart', touchstartHandler = function touchstartHandler(e) {
    if (!eventInContainer(e)) {
      return;
    }

    blurActiveDomElement();

    r.touchData.capture = true;
    r.data.bgActivePosistion = undefined;

    var cy = r.cy;
    var now = r.touchData.now;
    var earlier = r.touchData.earlier;

    if (e.touches[0]) {
      var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);now[0] = pos[0];now[1] = pos[1];
    }
    if (e.touches[1]) {
      var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);now[2] = pos[0];now[3] = pos[1];
    }
    if (e.touches[2]) {
      var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);now[4] = pos[0];now[5] = pos[1];
    }

    // record starting points for pinch-to-zoom
    if (e.touches[1]) {

      freeDraggedElements(r.dragData.touchDragEles);

      var offsets = r.findContainerClientCoords();
      offsetLeft = offsets[0];
      offsetTop = offsets[1];
      containerWidth = offsets[2];
      containerHeight = offsets[3];

      f1x1 = e.touches[0].clientX - offsetLeft;
      f1y1 = e.touches[0].clientY - offsetTop;

      f2x1 = e.touches[1].clientX - offsetLeft;
      f2y1 = e.touches[1].clientY - offsetTop;

      twoFingersStartInside = 0 <= f1x1 && f1x1 <= containerWidth && 0 <= f2x1 && f2x1 <= containerWidth && 0 <= f1y1 && f1y1 <= containerHeight && 0 <= f2y1 && f2y1 <= containerHeight;

      var pan = cy.pan();
      var zoom = cy.zoom();

      distance1 = distance(f1x1, f1y1, f2x1, f2y1);
      distance1Sq = distanceSq(f1x1, f1y1, f2x1, f2y1);
      center1 = [(f1x1 + f2x1) / 2, (f1y1 + f2y1) / 2];
      modelCenter1 = [(center1[0] - pan.x) / zoom, (center1[1] - pan.y) / zoom];

      // consider context tap
      var cxtDistThreshold = 200;
      var cxtDistThresholdSq = cxtDistThreshold * cxtDistThreshold;
      if (distance1Sq < cxtDistThresholdSq && !e.touches[2]) {

        var near1 = r.findNearestElement(now[0], now[1], true, true);
        var near2 = r.findNearestElement(now[2], now[3], true, true);

        if (near1 && near1.isNode()) {
          near1.activate().emit({
            originalEvent: e,
            type: 'cxttapstart',
            position: { x: now[0], y: now[1] }
          });
          r.touchData.start = near1;
        } else if (near2 && near2.isNode()) {
          near2.activate().emit({
            originalEvent: e,
            type: 'cxttapstart',
            position: { x: now[0], y: now[1] }
          });
          r.touchData.start = near2;
        } else {
          cy.emit({
            originalEvent: e,
            type: 'cxttapstart',
            position: { x: now[0], y: now[1] }
          });
        }

        if (r.touchData.start) {
          r.touchData.start._private.grabbed = false;
        }
        r.touchData.cxt = true;
        r.touchData.cxtDragged = false;
        r.data.bgActivePosistion = undefined;

        r.redraw();
        return;
      }
    }

    if (e.touches[2]) {
      // ignore
    } else if (e.touches[1]) {
      // ignore
    } else if (e.touches[0]) {
      var nears = r.findNearestElements(now[0], now[1], true, true);
      var near = nears[0];

      if (near != null) {
        near.activate();

        r.touchData.start = near;
        r.touchData.starts = nears;

        if (r.nodeIsGrabbable(near)) {

          var draggedEles = r.dragData.touchDragEles = [];
          var selectedNodes = null;

          r.redrawHint('eles', true);
          r.redrawHint('drag', true);

          if (near.selected()) {
            // reset drag elements, since near will be added again

            selectedNodes = cy.$(function (ele) {
              return ele.selected() && r.nodeIsGrabbable(ele);
            });

            addNodesToDrag(selectedNodes, { addToList: draggedEles });
          } else {
            addNodeToDrag(near, { addToList: draggedEles });
          }

          setGrabTarget(near);

          var makeEvent = function makeEvent(type) {
            return {
              originalEvent: e,
              type: type,
              position: { x: now[0], y: now[1] }
            };
          };

          near.emit(makeEvent('grabon'));

          if (selectedNodes) {
            selectedNodes.forEach(function (n) {
              n.emit(makeEvent('grab'));
            });
          } else {
            near.emit(makeEvent('grab'));
          }
        }
      }

      triggerEvents(near, ['touchstart', 'tapstart', 'vmousedown'], e, {
        position: { x: now[0], y: now[1] }
      });

      if (near == null) {
        r.data.bgActivePosistion = {
          x: pos[0],
          y: pos[1]
        };

        r.redrawHint('select', true);
        r.redraw();
      }

      // Tap, taphold
      // -----

      r.touchData.singleTouchMoved = false;
      r.touchData.singleTouchStartTime = +new Date();

      clearTimeout(r.touchData.tapholdTimeout);
      r.touchData.tapholdTimeout = setTimeout(function () {
        if (r.touchData.singleTouchMoved === false && !r.pinching // if pinching, then taphold unselect shouldn't take effect
        && !r.touchData.selecting // box selection shouldn't allow taphold through
        ) {
            triggerEvents(r.touchData.start, ['taphold'], e, {
              position: { x: now[0], y: now[1] }
            });

            if (!r.touchData.start) {
              cy.$(':selected').unselect();
            }
          }
      }, r.tapholdDuration);
    }

    if (e.touches.length >= 1) {
      var sPos = r.touchData.startPosition = [];

      for (var i = 0; i < now.length; i++) {
        sPos[i] = earlier[i] = now[i];
      }

      var touch0 = e.touches[0];

      r.touchData.startGPosition = [touch0.clientX, touch0.clientY];
    }
  }, false);

  var touchmoveHandler;
  r.registerBinding(window, 'touchmove', touchmoveHandler = function touchmoveHandler(e) {
    // eslint-disable-line no-undef
    var capture = r.touchData.capture;

    if (!capture && !eventInContainer(e)) {
      return;
    }

    var select = r.selection;
    var cy = r.cy;
    var now = r.touchData.now;
    var earlier = r.touchData.earlier;
    var zoom = cy.zoom();

    if (e.touches[0]) {
      var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);now[0] = pos[0];now[1] = pos[1];
    }
    if (e.touches[1]) {
      var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);now[2] = pos[0];now[3] = pos[1];
    }
    if (e.touches[2]) {
      var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);now[4] = pos[0];now[5] = pos[1];
    }

    var startGPos = r.touchData.startGPosition;
    var isOverThresholdDrag;

    if (capture && e.touches[0] && startGPos) {
      var disp = [];for (var j = 0; j < now.length; j++) {
        disp[j] = now[j] - earlier[j];
      }
      var dx = e.touches[0].clientX - startGPos[0];
      var dx2 = dx * dx;
      var dy = e.touches[0].clientY - startGPos[1];
      var dy2 = dy * dy;
      var dist2 = dx2 + dy2;

      isOverThresholdDrag = dist2 >= r.touchTapThreshold2;
    }

    // context swipe cancelling
    if (capture && r.touchData.cxt) {
      e.preventDefault();

      var f1x2 = e.touches[0].clientX - offsetLeft,
          f1y2 = e.touches[0].clientY - offsetTop;
      var f2x2 = e.touches[1].clientX - offsetLeft,
          f2y2 = e.touches[1].clientY - offsetTop;
      // var distance2 = distance( f1x2, f1y2, f2x2, f2y2 );
      var distance2Sq = distanceSq(f1x2, f1y2, f2x2, f2y2);
      var factorSq = distance2Sq / distance1Sq;

      var distThreshold = 150;
      var distThresholdSq = distThreshold * distThreshold;
      var factorThreshold = 1.5;
      var factorThresholdSq = factorThreshold * factorThreshold;

      // cancel ctx gestures if the distance b/t the fingers increases
      if (factorSq >= factorThresholdSq || distance2Sq >= distThresholdSq) {
        r.touchData.cxt = false;

        r.data.bgActivePosistion = undefined;

        r.redrawHint('select', true);

        var cxtEvt = {
          originalEvent: e,
          type: 'cxttapend',
          position: { x: now[0], y: now[1] }
        };

        if (r.touchData.start) {
          r.touchData.start.unactivate().emit(cxtEvt);

          r.touchData.start = null;
        } else {
          cy.emit(cxtEvt);
        }
      }
    }

    // context swipe
    if (capture && r.touchData.cxt) {
      var cxtEvt = {
        originalEvent: e,
        type: 'cxtdrag',
        position: { x: now[0], y: now[1] }
      };
      r.data.bgActivePosistion = undefined;
      r.redrawHint('select', true);

      if (r.touchData.start) {
        r.touchData.start.emit(cxtEvt);
      } else {
        cy.emit(cxtEvt);
      }

      if (r.touchData.start) {
        r.touchData.start._private.grabbed = false;
      }
      r.touchData.cxtDragged = true;

      var near = r.findNearestElement(now[0], now[1], true, true);

      if (!r.touchData.cxtOver || near !== r.touchData.cxtOver) {

        if (r.touchData.cxtOver) {
          r.touchData.cxtOver.emit({
            originalEvent: e,
            type: 'cxtdragout',
            position: { x: now[0], y: now[1] }
          });
        }

        r.touchData.cxtOver = near;

        if (near) {
          near.emit({
            originalEvent: e,
            type: 'cxtdragover',
            position: { x: now[0], y: now[1] }
          });
        }
      }

      // box selection
    } else if (capture && e.touches[2] && cy.boxSelectionEnabled()) {
      e.preventDefault();

      r.data.bgActivePosistion = undefined;

      this.lastThreeTouch = +new Date();

      if (!r.touchData.selecting) {
        cy.emit('boxstart');
      }

      r.touchData.selecting = true;

      r.redrawHint('select', true);

      if (!select || select.length === 0 || select[0] === undefined) {
        select[0] = (now[0] + now[2] + now[4]) / 3;
        select[1] = (now[1] + now[3] + now[5]) / 3;
        select[2] = (now[0] + now[2] + now[4]) / 3 + 1;
        select[3] = (now[1] + now[3] + now[5]) / 3 + 1;
      } else {
        select[2] = (now[0] + now[2] + now[4]) / 3;
        select[3] = (now[1] + now[3] + now[5]) / 3;
      }

      select[4] = 1;
      r.touchData.selecting = true;

      r.redraw();

      // pinch to zoom
    } else if (capture && e.touches[1] && cy.zoomingEnabled() && cy.panningEnabled() && cy.userZoomingEnabled() && cy.userPanningEnabled()) {
      // two fingers => pinch to zoom
      e.preventDefault();

      r.data.bgActivePosistion = undefined;
      r.redrawHint('select', true);

      var draggedEles = r.dragData.touchDragEles;
      if (draggedEles) {
        r.redrawHint('drag', true);

        for (var i = 0; i < draggedEles.length; i++) {
          var de_p = draggedEles[i]._private;

          de_p.grabbed = false;
          de_p.rscratch.inDragLayer = false;
        }
      }

      // (x2, y2) for fingers 1 and 2
      var f1x2 = e.touches[0].clientX - offsetLeft,
          f1y2 = e.touches[0].clientY - offsetTop;
      var f2x2 = e.touches[1].clientX - offsetLeft,
          f2y2 = e.touches[1].clientY - offsetTop;

      var distance2 = distance(f1x2, f1y2, f2x2, f2y2);
      // var distance2Sq = distanceSq( f1x2, f1y2, f2x2, f2y2 );
      // var factor = Math.sqrt( distance2Sq ) / Math.sqrt( distance1Sq );
      var factor = distance2 / distance1;

      if (twoFingersStartInside) {
        // delta finger1
        var df1x = f1x2 - f1x1;
        var df1y = f1y2 - f1y1;

        // delta finger 2
        var df2x = f2x2 - f2x1;
        var df2y = f2y2 - f2y1;

        // translation is the normalised vector of the two fingers movement
        // i.e. so pinching cancels out and moving together pans
        var tx = (df1x + df2x) / 2;
        var ty = (df1y + df2y) / 2;

        // adjust factor by the speed multiplier
        // var speed = 1.5;
        // if( factor > 1 ){
        //   factor = (factor - 1) * speed + 1;
        // } else {
        //   factor = 1 - (1 - factor) * speed;
        // }

        // now calculate the zoom
        var zoom1 = cy.zoom();
        var zoom2 = zoom1 * factor;
        var pan1 = cy.pan();

        // the model center point converted to the current rendered pos
        var ctrx = modelCenter1[0] * zoom1 + pan1.x;
        var ctry = modelCenter1[1] * zoom1 + pan1.y;

        var pan2 = {
          x: -zoom2 / zoom1 * (ctrx - pan1.x - tx) + ctrx,
          y: -zoom2 / zoom1 * (ctry - pan1.y - ty) + ctry
        };

        // remove dragged eles
        if (r.touchData.start && r.touchData.start.active()) {
          var draggedEles = r.dragData.touchDragEles;

          freeDraggedElements(draggedEles);

          r.redrawHint('drag', true);
          r.redrawHint('eles', true);

          r.touchData.start.unactivate().emit('free');
        }

        cy.viewport({
          zoom: zoom2,
          pan: pan2,
          cancelOnFailedZoom: true
        });

        distance1 = distance2;
        f1x1 = f1x2;
        f1y1 = f1y2;
        f2x1 = f2x2;
        f2y1 = f2y2;

        r.pinching = true;
      }

      // Re-project
      if (e.touches[0]) {
        var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);now[0] = pos[0];now[1] = pos[1];
      }
      if (e.touches[1]) {
        var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);now[2] = pos[0];now[3] = pos[1];
      }
      if (e.touches[2]) {
        var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);now[4] = pos[0];now[5] = pos[1];
      }
    } else if (e.touches[0]) {
      var start = r.touchData.start;
      var last = r.touchData.last;
      var near;

      if (!r.hoverData.draggingEles && !r.swipePanning) {
        near = r.findNearestElement(now[0], now[1], true, true);
      }

      if (capture && start != null) {
        e.preventDefault();
      }

      // dragging nodes
      if (capture && start != null && r.nodeIsDraggable(start)) {

        if (isOverThresholdDrag) {
          // then dragging can happen
          var draggedEles = r.dragData.touchDragEles;
          var justStartedDrag = !r.dragData.didDrag;

          if (justStartedDrag) {
            addNodesToDrag(cy.collection(draggedEles), { inDragLayer: true });
          }

          for (var k = 0; k < draggedEles.length; k++) {
            var draggedEle = draggedEles[k];

            if (r.nodeIsDraggable(draggedEle) && draggedEle.grabbed()) {
              r.dragData.didDrag = true;
              var dPos = draggedEle.position();

              if (is.number(disp[0]) && is.number(disp[1])) {
                dPos.x += disp[0];
                dPos.y += disp[1];
              }

              if (justStartedDrag) {
                r.redrawHint('eles', true);

                var dragDelta = r.touchData.dragDelta;

                if (dragDelta && is.number(dragDelta[0]) && is.number(dragDelta[1])) {
                  dPos.x += dragDelta[0];
                  dPos.y += dragDelta[1];
                }
              }
            }
          }

          var tcol = cy.collection(draggedEles);

          tcol.dirtyCompoundBoundsCache();
          tcol.emit('position drag');

          r.hoverData.draggingEles = true;

          r.redrawHint('drag', true);

          if (r.touchData.startPosition[0] == earlier[0] && r.touchData.startPosition[1] == earlier[1]) {

            r.redrawHint('eles', true);
          }

          r.redraw();
        } else {
          // otherise keep track of drag delta for later
          var dragDelta = r.touchData.dragDelta = r.touchData.dragDelta || [];

          if (dragDelta.length === 0) {
            dragDelta.push(disp[0]);
            dragDelta.push(disp[1]);
          } else {
            dragDelta[0] += disp[0];
            dragDelta[1] += disp[1];
          }
        }
      }

      // touchmove
      {
        triggerEvents(start || near, ['touchmove', 'tapdrag', 'vmousemove'], e, {
          position: { x: now[0], y: now[1] }
        });

        if ((!start || !start.grabbed()) && near != last) {
          if (last) {
            last.emit({ originalEvent: e, type: 'tapdragout', position: { x: now[0], y: now[1] } });
          }
          if (near) {
            near.emit({ originalEvent: e, type: 'tapdragover', position: { x: now[0], y: now[1] } });
          }
        }

        r.touchData.last = near;
      }

      // check to cancel taphold
      if (capture) {
        for (var i = 0; i < now.length; i++) {
          if (now[i] && r.touchData.startPosition[i] && isOverThresholdDrag) {

            r.touchData.singleTouchMoved = true;
          }
        }
      }

      // panning
      if (capture && (start == null || start.isEdge()) && cy.panningEnabled() && cy.userPanningEnabled()) {

        var allowPassthrough = allowPanningPassthrough(start, r.touchData.starts);

        if (allowPassthrough) {
          e.preventDefault();

          if (r.swipePanning) {
            cy.panBy({
              x: disp[0] * zoom,
              y: disp[1] * zoom
            });
          } else if (isOverThresholdDrag) {
            r.swipePanning = true;

            cy.panBy({
              x: dx * zoom,
              y: dy * zoom
            });

            if (start) {
              start.unactivate();

              if (!r.data.bgActivePosistion) {
                r.data.bgActivePosistion = math.array2point(r.touchData.startPosition);
              }

              r.redrawHint('select', true);

              r.touchData.start = null;
            }
          }
        }

        // Re-project
        var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);
        now[0] = pos[0];now[1] = pos[1];
      }
    }

    for (var j = 0; j < now.length; j++) {
      earlier[j] = now[j];
    }
    //r.redraw();

    // the active bg indicator should be removed when making a swipe that is neither for dragging nodes or panning
    if (capture && e.touches.length > 0 && !r.hoverData.draggingEles && !r.swipePanning && r.data.bgActivePosistion != null) {
      r.data.bgActivePosistion = undefined;
      r.redrawHint('select', true);
      r.redraw();
    }
  }, false);
  var touchcancelHandler;
  r.registerBinding(window, 'touchcancel', touchcancelHandler = function touchcancelHandler(e) {
    // eslint-disable-line no-undef
    var start = r.touchData.start;

    r.touchData.capture = false;

    if (start) {
      start.unactivate();
    }
  });

  var touchendHandler;
  r.registerBinding(window, 'touchend', touchendHandler = function touchendHandler(e) {
    // eslint-disable-line no-undef
    var start = r.touchData.start;

    var capture = r.touchData.capture;

    if (capture) {
      if (e.touches.length === 0) {
        r.touchData.capture = false;
      }

      e.preventDefault();
    } else {
      return;
    }

    var select = r.selection;

    r.swipePanning = false;
    r.hoverData.draggingEles = false;

    var cy = r.cy;
    var zoom = cy.zoom();
    var now = r.touchData.now;
    var earlier = r.touchData.earlier;

    if (e.touches[0]) {
      var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);now[0] = pos[0];now[1] = pos[1];
    }
    if (e.touches[1]) {
      var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);now[2] = pos[0];now[3] = pos[1];
    }
    if (e.touches[2]) {
      var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);now[4] = pos[0];now[5] = pos[1];
    }

    if (start) {
      start.unactivate();
    }

    var ctxTapend;
    if (r.touchData.cxt) {
      ctxTapend = {
        originalEvent: e,
        type: 'cxttapend',
        position: { x: now[0], y: now[1] }
      };

      if (start) {
        start.emit(ctxTapend);
      } else {
        cy.emit(ctxTapend);
      }

      if (!r.touchData.cxtDragged) {
        var ctxTap = {
          originalEvent: e,
          type: 'cxttap',
          position: { x: now[0], y: now[1] }
        };

        if (start) {
          start.emit(ctxTap);
        } else {
          cy.emit(ctxTap);
        }
      }

      if (r.touchData.start) {
        r.touchData.start._private.grabbed = false;
      }
      r.touchData.cxt = false;
      r.touchData.start = null;

      r.redraw();
      return;
    }

    // no more box selection if we don't have three fingers
    if (!e.touches[2] && cy.boxSelectionEnabled() && r.touchData.selecting) {
      r.touchData.selecting = false;

      var box = cy.collection(r.getAllInBox(select[0], select[1], select[2], select[3]));

      select[0] = undefined;
      select[1] = undefined;
      select[2] = undefined;
      select[3] = undefined;
      select[4] = 0;

      r.redrawHint('select', true);

      cy.emit('boxend');

      var eleWouldBeSelected = function eleWouldBeSelected(ele) {
        return ele.selectable() && !ele.selected();
      };

      box.emit('box').stdFilter(eleWouldBeSelected).select().emit('boxselect');

      if (box.nonempty()) {
        r.redrawHint('eles', true);
      }

      r.redraw();
    }

    if (start != null) {
      start.unactivate();
    }

    if (e.touches[2]) {
      r.data.bgActivePosistion = undefined;
      r.redrawHint('select', true);
    } else if (e.touches[1]) {
      // ignore
    } else if (e.touches[0]) {
      // ignore

      // Last touch released
    } else if (!e.touches[0]) {

      r.data.bgActivePosistion = undefined;
      r.redrawHint('select', true);

      var draggedEles = r.dragData.touchDragEles;

      if (start != null) {

        var startWasGrabbed = start._private.grabbed;

        freeDraggedElements(draggedEles);

        r.redrawHint('drag', true);
        r.redrawHint('eles', true);

        if (startWasGrabbed) {
          start.emit('free');
        }

        triggerEvents(start, ['touchend', 'tapend', 'vmouseup', 'tapdragout'], e, {
          position: { x: now[0], y: now[1] }
        });

        start.unactivate();

        r.touchData.start = null;
      } else {
        var near = r.findNearestElement(now[0], now[1], true, true);

        triggerEvents(near, ['touchend', 'tapend', 'vmouseup', 'tapdragout'], e, {
          position: { x: now[0], y: now[1] }
        });
      }

      var dx = r.touchData.startPosition[0] - now[0];
      var dx2 = dx * dx;
      var dy = r.touchData.startPosition[1] - now[1];
      var dy2 = dy * dy;
      var dist2 = dx2 + dy2;
      var rdist2 = dist2 * zoom * zoom;

      // Prepare to select the currently touched node, only if it hasn't been dragged past a certain distance
      if (start != null && !r.dragData.didDrag // didn't drag nodes around
      && start._private.selectable && rdist2 < r.touchTapThreshold2 && !r.pinching // pinch to zoom should not affect selection
      ) {

          if (cy.selectionType() === 'single') {
            cy.$(':selected').unmerge(start).unselect();
            start.select();
          } else {
            if (start.selected()) {
              start.unselect();
            } else {
              start.select();
            }
          }

          r.redrawHint('eles', true);
        }

      // Tap event, roughly same as mouse click event for touch
      if (!r.touchData.singleTouchMoved) {
        triggerEvents(start, ['tap', 'vclick'], e, {
          position: { x: now[0], y: now[1] }
        });
      }

      r.touchData.singleTouchMoved = true;
    }

    for (var j = 0; j < now.length; j++) {
      earlier[j] = now[j];
    }

    r.dragData.didDrag = false; // reset for next mousedown

    if (e.touches.length === 0) {
      r.touchData.dragDelta = [];
      r.touchData.startPosition = null;
      r.touchData.startGPosition = null;
    }

    if (e.touches.length < 2) {
      r.pinching = false;
      r.redrawHint('eles', true);
      r.redraw();
    }

    //r.redraw();
  }, false);

  // fallback compatibility layer for ms pointer events
  if (typeof TouchEvent === 'undefined') {

    var pointers = [];

    var makeTouch = function makeTouch(e) {
      return {
        clientX: e.clientX,
        clientY: e.clientY,
        force: 1,
        identifier: e.pointerId,
        pageX: e.pageX,
        pageY: e.pageY,
        radiusX: e.width / 2,
        radiusY: e.height / 2,
        screenX: e.screenX,
        screenY: e.screenY,
        target: e.target
      };
    };

    var makePointer = function makePointer(e) {
      return {
        event: e,
        touch: makeTouch(e)
      };
    };

    var addPointer = function addPointer(e) {
      pointers.push(makePointer(e));
    };

    var removePointer = function removePointer(e) {
      for (var i = 0; i < pointers.length; i++) {
        var p = pointers[i];

        if (p.event.pointerId === e.pointerId) {
          pointers.splice(i, 1);
          return;
        }
      }
    };

    var updatePointer = function updatePointer(e) {
      var p = pointers.filter(function (p) {
        return p.event.pointerId === e.pointerId;
      })[0];

      p.event = e;
      p.touch = makeTouch(e);
    };

    var addTouchesToEvent = function addTouchesToEvent(e) {
      e.touches = pointers.map(function (p) {
        return p.touch;
      });
    };

    var pointerIsMouse = function pointerIsMouse(e) {
      return e.pointerType === 'mouse' || e.pointerType === 4;
    };

    r.registerBinding(r.container, 'pointerdown', function (e) {
      if (pointerIsMouse(e)) {
        return;
      } // mouse already handled

      e.preventDefault();

      addPointer(e);

      addTouchesToEvent(e);
      touchstartHandler(e);
    });

    r.registerBinding(r.container, 'pointerup', function (e) {
      if (pointerIsMouse(e)) {
        return;
      } // mouse already handled

      removePointer(e);

      addTouchesToEvent(e);
      touchendHandler(e);
    });

    r.registerBinding(r.container, 'pointercancel', function (e) {
      if (pointerIsMouse(e)) {
        return;
      } // mouse already handled

      removePointer(e);

      addTouchesToEvent(e);
      touchcancelHandler(e);
    });

    r.registerBinding(r.container, 'pointermove', function (e) {
      if (pointerIsMouse(e)) {
        return;
      } // mouse already handled

      e.preventDefault();

      updatePointer(e);

      addTouchesToEvent(e);
      touchmoveHandler(e);
    });
  }
};

module.exports = BRp;

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var math = __webpack_require__(2);

var BRp = {};

BRp.generatePolygon = function (name, points) {
  return this.nodeShapes[name] = {
    renderer: this,

    name: name,

    points: points,

    draw: function draw(context, centerX, centerY, width, height) {
      this.renderer.nodeShapeImpl('polygon', context, centerX, centerY, width, height, this.points);
    },

    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
      return math.polygonIntersectLine(x, y, this.points, nodeX, nodeY, width / 2, height / 2, padding);
    },

    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {
      return math.pointInsidePolygon(x, y, this.points, centerX, centerY, width, height, [0, -1], padding);
    }
  };
};

BRp.generateEllipse = function () {
  return this.nodeShapes['ellipse'] = {
    renderer: this,

    name: 'ellipse',

    draw: function draw(context, centerX, centerY, width, height) {
      this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);
    },

    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
      return math.intersectLineEllipse(x, y, nodeX, nodeY, width / 2 + padding, height / 2 + padding);
    },

    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {
      return math.checkInEllipse(x, y, width, height, centerX, centerY, padding);
    }
  };
};

BRp.generateRoundRectangle = function () {
  return this.nodeShapes['roundrectangle'] = {
    renderer: this,

    name: 'roundrectangle',

    points: math.generateUnitNgonPointsFitToSquare(4, 0),

    draw: function draw(context, centerX, centerY, width, height) {
      this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);
    },

    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
      return math.roundRectangleIntersectLine(x, y, nodeX, nodeY, width, height, padding);
    },

    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {

      var cornerRadius = math.getRoundRectangleRadius(width, height);
      var diam = cornerRadius * 2;

      // Check hBox
      if (math.pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - diam, [0, -1], padding)) {
        return true;
      }

      // Check vBox
      if (math.pointInsidePolygon(x, y, this.points, centerX, centerY, width - diam, height, [0, -1], padding)) {
        return true;
      }

      // Check top left quarter circle
      if (math.checkInEllipse(x, y, diam, diam, centerX - width / 2 + cornerRadius, centerY - height / 2 + cornerRadius, padding)) {

        return true;
      }

      // Check top right quarter circle
      if (math.checkInEllipse(x, y, diam, diam, centerX + width / 2 - cornerRadius, centerY - height / 2 + cornerRadius, padding)) {

        return true;
      }

      // Check bottom right quarter circle
      if (math.checkInEllipse(x, y, diam, diam, centerX + width / 2 - cornerRadius, centerY + height / 2 - cornerRadius, padding)) {

        return true;
      }

      // Check bottom left quarter circle
      if (math.checkInEllipse(x, y, diam, diam, centerX - width / 2 + cornerRadius, centerY + height / 2 - cornerRadius, padding)) {

        return true;
      }

      return false;
    }
  };
};

BRp.generateCutRectangle = function () {
  return this.nodeShapes['cutrectangle'] = {
    renderer: this,

    name: 'cutrectangle',

    cornerLength: math.getCutRectangleCornerLength(),

    points: math.generateUnitNgonPointsFitToSquare(4, 0),

    draw: function draw(context, centerX, centerY, width, height) {
      this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);
    },

    generateCutTrianglePts: function generateCutTrianglePts(width, height, centerX, centerY) {
      var cl = this.cornerLength;
      var hh = height / 2;
      var hw = width / 2;
      var xBegin = centerX - hw;
      var xEnd = centerX + hw;
      var yBegin = centerY - hh;
      var yEnd = centerY + hh;

      // points are in clockwise order, inner (imaginary) triangle pt on [4, 5]
      return {
        topLeft: [xBegin, yBegin + cl, xBegin + cl, yBegin, xBegin + cl, yBegin + cl],
        topRight: [xEnd - cl, yBegin, xEnd, yBegin + cl, xEnd - cl, yBegin + cl],
        bottomRight: [xEnd, yEnd - cl, xEnd - cl, yEnd, xEnd - cl, yEnd - cl],
        bottomLeft: [xBegin + cl, yEnd, xBegin, yEnd - cl, xBegin + cl, yEnd - cl]
      };
    },

    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
      var cPts = this.generateCutTrianglePts(width + 2 * padding, height + 2 * padding, nodeX, nodeY);
      var pts = [].concat.apply([], [cPts.topLeft.splice(0, 4), cPts.topRight.splice(0, 4), cPts.bottomRight.splice(0, 4), cPts.bottomLeft.splice(0, 4)]);

      return math.polygonIntersectLine(x, y, pts, nodeX, nodeY);
    },

    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {
      // Check hBox
      if (math.pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - 2 * this.cornerLength, [0, -1], padding)) {
        return true;
      }

      // Check vBox
      if (math.pointInsidePolygon(x, y, this.points, centerX, centerY, width - 2 * this.cornerLength, height, [0, -1], padding)) {
        return true;
      }
      var cutTrianglePts = this.generateCutTrianglePts(width, height, centerX, centerY);
      return math.pointInsidePolygonPoints(x, y, cutTrianglePts.topLeft) || math.pointInsidePolygonPoints(x, y, cutTrianglePts.topRight) || math.pointInsidePolygonPoints(x, y, cutTrianglePts.bottomRight) || math.pointInsidePolygonPoints(x, y, cutTrianglePts.bottomLeft);
    }

  };
};

BRp.generateBarrel = function () {
  return this.nodeShapes['barrel'] = {
    renderer: this,

    name: 'barrel',

    points: math.generateUnitNgonPointsFitToSquare(4, 0),

    draw: function draw(context, centerX, centerY, width, height) {
      this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);
    },

    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
      // use two fixed t values for the bezier curve approximation

      var t0 = 0.15;
      var t1 = 0.5;
      var t2 = 0.85;

      var bPts = this.generateBarrelBezierPts(width + 2 * padding, height + 2 * padding, nodeX, nodeY);

      var approximateBarrelCurvePts = function approximateBarrelCurvePts(pts) {
        // approximate curve pts based on the two t values
        var m0 = math.qbezierPtAt({ x: pts[0], y: pts[1] }, { x: pts[2], y: pts[3] }, { x: pts[4], y: pts[5] }, t0);
        var m1 = math.qbezierPtAt({ x: pts[0], y: pts[1] }, { x: pts[2], y: pts[3] }, { x: pts[4], y: pts[5] }, t1);
        var m2 = math.qbezierPtAt({ x: pts[0], y: pts[1] }, { x: pts[2], y: pts[3] }, { x: pts[4], y: pts[5] }, t2);

        return [pts[0], pts[1], m0.x, m0.y, m1.x, m1.y, m2.x, m2.y, pts[4], pts[5]];
      };

      var pts = [].concat(approximateBarrelCurvePts(bPts.topLeft), approximateBarrelCurvePts(bPts.topRight), approximateBarrelCurvePts(bPts.bottomRight), approximateBarrelCurvePts(bPts.bottomLeft));

      return math.polygonIntersectLine(x, y, pts, nodeX, nodeY);
    },

    generateBarrelBezierPts: function generateBarrelBezierPts(width, height, centerX, centerY) {
      var hh = height / 2;
      var hw = width / 2;
      var xBegin = centerX - hw;
      var xEnd = centerX + hw;
      var yBegin = centerY - hh;
      var yEnd = centerY + hh;

      var curveConstants = math.getBarrelCurveConstants(width, height);
      var hOffset = curveConstants.heightOffset;
      var wOffset = curveConstants.widthOffset;
      var ctrlPtXOffset = curveConstants.ctrlPtOffsetPct * width;

      // points are in clockwise order, inner (imaginary) control pt on [4, 5]
      var pts = {
        topLeft: [xBegin, yBegin + hOffset, xBegin + ctrlPtXOffset, yBegin, xBegin + wOffset, yBegin],
        topRight: [xEnd - wOffset, yBegin, xEnd - ctrlPtXOffset, yBegin, xEnd, yBegin + hOffset],
        bottomRight: [xEnd, yEnd - hOffset, xEnd - ctrlPtXOffset, yEnd, xEnd - wOffset, yEnd],
        bottomLeft: [xBegin + wOffset, yEnd, xBegin + ctrlPtXOffset, yEnd, xBegin, yEnd - hOffset]
      };

      pts.topLeft.isTop = true;
      pts.topRight.isTop = true;
      pts.bottomLeft.isBottom = true;
      pts.bottomRight.isBottom = true;

      return pts;
    },

    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {

      var curveConstants = math.getBarrelCurveConstants(width, height);
      var hOffset = curveConstants.heightOffset;
      var wOffset = curveConstants.widthOffset;

      // Check hBox
      if (math.pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - 2 * hOffset, [0, -1], padding)) {
        return true;
      }

      // Check vBox
      if (math.pointInsidePolygon(x, y, this.points, centerX, centerY, width - 2 * wOffset, height, [0, -1], padding)) {
        return true;
      }

      var barrelCurvePts = this.generateBarrelBezierPts(width, height, centerX, centerY);

      var getCurveT = function getCurveT(x, y, curvePts) {
        var x0 = curvePts[4];
        var x1 = curvePts[2];
        var x2 = curvePts[0];
        var y0 = curvePts[5];
        // var y1 = curvePts[ 3 ];
        var y2 = curvePts[1];

        var xMin = Math.min(x0, x2);
        var xMax = Math.max(x0, x2);
        var yMin = Math.min(y0, y2);
        var yMax = Math.max(y0, y2);

        if (xMin <= x && x <= xMax && yMin <= y && y <= yMax) {
          var coeff = math.bezierPtsToQuadCoeff(x0, x1, x2);
          var roots = math.solveQuadratic(coeff[0], coeff[1], coeff[2], x);

          var validRoots = roots.filter(function (r) {
            return 0 <= r && r <= 1;
          });

          if (validRoots.length > 0) {
            return validRoots[0];
          }
        }
        return null;
      };

      var curveRegions = Object.keys(barrelCurvePts);
      for (var i = 0; i < curveRegions.length; i++) {
        var corner = curveRegions[i];
        var cornerPts = barrelCurvePts[corner];
        var t = getCurveT(x, y, cornerPts);

        if (t == null) {
          continue;
        }

        var y0 = cornerPts[5];
        var y1 = cornerPts[3];
        var y2 = cornerPts[1];
        var bezY = math.qbezierAt(y0, y1, y2, t);

        if (cornerPts.isTop && bezY <= y) {
          return true;
        }
        if (cornerPts.isBottom && y <= bezY) {
          return true;
        }
      }
      return false;
    }
  };
};

BRp.generateBottomRoundrectangle = function () {
  return this.nodeShapes['bottomroundrectangle'] = {
    renderer: this,

    name: 'bottomroundrectangle',

    points: math.generateUnitNgonPointsFitToSquare(4, 0),

    draw: function draw(context, centerX, centerY, width, height) {
      this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);
    },

    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
      var topStartX = nodeX - (width / 2 + padding);
      var topStartY = nodeY - (height / 2 + padding);
      var topEndY = topStartY;
      var topEndX = nodeX + (width / 2 + padding);

      var topIntersections = math.finiteLinesIntersect(x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false);
      if (topIntersections.length > 0) {
        return topIntersections;
      }

      return math.roundRectangleIntersectLine(x, y, nodeX, nodeY, width, height, padding);
    },

    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {

      var cornerRadius = math.getRoundRectangleRadius(width, height);
      var diam = 2 * cornerRadius;

      // Check hBox
      if (math.pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - diam, [0, -1], padding)) {
        return true;
      }

      // Check vBox
      if (math.pointInsidePolygon(x, y, this.points, centerX, centerY, width - diam, height, [0, -1], padding)) {
        return true;
      }

      // check non-rounded top side
      var outerWidth = width / 2 + 2 * padding;
      var outerHeight = height / 2 + 2 * padding;
      var points = [centerX - outerWidth, centerY - outerHeight, centerX - outerWidth, centerY, centerX + outerWidth, centerY, centerX + outerWidth, centerY - outerHeight];
      if (math.pointInsidePolygonPoints(x, y, points)) {
        return true;
      }

      // Check bottom right quarter circle
      if (math.checkInEllipse(x, y, diam, diam, centerX + width / 2 - cornerRadius, centerY + height / 2 - cornerRadius, padding)) {

        return true;
      }

      // Check bottom left quarter circle
      if (math.checkInEllipse(x, y, diam, diam, centerX - width / 2 + cornerRadius, centerY + height / 2 - cornerRadius, padding)) {

        return true;
      }

      return false;
    }
  };
};

BRp.registerNodeShapes = function () {
  var nodeShapes = this.nodeShapes = {};
  var renderer = this;

  this.generateEllipse();

  this.generatePolygon('triangle', math.generateUnitNgonPointsFitToSquare(3, 0));

  this.generatePolygon('rectangle', math.generateUnitNgonPointsFitToSquare(4, 0));
  nodeShapes['square'] = nodeShapes['rectangle'];

  this.generateRoundRectangle();

  this.generateCutRectangle();

  this.generateBarrel();

  this.generateBottomRoundrectangle();

  this.generatePolygon('diamond', [0, 1, 1, 0, 0, -1, -1, 0]);

  this.generatePolygon('pentagon', math.generateUnitNgonPointsFitToSquare(5, 0));

  this.generatePolygon('hexagon', math.generateUnitNgonPointsFitToSquare(6, 0));

  this.generatePolygon('heptagon', math.generateUnitNgonPointsFitToSquare(7, 0));

  this.generatePolygon('octagon', math.generateUnitNgonPointsFitToSquare(8, 0));

  var star5Points = new Array(20);
  {
    var outerPoints = math.generateUnitNgonPoints(5, 0);
    var innerPoints = math.generateUnitNgonPoints(5, Math.PI / 5);

    // Outer radius is 1; inner radius of star is smaller
    var innerRadius = 0.5 * (3 - Math.sqrt(5));
    innerRadius *= 1.57;

    for (var i = 0; i < innerPoints.length / 2; i++) {
      innerPoints[i * 2] *= innerRadius;
      innerPoints[i * 2 + 1] *= innerRadius;
    }

    for (var i = 0; i < 20 / 4; i++) {
      star5Points[i * 4] = outerPoints[i * 2];
      star5Points[i * 4 + 1] = outerPoints[i * 2 + 1];

      star5Points[i * 4 + 2] = innerPoints[i * 2];
      star5Points[i * 4 + 3] = innerPoints[i * 2 + 1];
    }
  }

  star5Points = math.fitPolygonToSquare(star5Points);

  this.generatePolygon('star', star5Points);

  this.generatePolygon('vee', [-1, -1, 0, -0.333, 1, -1, 0, 1]);

  this.generatePolygon('rhomboid', [-1, -1, 0.333, -1, 1, 1, -0.333, 1]);

  this.generatePolygon('concavehexagon', [-1, -0.95, -0.75, 0, -1, 0.95, 1, 0.95, 0.75, 0, 1, -0.95]);

  this.generatePolygon('tag', [-1, -1, 0.25, -1, 1, 0, 0.25, 1, -1, 1]);

  nodeShapes.makePolygon = function (points) {

    // use caching on user-specified polygons so they are as fast as native shapes

    var key = points.join('$');
    var name = 'polygon-' + key;
    var shape;

    if (shape = this[name]) {
      // got cached shape
      return shape;
    }

    // create and cache new shape
    return renderer.generatePolygon(name, points);
  };
};

module.exports = BRp;

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);

var BRp = {};

BRp.timeToRender = function () {
  return this.redrawTotalTime / this.redrawCount;
};

BRp.redraw = function (options) {
  options = options || util.staticEmptyObject();

  var r = this;

  if (r.averageRedrawTime === undefined) {
    r.averageRedrawTime = 0;
  }
  if (r.lastRedrawTime === undefined) {
    r.lastRedrawTime = 0;
  }
  if (r.lastDrawTime === undefined) {
    r.lastDrawTime = 0;
  }

  r.requestedFrame = true;
  r.renderOptions = options;
};

BRp.beforeRender = function (fn, priority) {
  // the renderer can't add tick callbacks when destroyed
  if (this.destroyed) {
    return;
  }

  priority = priority || 0;

  var cbs = this.beforeRenderCallbacks;

  cbs.push({ fn: fn, priority: priority });

  // higher priority callbacks executed first
  cbs.sort(function (a, b) {
    return b.priority - a.priority;
  });
};

var beforeRenderCallbacks = function beforeRenderCallbacks(r, willDraw, startTime) {
  var cbs = r.beforeRenderCallbacks;

  for (var i = 0; i < cbs.length; i++) {
    cbs[i].fn(willDraw, startTime);
  }
};

BRp.startRenderLoop = function () {
  var r = this;

  if (r.renderLoopStarted) {
    return;
  } else {
    r.renderLoopStarted = true;
  }

  var renderFn = function renderFn(requestTime) {
    if (r.destroyed) {
      return;
    }

    if (r.requestedFrame && !r.skipFrame) {
      beforeRenderCallbacks(r, true, requestTime);

      var startTime = util.performanceNow();

      r.render(r.renderOptions);

      var endTime = r.lastDrawTime = util.performanceNow();

      if (r.averageRedrawTime === undefined) {
        r.averageRedrawTime = endTime - startTime;
      }

      if (r.redrawCount === undefined) {
        r.redrawCount = 0;
      }

      r.redrawCount++;

      if (r.redrawTotalTime === undefined) {
        r.redrawTotalTime = 0;
      }

      var duration = endTime - startTime;

      r.redrawTotalTime += duration;
      r.lastRedrawTime = duration;

      // use a weighted average with a bias from the previous average so we don't spike so easily
      r.averageRedrawTime = r.averageRedrawTime / 2 + duration / 2;

      r.requestedFrame = false;
    } else {
      beforeRenderCallbacks(r, false, requestTime);
    }

    r.skipFrame = false;

    util.requestAnimationFrame(renderFn);
  };

  util.requestAnimationFrame(renderFn);
};

module.exports = BRp;

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
The canvas renderer was written by Yue Dong.

Modifications tracked on Github.
*/

var util = __webpack_require__(1);
var is = __webpack_require__(0);
var ElementTextureCache = __webpack_require__(124);
var LayeredTextureCache = __webpack_require__(125);

var CR = CanvasRenderer;
var CRp = CanvasRenderer.prototype;

CRp.CANVAS_LAYERS = 3;
//
CRp.SELECT_BOX = 0;
CRp.DRAG = 1;
CRp.NODE = 2;

CRp.BUFFER_COUNT = 3;
//
CRp.TEXTURE_BUFFER = 0;
CRp.MOTIONBLUR_BUFFER_NODE = 1;
CRp.MOTIONBLUR_BUFFER_DRAG = 2;

function CanvasRenderer(options) {
  var r = this;

  r.data = {
    canvases: new Array(CRp.CANVAS_LAYERS),
    contexts: new Array(CRp.CANVAS_LAYERS),
    canvasNeedsRedraw: new Array(CRp.CANVAS_LAYERS),

    bufferCanvases: new Array(CRp.BUFFER_COUNT),
    bufferContexts: new Array(CRp.CANVAS_LAYERS)
  };

  var tapHlOff = '-webkit-tap-highlight-color: rgba(0,0,0,0);';

  r.data.canvasContainer = document.createElement('div'); // eslint-disable-line no-undef
  var containerStyle = r.data.canvasContainer.style;
  r.data.canvasContainer.setAttribute('style', tapHlOff);
  containerStyle.position = 'relative';
  containerStyle.zIndex = '0';
  containerStyle.overflow = 'hidden';

  var container = options.cy.container();
  container.appendChild(r.data.canvasContainer);

  if ((container.getAttribute('style') || '').indexOf(tapHlOff) < 0) {
    container.setAttribute('style', (container.getAttribute('style') || '') + tapHlOff);
  }

  for (var i = 0; i < CRp.CANVAS_LAYERS; i++) {
    var canvas = r.data.canvases[i] = document.createElement('canvas'); // eslint-disable-line no-undef
    r.data.contexts[i] = canvas.getContext('2d');
    canvas.setAttribute('style', '-webkit-user-select: none; -moz-user-select: -moz-none; user-select: none; -webkit-tap-highlight-color: rgba(0,0,0,0); outline-style: none;' + (is.ms() ? ' -ms-touch-action: none; touch-action: none; ' : ''));
    canvas.style.position = 'absolute';
    canvas.setAttribute('data-id', 'layer' + i);
    canvas.style.zIndex = String(CRp.CANVAS_LAYERS - i);
    r.data.canvasContainer.appendChild(canvas);

    r.data.canvasNeedsRedraw[i] = false;
  }
  r.data.topCanvas = r.data.canvases[0];

  r.data.canvases[CRp.NODE].setAttribute('data-id', 'layer' + CRp.NODE + '-node');
  r.data.canvases[CRp.SELECT_BOX].setAttribute('data-id', 'layer' + CRp.SELECT_BOX + '-selectbox');
  r.data.canvases[CRp.DRAG].setAttribute('data-id', 'layer' + CRp.DRAG + '-drag');

  for (var i = 0; i < CRp.BUFFER_COUNT; i++) {
    r.data.bufferCanvases[i] = document.createElement('canvas'); // eslint-disable-line no-undef
    r.data.bufferContexts[i] = r.data.bufferCanvases[i].getContext('2d');
    r.data.bufferCanvases[i].style.position = 'absolute';
    r.data.bufferCanvases[i].setAttribute('data-id', 'buffer' + i);
    r.data.bufferCanvases[i].style.zIndex = String(-i - 1);
    r.data.bufferCanvases[i].style.visibility = 'hidden';
    //r.data.canvasContainer.appendChild(r.data.bufferCanvases[i]);
  }

  r.pathsEnabled = true;

  r.data.eleTxrCache = new ElementTextureCache(r);
  r.data.lyrTxrCache = new LayeredTextureCache(r, r.data.eleTxrCache);

  r.onUpdateEleCalcs(function invalidateTextureCaches(willDraw, eles) {
    for (var i = 0; i < eles.length; i++) {
      var ele = eles[i];
      var rs = ele._private.rstyle;
      var de = rs.dirtyEvents;

      if (ele.isNode() && de && de.length === 1 && de['position']) {
        // then keep cached ele texture
      } else {
        r.data.eleTxrCache.invalidateElement(ele);

        // NB this block of code should not be ported to 3.3 (unstable branch).
        // - This check is unneccesary in 3.3 as caches will be stored without respect to opacity.
        // - This fix may result in lowered performance for compound graphs.
        // - Ref : Opacity of child node is not updated for certain zoom levels after parent opacity is overriden #2078
        if (ele.isParent() && de['style']) {
          var op1 = rs.prevParentOpacity;
          var op2 = ele.pstyle('opacity').pfValue;

          rs.prevParentOpacity = op2;

          if (op1 !== op2) {
            var descs = ele.descendants();

            for (var j = 0; j < descs.length; j++) {
              r.data.eleTxrCache.invalidateElement(descs[j]);
            }
          }
        }
      }
    }

    if (eles.length > 0) {
      r.data.lyrTxrCache.invalidateElements(eles);
    }
  });
}

CRp.redrawHint = function (group, bool) {
  var r = this;

  switch (group) {
    case 'eles':
      r.data.canvasNeedsRedraw[CRp.NODE] = bool;
      break;
    case 'drag':
      r.data.canvasNeedsRedraw[CRp.DRAG] = bool;
      break;
    case 'select':
      r.data.canvasNeedsRedraw[CRp.SELECT_BOX] = bool;
      break;
  }
};

// whether to use Path2D caching for drawing
var pathsImpld = typeof Path2D !== 'undefined';

CRp.path2dEnabled = function (on) {
  if (on === undefined) {
    return this.pathsEnabled;
  }

  this.pathsEnabled = on ? true : false;
};

CRp.usePaths = function () {
  return pathsImpld && this.pathsEnabled;
};

[__webpack_require__(126), __webpack_require__(127), __webpack_require__(128), __webpack_require__(129), __webpack_require__(130), __webpack_require__(131), __webpack_require__(132), __webpack_require__(133), __webpack_require__(134), __webpack_require__(135)].forEach(function (props) {
  util.extend(CRp, props);
});

module.exports = CR;

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var math = __webpack_require__(2);
var util = __webpack_require__(1);
var Heap = __webpack_require__(9);
var defs = __webpack_require__(19);

var minTxrH = 25; // the size of the texture cache for small height eles (special case)
var txrStepH = 50; // the min size of the regular cache, and the size it increases with each step up
var minLvl = -4; // when scaling smaller than that we don't need to re-render
var maxLvl = 2; // when larger than this scale just render directly (caching is not helpful)
var maxZoom = 3.99; // beyond this zoom level, layered textures are not used
var eleTxrSpacing = 8; // spacing between elements on textures to avoid blitting overlaps
var defTxrWidth = 1024; // default/minimum texture width
var maxTxrW = 1024; // the maximum width of a texture
var maxTxrH = 1024; // the maximum height of a texture
var minUtility = 0.5; // if usage of texture is less than this, it is retired
var maxFullness = 0.8; // fullness of texture after which queue removal is checked
var maxFullnessChecks = 10; // dequeued after this many checks
var allowEdgeTxrCaching = false; // whether edges can be cached as textures (TODO maybe better on if webgl supported?)
var allowParentTxrCaching = false; // whether parent nodes can be cached as textures (TODO maybe better on if webgl supported?)
var deqCost = 0.15; // % of add'l rendering cost allowed for dequeuing ele caches each frame
var deqAvgCost = 0.1; // % of add'l rendering cost compared to average overall redraw time
var deqNoDrawCost = 0.9; // % of avg frame time that can be used for dequeueing when not drawing
var deqFastCost = 0.9; // % of frame time to be used when >60fps
var deqRedrawThreshold = 100; // time to batch redraws together from dequeueing to allow more dequeueing calcs to happen in the meanwhile
var maxDeqSize = 1; // number of eles to dequeue and render at higher texture in each batch

var getTxrReasons = {
  dequeue: 'dequeue',
  downscale: 'downscale',
  highQuality: 'highQuality'
};

var ElementTextureCache = function ElementTextureCache(renderer) {
  var self = this;

  self.renderer = renderer;
  self.onDequeues = [];

  self.setupDequeueing();
};

var ETCp = ElementTextureCache.prototype;

ETCp.reasons = getTxrReasons;

// the list of textures in which new subtextures for elements can be placed
ETCp.getTextureQueue = function (txrH) {
  var self = this;
  self.eleImgCaches = self.eleImgCaches || {};

  return self.eleImgCaches[txrH] = self.eleImgCaches[txrH] || [];
};

// the list of usused textures which can be recycled (in use in texture queue)
ETCp.getRetiredTextureQueue = function (txrH) {
  var self = this;

  var rtxtrQs = self.eleImgCaches.retired = self.eleImgCaches.retired || {};
  var rtxtrQ = rtxtrQs[txrH] = rtxtrQs[txrH] || [];

  return rtxtrQ;
};

// queue of element draw requests at different scale levels
ETCp.getElementQueue = function () {
  var self = this;

  var q = self.eleCacheQueue = self.eleCacheQueue || new Heap(function (a, b) {
    return b.reqs - a.reqs;
  });

  return q;
};

// queue of element draw requests at different scale levels (element id lookup)
ETCp.getElementIdToQueue = function () {
  var self = this;

  var id2q = self.eleIdToCacheQueue = self.eleIdToCacheQueue || {};

  return id2q;
};

ETCp.getElement = function (ele, bb, pxRatio, lvl, reason) {
  var self = this;
  var r = this.renderer;
  var rs = ele._private.rscratch;
  var zoom = r.cy.zoom();

  if (bb.w === 0 || bb.h === 0 || !ele.visible()) {
    return null;
  }

  if (lvl == null) {
    lvl = Math.ceil(math.log2(zoom * pxRatio));
  }

  if (lvl < minLvl) {
    lvl = minLvl;
  } else if (zoom >= maxZoom || lvl > maxLvl) {
    return null;
  }

  var scale = Math.pow(2, lvl);
  var eleScaledH = bb.h * scale;
  var eleScaledW = bb.w * scale;
  var caches = rs.imgCaches = rs.imgCaches || {};
  var eleCache = caches[lvl];

  if (eleCache) {
    return eleCache;
  }

  var txrH; // which texture height this ele belongs to

  if (eleScaledH <= minTxrH) {
    txrH = minTxrH;
  } else if (eleScaledH <= txrStepH) {
    txrH = txrStepH;
  } else {
    txrH = Math.ceil(eleScaledH / txrStepH) * txrStepH;
  }

  if (eleScaledH > maxTxrH || eleScaledW > maxTxrW || !allowEdgeTxrCaching && ele.isEdge() || !allowParentTxrCaching && ele.isParent()) {
    return null; // caching large elements is not efficient
  }

  var txrQ = self.getTextureQueue(txrH);

  // first try the second last one in case it has space at the end
  var txr = txrQ[txrQ.length - 2];

  var addNewTxr = function addNewTxr() {
    return self.recycleTexture(txrH, eleScaledW) || self.addTexture(txrH, eleScaledW);
  };

  // try the last one if there is no second last one
  if (!txr) {
    txr = txrQ[txrQ.length - 1];
  }

  // if the last one doesn't exist, we need a first one
  if (!txr) {
    txr = addNewTxr();
  }

  // if there's no room in the current texture, we need a new one
  if (txr.width - txr.usedWidth < eleScaledW) {
    txr = addNewTxr();
  }

  var scaledLabelShown = r.eleTextBiggerThanMin(ele, scale);
  var scalableFrom = function scalableFrom(otherCache) {
    return otherCache && otherCache.scaledLabelShown === scaledLabelShown;
  };

  var deqing = reason && reason === getTxrReasons.dequeue;
  var highQualityReq = reason && reason === getTxrReasons.highQuality;
  var downscaleReq = reason && reason === getTxrReasons.downscale;

  var higherCache; // the nearest cache with a higher level
  for (var l = lvl + 1; l <= maxLvl; l++) {
    var c = caches[l];

    if (c) {
      higherCache = c;break;
    }
  }

  var oneUpCache = higherCache && higherCache.level === lvl + 1 ? higherCache : null;

  var downscale = function downscale() {
    txr.context.drawImage(oneUpCache.texture.canvas, oneUpCache.x, 0, oneUpCache.width, oneUpCache.height, txr.usedWidth, 0, eleScaledW, eleScaledH);
  };

  // reset ele area in texture
  txr.context.setTransform(1, 0, 0, 1, 0, 0);
  txr.context.clearRect(txr.usedWidth, 0, eleScaledW, txrH);

  if (scalableFrom(oneUpCache)) {
    // then we can relatively cheaply rescale the existing image w/o rerendering
    downscale();
  } else if (scalableFrom(higherCache)) {
    // then use the higher cache for now and queue the next level down
    // to cheaply scale towards the smaller level

    if (highQualityReq) {
      for (var l = higherCache.level; l > lvl; l--) {
        oneUpCache = self.getElement(ele, bb, pxRatio, l, getTxrReasons.downscale);
      }

      downscale();
    } else {
      self.queueElement(ele, higherCache.level - 1);

      return higherCache;
    }
  } else {

    var lowerCache; // the nearest cache with a lower level
    if (!deqing && !highQualityReq && !downscaleReq) {
      for (var l = lvl - 1; l >= minLvl; l--) {
        var c = caches[l];

        if (c) {
          lowerCache = c;break;
        }
      }
    }

    if (scalableFrom(lowerCache)) {
      // then use the lower quality cache for now and queue the better one for later

      self.queueElement(ele, lvl);

      return lowerCache;
    }

    txr.context.translate(txr.usedWidth, 0);
    txr.context.scale(scale, scale);

    r.drawElement(txr.context, ele, bb, scaledLabelShown);

    txr.context.scale(1 / scale, 1 / scale);
    txr.context.translate(-txr.usedWidth, 0);
  }

  eleCache = caches[lvl] = {
    ele: ele,
    x: txr.usedWidth,
    texture: txr,
    level: lvl,
    scale: scale,
    width: eleScaledW,
    height: eleScaledH,
    scaledLabelShown: scaledLabelShown
  };

  txr.usedWidth += Math.ceil(eleScaledW + eleTxrSpacing);

  txr.eleCaches.push(eleCache);

  self.checkTextureFullness(txr);

  return eleCache;
};

ETCp.invalidateElement = function (ele) {
  var self = this;
  var caches = ele._private.rscratch.imgCaches;

  if (caches) {
    for (var lvl = minLvl; lvl <= maxLvl; lvl++) {
      var cache = caches[lvl];

      if (cache) {
        var txr = cache.texture;

        // remove space from the texture it belongs to
        txr.invalidatedWidth += cache.width;

        // remove refs with the element
        caches[lvl] = null;
        util.removeFromArray(txr.eleCaches, cache);

        // remove from queue since the old req was for the old state
        self.removeFromQueue(ele);

        // might have to remove the entire texture if it's not efficiently using its space
        self.checkTextureUtility(txr);
      }
    }
  }
};

ETCp.checkTextureUtility = function (txr) {
  // invalidate all entries in the cache if the cache size is small
  if (txr.invalidatedWidth >= minUtility * txr.width) {
    this.retireTexture(txr);
  }
};

ETCp.checkTextureFullness = function (txr) {
  // if texture has been mostly filled and passed over several times, remove
  // it from the queue so we don't need to waste time looking at it to put new things

  var self = this;
  var txrQ = self.getTextureQueue(txr.height);

  if (txr.usedWidth / txr.width > maxFullness && txr.fullnessChecks >= maxFullnessChecks) {
    util.removeFromArray(txrQ, txr);
  } else {
    txr.fullnessChecks++;
  }
};

ETCp.retireTexture = function (txr) {
  var self = this;
  var txrH = txr.height;
  var txrQ = self.getTextureQueue(txrH);

  // retire the texture from the active / searchable queue:

  util.removeFromArray(txrQ, txr);

  txr.retired = true;

  // remove the refs from the eles to the caches:

  var eleCaches = txr.eleCaches;

  for (var i = 0; i < eleCaches.length; i++) {
    var eleCache = eleCaches[i];
    var ele = eleCache.ele;
    var lvl = eleCache.level;
    var imgCaches = ele._private.rscratch.imgCaches;

    if (imgCaches) {
      imgCaches[lvl] = null;
    }
  }

  util.clearArray(eleCaches);

  // add the texture to a retired queue so it can be recycled in future:

  var rtxtrQ = self.getRetiredTextureQueue(txrH);

  rtxtrQ.push(txr);
};

ETCp.addTexture = function (txrH, minW) {
  var self = this;
  var txrQ = self.getTextureQueue(txrH);
  var txr = {};

  txrQ.push(txr);

  txr.eleCaches = [];

  txr.height = txrH;
  txr.width = Math.max(defTxrWidth, minW);
  txr.usedWidth = 0;
  txr.invalidatedWidth = 0;
  txr.fullnessChecks = 0;

  txr.canvas = document.createElement('canvas'); // eslint-disable-line no-undef
  txr.canvas.width = txr.width;
  txr.canvas.height = txr.height;

  txr.context = txr.canvas.getContext('2d');

  return txr;
};

ETCp.recycleTexture = function (txrH, minW) {
  var self = this;
  var txrQ = self.getTextureQueue(txrH);
  var rtxtrQ = self.getRetiredTextureQueue(txrH);

  for (var i = 0; i < rtxtrQ.length; i++) {
    var txr = rtxtrQ[i];

    if (txr.width >= minW) {
      txr.retired = false;

      txr.usedWidth = 0;
      txr.invalidatedWidth = 0;
      txr.fullnessChecks = 0;

      util.clearArray(txr.eleCaches);

      txr.context.setTransform(1, 0, 0, 1, 0, 0);
      txr.context.clearRect(0, 0, txr.width, txr.height);

      util.removeFromArray(rtxtrQ, txr);
      txrQ.push(txr);

      return txr;
    }
  }
};

ETCp.queueElement = function (ele, lvl) {
  var self = this;
  var q = self.getElementQueue();
  var id2q = self.getElementIdToQueue();
  var id = ele.id();
  var existingReq = id2q[id];

  if (existingReq) {
    // use the max lvl b/c in between lvls are cheap to make
    existingReq.level = Math.max(existingReq.level, lvl);
    existingReq.reqs++;

    q.updateItem(existingReq);
  } else {
    var req = {
      ele: ele,
      level: lvl,
      reqs: 1
    };

    q.push(req);

    id2q[id] = req;
  }
};

ETCp.dequeue = function (pxRatio /*, extent*/) {
  var self = this;
  var q = self.getElementQueue();
  var id2q = self.getElementIdToQueue();
  var dequeued = [];

  for (var i = 0; i < maxDeqSize; i++) {
    if (q.size() > 0) {
      var req = q.pop();
      var ele = req.ele;
      var caches = ele._private.rscratch.imgCaches;

      // dequeueing isn't necessary when an existing cache exists
      if (caches[req.level] != null) {
        continue;
      }

      id2q[ele.id()] = null;

      dequeued.push(req);

      var bb = ele.boundingBox();

      self.getElement(ele, bb, pxRatio, req.level, getTxrReasons.dequeue);
    } else {
      break;
    }
  }

  return dequeued;
};

ETCp.removeFromQueue = function (ele) {
  var self = this;
  var q = self.getElementQueue();
  var id2q = self.getElementIdToQueue();
  var req = id2q[ele.id()];

  if (req != null) {
    // bring to front of queue
    req.reqs = util.MAX_INT;
    q.updateItem(req);

    q.pop(); // remove from queue

    id2q[ele.id()] = null; // remove from lookup map
  }
};

ETCp.onDequeue = function (fn) {
  this.onDequeues.push(fn);
};
ETCp.offDequeue = function (fn) {
  util.removeFromArray(this.onDequeues, fn);
};

ETCp.setupDequeueing = defs.setupDequeueing({
  deqRedrawThreshold: deqRedrawThreshold,
  deqCost: deqCost,
  deqAvgCost: deqAvgCost,
  deqNoDrawCost: deqNoDrawCost,
  deqFastCost: deqFastCost,
  deq: function deq(self, pxRatio, extent) {
    return self.dequeue(pxRatio, extent);
  },
  onDeqd: function onDeqd(self, deqd) {
    for (var i = 0; i < self.onDequeues.length; i++) {
      var fn = self.onDequeues[i];

      fn(deqd);
    }
  },
  shouldRedraw: function shouldRedraw(self, deqd, pxRatio, extent) {
    for (var i = 0; i < deqd.length; i++) {
      var bb = deqd[i].ele.boundingBox();

      if (math.boundingBoxesIntersect(bb, extent)) {
        return true;
      }
    }

    return false;
  },
  priority: function priority(self) {
    return self.renderer.beforeRenderPriorities.eleTxrDeq;
  }
});

module.exports = ElementTextureCache;

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);
var math = __webpack_require__(2);
var Heap = __webpack_require__(9);
var is = __webpack_require__(0);
var defs = __webpack_require__(19);

var defNumLayers = 1; // default number of layers to use
var minLvl = -4; // when scaling smaller than that we don't need to re-render
var maxLvl = 2; // when larger than this scale just render directly (caching is not helpful)
var maxZoom = 3.99; // beyond this zoom level, layered textures are not used
var deqRedrawThreshold = 50; // time to batch redraws together from dequeueing to allow more dequeueing calcs to happen in the meanwhile
var refineEleDebounceTime = 50; // time to debounce sharper ele texture updates
var disableEleImgSmoothing = true; // when drawing eles on layers from an ele cache ; crisper and more performant when true
var deqCost = 0.15; // % of add'l rendering cost allowed for dequeuing ele caches each frame
var deqAvgCost = 0.1; // % of add'l rendering cost compared to average overall redraw time
var deqNoDrawCost = 0.9; // % of avg frame time that can be used for dequeueing when not drawing
var deqFastCost = 0.9; // % of frame time to be used when >60fps
var maxDeqSize = 1; // number of eles to dequeue and render at higher texture in each batch
var invalidThreshold = 250; // time threshold for disabling b/c of invalidations
var maxLayerArea = 4000 * 4000; // layers can't be bigger than this
var alwaysQueue = true; // never draw all the layers in a level on a frame; draw directly until all dequeued
var useHighQualityEleTxrReqs = true; // whether to use high quality ele txr requests (generally faster and cheaper in the longterm)

var useEleTxrCaching = true; // whether to use individual ele texture caching underneath this cache

// var log = function(){ console.log.apply( console, arguments ); };

var LayeredTextureCache = function LayeredTextureCache(renderer, eleTxrCache) {
  var self = this;

  var r = self.renderer = renderer;

  self.layersByLevel = {}; // e.g. 2 => [ layer1, layer2, ..., layerN ]

  self.firstGet = true;

  self.lastInvalidationTime = util.performanceNow() - 2 * invalidThreshold;

  self.skipping = false;

  r.beforeRender(function (willDraw, now) {
    if (now - self.lastInvalidationTime <= invalidThreshold) {
      self.skipping = true;
    } else {
      self.skipping = false;
    }
  });

  var qSort = function qSort(a, b) {
    return b.reqs - a.reqs;
  };

  self.layersQueue = new Heap(qSort);

  self.eleTxrCache = eleTxrCache;

  self.setupEleCacheInvalidation();

  self.setupDequeueing();
};

var LTCp = LayeredTextureCache.prototype;

var layerIdPool = 0;
var MAX_INT = Math.pow(2, 53) - 1;

LTCp.makeLayer = function (bb, lvl) {
  var scale = Math.pow(2, lvl);

  var w = Math.ceil(bb.w * scale);
  var h = Math.ceil(bb.h * scale);

  var canvas = document.createElement('canvas'); // eslint-disable-line no-undef

  canvas.width = w;
  canvas.height = h;

  var layer = {
    id: layerIdPool = ++layerIdPool % MAX_INT,
    bb: bb,
    level: lvl,
    width: w,
    height: h,
    canvas: canvas,
    context: canvas.getContext('2d'),
    eles: [],
    elesQueue: [],
    reqs: 0
  };

  // log('make layer %s with w %s and h %s and lvl %s', layer.id, layer.width, layer.height, layer.level);

  var cxt = layer.context;
  var dx = -layer.bb.x1;
  var dy = -layer.bb.y1;

  // do the transform on creation to save cycles (it's the same for all eles)
  cxt.scale(scale, scale);
  cxt.translate(dx, dy);

  return layer;
};

LTCp.getLayers = function (eles, pxRatio, lvl) {
  var self = this;
  var r = self.renderer;
  var cy = r.cy;
  var zoom = cy.zoom();
  var firstGet = self.firstGet;

  self.firstGet = false;

  // log('--\nget layers with %s eles', eles.length);
  //log eles.map(function(ele){ return ele.id() }) );

  if (lvl == null) {
    lvl = Math.ceil(math.log2(zoom * pxRatio));

    if (lvl < minLvl) {
      lvl = minLvl;
    } else if (zoom >= maxZoom || lvl > maxLvl) {
      return null;
    }
  }

  self.validateLayersElesOrdering(lvl, eles);

  var layersByLvl = self.layersByLevel;
  var scale = Math.pow(2, lvl);
  var layers = layersByLvl[lvl] = layersByLvl[lvl] || [];
  var bb;

  var lvlComplete = self.levelIsComplete(lvl, eles);
  var tmpLayers;

  var checkTempLevels = function checkTempLevels() {
    var canUseAsTmpLvl = function canUseAsTmpLvl(l) {
      self.validateLayersElesOrdering(l, eles);

      if (self.levelIsComplete(l, eles)) {
        tmpLayers = layersByLvl[l];
        return true;
      }
    };

    var checkLvls = function checkLvls(dir) {
      if (tmpLayers) {
        return;
      }

      for (var l = lvl + dir; minLvl <= l && l <= maxLvl; l += dir) {
        if (canUseAsTmpLvl(l)) {
          break;
        }
      }
    };

    checkLvls(+1);
    checkLvls(-1);

    // remove the invalid layers; they will be replaced as needed later in this function
    for (var i = layers.length - 1; i >= 0; i--) {
      var layer = layers[i];

      if (layer.invalid) {
        util.removeFromArray(layers, layer);
      }
    }
  };

  if (!lvlComplete) {
    // if the current level is incomplete, then use the closest, best quality layerset temporarily
    // and later queue the current layerset so we can get the proper quality level soon

    checkTempLevels();
  } else {
    // log('level complete, using existing layers\n--');
    return layers;
  }

  var getBb = function getBb() {
    if (!bb) {
      bb = math.makeBoundingBox();

      for (var i = 0; i < eles.length; i++) {
        math.updateBoundingBox(bb, eles[i].boundingBox());
      }
    }

    return bb;
  };

  var makeLayer = function makeLayer(opts) {
    opts = opts || {};

    var after = opts.after;

    getBb();

    var area = bb.w * scale * (bb.h * scale);

    if (area > maxLayerArea) {
      return null;
    }

    var layer = self.makeLayer(bb, lvl);

    if (after != null) {
      var index = layers.indexOf(after) + 1;

      layers.splice(index, 0, layer);
    } else if (opts.insert === undefined || opts.insert) {
      // no after specified => first layer made so put at start
      layers.unshift(layer);
    }

    // if( tmpLayers ){
    //self.queueLayer( layer );
    // }

    return layer;
  };

  if (self.skipping && !firstGet) {
    // log('skip layers');
    return null;
  }

  // log('do layers');

  var layer = null;
  var maxElesPerLayer = eles.length / defNumLayers;
  var allowLazyQueueing = alwaysQueue && !firstGet;

  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];
    var rs = ele._private.rscratch;
    var caches = rs.imgLayerCaches = rs.imgLayerCaches || {};

    // log('look at ele', ele.id());

    var existingLayer = caches[lvl];

    if (existingLayer) {
      // reuse layer for later eles
      // log('reuse layer for', ele.id());
      layer = existingLayer;
      continue;
    }

    if (!layer || layer.eles.length >= maxElesPerLayer || !math.boundingBoxInBoundingBox(layer.bb, ele.boundingBox())) {
      // log('make new layer for ele %s', ele.id());

      layer = makeLayer({ insert: true, after: layer });

      // if now layer can be built then we can't use layers at this level
      if (!layer) {
        return null;
      }

      // log('new layer with id %s', layer.id);
    }

    if (tmpLayers || allowLazyQueueing) {
      // log('queue ele %s in layer %s', ele.id(), layer.id);
      self.queueLayer(layer, ele);
    } else {
      // log('draw ele %s in layer %s', ele.id(), layer.id);
      self.drawEleInLayer(layer, ele, lvl, pxRatio);
    }

    layer.eles.push(ele);

    caches[lvl] = layer;
  }

  // log('--');

  if (tmpLayers) {
    // then we only queued the current layerset and can't draw it yet
    return tmpLayers;
  }

  if (allowLazyQueueing) {
    // log('lazy queue level', lvl);
    return null;
  }

  return layers;
};

// a layer may want to use an ele cache of a higher level to avoid blurriness
// so the layer level might not equal the ele level
LTCp.getEleLevelForLayerLevel = function (lvl, pxRatio) {
  return lvl;
};

function imgSmoothing(context, bool) {
  if (context.imageSmoothingEnabled != null) {
    context.imageSmoothingEnabled = bool;
  } else {
    context.webkitImageSmoothingEnabled = bool;
    context.mozImageSmoothingEnabled = bool;
    context.msImageSmoothingEnabled = bool;
  }
}

LTCp.drawEleInLayer = function (layer, ele, lvl, pxRatio) {
  var self = this;
  var r = this.renderer;
  var context = layer.context;
  var bb = ele.boundingBox();

  if (bb.w === 0 || bb.h === 0 || !ele.visible()) {
    return;
  }

  var eleCache = self.eleTxrCache;
  var reason = useHighQualityEleTxrReqs ? eleCache.reasons.highQuality : undefined;

  lvl = self.getEleLevelForLayerLevel(lvl, pxRatio);

  var cache = useEleTxrCaching ? eleCache.getElement(ele, bb, null, lvl, reason) : null;

  if (cache) {
    if (disableEleImgSmoothing) {
      imgSmoothing(context, false);
    }

    context.drawImage(cache.texture.canvas, cache.x, 0, cache.width, cache.height, bb.x1, bb.y1, bb.w, bb.h);

    if (disableEleImgSmoothing) {
      imgSmoothing(context, true);
    }
  } else {
    // if the element is not cacheable, then draw directly
    r.drawElement(context, ele);
  }
};

LTCp.levelIsComplete = function (lvl, eles) {
  var self = this;
  var layers = self.layersByLevel[lvl];

  if (!layers || layers.length === 0) {
    return false;
  }

  var numElesInLayers = 0;

  for (var i = 0; i < layers.length; i++) {
    var layer = layers[i];

    // if there are any eles needed to be drawn yet, the level is not complete
    if (layer.reqs > 0) {
      return false;
    }

    // if the layer is invalid, the level is not complete
    if (layer.invalid) {
      return false;
    }

    numElesInLayers += layer.eles.length;
  }

  // we should have exactly the number of eles passed in to be complete
  if (numElesInLayers !== eles.length) {
    return false;
  }

  return true;
};

LTCp.validateLayersElesOrdering = function (lvl, eles) {
  var layers = this.layersByLevel[lvl];

  if (!layers) {
    return;
  }

  // if in a layer the eles are not in the same order, then the layer is invalid
  // (i.e. there is an ele in between the eles in the layer)

  for (var i = 0; i < layers.length; i++) {
    var layer = layers[i];
    var offset = -1;

    // find the offset
    for (var j = 0; j < eles.length; j++) {
      if (layer.eles[0] === eles[j]) {
        offset = j;
        break;
      }
    }

    if (offset < 0) {
      // then the layer has nonexistant elements and is invalid
      this.invalidateLayer(layer);
      continue;
    }

    // the eles in the layer must be in the same continuous order, else the layer is invalid

    var o = offset;

    for (var j = 0; j < layer.eles.length; j++) {
      if (layer.eles[j] !== eles[o + j]) {
        // log('invalidate based on ordering', layer.id);

        this.invalidateLayer(layer);
        break;
      }
    }
  }
};

LTCp.updateElementsInLayers = function (eles, update) {
  var self = this;
  var isEles = is.element(eles[0]);

  // collect udpated elements (cascaded from the layers) and update each
  // layer itself along the way
  for (var i = 0; i < eles.length; i++) {
    var req = isEles ? null : eles[i];
    var ele = isEles ? eles[i] : eles[i].ele;
    var rs = ele._private.rscratch;
    var caches = rs.imgLayerCaches = rs.imgLayerCaches || {};

    for (var l = minLvl; l <= maxLvl; l++) {
      var layer = caches[l];

      if (!layer) {
        continue;
      }

      // if update is a request from the ele cache, then it affects only
      // the matching level
      if (req && self.getEleLevelForLayerLevel(layer.level) !== req.level) {
        continue;
      }

      update(layer, ele, req);
    }
  }
};

LTCp.haveLayers = function () {
  var self = this;
  var haveLayers = false;

  for (var l = minLvl; l <= maxLvl; l++) {
    var layers = self.layersByLevel[l];

    if (layers && layers.length > 0) {
      haveLayers = true;
      break;
    }
  }

  return haveLayers;
};

LTCp.invalidateElements = function (eles) {
  var self = this;

  self.lastInvalidationTime = util.performanceNow();

  // log('update invalidate layer time from eles');

  if (eles.length === 0 || !self.haveLayers()) {
    return;
  }

  self.updateElementsInLayers(eles, function invalAssocLayers(layer, ele, req) {
    self.invalidateLayer(layer);
  });
};

LTCp.invalidateLayer = function (layer) {
  // log('update invalidate layer time');

  this.lastInvalidationTime = util.performanceNow();

  if (layer.invalid) {
    return;
  } // save cycles

  var lvl = layer.level;
  var eles = layer.eles;
  var layers = this.layersByLevel[lvl];

  // log('invalidate layer', layer.id );

  util.removeFromArray(layers, layer);
  // layer.eles = [];

  layer.elesQueue = [];

  layer.invalid = true;

  if (layer.replacement) {
    layer.replacement.invalid = true;
  }

  for (var i = 0; i < eles.length; i++) {
    var caches = eles[i]._private.rscratch.imgLayerCaches;

    if (caches) {
      caches[lvl] = null;
    }
  }
};

LTCp.refineElementTextures = function (eles) {
  var self = this;

  // log('refine', eles.length);

  self.updateElementsInLayers(eles, function refineEachEle(layer, ele, req) {
    var rLyr = layer.replacement;

    if (!rLyr) {
      rLyr = layer.replacement = self.makeLayer(layer.bb, layer.level);
      rLyr.replaces = layer;
      rLyr.eles = layer.eles;

      // log('make replacement layer %s for %s with level %s', rLyr.id, layer.id, rLyr.level);
    }

    if (!rLyr.reqs) {
      for (var i = 0; i < rLyr.eles.length; i++) {
        self.queueLayer(rLyr, rLyr.eles[i]);
      }

      // log('queue replacement layer refinement', rLyr.id);
    }
  });
};

LTCp.setupEleCacheInvalidation = function () {
  var self = this;
  var eleDeqs = [];

  if (!useEleTxrCaching) {
    return;
  }

  var updatedElesInLayers = util.debounce(function () {
    self.refineElementTextures(eleDeqs);

    eleDeqs = [];
  }, refineEleDebounceTime);

  self.eleTxrCache.onDequeue(function (reqs) {
    for (var i = 0; i < reqs.length; i++) {
      eleDeqs.push(reqs[i]);
    }

    updatedElesInLayers();
  });
};

LTCp.queueLayer = function (layer, ele) {
  var self = this;
  var q = self.layersQueue;
  var elesQ = layer.elesQueue;
  var hasId = elesQ.hasId = elesQ.hasId || {};

  // if a layer is going to be replaced, queuing is a waste of time
  if (layer.replacement) {
    return;
  }

  if (ele) {
    if (hasId[ele.id()]) {
      return;
    }

    elesQ.push(ele);
    hasId[ele.id()] = true;
  }

  if (layer.reqs) {
    layer.reqs++;

    q.updateItem(layer);
  } else {
    layer.reqs = 1;

    q.push(layer);
  }
};

LTCp.dequeue = function (pxRatio) {
  var self = this;
  var q = self.layersQueue;
  var deqd = [];
  var eleDeqs = 0;

  while (eleDeqs < maxDeqSize) {
    if (q.size() === 0) {
      break;
    }

    var layer = q.peek();

    // if a layer has been or will be replaced, then don't waste time with it
    if (layer.replacement) {
      // log('layer %s in queue skipped b/c it already has a replacement', layer.id);
      q.pop();
      continue;
    }

    // if this is a replacement layer that has been superceded, then forget it
    if (layer.replaces && layer !== layer.replaces.replacement) {
      // log('layer is no longer the most uptodate replacement; dequeued', layer.id)
      q.pop();
      continue;
    }

    if (layer.invalid) {
      // log('replacement layer %s is invalid; dequeued', layer.id);
      q.pop();
      continue;
    }

    var ele = layer.elesQueue.shift();

    if (ele) {
      // log('dequeue layer %s', layer.id);

      self.drawEleInLayer(layer, ele, layer.level, pxRatio);

      eleDeqs++;
    }

    if (deqd.length === 0) {
      // we need only one entry in deqd to queue redrawing etc
      deqd.push(true);
    }

    // if the layer has all its eles done, then remove from the queue
    if (layer.elesQueue.length === 0) {
      q.pop();

      layer.reqs = 0;

      // log('dequeue of layer %s complete', layer.id);

      // when a replacement layer is dequeued, it replaces the old layer in the level
      if (layer.replaces) {
        self.applyLayerReplacement(layer);
      }

      self.requestRedraw();
    }
  }

  return deqd;
};

LTCp.applyLayerReplacement = function (layer) {
  var self = this;
  var layersInLevel = self.layersByLevel[layer.level];
  var replaced = layer.replaces;
  var index = layersInLevel.indexOf(replaced);

  // if the replaced layer is not in the active list for the level, then replacing
  // refs would be a mistake (i.e. overwriting the true active layer)
  if (index < 0 || replaced.invalid) {
    // log('replacement layer would have no effect', layer.id);
    return;
  }

  layersInLevel[index] = layer; // replace level ref

  // replace refs in eles
  for (var i = 0; i < layer.eles.length; i++) {
    var _p = layer.eles[i]._private;
    var cache = _p.imgLayerCaches = _p.imgLayerCaches || {};

    if (cache) {
      cache[layer.level] = layer;
    }
  }

  // log('apply replacement layer %s over %s', layer.id, replaced.id);

  self.requestRedraw();
};

LTCp.requestRedraw = util.debounce(function () {
  var r = this.renderer;

  r.redrawHint('eles', true);
  r.redrawHint('drag', true);
  r.redraw();
}, 100);

LTCp.setupDequeueing = defs.setupDequeueing({
  deqRedrawThreshold: deqRedrawThreshold,
  deqCost: deqCost,
  deqAvgCost: deqAvgCost,
  deqNoDrawCost: deqNoDrawCost,
  deqFastCost: deqFastCost,
  deq: function deq(self, pxRatio) {
    return self.dequeue(pxRatio);
  },
  onDeqd: util.noop,
  shouldRedraw: util.trueify,
  priority: function priority(self) {
    return self.renderer.beforeRenderPriorities.lyrTxrDeq;
  }
});

module.exports = LayeredTextureCache;

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var CRp = {};

var impl;

CRp.arrowShapeImpl = function (name) {
  return (impl || (impl = {
    'polygon': function polygon(context, points) {
      for (var i = 0; i < points.length; i++) {
        var pt = points[i];

        context.lineTo(pt.x, pt.y);
      }
    },

    'triangle-backcurve': function triangleBackcurve(context, points, controlPoint) {
      var firstPt;

      for (var i = 0; i < points.length; i++) {
        var pt = points[i];

        if (i === 0) {
          firstPt = pt;
        }

        context.lineTo(pt.x, pt.y);
      }

      context.quadraticCurveTo(controlPoint.x, controlPoint.y, firstPt.x, firstPt.y);
    },

    'triangle-tee': function triangleTee(context, trianglePoints, teePoints) {
      if (context.beginPath) {
        context.beginPath();
      }

      var triPts = trianglePoints;
      for (var i = 0; i < triPts.length; i++) {
        var pt = triPts[i];

        context.lineTo(pt.x, pt.y);
      }

      if (context.closePath) {
        context.closePath();
      }

      if (context.beginPath) {
        context.beginPath();
      }

      var teePts = teePoints;
      var firstTeePt = teePoints[0];
      context.moveTo(firstTeePt.x, firstTeePt.y);

      for (var i = 0; i < teePts.length; i++) {
        var pt = teePts[i];

        context.lineTo(pt.x, pt.y);
      }
      if (context.closePath) {
        context.closePath();
      }
    },

    'triangle-cross': function triangleCross(context, trianglePoints, crossLinePoints) {
      if (context.beginPath) {
        context.beginPath();
      }

      var triPts = trianglePoints;
      for (var i = 0; i < triPts.length; i++) {
        var pt = triPts[i];

        context.lineTo(pt.x, pt.y);
      }

      if (context.closePath) {
        context.closePath();
      }

      if (context.beginPath) {
        context.beginPath();
      }

      var teePts = crossLinePoints;
      var firstTeePt = crossLinePoints[0];
      context.moveTo(firstTeePt.x, firstTeePt.y);

      for (var i = 0; i < teePts.length; i++) {
        var pt = teePts[i];

        context.lineTo(pt.x, pt.y);
      }
      if (context.closePath) {
        context.closePath();
      }
    },

    'circle': function circle(context, rx, ry, r) {
      context.arc(rx, ry, r, 0, Math.PI * 2, false);
    }
  }))[name];
};

module.exports = CRp;

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var math = __webpack_require__(2);

var CRp = {};

CRp.drawElement = function (context, ele, shiftToOriginWithBb, showLabel) {
  var r = this;

  if (ele.isNode()) {
    r.drawNode(context, ele, shiftToOriginWithBb, showLabel);
  } else {
    r.drawEdge(context, ele, shiftToOriginWithBb, showLabel);
  }
};

CRp.drawCachedElement = function (context, ele, pxRatio, extent) {
  var r = this;
  var bb = ele.boundingBox();

  if (bb.w === 0 || bb.h === 0) {
    return;
  }

  if (!extent || math.boundingBoxesIntersect(bb, extent)) {
    var cache = r.data.eleTxrCache.getElement(ele, bb, pxRatio);

    if (cache != null) {
      context.drawImage(cache.texture.canvas, cache.x, 0, cache.width, cache.height, bb.x1, bb.y1, bb.w, bb.h);
    } else {
      // if the element is not cacheable, then draw directly
      r.drawElement(context, ele);
    }
  }
};

CRp.drawElements = function (context, eles) {
  var r = this;

  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];

    r.drawElement(context, ele);
  }
};

CRp.drawCachedElements = function (context, eles, pxRatio, extent) {
  var r = this;

  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];

    r.drawCachedElement(context, ele, pxRatio, extent);
  }
};

CRp.drawCachedNodes = function (context, eles, pxRatio, extent) {
  var r = this;

  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];

    if (!ele.isNode()) {
      continue;
    }

    r.drawCachedElement(context, ele, pxRatio, extent);
  }
};

CRp.drawLayeredElements = function (context, eles, pxRatio, extent) {
  var r = this;

  var layers = r.data.lyrTxrCache.getLayers(eles, pxRatio);

  if (layers) {
    for (var i = 0; i < layers.length; i++) {
      var layer = layers[i];
      var bb = layer.bb;

      if (bb.w === 0 || bb.h === 0) {
        continue;
      }

      context.drawImage(layer.canvas, bb.x1, bb.y1, bb.w, bb.h);
    }
  } else {
    // fall back on plain caching if no layers
    r.drawCachedElements(context, eles, pxRatio, extent);
  }
};

CRp.drawDebugPoints = function (context, eles) {
  var draw = function draw(x, y, color) {
    context.fillStyle = color;
    context.fillRect(x - 1, y - 1, 3, 3);
  };

  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];
    var rs = ele._private.rscratch;

    if (ele.isNode()) {
      var p = ele.position();

      draw(p.x, p.y, 'magenta');
    } else {
      var pts = rs.allpts;

      for (var j = 0; j + 1 < pts.length; j += 2) {
        var x = pts[j];
        var y = pts[j + 1];

        draw(x, y, 'cyan');
      }

      draw(rs.midX, rs.midY, 'yellow');
    }
  }
};

module.exports = CRp;

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var CRp = {};

CRp.drawEdge = function (context, edge, shiftToOriginWithBb, drawLabel) {
  var r = this;
  var rs = edge._private.rscratch;
  var usePaths = r.usePaths();

  if (!edge.visible()) {
    return;
  }

  // if bezier ctrl pts can not be calculated, then die
  if (rs.badLine || rs.allpts == null || isNaN(rs.allpts[0])) {
    // isNaN in case edge is impossible and browser bugs (e.g. safari)
    return;
  }

  var bb = void 0;
  if (shiftToOriginWithBb) {
    bb = shiftToOriginWithBb;

    context.translate(-bb.x1, -bb.y1);
  }

  var overlayPadding = edge.pstyle('overlay-padding').pfValue;
  var overlayWidth = 2 * overlayPadding;
  var overlayOpacity = edge.pstyle('overlay-opacity').value;
  var overlayColor = edge.pstyle('overlay-color').value;
  var lineColor = edge.pstyle('line-color').value;
  var opacity = edge.pstyle('opacity').value;
  var lineStyle = edge.pstyle('line-style').value;
  var edgeWidth = edge.pstyle('width').pfValue;

  var drawLine = function drawLine() {
    var strokeOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : opacity;

    context.lineWidth = edgeWidth;
    context.lineCap = 'butt';

    r.strokeStyle(context, lineColor[0], lineColor[1], lineColor[2], strokeOpacity);

    r.drawEdgePath(edge, context, rs.allpts, lineStyle);
  };

  var drawOverlay = function drawOverlay() {
    var strokeOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : overlayOpacity;

    context.lineWidth = overlayWidth;

    if (rs.edgeType === 'self' && !usePaths) {
      context.lineCap = 'butt';
    } else {
      context.lineCap = 'round';
    }

    r.strokeStyle(context, overlayColor[0], overlayColor[1], overlayColor[2], strokeOpacity);

    r.drawEdgePath(edge, context, rs.allpts, 'solid');
  };

  var drawArrows = function drawArrows() {
    var arrowOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : opacity;

    r.drawArrowheads(context, edge, arrowOpacity);
  };

  var drawText = function drawText() {
    r.drawElementText(context, edge, drawLabel);
  };

  context.lineJoin = 'round';

  var ghost = edge.pstyle('ghost').value === 'yes';

  if (ghost) {
    var gx = edge.pstyle('ghost-offset-x').pfValue;
    var gy = edge.pstyle('ghost-offset-y').pfValue;
    var ghostOpacity = edge.pstyle('ghost-opacity').value;
    var effectiveGhostOpacity = opacity * ghostOpacity;

    context.translate(gx, gy);

    drawLine(effectiveGhostOpacity);
    drawArrows(effectiveGhostOpacity);

    context.translate(-gx, -gy);
  }

  drawLine();
  drawArrows();
  drawOverlay();
  drawText();

  if (shiftToOriginWithBb) {
    context.translate(bb.x1, bb.y1);
  }
};

CRp.drawEdgePath = function (edge, context, pts, type) {
  var rs = edge._private.rscratch;
  var canvasCxt = context;
  var path = void 0;
  var pathCacheHit = false;
  var usePaths = this.usePaths();

  if (usePaths) {
    var pathCacheKey = pts.join('$');
    var keyMatches = rs.pathCacheKey && rs.pathCacheKey === pathCacheKey;

    if (keyMatches) {
      path = context = rs.pathCache;
      pathCacheHit = true;
    } else {
      path = context = new Path2D(); // eslint-disable-line no-undef
      rs.pathCacheKey = pathCacheKey;
      rs.pathCache = path;
    }
  }

  if (canvasCxt.setLineDash) {
    // for very outofdate browsers
    switch (type) {
      case 'dotted':
        canvasCxt.setLineDash([1, 1]);
        break;

      case 'dashed':
        canvasCxt.setLineDash([6, 3]);
        break;

      case 'solid':
        canvasCxt.setLineDash([]);
        break;
    }
  }

  if (!pathCacheHit && !rs.badLine) {
    if (context.beginPath) {
      context.beginPath();
    }
    context.moveTo(pts[0], pts[1]);

    switch (rs.edgeType) {
      case 'bezier':
      case 'self':
      case 'compound':
      case 'multibezier':
        for (var i = 2; i + 3 < pts.length; i += 4) {
          context.quadraticCurveTo(pts[i], pts[i + 1], pts[i + 2], pts[i + 3]);
        }
        break;

      case 'straight':
      case 'segments':
      case 'haystack':
        for (var _i = 2; _i + 1 < pts.length; _i += 2) {
          context.lineTo(pts[_i], pts[_i + 1]);
        }
        break;
    }
  }

  context = canvasCxt;
  if (usePaths) {
    context.stroke(path);
  } else {
    context.stroke();
  }

  // reset any line dashes
  if (context.setLineDash) {
    // for very outofdate browsers
    context.setLineDash([]);
  }
};

CRp.drawArrowheads = function (context, edge, opacity) {
  var rs = edge._private.rscratch;
  var isHaystack = rs.edgeType === 'haystack';

  if (!isHaystack) {
    this.drawArrowhead(context, edge, 'source', rs.arrowStartX, rs.arrowStartY, rs.srcArrowAngle, opacity);
  }

  this.drawArrowhead(context, edge, 'mid-target', rs.midX, rs.midY, rs.midtgtArrowAngle, opacity);

  this.drawArrowhead(context, edge, 'mid-source', rs.midX, rs.midY, rs.midsrcArrowAngle, opacity);

  if (!isHaystack) {
    this.drawArrowhead(context, edge, 'target', rs.arrowEndX, rs.arrowEndY, rs.tgtArrowAngle, opacity);
  }
};

CRp.drawArrowhead = function (context, edge, prefix, x, y, angle, opacity) {
  if (isNaN(x) || x == null || isNaN(y) || y == null || isNaN(angle) || angle == null) {
    return;
  }

  var self = this;
  var arrowShape = edge.pstyle(prefix + '-arrow-shape').value;
  if (arrowShape === 'none') {
    return;
  }

  var arrowClearFill = edge.pstyle(prefix + '-arrow-fill').value === 'hollow' ? 'both' : 'filled';
  var arrowFill = edge.pstyle(prefix + '-arrow-fill').value;
  var edgeWidth = edge.pstyle('width').pfValue;
  var edgeOpacity = edge.pstyle('opacity').value;

  if (opacity === undefined) {
    opacity = edgeOpacity;
  }

  var gco = context.globalCompositeOperation;

  if (opacity !== 1 || arrowFill === 'hollow') {
    // then extra clear is needed
    context.globalCompositeOperation = 'destination-out';

    self.fillStyle(context, 255, 255, 255, 1);
    self.strokeStyle(context, 255, 255, 255, 1);

    self.drawArrowShape(edge, prefix, context, arrowClearFill, edgeWidth, arrowShape, x, y, angle);

    context.globalCompositeOperation = gco;
  } // otherwise, the opaque arrow clears it for free :)

  var color = edge.pstyle(prefix + '-arrow-color').value;
  self.fillStyle(context, color[0], color[1], color[2], opacity);
  self.strokeStyle(context, color[0], color[1], color[2], opacity);

  self.drawArrowShape(edge, prefix, context, arrowFill, edgeWidth, arrowShape, x, y, angle);
};

CRp.drawArrowShape = function (edge, arrowType, context, fill, edgeWidth, shape, x, y, angle) {
  var r = this;
  var usePaths = this.usePaths();
  var rs = edge._private.rscratch;
  var pathCacheHit = false;
  var path = void 0;
  var canvasContext = context;
  var translation = { x: x, y: y };
  var scale = edge.pstyle('arrow-scale').value;
  var size = this.getArrowWidth(edgeWidth, scale);
  var shapeImpl = r.arrowShapes[shape];

  if (usePaths) {
    var pathCacheKey = size + '$' + shape + '$' + angle + '$' + x + '$' + y;
    rs.arrowPathCacheKey = rs.arrowPathCacheKey || {};
    rs.arrowPathCache = rs.arrowPathCache || {};

    var alreadyCached = rs.arrowPathCacheKey[arrowType] === pathCacheKey;
    if (alreadyCached) {
      path = context = rs.arrowPathCache[arrowType];
      pathCacheHit = true;
    } else {
      path = context = new Path2D(); // eslint-disable-line no-undef
      rs.arrowPathCacheKey[arrowType] = pathCacheKey;
      rs.arrowPathCache[arrowType] = path;
    }
  }

  if (context.beginPath) {
    context.beginPath();
  }

  if (!pathCacheHit) {
    shapeImpl.draw(context, size, angle, translation, edgeWidth);
  }

  if (!shapeImpl.leavePathOpen && context.closePath) {
    context.closePath();
  }

  context = canvasContext;

  if (fill === 'filled' || fill === 'both') {
    if (usePaths) {
      context.fill(path);
    } else {
      context.fill();
    }
  }

  if (fill === 'hollow' || fill === 'both') {
    context.lineWidth = shapeImpl.matchEdgeWidth ? edgeWidth : 1;
    context.lineJoin = 'miter';

    if (usePaths) {
      context.stroke(path);
    } else {
      context.stroke();
    }
  }
};

module.exports = CRp;

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var CRp = {};

CRp.safeDrawImage = function (context, img, ix, iy, iw, ih, x, y, w, h) {
  var r = this;

  // detect problematic cases for old browsers with bad images (cheaper than try-catch)
  if (iw <= 0 || ih <= 0 || w <= 0 || h <= 0) {
    return;
  }

  context.drawImage(img, ix, iy, iw, ih, x, y, w, h);
};

CRp.drawInscribedImage = function (context, img, node, index, nodeOpacity) {
  var r = this;
  var pos = node.position();
  var nodeX = pos.x;
  var nodeY = pos.y;
  var styleObj = node.cy().style();
  var getIndexedStyle = styleObj.getIndexedStyle.bind(styleObj);
  var fit = getIndexedStyle(node, 'background-fit', 'value', index);
  var repeat = getIndexedStyle(node, 'background-repeat', 'value', index);
  var nodeW = node.width();
  var nodeH = node.height();
  var paddingX2 = node.padding() * 2;
  var nodeTW = nodeW + (getIndexedStyle(node, 'background-width-relative-to', 'value', index) === 'inner' ? 0 : paddingX2);
  var nodeTH = nodeH + (getIndexedStyle(node, 'background-height-relative-to', 'value', index) === 'inner' ? 0 : paddingX2);
  var rs = node._private.rscratch;
  var clip = node.pstyle('background-clip').value;
  var shouldClip = clip === 'node';
  var imgOpacity = getIndexedStyle(node, 'background-image-opacity', 'value', index) * nodeOpacity;

  var imgW = img.width || img.cachedW;
  var imgH = img.height || img.cachedH;

  // workaround for broken browsers like ie
  if (null == imgW || null == imgH) {
    document.body.appendChild(img); // eslint-disable-line no-undef

    imgW = img.cachedW = img.width || img.offsetWidth;
    imgH = img.cachedH = img.height || img.offsetHeight;

    document.body.removeChild(img); // eslint-disable-line no-undef
  }

  var w = imgW;
  var h = imgH;

  if (getIndexedStyle(node, 'background-width', 'value', index) !== 'auto') {
    if (getIndexedStyle(node, 'background-width', 'units', index) === '%') {
      w = getIndexedStyle(node, 'background-width', 'pfValue', index) * nodeTW;
    } else {
      w = getIndexedStyle(node, 'background-width', 'pfValue', index);
    }
  }

  if (getIndexedStyle(node, 'background-height', 'value', index) !== 'auto') {
    if (getIndexedStyle(node, 'background-height', 'units', index) === '%') {
      h = getIndexedStyle(node, 'background-height', 'pfValue', index) * nodeTH;
    } else {
      h = getIndexedStyle(node, 'background-height', 'pfValue', index);
    }
  }

  if (w === 0 || h === 0) {
    return; // no point in drawing empty image (and chrome is broken in this case)
  }

  if (fit === 'contain') {
    var scale = Math.min(nodeTW / w, nodeTH / h);

    w *= scale;
    h *= scale;
  } else if (fit === 'cover') {
    var scale = Math.max(nodeTW / w, nodeTH / h);

    w *= scale;
    h *= scale;
  }

  var x = nodeX - nodeTW / 2; // left
  if (getIndexedStyle(node, 'background-position-x', 'units', index) === '%') {
    x += (nodeTW - w) * getIndexedStyle(node, 'background-position-x', 'pfValue', index);
  } else {
    x += getIndexedStyle(node, 'background-position-x', 'pfValue', index);
  }

  var y = nodeY - nodeTH / 2; // top
  if (getIndexedStyle(node, 'background-position-y', 'units', index) === '%') {
    y += (nodeTH - h) * getIndexedStyle(node, 'background-position-y', 'pfValue', index);
  } else {
    y += getIndexedStyle(node, 'background-position-y', 'pfValue', index);
  }

  if (rs.pathCache) {
    x -= nodeX;
    y -= nodeY;

    nodeX = 0;
    nodeY = 0;
  }

  var gAlpha = context.globalAlpha;

  context.globalAlpha = imgOpacity;

  if (repeat === 'no-repeat') {

    if (shouldClip) {
      context.save();

      if (rs.pathCache) {
        context.clip(rs.pathCache);
      } else {
        r.nodeShapes[r.getNodeShape(node)].draw(context, nodeX, nodeY, nodeTW, nodeTH);

        context.clip();
      }
    }

    r.safeDrawImage(context, img, 0, 0, imgW, imgH, x, y, w, h);

    if (shouldClip) {
      context.restore();
    }
  } else {
    var pattern = context.createPattern(img, repeat);
    context.fillStyle = pattern;

    r.nodeShapes[r.getNodeShape(node)].draw(context, nodeX, nodeY, nodeTW, nodeTH);

    context.translate(x, y);
    context.fill();
    context.translate(-x, -y);
  }

  context.globalAlpha = gAlpha;
};

module.exports = CRp;

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);
var math = __webpack_require__(2);

var CRp = {};

CRp.eleTextBiggerThanMin = function (ele, scale) {
  if (!scale) {
    var zoom = ele.cy().zoom();
    var pxRatio = this.getPixelRatio();
    var lvl = Math.ceil(math.log2(zoom * pxRatio)); // the effective texture level

    scale = Math.pow(2, lvl);
  }

  var computedSize = ele.pstyle('font-size').pfValue * scale;
  var minSize = ele.pstyle('min-zoomed-font-size').pfValue;

  if (computedSize < minSize) {
    return false;
  }

  return true;
};

CRp.drawElementText = function (context, ele, force) {
  var r = this;

  if (force === undefined) {
    if (!r.eleTextBiggerThanMin(ele)) {
      return;
    }
  } else {
    if (!force) {
      return;
    }
  }

  if (ele.isNode()) {
    var label = ele.pstyle('label');

    if (!label || !label.value) {
      return;
    }

    var textHalign = ele.pstyle('text-halign').strValue;
    var textValign = ele.pstyle('text-valign').strValue;

    switch (textHalign) {
      case 'left':
        context.textAlign = 'right';
        break;

      case 'right':
        context.textAlign = 'left';
        break;

      default:
        // e.g. center
        context.textAlign = 'center';
    }

    context.textBaseline = 'bottom';
  } else {
    var label = ele.pstyle('label');
    var srcLabel = ele.pstyle('source-label');
    var tgtLabel = ele.pstyle('target-label');

    if ((!label || !label.value) && (!srcLabel || !srcLabel.value) && (!tgtLabel || !tgtLabel.value)) {
      return;
    }

    context.textAlign = 'center';
    context.textBaseline = 'bottom';
  }

  r.drawText(context, ele);

  if (ele.isEdge()) {
    r.drawText(context, ele, 'source');

    r.drawText(context, ele, 'target');
  }
};

CRp.drawNodeText = CRp.drawEdgeText = CRp.drawElementText;

CRp.getFontCache = function (context) {
  var cache;

  this.fontCaches = this.fontCaches || [];

  for (var i = 0; i < this.fontCaches.length; i++) {
    cache = this.fontCaches[i];

    if (cache.context === context) {
      return cache;
    }
  }

  cache = {
    context: context
  };
  this.fontCaches.push(cache);

  return cache;
};

// set up canvas context with font
// returns transformed text string
CRp.setupTextStyle = function (context, ele) {
  // Font style
  var parentOpacity = ele.effectiveOpacity();
  var labelStyle = ele.pstyle('font-style').strValue;
  var labelSize = ele.pstyle('font-size').pfValue + 'px';
  var labelFamily = ele.pstyle('font-family').strValue;
  var labelWeight = ele.pstyle('font-weight').strValue;
  var opacity = ele.pstyle('text-opacity').value * ele.pstyle('opacity').value * parentOpacity;
  var outlineOpacity = ele.pstyle('text-outline-opacity').value * opacity;
  var color = ele.pstyle('color').value;
  var outlineColor = ele.pstyle('text-outline-color').value;

  var fontCacheKey = ele._private.fontKey;
  var cache = this.getFontCache(context);

  if (cache.key !== fontCacheKey) {
    context.font = labelStyle + ' ' + labelWeight + ' ' + labelSize + ' ' + labelFamily;

    cache.key = fontCacheKey;
  }

  // Calculate text draw position based on text alignment

  // so text outlines aren't jagged
  context.lineJoin = 'round';

  this.fillStyle(context, color[0], color[1], color[2], opacity);

  this.strokeStyle(context, outlineColor[0], outlineColor[1], outlineColor[2], outlineOpacity);
};

function roundRect(ctx, x, y, width, height, radius) {
  var radius = radius || 5;
  ctx.beginPath();
  ctx.moveTo(x + radius, y);
  ctx.lineTo(x + width - radius, y);
  ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
  ctx.lineTo(x + width, y + height - radius);
  ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
  ctx.lineTo(x + radius, y + height);
  ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
  ctx.lineTo(x, y + radius);
  ctx.quadraticCurveTo(x, y, x + radius, y);
  ctx.closePath();
  ctx.fill();
}

// Draw text
CRp.drawText = function (context, ele, prefix) {
  var _p = ele._private;
  var rscratch = _p.rscratch;
  var parentOpacity = ele.effectiveOpacity();
  if (parentOpacity === 0 || ele.pstyle('text-opacity').value === 0) {
    return;
  }

  var textX = util.getPrefixedProperty(rscratch, 'labelX', prefix);
  var textY = util.getPrefixedProperty(rscratch, 'labelY', prefix);
  var text = this.getLabelText(ele, prefix);

  if (text != null && text !== '' && !isNaN(textX) && !isNaN(textY)) {
    this.setupTextStyle(context, ele);

    var pdash = prefix ? prefix + '-' : '';
    var textW = util.getPrefixedProperty(rscratch, 'labelWidth', prefix);
    var textH = util.getPrefixedProperty(rscratch, 'labelHeight', prefix);
    var textAngle = util.getPrefixedProperty(rscratch, 'labelAngle', prefix);
    var marginX = ele.pstyle(pdash + 'text-margin-x').pfValue;
    var marginY = ele.pstyle(pdash + 'text-margin-y').pfValue;

    var isEdge = ele.isEdge();
    var isNode = ele.isNode();

    var halign = ele.pstyle('text-halign').value;
    var valign = ele.pstyle('text-valign').value;

    if (isEdge) {
      halign = 'center';
      valign = 'center';
    }

    textX += marginX;
    textY += marginY;

    var rotation = ele.pstyle(pdash + 'text-rotation');
    var theta;

    if (rotation.strValue === 'autorotate') {
      theta = isEdge ? textAngle : 0;
    } else if (rotation.strValue === 'none') {
      theta = 0;
    } else {
      theta = rotation.pfValue;
    }

    if (theta !== 0) {
      var orgTextX = textX;
      var orgTextY = textY;

      context.translate(orgTextX, orgTextY);
      context.rotate(theta);

      textX = 0;
      textY = 0;
    }

    switch (valign) {
      case 'top':
        break;
      case 'center':
        textY += textH / 2;
        break;
      case 'bottom':
        textY += textH;
        break;
    }

    var backgroundOpacity = ele.pstyle('text-background-opacity').value;
    var borderOpacity = ele.pstyle('text-border-opacity').value;
    var textBorderWidth = ele.pstyle('text-border-width').pfValue;
    var backgroundPadding = ele.pstyle('text-background-padding').pfValue;

    if (backgroundOpacity > 0 || textBorderWidth > 0 && borderOpacity > 0) {
      var bgX = textX - backgroundPadding;

      switch (halign) {
        case 'left':
          bgX -= textW;
          break;
        case 'center':
          bgX -= textW / 2;
          break;
        case 'right':
          break;
      }

      var bgY = textY - textH - backgroundPadding;
      var bgW = textW + 2 * backgroundPadding;
      var bgH = textH + 2 * backgroundPadding;

      if (backgroundOpacity > 0) {
        var textFill = context.fillStyle;
        var textBackgroundColor = ele.pstyle('text-background-color').value;

        context.fillStyle = 'rgba(' + textBackgroundColor[0] + ',' + textBackgroundColor[1] + ',' + textBackgroundColor[2] + ',' + backgroundOpacity * parentOpacity + ')';
        var styleShape = ele.pstyle('text-background-shape').strValue;
        if (styleShape == 'roundrectangle') {
          roundRect(context, bgX, bgY, bgW, bgH, 2);
        } else {
          context.fillRect(bgX, bgY, bgW, bgH);
        }
        context.fillStyle = textFill;
      }

      if (textBorderWidth > 0 && borderOpacity > 0) {
        var textStroke = context.strokeStyle;
        var textLineWidth = context.lineWidth;
        var textBorderColor = ele.pstyle('text-border-color').value;
        var textBorderStyle = ele.pstyle('text-border-style').value;

        context.strokeStyle = 'rgba(' + textBorderColor[0] + ',' + textBorderColor[1] + ',' + textBorderColor[2] + ',' + borderOpacity * parentOpacity + ')';
        context.lineWidth = textBorderWidth;

        if (context.setLineDash) {
          // for very outofdate browsers
          switch (textBorderStyle) {
            case 'dotted':
              context.setLineDash([1, 1]);
              break;
            case 'dashed':
              context.setLineDash([4, 2]);
              break;
            case 'double':
              context.lineWidth = textBorderWidth / 4; // 50% reserved for white between the two borders
              context.setLineDash([]);
              break;
            case 'solid':
              context.setLineDash([]);
              break;
          }
        }

        context.strokeRect(bgX, bgY, bgW, bgH);

        if (textBorderStyle === 'double') {
          var whiteWidth = textBorderWidth / 2;

          context.strokeRect(bgX + whiteWidth, bgY + whiteWidth, bgW - whiteWidth * 2, bgH - whiteWidth * 2);
        }

        if (context.setLineDash) {
          // for very outofdate browsers
          context.setLineDash([]);
        }
        context.lineWidth = textLineWidth;
        context.strokeStyle = textStroke;
      }
    }

    var lineWidth = 2 * ele.pstyle('text-outline-width').pfValue; // *2 b/c the stroke is drawn centred on the middle

    if (lineWidth > 0) {
      context.lineWidth = lineWidth;
    }

    if (ele.pstyle('text-wrap').value === 'wrap') {
      var lines = util.getPrefixedProperty(rscratch, 'labelWrapCachedLines', prefix);
      var lineHeight = textH / lines.length;

      switch (valign) {
        case 'top':
          textY -= (lines.length - 1) * lineHeight;
          break;
        case 'center':
        case 'bottom':
          textY -= (lines.length - 1) * lineHeight;
          break;
      }

      for (var l = 0; l < lines.length; l++) {
        if (lineWidth > 0) {
          context.strokeText(lines[l], textX, textY);
        }

        context.fillText(lines[l], textX, textY);

        textY += lineHeight;
      }
    } else {
      if (lineWidth > 0) {
        context.strokeText(text, textX, textY);
      }

      context.fillText(text, textX, textY);
    }

    if (theta !== 0) {
      context.rotate(-theta);
      context.translate(-orgTextX, -orgTextY);
    }
  }
};

module.exports = CRp;

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* global Path2D */

var is = __webpack_require__(0);

var CRp = {};

CRp.drawNode = function (context, node, shiftToOriginWithBb, drawLabel) {
  var r = this;
  var nodeWidth = void 0,
      nodeHeight = void 0;
  var _p = node._private;
  var rs = _p.rscratch;
  var pos = node.position();

  if (!is.number(pos.x) || !is.number(pos.y)) {
    return; // can't draw node with undefined position
  }

  if (!node.visible()) {
    return;
  }

  var parentOpacity = node.effectiveOpacity();

  var usePaths = r.usePaths();
  var path = void 0;
  var pathCacheHit = false;

  var padding = node.padding();

  nodeWidth = node.width() + 2 * padding;
  nodeHeight = node.height() + 2 * padding;

  //
  // setup shift

  var bb = void 0;
  if (shiftToOriginWithBb) {
    bb = shiftToOriginWithBb;

    context.translate(-bb.x1, -bb.y1);
  }

  //
  // load bg image

  var bgImgProp = node.pstyle('background-image');
  var urls = bgImgProp.value;
  var urlDefined = new Array(urls.length);
  var image = new Array(urls.length);
  var numImages = 0;
  for (var i = 0; i < urls.length; i++) {
    var url = urls[i];
    var defd = urlDefined[i] = url != null && url !== 'none';

    if (defd) {
      var bgImgCrossOrigin = node.cy().style().getIndexedStyle(node, 'background-image-crossorigin', 'value', i);

      numImages++;

      // get image, and if not loaded then ask to redraw when later loaded
      image[i] = r.getCachedImage(url, bgImgCrossOrigin, function () {
        node.emitAndNotify('background');
      });
    }
  }

  //
  // setup styles

  var darkness = node.pstyle('background-blacken').value;
  var borderWidth = node.pstyle('border-width').pfValue;
  var bgColor = node.pstyle('background-color').value;
  var bgOpacity = node.pstyle('background-opacity').value * parentOpacity;
  var borderColor = node.pstyle('border-color').value;
  var borderStyle = node.pstyle('border-style').value;
  var borderOpacity = node.pstyle('border-opacity').value * parentOpacity;

  context.lineJoin = 'miter'; // so borders are square with the node shape

  var setupShapeColor = function setupShapeColor() {
    var bgOpy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : bgOpacity;

    r.fillStyle(context, bgColor[0], bgColor[1], bgColor[2], bgOpy);
  };

  var setupBorderColor = function setupBorderColor() {
    var bdrOpy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : borderOpacity;

    r.strokeStyle(context, borderColor[0], borderColor[1], borderColor[2], bdrOpy);
  };

  //
  // setup shape

  var styleShape = node.pstyle('shape').strValue;
  var shapePts = node.pstyle('shape-polygon-points').pfValue;

  if (usePaths) {
    var pathCacheKey = styleShape + '$' + nodeWidth + '$' + nodeHeight + (styleShape === 'polygon' ? '$' + shapePts.join('$') : '');

    context.translate(pos.x, pos.y);

    if (rs.pathCacheKey === pathCacheKey) {
      path = rs.pathCache;
      pathCacheHit = true;
    } else {
      path = new Path2D();
      rs.pathCacheKey = pathCacheKey;
      rs.pathCache = path;
    }
  }

  var drawShape = function drawShape() {
    if (!pathCacheHit) {

      var npos = pos;

      if (usePaths) {
        npos = {
          x: 0,
          y: 0
        };
      }

      r.nodeShapes[r.getNodeShape(node)].draw(path || context, npos.x, npos.y, nodeWidth, nodeHeight);
    }

    if (usePaths) {
      context.fill(path);
    } else {
      context.fill();
    }
  };

  var drawImages = function drawImages() {
    var nodeOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : parentOpacity;

    var prevBging = _p.backgrounding;
    var totalCompleted = 0;

    for (var _i = 0; _i < image.length; _i++) {
      if (urlDefined[_i] && image[_i].complete && !image[_i].error) {
        totalCompleted++;
        r.drawInscribedImage(context, image[_i], node, _i, nodeOpacity);
      }
    }

    _p.backgrounding = !(totalCompleted === numImages);
    if (prevBging !== _p.backgrounding) {
      // update style b/c :backgrounding state changed
      node.updateStyle(false);
    }
  };

  var drawPie = function drawPie() {
    var redrawShape = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    var pieOpacity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : parentOpacity;

    if (r.hasPie(node)) {
      r.drawPie(context, node, pieOpacity);

      // redraw/restore path if steps after pie need it
      if (redrawShape) {

        if (!usePaths) {
          r.nodeShapes[r.getNodeShape(node)].draw(context, pos.x, pos.y, nodeWidth, nodeHeight);
        }
      }
    }
  };

  var darken = function darken() {
    var darkenOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : parentOpacity;

    var opacity = (darkness > 0 ? darkness : -darkness) * darkenOpacity;
    var c = darkness > 0 ? 0 : 255;

    if (darkness !== 0) {
      r.fillStyle(context, c, c, c, opacity);

      if (usePaths) {
        context.fill(path);
      } else {
        context.fill();
      }
    }
  };

  var drawBorder = function drawBorder() {
    if (borderWidth > 0) {

      context.lineWidth = borderWidth;
      context.lineCap = 'butt';

      if (context.setLineDash) {
        // for very outofdate browsers
        switch (borderStyle) {
          case 'dotted':
            context.setLineDash([1, 1]);
            break;

          case 'dashed':
            context.setLineDash([4, 2]);
            break;

          case 'solid':
          case 'double':
            context.setLineDash([]);
            break;
        }
      }

      if (usePaths) {
        context.stroke(path);
      } else {
        context.stroke();
      }

      if (borderStyle === 'double') {
        context.lineWidth = borderWidth / 3;

        var gco = context.globalCompositeOperation;
        context.globalCompositeOperation = 'destination-out';

        if (usePaths) {
          context.stroke(path);
        } else {
          context.stroke();
        }

        context.globalCompositeOperation = gco;
      }

      // reset in case we changed the border style
      if (context.setLineDash) {
        // for very outofdate browsers
        context.setLineDash([]);
      }
    }
  };

  var drawOverlay = function drawOverlay() {
    var overlayPadding = node.pstyle('overlay-padding').pfValue;
    var overlayOpacity = node.pstyle('overlay-opacity').value;
    var overlayColor = node.pstyle('overlay-color').value;

    if (overlayOpacity > 0) {
      r.fillStyle(context, overlayColor[0], overlayColor[1], overlayColor[2], overlayOpacity);

      r.nodeShapes['roundrectangle'].draw(context, pos.x, pos.y, nodeWidth + overlayPadding * 2, nodeHeight + overlayPadding * 2);

      context.fill();
    }
  };

  var drawText = function drawText() {
    r.drawElementText(context, node, drawLabel);
  };

  var ghost = node.pstyle('ghost').value === 'yes';

  if (ghost) {
    var gx = node.pstyle('ghost-offset-x').pfValue;
    var gy = node.pstyle('ghost-offset-y').pfValue;
    var ghostOpacity = node.pstyle('ghost-opacity').value;
    var effGhostOpacity = ghostOpacity * parentOpacity;

    context.translate(gx, gy);

    setupShapeColor(ghostOpacity * bgOpacity);
    drawShape();
    drawImages(effGhostOpacity);
    drawPie(darkness !== 0 || borderWidth !== 0);
    darken(effGhostOpacity);
    setupBorderColor(ghostOpacity * borderOpacity);
    drawBorder();

    context.translate(-gx, -gy);
  }

  setupShapeColor();
  drawShape();
  drawImages();
  drawPie(darkness !== 0 || borderWidth !== 0);
  darken();
  setupBorderColor();
  drawBorder();

  if (usePaths) {
    context.translate(-pos.x, -pos.y);
  }

  drawText();
  drawOverlay();

  //
  // clean up shift

  if (shiftToOriginWithBb) {
    context.translate(bb.x1, bb.y1);
  }
};

// does the node have at least one pie piece?
CRp.hasPie = function (node) {
  node = node[0]; // ensure ele ref

  return node._private.hasPie;
};

CRp.drawPie = function (context, node, nodeOpacity, pos) {
  node = node[0]; // ensure ele ref
  pos = pos || node.position();

  var cyStyle = node.cy().style();
  var pieSize = node.pstyle('pie-size');
  var x = pos.x;
  var y = pos.y;
  var nodeW = node.width();
  var nodeH = node.height();
  var radius = Math.min(nodeW, nodeH) / 2; // must fit in node
  var lastPercent = 0; // what % to continue drawing pie slices from on [0, 1]
  var usePaths = this.usePaths();

  if (usePaths) {
    x = 0;
    y = 0;
  }

  if (pieSize.units === '%') {
    radius = radius * pieSize.pfValue;
  } else if (pieSize.pfValue !== undefined) {
    radius = pieSize.pfValue / 2;
  }

  for (var i = 1; i <= cyStyle.pieBackgroundN; i++) {
    // 1..N
    var size = node.pstyle('pie-' + i + '-background-size').value;
    var color = node.pstyle('pie-' + i + '-background-color').value;
    var opacity = node.pstyle('pie-' + i + '-background-opacity').value * nodeOpacity;
    var percent = size / 100; // map integer range [0, 100] to [0, 1]

    // percent can't push beyond 1
    if (percent + lastPercent > 1) {
      percent = 1 - lastPercent;
    }

    var angleStart = 1.5 * Math.PI + 2 * Math.PI * lastPercent; // start at 12 o'clock and go clockwise
    var angleDelta = 2 * Math.PI * percent;
    var angleEnd = angleStart + angleDelta;

    // ignore if
    // - zero size
    // - we're already beyond the full circle
    // - adding the current slice would go beyond the full circle
    if (size === 0 || lastPercent >= 1 || lastPercent + percent > 1) {
      continue;
    }

    context.beginPath();
    context.moveTo(x, y);
    context.arc(x, y, radius, angleStart, angleEnd);
    context.closePath();

    this.fillStyle(context, color[0], color[1], color[2], opacity);

    context.fill();

    lastPercent += percent;
  }
};

module.exports = CRp;

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var CRp = {};

var util = __webpack_require__(1);

var motionBlurDelay = 100;

// var isFirefox = typeof InstallTrigger !== 'undefined';

CRp.getPixelRatio = function () {
  var context = this.data.contexts[0];

  if (this.forcedPixelRatio != null) {
    return this.forcedPixelRatio;
  }

  var backingStore = context.backingStorePixelRatio || context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;

  return (window.devicePixelRatio || 1) / backingStore; // eslint-disable-line no-undef
};

CRp.paintCache = function (context) {
  var caches = this.paintCaches = this.paintCaches || [];
  var needToCreateCache = true;
  var cache;

  for (var i = 0; i < caches.length; i++) {
    cache = caches[i];

    if (cache.context === context) {
      needToCreateCache = false;
      break;
    }
  }

  if (needToCreateCache) {
    cache = {
      context: context
    };
    caches.push(cache);
  }

  return cache;
};

CRp.fillStyle = function (context, r, g, b, a) {
  context.fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';

  // turn off for now, seems context does its own caching

  // var cache = this.paintCache(context);

  // var fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';

  // if( cache.fillStyle !== fillStyle ){
  //   context.fillStyle = cache.fillStyle = fillStyle;
  // }
};

CRp.strokeStyle = function (context, r, g, b, a) {
  context.strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';

  // turn off for now, seems context does its own caching

  // var cache = this.paintCache(context);

  // var strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';

  // if( cache.strokeStyle !== strokeStyle ){
  //   context.strokeStyle = cache.strokeStyle = strokeStyle;
  // }
};

// Resize canvas
CRp.matchCanvasSize = function (container) {
  var r = this;
  var data = r.data;
  var bb = r.findContainerClientCoords();
  var width = bb[2];
  var height = bb[3];
  var pixelRatio = r.getPixelRatio();
  var mbPxRatio = r.motionBlurPxRatio;

  if (container === r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_NODE] || container === r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_DRAG]) {
    pixelRatio = mbPxRatio;
  }

  var canvasWidth = width * pixelRatio;
  var canvasHeight = height * pixelRatio;
  var canvas;

  if (canvasWidth === r.canvasWidth && canvasHeight === r.canvasHeight) {
    return; // save cycles if same
  }

  r.fontCaches = null; // resizing resets the style

  var canvasContainer = data.canvasContainer;
  canvasContainer.style.width = width + 'px';
  canvasContainer.style.height = height + 'px';

  for (var i = 0; i < r.CANVAS_LAYERS; i++) {
    canvas = data.canvases[i];

    canvas.width = canvasWidth;
    canvas.height = canvasHeight;

    canvas.style.width = width + 'px';
    canvas.style.height = height + 'px';
  }

  for (var i = 0; i < r.BUFFER_COUNT; i++) {
    canvas = data.bufferCanvases[i];

    canvas.width = canvasWidth;
    canvas.height = canvasHeight;

    canvas.style.width = width + 'px';
    canvas.style.height = height + 'px';
  }

  r.textureMult = 1;
  if (pixelRatio <= 1) {
    canvas = data.bufferCanvases[r.TEXTURE_BUFFER];

    r.textureMult = 2;
    canvas.width = canvasWidth * r.textureMult;
    canvas.height = canvasHeight * r.textureMult;
  }

  r.canvasWidth = canvasWidth;
  r.canvasHeight = canvasHeight;
};

CRp.renderTo = function (cxt, zoom, pan, pxRatio) {
  this.render({
    forcedContext: cxt,
    forcedZoom: zoom,
    forcedPan: pan,
    drawAllLayers: true,
    forcedPxRatio: pxRatio
  });
};

CRp.render = function (options) {
  options = options || util.staticEmptyObject();

  var forcedContext = options.forcedContext;
  var drawAllLayers = options.drawAllLayers;
  var drawOnlyNodeLayer = options.drawOnlyNodeLayer;
  var forcedZoom = options.forcedZoom;
  var forcedPan = options.forcedPan;
  var r = this;
  var pixelRatio = options.forcedPxRatio === undefined ? this.getPixelRatio() : options.forcedPxRatio;
  var cy = r.cy;var data = r.data;
  var needDraw = data.canvasNeedsRedraw;
  var textureDraw = r.textureOnViewport && !forcedContext && (r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming);
  var motionBlur = options.motionBlur !== undefined ? options.motionBlur : r.motionBlur;
  var mbPxRatio = r.motionBlurPxRatio;
  var hasCompoundNodes = cy.hasCompoundNodes();
  var inNodeDragGesture = r.hoverData.draggingEles;
  var inBoxSelection = r.hoverData.selecting || r.touchData.selecting ? true : false;
  motionBlur = motionBlur && !forcedContext && r.motionBlurEnabled && !inBoxSelection;
  var motionBlurFadeEffect = motionBlur;

  if (!forcedContext) {
    if (r.prevPxRatio !== pixelRatio) {
      r.invalidateContainerClientCoordsCache();
      r.matchCanvasSize(r.container);

      r.redrawHint('eles', true);
      r.redrawHint('drag', true);
    }

    r.prevPxRatio = pixelRatio;
  }

  if (!forcedContext && r.motionBlurTimeout) {
    clearTimeout(r.motionBlurTimeout);
  }

  if (motionBlur) {
    if (r.mbFrames == null) {
      r.mbFrames = 0;
    }

    r.mbFrames++;

    if (r.mbFrames < 3) {
      // need several frames before even high quality motionblur
      motionBlurFadeEffect = false;
    }

    // go to lower quality blurry frames when several m/b frames have been rendered (avoids flashing)
    if (r.mbFrames > r.minMbLowQualFrames) {
      //r.fullQualityMb = false;
      r.motionBlurPxRatio = r.mbPxRBlurry;
    }
  }

  if (r.clearingMotionBlur) {
    r.motionBlurPxRatio = 1;
  }

  // b/c drawToContext() may be async w.r.t. redraw(), keep track of last texture frame
  // because a rogue async texture frame would clear needDraw
  if (r.textureDrawLastFrame && !textureDraw) {
    needDraw[r.NODE] = true;
    needDraw[r.SELECT_BOX] = true;
  }

  var coreStyle = cy.style()._private.coreStyle;

  var zoom = cy.zoom();
  var effectiveZoom = forcedZoom !== undefined ? forcedZoom : zoom;
  var pan = cy.pan();
  var effectivePan = {
    x: pan.x,
    y: pan.y
  };

  var vp = {
    zoom: zoom,
    pan: {
      x: pan.x,
      y: pan.y
    }
  };
  var prevVp = r.prevViewport;
  var viewportIsDiff = prevVp === undefined || vp.zoom !== prevVp.zoom || vp.pan.x !== prevVp.pan.x || vp.pan.y !== prevVp.pan.y;

  // we want the low quality motionblur only when the viewport is being manipulated etc (where it's not noticed)
  if (!viewportIsDiff && !(inNodeDragGesture && !hasCompoundNodes)) {
    r.motionBlurPxRatio = 1;
  }

  if (forcedPan) {
    effectivePan = forcedPan;
  }

  // apply pixel ratio

  effectiveZoom *= pixelRatio;
  effectivePan.x *= pixelRatio;
  effectivePan.y *= pixelRatio;

  var eles = r.getCachedZSortedEles();

  function mbclear(context, x, y, w, h) {
    var gco = context.globalCompositeOperation;

    context.globalCompositeOperation = 'destination-out';
    r.fillStyle(context, 255, 255, 255, r.motionBlurTransparency);
    context.fillRect(x, y, w, h);

    context.globalCompositeOperation = gco;
  }

  function setContextTransform(context, clear) {
    var ePan, eZoom, w, h;

    if (!r.clearingMotionBlur && (context === data.bufferContexts[r.MOTIONBLUR_BUFFER_NODE] || context === data.bufferContexts[r.MOTIONBLUR_BUFFER_DRAG])) {
      ePan = {
        x: pan.x * mbPxRatio,
        y: pan.y * mbPxRatio
      };

      eZoom = zoom * mbPxRatio;

      w = r.canvasWidth * mbPxRatio;
      h = r.canvasHeight * mbPxRatio;
    } else {
      ePan = effectivePan;
      eZoom = effectiveZoom;

      w = r.canvasWidth;
      h = r.canvasHeight;
    }

    context.setTransform(1, 0, 0, 1, 0, 0);

    if (clear === 'motionBlur') {
      mbclear(context, 0, 0, w, h);
    } else if (!forcedContext && (clear === undefined || clear)) {
      context.clearRect(0, 0, w, h);
    }

    if (!drawAllLayers) {
      context.translate(ePan.x, ePan.y);
      context.scale(eZoom, eZoom);
    }
    if (forcedPan) {
      context.translate(forcedPan.x, forcedPan.y);
    }
    if (forcedZoom) {
      context.scale(forcedZoom, forcedZoom);
    }
  }

  if (!textureDraw) {
    r.textureDrawLastFrame = false;
  }

  if (textureDraw) {
    r.textureDrawLastFrame = true;

    var bb;

    if (!r.textureCache) {
      r.textureCache = {};

      bb = r.textureCache.bb = cy.mutableElements().boundingBox();

      r.textureCache.texture = r.data.bufferCanvases[r.TEXTURE_BUFFER];

      var cxt = r.data.bufferContexts[r.TEXTURE_BUFFER];

      cxt.setTransform(1, 0, 0, 1, 0, 0);
      cxt.clearRect(0, 0, r.canvasWidth * r.textureMult, r.canvasHeight * r.textureMult);

      r.render({
        forcedContext: cxt,
        drawOnlyNodeLayer: true,
        forcedPxRatio: pixelRatio * r.textureMult
      });

      var vp = r.textureCache.viewport = {
        zoom: cy.zoom(),
        pan: cy.pan(),
        width: r.canvasWidth,
        height: r.canvasHeight
      };

      vp.mpan = {
        x: (0 - vp.pan.x) / vp.zoom,
        y: (0 - vp.pan.y) / vp.zoom
      };
    }

    needDraw[r.DRAG] = false;
    needDraw[r.NODE] = false;

    var context = data.contexts[r.NODE];

    var texture = r.textureCache.texture;
    var vp = r.textureCache.viewport;
    bb = r.textureCache.bb;

    context.setTransform(1, 0, 0, 1, 0, 0);

    if (motionBlur) {
      mbclear(context, 0, 0, vp.width, vp.height);
    } else {
      context.clearRect(0, 0, vp.width, vp.height);
    }

    var outsideBgColor = coreStyle['outside-texture-bg-color'].value;
    var outsideBgOpacity = coreStyle['outside-texture-bg-opacity'].value;
    r.fillStyle(context, outsideBgColor[0], outsideBgColor[1], outsideBgColor[2], outsideBgOpacity);
    context.fillRect(0, 0, vp.width, vp.height);

    var zoom = cy.zoom();

    setContextTransform(context, false);

    context.clearRect(vp.mpan.x, vp.mpan.y, vp.width / vp.zoom / pixelRatio, vp.height / vp.zoom / pixelRatio);
    context.drawImage(texture, vp.mpan.x, vp.mpan.y, vp.width / vp.zoom / pixelRatio, vp.height / vp.zoom / pixelRatio);
  } else if (r.textureOnViewport && !forcedContext) {
    // clear the cache since we don't need it
    r.textureCache = null;
  }

  var extent = cy.extent();
  var vpManip = r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming || r.hoverData.draggingEles;
  var hideEdges = r.hideEdgesOnViewport && vpManip;

  var needMbClear = [];

  needMbClear[r.NODE] = !needDraw[r.NODE] && motionBlur && !r.clearedForMotionBlur[r.NODE] || r.clearingMotionBlur;
  if (needMbClear[r.NODE]) {
    r.clearedForMotionBlur[r.NODE] = true;
  }

  needMbClear[r.DRAG] = !needDraw[r.DRAG] && motionBlur && !r.clearedForMotionBlur[r.DRAG] || r.clearingMotionBlur;
  if (needMbClear[r.DRAG]) {
    r.clearedForMotionBlur[r.DRAG] = true;
  }

  if (needDraw[r.NODE] || drawAllLayers || drawOnlyNodeLayer || needMbClear[r.NODE]) {
    var useBuffer = motionBlur && !needMbClear[r.NODE] && mbPxRatio !== 1;
    var context = forcedContext || (useBuffer ? r.data.bufferContexts[r.MOTIONBLUR_BUFFER_NODE] : data.contexts[r.NODE]);
    var clear = motionBlur && !useBuffer ? 'motionBlur' : undefined;

    setContextTransform(context, clear);

    if (hideEdges) {
      r.drawCachedNodes(context, eles.nondrag, pixelRatio, extent);
    } else {
      r.drawLayeredElements(context, eles.nondrag, pixelRatio, extent);
    }

    if (r.debug) {
      r.drawDebugPoints(context, eles.nondrag);
    }

    if (!drawAllLayers && !motionBlur) {
      needDraw[r.NODE] = false;
    }
  }

  if (!drawOnlyNodeLayer && (needDraw[r.DRAG] || drawAllLayers || needMbClear[r.DRAG])) {
    var useBuffer = motionBlur && !needMbClear[r.DRAG] && mbPxRatio !== 1;
    var context = forcedContext || (useBuffer ? r.data.bufferContexts[r.MOTIONBLUR_BUFFER_DRAG] : data.contexts[r.DRAG]);

    setContextTransform(context, motionBlur && !useBuffer ? 'motionBlur' : undefined);

    if (hideEdges) {
      r.drawCachedNodes(context, eles.drag, pixelRatio, extent);
    } else {
      r.drawCachedElements(context, eles.drag, pixelRatio, extent);
    }

    if (r.debug) {
      r.drawDebugPoints(context, eles.drag);
    }

    if (!drawAllLayers && !motionBlur) {
      needDraw[r.DRAG] = false;
    }
  }

  if (r.showFps || !drawOnlyNodeLayer && needDraw[r.SELECT_BOX] && !drawAllLayers) {
    var context = forcedContext || data.contexts[r.SELECT_BOX];

    setContextTransform(context);

    if (r.selection[4] == 1 && (r.hoverData.selecting || r.touchData.selecting)) {
      var zoom = r.cy.zoom();
      var borderWidth = coreStyle['selection-box-border-width'].value / zoom;

      context.lineWidth = borderWidth;
      context.fillStyle = 'rgba(' + coreStyle['selection-box-color'].value[0] + ',' + coreStyle['selection-box-color'].value[1] + ',' + coreStyle['selection-box-color'].value[2] + ',' + coreStyle['selection-box-opacity'].value + ')';

      context.fillRect(r.selection[0], r.selection[1], r.selection[2] - r.selection[0], r.selection[3] - r.selection[1]);

      if (borderWidth > 0) {
        context.strokeStyle = 'rgba(' + coreStyle['selection-box-border-color'].value[0] + ',' + coreStyle['selection-box-border-color'].value[1] + ',' + coreStyle['selection-box-border-color'].value[2] + ',' + coreStyle['selection-box-opacity'].value + ')';

        context.strokeRect(r.selection[0], r.selection[1], r.selection[2] - r.selection[0], r.selection[3] - r.selection[1]);
      }
    }

    if (data.bgActivePosistion && !r.hoverData.selecting) {
      var zoom = r.cy.zoom();
      var pos = data.bgActivePosistion;

      context.fillStyle = 'rgba(' + coreStyle['active-bg-color'].value[0] + ',' + coreStyle['active-bg-color'].value[1] + ',' + coreStyle['active-bg-color'].value[2] + ',' + coreStyle['active-bg-opacity'].value + ')';

      context.beginPath();
      context.arc(pos.x, pos.y, coreStyle['active-bg-size'].pfValue / zoom, 0, 2 * Math.PI);
      context.fill();
    }

    var timeToRender = r.lastRedrawTime;
    if (r.showFps && timeToRender) {
      timeToRender = Math.round(timeToRender);
      var fps = Math.round(1000 / timeToRender);

      context.setTransform(1, 0, 0, 1, 0, 0);

      context.fillStyle = 'rgba(255, 0, 0, 0.75)';
      context.strokeStyle = 'rgba(255, 0, 0, 0.75)';
      context.lineWidth = 1;
      context.fillText('1 frame = ' + timeToRender + ' ms = ' + fps + ' fps', 0, 20);

      var maxFps = 60;
      context.strokeRect(0, 30, 250, 20);
      context.fillRect(0, 30, 250 * Math.min(fps / maxFps, 1), 20);
    }

    if (!drawAllLayers) {
      needDraw[r.SELECT_BOX] = false;
    }
  }

  // motionblur: blit rendered blurry frames
  if (motionBlur && mbPxRatio !== 1) {
    var cxtNode = data.contexts[r.NODE];
    var txtNode = r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_NODE];

    var cxtDrag = data.contexts[r.DRAG];
    var txtDrag = r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_DRAG];

    var drawMotionBlur = function drawMotionBlur(cxt, txt, needClear) {
      cxt.setTransform(1, 0, 0, 1, 0, 0);

      if (needClear || !motionBlurFadeEffect) {
        cxt.clearRect(0, 0, r.canvasWidth, r.canvasHeight);
      } else {
        mbclear(cxt, 0, 0, r.canvasWidth, r.canvasHeight);
      }

      var pxr = mbPxRatio;

      cxt.drawImage(txt, // img
      0, 0, // sx, sy
      r.canvasWidth * pxr, r.canvasHeight * pxr, // sw, sh
      0, 0, // x, y
      r.canvasWidth, r.canvasHeight // w, h
      );
    };

    if (needDraw[r.NODE] || needMbClear[r.NODE]) {
      drawMotionBlur(cxtNode, txtNode, needMbClear[r.NODE]);
      needDraw[r.NODE] = false;
    }

    if (needDraw[r.DRAG] || needMbClear[r.DRAG]) {
      drawMotionBlur(cxtDrag, txtDrag, needMbClear[r.DRAG]);
      needDraw[r.DRAG] = false;
    }
  }

  r.prevViewport = vp;

  if (r.clearingMotionBlur) {
    r.clearingMotionBlur = false;
    r.motionBlurCleared = true;
    r.motionBlur = true;
  }

  if (motionBlur) {
    r.motionBlurTimeout = setTimeout(function () {
      r.motionBlurTimeout = null;

      r.clearedForMotionBlur[r.NODE] = false;
      r.clearedForMotionBlur[r.DRAG] = false;
      r.motionBlur = false;
      r.clearingMotionBlur = !textureDraw;
      r.mbFrames = 0;

      needDraw[r.NODE] = true;
      needDraw[r.DRAG] = true;

      r.redraw();
    }, motionBlurDelay);
  }

  if (!forcedContext) {
    cy.emit('render');
  }
};

module.exports = CRp;

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var math = __webpack_require__(2);

var CRp = {};

// @O Polygon drawing
CRp.drawPolygonPath = function (context, x, y, width, height, points) {

  var halfW = width / 2;
  var halfH = height / 2;

  if (context.beginPath) {
    context.beginPath();
  }

  context.moveTo(x + halfW * points[0], y + halfH * points[1]);

  for (var i = 1; i < points.length / 2; i++) {
    context.lineTo(x + halfW * points[i * 2], y + halfH * points[i * 2 + 1]);
  }

  context.closePath();
};

// Round rectangle drawing
CRp.drawRoundRectanglePath = function (context, x, y, width, height) {

  var halfWidth = width / 2;
  var halfHeight = height / 2;
  var cornerRadius = math.getRoundRectangleRadius(width, height);

  if (context.beginPath) {
    context.beginPath();
  }

  // Start at top middle
  context.moveTo(x, y - halfHeight);
  // Arc from middle top to right side
  context.arcTo(x + halfWidth, y - halfHeight, x + halfWidth, y, cornerRadius);
  // Arc from right side to bottom
  context.arcTo(x + halfWidth, y + halfHeight, x, y + halfHeight, cornerRadius);
  // Arc from bottom to left side
  context.arcTo(x - halfWidth, y + halfHeight, x - halfWidth, y, cornerRadius);
  // Arc from left side to topBorder
  context.arcTo(x - halfWidth, y - halfHeight, x, y - halfHeight, cornerRadius);
  // Join line
  context.lineTo(x, y - halfHeight);

  context.closePath();
};

CRp.drawBottomRoundRectanglePath = function (context, x, y, width, height) {

  var halfWidth = width / 2;
  var halfHeight = height / 2;
  var cornerRadius = math.getRoundRectangleRadius(width, height);

  if (context.beginPath) {
    context.beginPath();
  }

  // Start at top middle
  context.moveTo(x, y - halfHeight);
  context.lineTo(x + halfWidth, y - halfHeight);
  context.lineTo(x + halfWidth, y);

  context.arcTo(x + halfWidth, y + halfHeight, x, y + halfHeight, cornerRadius);
  context.arcTo(x - halfWidth, y + halfHeight, x - halfWidth, y, cornerRadius);

  context.lineTo(x - halfWidth, y - halfHeight);
  context.lineTo(x, y - halfHeight);

  context.closePath();
};

CRp.drawCutRectanglePath = function (context, x, y, width, height) {

  var halfWidth = width / 2;
  var halfHeight = height / 2;
  var cornerLength = math.getCutRectangleCornerLength();

  if (context.beginPath) {
    context.beginPath();
  }

  context.moveTo(x - halfWidth + cornerLength, y - halfHeight);

  context.lineTo(x + halfWidth - cornerLength, y - halfHeight);
  context.lineTo(x + halfWidth, y - halfHeight + cornerLength);
  context.lineTo(x + halfWidth, y + halfHeight - cornerLength);
  context.lineTo(x + halfWidth - cornerLength, y + halfHeight);
  context.lineTo(x - halfWidth + cornerLength, y + halfHeight);
  context.lineTo(x - halfWidth, y + halfHeight - cornerLength);
  context.lineTo(x - halfWidth, y - halfHeight + cornerLength);

  context.closePath();
};

CRp.drawBarrelPath = function (context, x, y, width, height) {

  var halfWidth = width / 2;
  var halfHeight = height / 2;

  var xBegin = x - halfWidth;
  var xEnd = x + halfWidth;
  var yBegin = y - halfHeight;
  var yEnd = y + halfHeight;

  var barrelCurveConstants = math.getBarrelCurveConstants(width, height);
  var wOffset = barrelCurveConstants.widthOffset;
  var hOffset = barrelCurveConstants.heightOffset;
  var ctrlPtXOffset = barrelCurveConstants.ctrlPtOffsetPct * wOffset;

  if (context.beginPath) {
    context.beginPath();
  }

  context.moveTo(xBegin, yBegin + hOffset);

  context.lineTo(xBegin, yEnd - hOffset);
  context.quadraticCurveTo(xBegin + ctrlPtXOffset, yEnd, xBegin + wOffset, yEnd);

  context.lineTo(xEnd - wOffset, yEnd);
  context.quadraticCurveTo(xEnd - ctrlPtXOffset, yEnd, xEnd, yEnd - hOffset);

  context.lineTo(xEnd, yBegin + hOffset);
  context.quadraticCurveTo(xEnd - ctrlPtXOffset, yBegin, xEnd - wOffset, yBegin);

  context.lineTo(xBegin + wOffset, yBegin);
  context.quadraticCurveTo(xBegin + ctrlPtXOffset, yBegin, xBegin, yBegin + hOffset);

  context.closePath();
};

var sin0 = Math.sin(0);
var cos0 = Math.cos(0);

var sin = {};
var cos = {};

var ellipseStepSize = Math.PI / 40;

for (var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize) {
  sin[i] = Math.sin(i);
  cos[i] = Math.cos(i);
}

CRp.drawEllipsePath = function (context, centerX, centerY, width, height) {
  if (context.beginPath) {
    context.beginPath();
  }

  if (context.ellipse) {
    context.ellipse(centerX, centerY, width / 2, height / 2, 0, 0, 2 * Math.PI);
  } else {
    var xPos, yPos;
    var rw = width / 2;
    var rh = height / 2;
    for (var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize) {
      xPos = centerX - rw * sin[i] * sin0 + rw * cos[i] * cos0;
      yPos = centerY + rh * cos[i] * sin0 + rh * sin[i] * cos0;

      if (i === 0) {
        context.moveTo(xPos, yPos);
      } else {
        context.lineTo(xPos, yPos);
      }
    }
  }

  context.closePath();
};

module.exports = CRp;

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);

var CRp = {};

CRp.createBuffer = function (w, h) {
  var buffer = document.createElement('canvas'); // eslint-disable-line no-undef
  buffer.width = w;
  buffer.height = h;

  return [buffer, buffer.getContext('2d')];
};

CRp.bufferCanvasImage = function (options) {
  var cy = this.cy;
  var eles = cy.mutableElements();
  var bb = eles.boundingBox();
  var ctrRect = this.findContainerClientCoords();
  var width = options.full ? Math.ceil(bb.w) : ctrRect[2];
  var height = options.full ? Math.ceil(bb.h) : ctrRect[3];
  var specdMaxDims = is.number(options.maxWidth) || is.number(options.maxHeight);
  var pxRatio = this.getPixelRatio();
  var scale = 1;

  if (options.scale !== undefined) {
    width *= options.scale;
    height *= options.scale;

    scale = options.scale;
  } else if (specdMaxDims) {
    var maxScaleW = Infinity;
    var maxScaleH = Infinity;

    if (is.number(options.maxWidth)) {
      maxScaleW = scale * options.maxWidth / width;
    }

    if (is.number(options.maxHeight)) {
      maxScaleH = scale * options.maxHeight / height;
    }

    scale = Math.min(maxScaleW, maxScaleH);

    width *= scale;
    height *= scale;
  }

  if (!specdMaxDims) {
    width *= pxRatio;
    height *= pxRatio;
    scale *= pxRatio;
  }

  var buffCanvas = document.createElement('canvas'); // eslint-disable-line no-undef

  buffCanvas.width = width;
  buffCanvas.height = height;

  buffCanvas.style.width = width + 'px';
  buffCanvas.style.height = height + 'px';

  var buffCxt = buffCanvas.getContext('2d');

  // Rasterize the layers, but only if container has nonzero size
  if (width > 0 && height > 0) {

    buffCxt.clearRect(0, 0, width, height);

    buffCxt.globalCompositeOperation = 'source-over';

    var zsortedEles = this.getCachedZSortedEles();

    if (options.full) {
      // draw the full bounds of the graph
      buffCxt.translate(-bb.x1 * scale, -bb.y1 * scale);
      buffCxt.scale(scale, scale);

      this.drawElements(buffCxt, zsortedEles);

      buffCxt.scale(1 / scale, 1 / scale);
      buffCxt.translate(bb.x1 * scale, bb.y1 * scale);
    } else {
      // draw the current view
      var pan = cy.pan();

      var translation = {
        x: pan.x * scale,
        y: pan.y * scale
      };

      scale *= cy.zoom();

      buffCxt.translate(translation.x, translation.y);
      buffCxt.scale(scale, scale);

      this.drawElements(buffCxt, zsortedEles);

      buffCxt.scale(1 / scale, 1 / scale);
      buffCxt.translate(-translation.x, -translation.y);
    }

    // need to fill bg at end like this in order to fill cleared transparent pixels in jpgs
    if (options.bg) {
      buffCxt.globalCompositeOperation = 'destination-over';

      buffCxt.fillStyle = options.bg;
      buffCxt.rect(0, 0, width, height);
      buffCxt.fill();
    }
  }

  return buffCanvas;
};

function b64ToBlob(b64, mimeType) {
  var bytes = atob(b64);
  var buff = new ArrayBuffer(bytes.length);
  var buffUint8 = new Uint8Array(buff);

  for (var i = 0; i < bytes.length; i++) {
    buffUint8[i] = bytes.charCodeAt(i);
  }

  return new Blob([buff], { type: mimeType });
}

function b64UriToB64(b64uri) {
  var i = b64uri.indexOf(',');

  return b64uri.substr(i + 1);
};

function output(options, canvas, mimeType) {
  var b64Uri = canvas.toDataURL(mimeType, options.quality);

  switch (options.output) {
    case 'blob':
      return b64ToBlob(b64UriToB64(b64Uri), mimeType);

    case 'base64':
      return b64UriToB64(b64Uri);

    case 'base64uri':
    default:
      return b64Uri;
  }
}

CRp.png = function (options) {
  return output(options, this.bufferCanvasImage(options), 'image/png');
};

CRp.jpg = function (options) {
  return output(options, this.bufferCanvasImage(options), 'image/jpeg');
};

module.exports = CRp;

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var CRp = {};

CRp.nodeShapeImpl = function (name, context, centerX, centerY, width, height, points) {
  switch (name) {
    case 'ellipse':
      return this.drawEllipsePath(context, centerX, centerY, width, height);
    case 'polygon':
      return this.drawPolygonPath(context, centerX, centerY, width, height, points);
    case 'roundrectangle':
      return this.drawRoundRectanglePath(context, centerX, centerY, width, height);
    case 'cutrectangle':
      return this.drawCutRectanglePath(context, centerX, centerY, width, height);
    case 'bottomroundrectangle':
      return this.drawBottomRoundRectanglePath(context, centerX, centerY, width, height);
    case 'barrel':
      return this.drawBarrelPath(context, centerX, centerY, width, height);
  }
};

module.exports = CRp;

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__(0);
var util = __webpack_require__(1);
var Style = __webpack_require__(18);

// a dummy stylesheet object that doesn't need a reference to the core
// (useful for init)
var Stylesheet = function Stylesheet() {
  if (!(this instanceof Stylesheet)) {
    return new Stylesheet();
  }

  this.length = 0;
};

var sheetfn = Stylesheet.prototype;

sheetfn.instanceString = function () {
  return 'stylesheet';
};

// just store the selector to be parsed later
sheetfn.selector = function (selector) {
  var i = this.length++;

  this[i] = {
    selector: selector,
    properties: []
  };

  return this; // chaining
};

// just store the property to be parsed later
sheetfn.css = function (name, value) {
  var i = this.length - 1;

  if (is.string(name)) {
    this[i].properties.push({
      name: name,
      value: value
    });
  } else if (is.plainObject(name)) {
    var map = name;

    for (var j = 0; j < Style.properties.length; j++) {
      var prop = Style.properties[j];
      var mapVal = map[prop.name];

      if (mapVal === undefined) {
        // also try camel case name
        mapVal = map[util.dash2camel(prop.name)];
      }

      if (mapVal !== undefined) {
        var _name = prop.name;
        var _value = mapVal;

        this[i].properties.push({
          name: _name,
          value: _value
        });
      }
    }
  }

  return this; // chaining
};

sheetfn.style = sheetfn.css;

// generate a real style object from the dummy stylesheet
sheetfn.generateStyle = function (cy) {
  var style = new Style(cy);

  return this.appendToStyle(style);
};

// append a dummy stylesheet object on a real style object
sheetfn.appendToStyle = function (style) {
  for (var i = 0; i < this.length; i++) {
    var context = this[i];
    var selector = context.selector;
    var props = context.properties;

    style.selector(selector); // apply selector

    for (var j = 0; j < props.length; j++) {
      var prop = props[j];

      style.css(prop.name, prop.value); // apply property
    }
  }

  return style;
};

module.exports = Stylesheet;

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = "3.2.20";

/***/ })
/******/ ]);
});
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).setImmediate))

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = debounce;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(10);


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Generated by CoffeeScript 1.8.0
(function() {
  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;

  floor = Math.floor, min = Math.min;


  /*
  Default comparison function to be used
   */

  defaultCmp = function(x, y) {
    if (x < y) {
      return -1;
    }
    if (x > y) {
      return 1;
    }
    return 0;
  };


  /*
  Insert item x in list a, and keep it sorted assuming a is sorted.
  
  If x is already in a, insert it to the right of the rightmost x.
  
  Optional args lo (default 0) and hi (default a.length) bound the slice
  of a to be searched.
   */

  insort = function(a, x, lo, hi, cmp) {
    var mid;
    if (lo == null) {
      lo = 0;
    }
    if (cmp == null) {
      cmp = defaultCmp;
    }
    if (lo < 0) {
      throw new Error('lo must be non-negative');
    }
    if (hi == null) {
      hi = a.length;
    }
    while (lo < hi) {
      mid = floor((lo + hi) / 2);
      if (cmp(x, a[mid]) < 0) {
        hi = mid;
      } else {
        lo = mid + 1;
      }
    }
    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);
  };


  /*
  Push item onto heap, maintaining the heap invariant.
   */

  heappush = function(array, item, cmp) {
    if (cmp == null) {
      cmp = defaultCmp;
    }
    array.push(item);
    return _siftdown(array, 0, array.length - 1, cmp);
  };


  /*
  Pop the smallest item off the heap, maintaining the heap invariant.
   */

  heappop = function(array, cmp) {
    var lastelt, returnitem;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    lastelt = array.pop();
    if (array.length) {
      returnitem = array[0];
      array[0] = lastelt;
      _siftup(array, 0, cmp);
    } else {
      returnitem = lastelt;
    }
    return returnitem;
  };


  /*
  Pop and return the current smallest value, and add the new item.
  
  This is more efficient than heappop() followed by heappush(), and can be
  more appropriate when using a fixed size heap. Note that the value
  returned may be larger than item! That constrains reasonable use of
  this routine unless written as part of a conditional replacement:
      if item > array[0]
        item = heapreplace(array, item)
   */

  heapreplace = function(array, item, cmp) {
    var returnitem;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    returnitem = array[0];
    array[0] = item;
    _siftup(array, 0, cmp);
    return returnitem;
  };


  /*
  Fast version of a heappush followed by a heappop.
   */

  heappushpop = function(array, item, cmp) {
    var _ref;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    if (array.length && cmp(array[0], item) < 0) {
      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];
      _siftup(array, 0, cmp);
    }
    return item;
  };


  /*
  Transform list into a heap, in-place, in O(array.length) time.
   */

  heapify = function(array, cmp) {
    var i, _i, _j, _len, _ref, _ref1, _results, _results1;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    _ref1 = (function() {
      _results1 = [];
      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }
      return _results1;
    }).apply(this).reverse();
    _results = [];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      i = _ref1[_i];
      _results.push(_siftup(array, i, cmp));
    }
    return _results;
  };


  /*
  Update the position of the given item in the heap.
  This function should be called every time the item is being modified.
   */

  updateItem = function(array, item, cmp) {
    var pos;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    pos = array.indexOf(item);
    if (pos === -1) {
      return;
    }
    _siftdown(array, 0, pos, cmp);
    return _siftup(array, pos, cmp);
  };


  /*
  Find the n largest elements in a dataset.
   */

  nlargest = function(array, n, cmp) {
    var elem, result, _i, _len, _ref;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    result = array.slice(0, n);
    if (!result.length) {
      return result;
    }
    heapify(result, cmp);
    _ref = array.slice(n);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      elem = _ref[_i];
      heappushpop(result, elem, cmp);
    }
    return result.sort(cmp).reverse();
  };


  /*
  Find the n smallest elements in a dataset.
   */

  nsmallest = function(array, n, cmp) {
    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    if (n * 10 <= array.length) {
      result = array.slice(0, n).sort(cmp);
      if (!result.length) {
        return result;
      }
      los = result[result.length - 1];
      _ref = array.slice(n);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        elem = _ref[_i];
        if (cmp(elem, los) < 0) {
          insort(result, elem, 0, null, cmp);
          result.pop();
          los = result[result.length - 1];
        }
      }
      return result;
    }
    heapify(array, cmp);
    _results = [];
    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
      _results.push(heappop(array, cmp));
    }
    return _results;
  };

  _siftdown = function(array, startpos, pos, cmp) {
    var newitem, parent, parentpos;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    newitem = array[pos];
    while (pos > startpos) {
      parentpos = (pos - 1) >> 1;
      parent = array[parentpos];
      if (cmp(newitem, parent) < 0) {
        array[pos] = parent;
        pos = parentpos;
        continue;
      }
      break;
    }
    return array[pos] = newitem;
  };

  _siftup = function(array, pos, cmp) {
    var childpos, endpos, newitem, rightpos, startpos;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    endpos = array.length;
    startpos = pos;
    newitem = array[pos];
    childpos = 2 * pos + 1;
    while (childpos < endpos) {
      rightpos = childpos + 1;
      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {
        childpos = rightpos;
      }
      array[pos] = array[childpos];
      pos = childpos;
      childpos = 2 * pos + 1;
    }
    array[pos] = newitem;
    return _siftdown(array, startpos, pos, cmp);
  };

  Heap = (function() {
    Heap.push = heappush;

    Heap.pop = heappop;

    Heap.replace = heapreplace;

    Heap.pushpop = heappushpop;

    Heap.heapify = heapify;

    Heap.updateItem = updateItem;

    Heap.nlargest = nlargest;

    Heap.nsmallest = nsmallest;

    function Heap(cmp) {
      this.cmp = cmp != null ? cmp : defaultCmp;
      this.nodes = [];
    }

    Heap.prototype.push = function(x) {
      return heappush(this.nodes, x, this.cmp);
    };

    Heap.prototype.pop = function() {
      return heappop(this.nodes, this.cmp);
    };

    Heap.prototype.peek = function() {
      return this.nodes[0];
    };

    Heap.prototype.contains = function(x) {
      return this.nodes.indexOf(x) !== -1;
    };

    Heap.prototype.replace = function(x) {
      return heapreplace(this.nodes, x, this.cmp);
    };

    Heap.prototype.pushpop = function(x) {
      return heappushpop(this.nodes, x, this.cmp);
    };

    Heap.prototype.heapify = function() {
      return heapify(this.nodes, this.cmp);
    };

    Heap.prototype.updateItem = function(x) {
      return updateItem(this.nodes, x, this.cmp);
    };

    Heap.prototype.clear = function() {
      return this.nodes = [];
    };

    Heap.prototype.empty = function() {
      return this.nodes.length === 0;
    };

    Heap.prototype.size = function() {
      return this.nodes.length;
    };

    Heap.prototype.clone = function() {
      var heap;
      heap = new Heap();
      heap.nodes = this.nodes.slice(0);
      return heap;
    };

    Heap.prototype.toArray = function() {
      return this.nodes.slice(0);
    };

    Heap.prototype.insert = Heap.prototype.push;

    Heap.prototype.top = Heap.prototype.peek;

    Heap.prototype.front = Heap.prototype.peek;

    Heap.prototype.has = Heap.prototype.contains;

    Heap.prototype.copy = Heap.prototype.clone;

    return Heap;

  })();

  (function(root, factory) {
    if (true) {
      return !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else if (typeof exports === 'object') {
      return module.exports = factory();
    } else {
      return root.Heap = factory();
    }
  })(this, function() {
    return Heap;
  });

}).call(this);


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _moJs = __webpack_require__(12);

var _moJs2 = _interopRequireDefault(_moJs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Creates a Mo.js party popper animation.
 * https://codepen.io/johanmouchet/pen/qpjavE
 *
 * @property {string}  selector - DOM selector to attach the animation to
 */
function partyPopper(selector) {
  var colors = ['#bea4ff', '#feb535', '#ff6e83', '#58cafe'];

  var torsadeBurst = new _moJs2.default.Burst({
    parent: selector,
    radius: { 0: 'rand(50, 100)' },
    count: 'rand(18, 22)',
    degree: 30,
    children: {
      shape: 'zigzag',
      points: 'rand(4, 6)',
      radius: 40,
      radiusY: 30,
      strokeLinecap: 'round',
      strokeWidth: 8,
      fill: 'none',
      stroke: colors,
      angle: { 0: 'rand(-720, 720)' },
      isSwirl: true,
      swirlSize: 'rand(10, 20)',
      swirlFrequency: 'rand(1, 3)',
      direction: [-1, 1],
      degreeShift: 'rand(-15, 15)',
      duration: 2000,
      easing: 'cubic.out',
      pathScale: 'stagger(.2)'
    }
  });

  var bentBurst = new _moJs2.default.Burst({
    parent: selector,
    radius: { 0: 'rand(50, 100)' },
    count: 'rand(18, 22)',
    degree: 30,
    children: {
      shape: 'curve',
      radius: 'rand(25, 35)',
      radiusY: 15,
      strokeLinecap: 'round',
      strokeWidth: 8,
      fill: 'none',
      stroke: colors,
      angle: { 0: 'rand(-720, 720)' },
      isSwirl: true,
      swirlSize: 'rand(10, 20)',
      swirlFrequency: 'rand(1, 3)',
      direction: [-1, 1],
      degreeShift: 'rand(-15, 15)',
      duration: 2000,
      easing: 'cubic.out',
      pathScale: 'stagger(.2)'
    }
  });

  var flakeBurst = new _moJs2.default.Burst({
    parent: selector,
    radius: { 0: 'rand(50, 100)' },
    count: 'rand(18, 22)',
    degree: 30,
    children: {
      shape: 'circle',
      radius: 'rand(5, 10)',
      fill: colors,
      isSwirl: true,
      swirlSize: 'rand(10, 20)',
      swirlFrequency: 'rand(1, 3)',
      direction: [-1, 1],
      degreeShift: 'rand(-15, 15)',
      duration: 2000,
      easing: 'cubic.out',
      pathScale: 'stagger(.2)'
    }
  });

  torsadeBurst.play();
  bentBurst.play();
  flakeBurst.play();
};

if (document.querySelector('.party-popper-effects')) setTimeout(function () {
  return partyPopper('.party-popper-effects');
}, 400);

document.querySelectorAll('.party-popper-emoji').forEach(function (elem) {
  elem.addEventListener("click", function () {
    partyPopper('.party-popper-effects');
  });
});

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("mojs", [], factory);
	else if(typeof exports === 'object')
		exports["mojs"] = factory();
	else
		root["mojs"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "build/";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module) {'use strict';

	exports.__esModule = true;

	var _typeof2 = __webpack_require__(3);

	var _typeof3 = _interopRequireDefault(_typeof2);

	var _h = __webpack_require__(71);

	var _h2 = _interopRequireDefault(_h);

	var _shapesMap = __webpack_require__(72);

	var _shapesMap2 = _interopRequireDefault(_shapesMap);

	var _shape = __webpack_require__(94);

	var _shape2 = _interopRequireDefault(_shape);

	var _shapeSwirl = __webpack_require__(117);

	var _shapeSwirl2 = _interopRequireDefault(_shapeSwirl);

	var _burst = __webpack_require__(118);

	var _burst2 = _interopRequireDefault(_burst);

	var _html = __webpack_require__(119);

	var _html2 = _interopRequireDefault(_html);

	var _stagger = __webpack_require__(127);

	var _stagger2 = _interopRequireDefault(_stagger);

	var _spriter = __webpack_require__(128);

	var _spriter2 = _interopRequireDefault(_spriter);

	var _motionPath = __webpack_require__(129);

	var _motionPath2 = _interopRequireDefault(_motionPath);

	var _tween = __webpack_require__(101);

	var _tween2 = _interopRequireDefault(_tween);

	var _timeline = __webpack_require__(110);

	var _timeline2 = _interopRequireDefault(_timeline);

	var _tweener = __webpack_require__(102);

	var _tweener2 = _interopRequireDefault(_tweener);

	var _tweenable = __webpack_require__(100);

	var _tweenable2 = _interopRequireDefault(_tweenable);

	var _thenable = __webpack_require__(99);

	var _thenable2 = _interopRequireDefault(_thenable);

	var _tunable = __webpack_require__(116);

	var _tunable2 = _interopRequireDefault(_tunable);

	var _delta = __webpack_require__(126);

	var _delta2 = _interopRequireDefault(_delta);

	var _deltas = __webpack_require__(125);

	var _deltas2 = _interopRequireDefault(_deltas);

	var _module = __webpack_require__(84);

	var _module2 = _interopRequireDefault(_module);

	var _easing = __webpack_require__(105);

	var _easing2 = _interopRequireDefault(_easing);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var mojs = {
	  revision: '0.288.2', isDebug: true, helpers: _h2.default,
	  Shape: _shape2.default, ShapeSwirl: _shapeSwirl2.default, Burst: _burst2.default, Html: _html2.default, stagger: _stagger2.default, Spriter: _spriter2.default, MotionPath: _motionPath2.default,
	  Tween: _tween2.default, Timeline: _timeline2.default, Tweenable: _tweenable2.default, Thenable: _thenable2.default, Tunable: _tunable2.default, Module: _module2.default,
	  tweener: _tweener2.default, easing: _easing2.default, shapesMap: _shapesMap2.default, _pool: { Delta: _delta2.default, Deltas: _deltas2.default }
	};

	// functions alias
	mojs.h = mojs.helpers;
	mojs.delta = mojs.h.delta;
	// custom shape add function and class
	mojs.addShape = mojs.shapesMap.addShape;
	mojs.CustomShape = mojs.shapesMap.custom;
	// module alias
	mojs.Transit = mojs.Shape;
	mojs.Swirl = mojs.ShapeSwirl;

	// TODO:
	/*
	  H/V in paths

	  rand for direction
	  burst children angle after tune
	  burst pathScale after tune
	  swirl then issue
	  'rand' angle flick with `then`
	  not able to `play()` in `onComplete` callback
	  ---
	  module names
	  swirls in then chains for x/y
	  parse rand(stagger(20, 10), 20) values
	  percentage for radius
	*/

	// istanbul ignore next
	if (true) {
	  !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    return mojs;
	  }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}
	// istanbul ignore next
	if (( false ? 'undefined' : (0, _typeof3.default)(module)) === "object" && (0, _typeof3.default)(module.exports) === "object") {
	  module.exports = mojs;
	}

	exports.default = mojs;


	typeof window !== 'undefined' && (window.mojs = mojs);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)(module)))

/***/ }),
/* 2 */
/***/ (function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;

	var _iterator = __webpack_require__(4);

	var _iterator2 = _interopRequireDefault(_iterator);

	var _symbol = __webpack_require__(55);

	var _symbol2 = _interopRequireDefault(_symbol);

	var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
	  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
	} : function (obj) {
	  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
	};

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(5), __esModule: true };

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(6);
	__webpack_require__(50);
	module.exports = __webpack_require__(54).f('iterator');

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $at  = __webpack_require__(7)(true);

	// 21.1.3.27 String.prototype[@@iterator]()
	__webpack_require__(10)(String, 'String', function(iterated){
	  this._t = String(iterated); // target
	  this._i = 0;                // next index
	// 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , index = this._i
	    , point;
	  if(index >= O.length)return {value: undefined, done: true};
	  point = $at(O, index);
	  this._i += point.length;
	  return {value: point, done: false};
	});

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(8)
	  , defined   = __webpack_require__(9);
	// true  -> String#at
	// false -> String#codePointAt
	module.exports = function(TO_STRING){
	  return function(that, pos){
	    var s = String(defined(that))
	      , i = toInteger(pos)
	      , l = s.length
	      , a, b;
	    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	      ? TO_STRING ? s.charAt(i) : a
	      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};

/***/ }),
/* 8 */
/***/ (function(module, exports) {

	// 7.1.4 ToInteger
	var ceil  = Math.ceil
	  , floor = Math.floor;
	module.exports = function(it){
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

/***/ }),
/* 9 */
/***/ (function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function(it){
	  if(it == undefined)throw TypeError("Can't call method on  " + it);
	  return it;
	};

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY        = __webpack_require__(11)
	  , $export        = __webpack_require__(12)
	  , redefine       = __webpack_require__(27)
	  , hide           = __webpack_require__(17)
	  , has            = __webpack_require__(28)
	  , Iterators      = __webpack_require__(29)
	  , $iterCreate    = __webpack_require__(30)
	  , setToStringTag = __webpack_require__(46)
	  , getPrototypeOf = __webpack_require__(48)
	  , ITERATOR       = __webpack_require__(47)('iterator')
	  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
	  , FF_ITERATOR    = '@@iterator'
	  , KEYS           = 'keys'
	  , VALUES         = 'values';

	var returnThis = function(){ return this; };

	module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
	  $iterCreate(Constructor, NAME, next);
	  var getMethod = function(kind){
	    if(!BUGGY && kind in proto)return proto[kind];
	    switch(kind){
	      case KEYS: return function keys(){ return new Constructor(this, kind); };
	      case VALUES: return function values(){ return new Constructor(this, kind); };
	    } return function entries(){ return new Constructor(this, kind); };
	  };
	  var TAG        = NAME + ' Iterator'
	    , DEF_VALUES = DEFAULT == VALUES
	    , VALUES_BUG = false
	    , proto      = Base.prototype
	    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
	    , $default   = $native || getMethod(DEFAULT)
	    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
	    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
	    , methods, key, IteratorPrototype;
	  // Fix native
	  if($anyNative){
	    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
	    if(IteratorPrototype !== Object.prototype){
	      // Set @@toStringTag to native iterators
	      setToStringTag(IteratorPrototype, TAG, true);
	      // fix for some old engines
	      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
	    }
	  }
	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if(DEF_VALUES && $native && $native.name !== VALUES){
	    VALUES_BUG = true;
	    $default = function values(){ return $native.call(this); };
	  }
	  // Define iterator
	  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
	    hide(proto, ITERATOR, $default);
	  }
	  // Plug for library
	  Iterators[NAME] = $default;
	  Iterators[TAG]  = returnThis;
	  if(DEFAULT){
	    methods = {
	      values:  DEF_VALUES ? $default : getMethod(VALUES),
	      keys:    IS_SET     ? $default : getMethod(KEYS),
	      entries: $entries
	    };
	    if(FORCED)for(key in methods){
	      if(!(key in proto))redefine(proto, key, methods[key]);
	    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
	  }
	  return methods;
	};

/***/ }),
/* 11 */
/***/ (function(module, exports) {

	module.exports = true;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(13)
	  , core      = __webpack_require__(14)
	  , ctx       = __webpack_require__(15)
	  , hide      = __webpack_require__(17)
	  , PROTOTYPE = 'prototype';

	var $export = function(type, name, source){
	  var IS_FORCED = type & $export.F
	    , IS_GLOBAL = type & $export.G
	    , IS_STATIC = type & $export.S
	    , IS_PROTO  = type & $export.P
	    , IS_BIND   = type & $export.B
	    , IS_WRAP   = type & $export.W
	    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
	    , expProto  = exports[PROTOTYPE]
	    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
	    , key, own, out;
	  if(IS_GLOBAL)source = name;
	  for(key in source){
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    if(own && key in exports)continue;
	    // export native or passed
	    out = own ? target[key] : source[key];
	    // prevent global pollution for namespaces
	    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
	    // bind timers to global for call from export context
	    : IS_BIND && own ? ctx(out, global)
	    // wrap global constructors for prevent change them in library
	    : IS_WRAP && target[key] == out ? (function(C){
	      var F = function(a, b, c){
	        if(this instanceof C){
	          switch(arguments.length){
	            case 0: return new C;
	            case 1: return new C(a);
	            case 2: return new C(a, b);
	          } return new C(a, b, c);
	        } return C.apply(this, arguments);
	      };
	      F[PROTOTYPE] = C[PROTOTYPE];
	      return F;
	    // make static versions for prototype methods
	    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
	    if(IS_PROTO){
	      (exports.virtual || (exports.virtual = {}))[key] = out;
	      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
	      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);
	    }
	  }
	};
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library` 
	module.exports = $export;

/***/ }),
/* 13 */
/***/ (function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
	if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ }),
/* 14 */
/***/ (function(module, exports) {

	var core = module.exports = {version: '2.4.0'};
	if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(16);
	module.exports = function(fn, that, length){
	  aFunction(fn);
	  if(that === undefined)return fn;
	  switch(length){
	    case 1: return function(a){
	      return fn.call(that, a);
	    };
	    case 2: return function(a, b){
	      return fn.call(that, a, b);
	    };
	    case 3: return function(a, b, c){
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function(/* ...args */){
	    return fn.apply(that, arguments);
	  };
	};

/***/ }),
/* 16 */
/***/ (function(module, exports) {

	module.exports = function(it){
	  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
	  return it;
	};

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

	var dP         = __webpack_require__(18)
	  , createDesc = __webpack_require__(26);
	module.exports = __webpack_require__(22) ? function(object, key, value){
	  return dP.f(object, key, createDesc(1, value));
	} : function(object, key, value){
	  object[key] = value;
	  return object;
	};

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

	var anObject       = __webpack_require__(19)
	  , IE8_DOM_DEFINE = __webpack_require__(21)
	  , toPrimitive    = __webpack_require__(25)
	  , dP             = Object.defineProperty;

	exports.f = __webpack_require__(22) ? Object.defineProperty : function defineProperty(O, P, Attributes){
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if(IE8_DOM_DEFINE)try {
	    return dP(O, P, Attributes);
	  } catch(e){ /* empty */ }
	  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
	  if('value' in Attributes)O[P] = Attributes.value;
	  return O;
	};

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(20);
	module.exports = function(it){
	  if(!isObject(it))throw TypeError(it + ' is not an object!');
	  return it;
	};

/***/ }),
/* 20 */
/***/ (function(module, exports) {

	module.exports = function(it){
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = !__webpack_require__(22) && !__webpack_require__(23)(function(){
	  return Object.defineProperty(__webpack_require__(24)('div'), 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

	// Thank's IE8 for his funny defineProperty
	module.exports = !__webpack_require__(23)(function(){
	  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ }),
/* 23 */
/***/ (function(module, exports) {

	module.exports = function(exec){
	  try {
	    return !!exec();
	  } catch(e){
	    return true;
	  }
	};

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(20)
	  , document = __webpack_require__(13).document
	  // in old IE typeof document.createElement is 'object'
	  , is = isObject(document) && isObject(document.createElement);
	module.exports = function(it){
	  return is ? document.createElement(it) : {};
	};

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

	// 7.1.1 ToPrimitive(input [, PreferredType])
	var isObject = __webpack_require__(20);
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	module.exports = function(it, S){
	  if(!isObject(it))return it;
	  var fn, val;
	  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  throw TypeError("Can't convert object to primitive value");
	};

/***/ }),
/* 26 */
/***/ (function(module, exports) {

	module.exports = function(bitmap, value){
	  return {
	    enumerable  : !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable    : !(bitmap & 4),
	    value       : value
	  };
	};

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(17);

/***/ }),
/* 28 */
/***/ (function(module, exports) {

	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function(it, key){
	  return hasOwnProperty.call(it, key);
	};

/***/ }),
/* 29 */
/***/ (function(module, exports) {

	module.exports = {};

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var create         = __webpack_require__(31)
	  , descriptor     = __webpack_require__(26)
	  , setToStringTag = __webpack_require__(46)
	  , IteratorPrototype = {};

	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	__webpack_require__(17)(IteratorPrototype, __webpack_require__(47)('iterator'), function(){ return this; });

	module.exports = function(Constructor, NAME, next){
	  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
	  setToStringTag(Constructor, NAME + ' Iterator');
	};

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	var anObject    = __webpack_require__(19)
	  , dPs         = __webpack_require__(32)
	  , enumBugKeys = __webpack_require__(44)
	  , IE_PROTO    = __webpack_require__(41)('IE_PROTO')
	  , Empty       = function(){ /* empty */ }
	  , PROTOTYPE   = 'prototype';

	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var createDict = function(){
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = __webpack_require__(24)('iframe')
	    , i      = enumBugKeys.length
	    , lt     = '<'
	    , gt     = '>'
	    , iframeDocument;
	  iframe.style.display = 'none';
	  __webpack_require__(45).appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
	  return createDict();
	};

	module.exports = Object.create || function create(O, Properties){
	  var result;
	  if(O !== null){
	    Empty[PROTOTYPE] = anObject(O);
	    result = new Empty;
	    Empty[PROTOTYPE] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO] = O;
	  } else result = createDict();
	  return Properties === undefined ? result : dPs(result, Properties);
	};


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

	var dP       = __webpack_require__(18)
	  , anObject = __webpack_require__(19)
	  , getKeys  = __webpack_require__(33);

	module.exports = __webpack_require__(22) ? Object.defineProperties : function defineProperties(O, Properties){
	  anObject(O);
	  var keys   = getKeys(Properties)
	    , length = keys.length
	    , i = 0
	    , P;
	  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
	  return O;
	};

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)
	var $keys       = __webpack_require__(34)
	  , enumBugKeys = __webpack_require__(44);

	module.exports = Object.keys || function keys(O){
	  return $keys(O, enumBugKeys);
	};

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

	var has          = __webpack_require__(28)
	  , toIObject    = __webpack_require__(35)
	  , arrayIndexOf = __webpack_require__(38)(false)
	  , IE_PROTO     = __webpack_require__(41)('IE_PROTO');

	module.exports = function(object, names){
	  var O      = toIObject(object)
	    , i      = 0
	    , result = []
	    , key;
	  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while(names.length > i)if(has(O, key = names[i++])){
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = __webpack_require__(36)
	  , defined = __webpack_require__(9);
	module.exports = function(it){
	  return IObject(defined(it));
	};

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = __webpack_require__(37);
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};

/***/ }),
/* 37 */
/***/ (function(module, exports) {

	var toString = {}.toString;

	module.exports = function(it){
	  return toString.call(it).slice(8, -1);
	};

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

	// false -> Array#indexOf
	// true  -> Array#includes
	var toIObject = __webpack_require__(35)
	  , toLength  = __webpack_require__(39)
	  , toIndex   = __webpack_require__(40);
	module.exports = function(IS_INCLUDES){
	  return function($this, el, fromIndex){
	    var O      = toIObject($this)
	      , length = toLength(O.length)
	      , index  = toIndex(fromIndex, length)
	      , value;
	    // Array#includes uses SameValueZero equality algorithm
	    if(IS_INCLUDES && el != el)while(length > index){
	      value = O[index++];
	      if(value != value)return true;
	    // Array#toIndex ignores holes, Array#includes - not
	    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
	      if(O[index] === el)return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

	// 7.1.15 ToLength
	var toInteger = __webpack_require__(8)
	  , min       = Math.min;
	module.exports = function(it){
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(8)
	  , max       = Math.max
	  , min       = Math.min;
	module.exports = function(index, length){
	  index = toInteger(index);
	  return index < 0 ? max(index + length, 0) : min(index, length);
	};

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

	var shared = __webpack_require__(42)('keys')
	  , uid    = __webpack_require__(43);
	module.exports = function(key){
	  return shared[key] || (shared[key] = uid(key));
	};

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

	var global = __webpack_require__(13)
	  , SHARED = '__core-js_shared__'
	  , store  = global[SHARED] || (global[SHARED] = {});
	module.exports = function(key){
	  return store[key] || (store[key] = {});
	};

/***/ }),
/* 43 */
/***/ (function(module, exports) {

	var id = 0
	  , px = Math.random();
	module.exports = function(key){
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

/***/ }),
/* 44 */
/***/ (function(module, exports) {

	// IE 8- don't enum bug keys
	module.exports = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(13).document && document.documentElement;

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

	var def = __webpack_require__(18).f
	  , has = __webpack_require__(28)
	  , TAG = __webpack_require__(47)('toStringTag');

	module.exports = function(it, tag, stat){
	  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
	};

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

	var store      = __webpack_require__(42)('wks')
	  , uid        = __webpack_require__(43)
	  , Symbol     = __webpack_require__(13).Symbol
	  , USE_SYMBOL = typeof Symbol == 'function';

	var $exports = module.exports = function(name){
	  return store[name] || (store[name] =
	    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
	};

	$exports.store = store;

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
	var has         = __webpack_require__(28)
	  , toObject    = __webpack_require__(49)
	  , IE_PROTO    = __webpack_require__(41)('IE_PROTO')
	  , ObjectProto = Object.prototype;

	module.exports = Object.getPrototypeOf || function(O){
	  O = toObject(O);
	  if(has(O, IE_PROTO))return O[IE_PROTO];
	  if(typeof O.constructor == 'function' && O instanceof O.constructor){
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectProto : null;
	};

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(9);
	module.exports = function(it){
	  return Object(defined(it));
	};

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(51);
	var global        = __webpack_require__(13)
	  , hide          = __webpack_require__(17)
	  , Iterators     = __webpack_require__(29)
	  , TO_STRING_TAG = __webpack_require__(47)('toStringTag');

	for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
	  var NAME       = collections[i]
	    , Collection = global[NAME]
	    , proto      = Collection && Collection.prototype;
	  if(proto && !proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
	  Iterators[NAME] = Iterators.Array;
	}

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var addToUnscopables = __webpack_require__(52)
	  , step             = __webpack_require__(53)
	  , Iterators        = __webpack_require__(29)
	  , toIObject        = __webpack_require__(35);

	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	module.exports = __webpack_require__(10)(Array, 'Array', function(iterated, kind){
	  this._t = toIObject(iterated); // target
	  this._i = 0;                   // next index
	  this._k = kind;                // kind
	// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , kind  = this._k
	    , index = this._i++;
	  if(!O || index >= O.length){
	    this._t = undefined;
	    return step(1);
	  }
	  if(kind == 'keys'  )return step(0, index);
	  if(kind == 'values')return step(0, O[index]);
	  return step(0, [index, O[index]]);
	}, 'values');

	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	Iterators.Arguments = Iterators.Array;

	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');

/***/ }),
/* 52 */
/***/ (function(module, exports) {

	module.exports = function(){ /* empty */ };

/***/ }),
/* 53 */
/***/ (function(module, exports) {

	module.exports = function(done, value){
	  return {value: value, done: !!done};
	};

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

	exports.f = __webpack_require__(47);

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(56), __esModule: true };

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(57);
	__webpack_require__(68);
	__webpack_require__(69);
	__webpack_require__(70);
	module.exports = __webpack_require__(14).Symbol;

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// ECMAScript 6 symbols shim
	var global         = __webpack_require__(13)
	  , has            = __webpack_require__(28)
	  , DESCRIPTORS    = __webpack_require__(22)
	  , $export        = __webpack_require__(12)
	  , redefine       = __webpack_require__(27)
	  , META           = __webpack_require__(58).KEY
	  , $fails         = __webpack_require__(23)
	  , shared         = __webpack_require__(42)
	  , setToStringTag = __webpack_require__(46)
	  , uid            = __webpack_require__(43)
	  , wks            = __webpack_require__(47)
	  , wksExt         = __webpack_require__(54)
	  , wksDefine      = __webpack_require__(59)
	  , keyOf          = __webpack_require__(60)
	  , enumKeys       = __webpack_require__(61)
	  , isArray        = __webpack_require__(64)
	  , anObject       = __webpack_require__(19)
	  , toIObject      = __webpack_require__(35)
	  , toPrimitive    = __webpack_require__(25)
	  , createDesc     = __webpack_require__(26)
	  , _create        = __webpack_require__(31)
	  , gOPNExt        = __webpack_require__(65)
	  , $GOPD          = __webpack_require__(67)
	  , $DP            = __webpack_require__(18)
	  , $keys          = __webpack_require__(33)
	  , gOPD           = $GOPD.f
	  , dP             = $DP.f
	  , gOPN           = gOPNExt.f
	  , $Symbol        = global.Symbol
	  , $JSON          = global.JSON
	  , _stringify     = $JSON && $JSON.stringify
	  , PROTOTYPE      = 'prototype'
	  , HIDDEN         = wks('_hidden')
	  , TO_PRIMITIVE   = wks('toPrimitive')
	  , isEnum         = {}.propertyIsEnumerable
	  , SymbolRegistry = shared('symbol-registry')
	  , AllSymbols     = shared('symbols')
	  , OPSymbols      = shared('op-symbols')
	  , ObjectProto    = Object[PROTOTYPE]
	  , USE_NATIVE     = typeof $Symbol == 'function'
	  , QObject        = global.QObject;
	// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
	var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDesc = DESCRIPTORS && $fails(function(){
	  return _create(dP({}, 'a', {
	    get: function(){ return dP(this, 'a', {value: 7}).a; }
	  })).a != 7;
	}) ? function(it, key, D){
	  var protoDesc = gOPD(ObjectProto, key);
	  if(protoDesc)delete ObjectProto[key];
	  dP(it, key, D);
	  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);
	} : dP;

	var wrap = function(tag){
	  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
	  sym._k = tag;
	  return sym;
	};

	var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
	  return typeof it == 'symbol';
	} : function(it){
	  return it instanceof $Symbol;
	};

	var $defineProperty = function defineProperty(it, key, D){
	  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);
	  anObject(it);
	  key = toPrimitive(key, true);
	  anObject(D);
	  if(has(AllSymbols, key)){
	    if(!D.enumerable){
	      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));
	      it[HIDDEN][key] = true;
	    } else {
	      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
	      D = _create(D, {enumerable: createDesc(0, false)});
	    } return setSymbolDesc(it, key, D);
	  } return dP(it, key, D);
	};
	var $defineProperties = function defineProperties(it, P){
	  anObject(it);
	  var keys = enumKeys(P = toIObject(P))
	    , i    = 0
	    , l = keys.length
	    , key;
	  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
	  return it;
	};
	var $create = function create(it, P){
	  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable(key){
	  var E = isEnum.call(this, key = toPrimitive(key, true));
	  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;
	  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
	};
	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
	  it  = toIObject(it);
	  key = toPrimitive(key, true);
	  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;
	  var D = gOPD(it, key);
	  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
	  return D;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(it){
	  var names  = gOPN(toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
	  } return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
	  var IS_OP  = it === ObjectProto
	    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);
	  } return result;
	};

	// 19.4.1.1 Symbol([description])
	if(!USE_NATIVE){
	  $Symbol = function Symbol(){
	    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
	    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
	    var $set = function(value){
	      if(this === ObjectProto)$set.call(OPSymbols, value);
	      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
	      setSymbolDesc(this, tag, createDesc(1, value));
	    };
	    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});
	    return wrap(tag);
	  };
	  redefine($Symbol[PROTOTYPE], 'toString', function toString(){
	    return this._k;
	  });

	  $GOPD.f = $getOwnPropertyDescriptor;
	  $DP.f   = $defineProperty;
	  __webpack_require__(66).f = gOPNExt.f = $getOwnPropertyNames;
	  __webpack_require__(63).f  = $propertyIsEnumerable;
	  __webpack_require__(62).f = $getOwnPropertySymbols;

	  if(DESCRIPTORS && !__webpack_require__(11)){
	    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
	  }

	  wksExt.f = function(name){
	    return wrap(wks(name));
	  }
	}

	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});

	for(var symbols = (
	  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
	  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
	).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);

	for(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);

	$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
	  // 19.4.2.1 Symbol.for(key)
	  'for': function(key){
	    return has(SymbolRegistry, key += '')
	      ? SymbolRegistry[key]
	      : SymbolRegistry[key] = $Symbol(key);
	  },
	  // 19.4.2.5 Symbol.keyFor(sym)
	  keyFor: function keyFor(key){
	    if(isSymbol(key))return keyOf(SymbolRegistry, key);
	    throw TypeError(key + ' is not a symbol!');
	  },
	  useSetter: function(){ setter = true; },
	  useSimple: function(){ setter = false; }
	});

	$export($export.S + $export.F * !USE_NATIVE, 'Object', {
	  // 19.1.2.2 Object.create(O [, Properties])
	  create: $create,
	  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
	  defineProperty: $defineProperty,
	  // 19.1.2.3 Object.defineProperties(O, Properties)
	  defineProperties: $defineProperties,
	  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
	  // 19.1.2.7 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // 19.1.2.8 Object.getOwnPropertySymbols(O)
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});

	// 24.3.2 JSON.stringify(value [, replacer [, space]])
	$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){
	  var S = $Symbol();
	  // MS Edge converts symbol values to JSON as {}
	  // WebKit converts symbol values to JSON as null
	  // V8 throws on boxed symbols
	  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
	})), 'JSON', {
	  stringify: function stringify(it){
	    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
	    var args = [it]
	      , i    = 1
	      , replacer, $replacer;
	    while(arguments.length > i)args.push(arguments[i++]);
	    replacer = args[1];
	    if(typeof replacer == 'function')$replacer = replacer;
	    if($replacer || !isArray(replacer))replacer = function(key, value){
	      if($replacer)value = $replacer.call(this, key, value);
	      if(!isSymbol(value))return value;
	    };
	    args[1] = replacer;
	    return _stringify.apply($JSON, args);
	  }
	});

	// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
	$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(17)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
	// 19.4.3.5 Symbol.prototype[@@toStringTag]
	setToStringTag($Symbol, 'Symbol');
	// 20.2.1.9 Math[@@toStringTag]
	setToStringTag(Math, 'Math', true);
	// 24.3.3 JSON[@@toStringTag]
	setToStringTag(global.JSON, 'JSON', true);

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

	var META     = __webpack_require__(43)('meta')
	  , isObject = __webpack_require__(20)
	  , has      = __webpack_require__(28)
	  , setDesc  = __webpack_require__(18).f
	  , id       = 0;
	var isExtensible = Object.isExtensible || function(){
	  return true;
	};
	var FREEZE = !__webpack_require__(23)(function(){
	  return isExtensible(Object.preventExtensions({}));
	});
	var setMeta = function(it){
	  setDesc(it, META, {value: {
	    i: 'O' + ++id, // object ID
	    w: {}          // weak collections IDs
	  }});
	};
	var fastKey = function(it, create){
	  // return primitive with prefix
	  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return 'F';
	    // not necessary to add metadata
	    if(!create)return 'E';
	    // add missing metadata
	    setMeta(it);
	  // return object ID
	  } return it[META].i;
	};
	var getWeak = function(it, create){
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return true;
	    // not necessary to add metadata
	    if(!create)return false;
	    // add missing metadata
	    setMeta(it);
	  // return hash weak collections IDs
	  } return it[META].w;
	};
	// add metadata on freeze-family methods calling
	var onFreeze = function(it){
	  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
	  return it;
	};
	var meta = module.exports = {
	  KEY:      META,
	  NEED:     false,
	  fastKey:  fastKey,
	  getWeak:  getWeak,
	  onFreeze: onFreeze
	};

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

	var global         = __webpack_require__(13)
	  , core           = __webpack_require__(14)
	  , LIBRARY        = __webpack_require__(11)
	  , wksExt         = __webpack_require__(54)
	  , defineProperty = __webpack_require__(18).f;
	module.exports = function(name){
	  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
	  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});
	};

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

	var getKeys   = __webpack_require__(33)
	  , toIObject = __webpack_require__(35);
	module.exports = function(object, el){
	  var O      = toIObject(object)
	    , keys   = getKeys(O)
	    , length = keys.length
	    , index  = 0
	    , key;
	  while(length > index)if(O[key = keys[index++]] === el)return key;
	};

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

	// all enumerable object keys, includes symbols
	var getKeys = __webpack_require__(33)
	  , gOPS    = __webpack_require__(62)
	  , pIE     = __webpack_require__(63);
	module.exports = function(it){
	  var result     = getKeys(it)
	    , getSymbols = gOPS.f;
	  if(getSymbols){
	    var symbols = getSymbols(it)
	      , isEnum  = pIE.f
	      , i       = 0
	      , key;
	    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
	  } return result;
	};

/***/ }),
/* 62 */
/***/ (function(module, exports) {

	exports.f = Object.getOwnPropertySymbols;

/***/ }),
/* 63 */
/***/ (function(module, exports) {

	exports.f = {}.propertyIsEnumerable;

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

	// 7.2.2 IsArray(argument)
	var cof = __webpack_require__(37);
	module.exports = Array.isArray || function isArray(arg){
	  return cof(arg) == 'Array';
	};

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
	var toIObject = __webpack_require__(35)
	  , gOPN      = __webpack_require__(66).f
	  , toString  = {}.toString;

	var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];

	var getWindowNames = function(it){
	  try {
	    return gOPN(it);
	  } catch(e){
	    return windowNames.slice();
	  }
	};

	module.exports.f = function getOwnPropertyNames(it){
	  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
	};


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
	var $keys      = __webpack_require__(34)
	  , hiddenKeys = __webpack_require__(44).concat('length', 'prototype');

	exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
	  return $keys(O, hiddenKeys);
	};

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

	var pIE            = __webpack_require__(63)
	  , createDesc     = __webpack_require__(26)
	  , toIObject      = __webpack_require__(35)
	  , toPrimitive    = __webpack_require__(25)
	  , has            = __webpack_require__(28)
	  , IE8_DOM_DEFINE = __webpack_require__(21)
	  , gOPD           = Object.getOwnPropertyDescriptor;

	exports.f = __webpack_require__(22) ? gOPD : function getOwnPropertyDescriptor(O, P){
	  O = toIObject(O);
	  P = toPrimitive(P, true);
	  if(IE8_DOM_DEFINE)try {
	    return gOPD(O, P);
	  } catch(e){ /* empty */ }
	  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
	};

/***/ }),
/* 68 */
/***/ (function(module, exports) {

	

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(59)('asyncIterator');

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(59)('observable');

/***/ }),
/* 71 */
/***/ (function(module, exports) {

	var Helpers, h;

	Helpers = (function() {
	  Helpers.prototype.NS = 'http://www.w3.org/2000/svg';

	  Helpers.prototype.logBadgeCss = 'background:#3A0839;color:#FF512F;border-radius:5px; padding: 1px 5px 2px; border: 1px solid #FF512F;';

	  Helpers.prototype.shortColors = {
	    transparent: 'rgba(0,0,0,0)',
	    none: 'rgba(0,0,0,0)',
	    aqua: 'rgb(0,255,255)',
	    black: 'rgb(0,0,0)',
	    blue: 'rgb(0,0,255)',
	    fuchsia: 'rgb(255,0,255)',
	    gray: 'rgb(128,128,128)',
	    green: 'rgb(0,128,0)',
	    lime: 'rgb(0,255,0)',
	    maroon: 'rgb(128,0,0)',
	    navy: 'rgb(0,0,128)',
	    olive: 'rgb(128,128,0)',
	    purple: 'rgb(128,0,128)',
	    red: 'rgb(255,0,0)',
	    silver: 'rgb(192,192,192)',
	    teal: 'rgb(0,128,128)',
	    white: 'rgb(255,255,255)',
	    yellow: 'rgb(255,255,0)',
	    orange: 'rgb(255,128,0)'
	  };

	  Helpers.prototype.chainOptionMap = {};

	  Helpers.prototype.callbacksMap = {
	    onRefresh: 1,
	    onStart: 1,
	    onComplete: 1,
	    onFirstUpdate: 1,
	    onUpdate: 1,
	    onProgress: 1,
	    onRepeatStart: 1,
	    onRepeatComplete: 1,
	    onPlaybackStart: 1,
	    onPlaybackPause: 1,
	    onPlaybackStop: 1,
	    onPlaybackComplete: 1
	  };

	  Helpers.prototype.tweenOptionMap = {
	    duration: 1,
	    delay: 1,
	    speed: 1,
	    repeat: 1,
	    easing: 1,
	    backwardEasing: 1,
	    isYoyo: 1,
	    shiftTime: 1,
	    isReversed: 1,
	    callbacksContext: 1
	  };

	  Helpers.prototype.unitOptionMap = {
	    left: 1,
	    top: 1,
	    x: 1,
	    y: 1,
	    rx: 1,
	    ry: 1
	  };

	  Helpers.prototype.RAD_TO_DEG = 180 / Math.PI;

	  function Helpers() {
	    this.vars();
	  }

	  Helpers.prototype.vars = function() {
	    var ua;
	    this.prefix = this.getPrefix();
	    this.getRemBase();
	    this.isFF = this.prefix.lowercase === 'moz';
	    this.isIE = this.prefix.lowercase === 'ms';
	    ua = navigator.userAgent;
	    this.isOldOpera = ua.match(/presto/gim);
	    this.isSafari = ua.indexOf('Safari') > -1;
	    this.isChrome = ua.indexOf('Chrome') > -1;
	    this.isOpera = ua.toLowerCase().indexOf("op") > -1;
	    this.isChrome && this.isSafari && (this.isSafari = false);
	    (ua.match(/PhantomJS/gim)) && (this.isSafari = false);
	    this.isChrome && this.isOpera && (this.isChrome = false);
	    this.is3d = this.checkIf3d();
	    this.uniqIDs = -1;
	    this.div = document.createElement('div');
	    document.body.appendChild(this.div);
	    return this.defaultStyles = this.computedStyle(this.div);
	  };

	  Helpers.prototype.cloneObj = function(obj, exclude) {
	    var i, key, keys, newObj;
	    keys = Object.keys(obj);
	    newObj = {};
	    i = keys.length;
	    while (i--) {
	      key = keys[i];
	      if (exclude != null) {
	        if (!exclude[key]) {
	          newObj[key] = obj[key];
	        }
	      } else {
	        newObj[key] = obj[key];
	      }
	    }
	    return newObj;
	  };

	  Helpers.prototype.extend = function(objTo, objFrom) {
	    var key, value;
	    for (key in objFrom) {
	      value = objFrom[key];
	      if (objTo[key] == null) {
	        objTo[key] = objFrom[key];
	      }
	    }
	    return objTo;
	  };

	  Helpers.prototype.getRemBase = function() {
	    var html, style;
	    html = document.querySelector('html');
	    style = getComputedStyle(html);
	    return this.remBase = parseFloat(style.fontSize);
	  };

	  Helpers.prototype.clamp = function(value, min, max) {
	    if (value < min) {
	      return min;
	    } else if (value > max) {
	      return max;
	    } else {
	      return value;
	    }
	  };

	  Helpers.prototype.setPrefixedStyle = function(el, name, value) {
	    (name === 'transform') && (el.style["" + this.prefix.css + name] = value);
	    return el.style[name] = value;
	  };

	  Helpers.prototype.style = function(el, name, value) {
	    var key, keys, len, results;
	    if (typeof name === 'object') {
	      keys = Object.keys(name);
	      len = keys.length;
	      results = [];
	      while (len--) {
	        key = keys[len];
	        value = name[key];
	        results.push(this.setPrefixedStyle(el, key, value));
	      }
	      return results;
	    } else {
	      return this.setPrefixedStyle(el, name, value);
	    }
	  };

	  Helpers.prototype.prepareForLog = function(args) {
	    args = Array.prototype.slice.apply(args);
	    args.unshift('::');
	    args.unshift(this.logBadgeCss);
	    args.unshift('%cmo·js%c');
	    return args;
	  };

	  Helpers.prototype.log = function() {
	    if (mojs.isDebug === false) {
	      return;
	    }
	    return console.log.apply(console, this.prepareForLog(arguments));
	  };

	  Helpers.prototype.warn = function() {
	    if (mojs.isDebug === false) {
	      return;
	    }
	    return console.warn.apply(console, this.prepareForLog(arguments));
	  };

	  Helpers.prototype.error = function() {
	    if (mojs.isDebug === false) {
	      return;
	    }
	    return console.error.apply(console, this.prepareForLog(arguments));
	  };

	  Helpers.prototype.parseUnit = function(value) {
	    var amount, isStrict, ref, regex, returnVal, unit;
	    if (typeof value === 'number') {
	      return returnVal = {
	        unit: 'px',
	        isStrict: false,
	        value: value,
	        string: value === 0 ? "" + value : value + "px"
	      };
	    } else if (typeof value === 'string') {
	      regex = /px|%|rem|em|ex|cm|ch|mm|in|pt|pc|vh|vw|vmin|deg/gim;
	      unit = (ref = value.match(regex)) != null ? ref[0] : void 0;
	      isStrict = true;
	      if (!unit) {
	        unit = 'px';
	        isStrict = false;
	      }
	      amount = parseFloat(value);
	      return returnVal = {
	        unit: unit,
	        isStrict: isStrict,
	        value: amount,
	        string: amount === 0 ? "" + amount : "" + amount + unit
	      };
	    }
	    return value;
	  };

	  Helpers.prototype.bind = function(func, context) {
	    var bindArgs, wrapper;
	    wrapper = function() {
	      var args, unshiftArgs;
	      args = Array.prototype.slice.call(arguments);
	      unshiftArgs = bindArgs.concat(args);
	      return func.apply(context, unshiftArgs);
	    };
	    bindArgs = Array.prototype.slice.call(arguments, 2);
	    return wrapper;
	  };

	  Helpers.prototype.getRadialPoint = function(o) {
	    var point, radAngle, radiusX, radiusY;
	    if (o == null) {
	      o = {};
	    }
	    radAngle = (o.angle - 90) * 0.017453292519943295;
	    radiusX = o.radiusX != null ? o.radiusX : o.radius;
	    radiusY = o.radiusY != null ? o.radiusY : o.radius;
	    return point = {
	      x: o.center.x + (Math.cos(radAngle) * radiusX),
	      y: o.center.y + (Math.sin(radAngle) * radiusY)
	    };
	  };

	  Helpers.prototype.getPrefix = function() {
	    var dom, pre, styles, v;
	    styles = window.getComputedStyle(document.documentElement, "");
	    v = Array.prototype.slice.call(styles).join("").match(/-(moz|webkit|ms)-/);
	    pre = (v || (styles.OLink === "" && ["", "o"]))[1];
	    dom = "WebKit|Moz|MS|O".match(new RegExp("(" + pre + ")", "i"))[1];
	    return {
	      dom: dom,
	      lowercase: pre,
	      css: "-" + pre + "-",
	      js: pre[0].toUpperCase() + pre.substr(1)
	    };
	  };

	  Helpers.prototype.strToArr = function(string) {
	    var arr;
	    arr = [];
	    if (typeof string === 'number' && !isNaN(string)) {
	      arr.push(this.parseUnit(string));
	      return arr;
	    }
	    string.trim().split(/\s+/gim).forEach((function(_this) {
	      return function(str) {
	        return arr.push(_this.parseUnit(_this.parseIfRand(str)));
	      };
	    })(this));
	    return arr;
	  };

	  Helpers.prototype.calcArrDelta = function(arr1, arr2) {
	    var delta, i, j, len1, num;
	    delta = [];
	    for (i = j = 0, len1 = arr1.length; j < len1; i = ++j) {
	      num = arr1[i];
	      delta[i] = this.parseUnit("" + (arr2[i].value - arr1[i].value) + arr2[i].unit);
	    }
	    return delta;
	  };

	  Helpers.prototype.isArray = function(variable) {
	    return variable instanceof Array;
	  };

	  Helpers.prototype.normDashArrays = function(arr1, arr2) {
	    var arr1Len, arr2Len, currItem, i, j, k, lenDiff, ref, ref1, startI;
	    arr1Len = arr1.length;
	    arr2Len = arr2.length;
	    if (arr1Len > arr2Len) {
	      lenDiff = arr1Len - arr2Len;
	      startI = arr2.length;
	      for (i = j = 0, ref = lenDiff; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
	        currItem = i + startI;
	        arr2.push(this.parseUnit("0" + arr1[currItem].unit));
	      }
	    } else if (arr2Len > arr1Len) {
	      lenDiff = arr2Len - arr1Len;
	      startI = arr1.length;
	      for (i = k = 0, ref1 = lenDiff; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
	        currItem = i + startI;
	        arr1.push(this.parseUnit("0" + arr2[currItem].unit));
	      }
	    }
	    return [arr1, arr2];
	  };

	  Helpers.prototype.makeColorObj = function(color) {
	    var alpha, b, colorObj, g, isRgb, r, regexString1, regexString2, result, rgbColor;
	    if (color[0] === '#') {
	      result = /^#?([a-f\d]{1,2})([a-f\d]{1,2})([a-f\d]{1,2})$/i.exec(color);
	      colorObj = {};
	      if (result) {
	        r = result[1].length === 2 ? result[1] : result[1] + result[1];
	        g = result[2].length === 2 ? result[2] : result[2] + result[2];
	        b = result[3].length === 2 ? result[3] : result[3] + result[3];
	        colorObj = {
	          r: parseInt(r, 16),
	          g: parseInt(g, 16),
	          b: parseInt(b, 16),
	          a: 1
	        };
	      }
	    }
	    if (color[0] !== '#') {
	      isRgb = color[0] === 'r' && color[1] === 'g' && color[2] === 'b';
	      if (isRgb) {
	        rgbColor = color;
	      }
	      if (!isRgb) {
	        rgbColor = !this.shortColors[color] ? (this.div.style.color = color, this.computedStyle(this.div).color) : this.shortColors[color];
	      }
	      regexString1 = '^rgba?\\((\\d{1,3}),\\s?(\\d{1,3}),';
	      regexString2 = '\\s?(\\d{1,3}),?\\s?(\\d{1}|0?\\.\\d{1,})?\\)$';
	      result = new RegExp(regexString1 + regexString2, 'gi').exec(rgbColor);
	      colorObj = {};
	      alpha = parseFloat(result[4] || 1);
	      if (result) {
	        colorObj = {
	          r: parseInt(result[1], 10),
	          g: parseInt(result[2], 10),
	          b: parseInt(result[3], 10),
	          a: (alpha != null) && !isNaN(alpha) ? alpha : 1
	        };
	      }
	    }
	    return colorObj;
	  };

	  Helpers.prototype.computedStyle = function(el) {
	    return getComputedStyle(el);
	  };

	  Helpers.prototype.capitalize = function(str) {
	    if (typeof str !== 'string') {
	      throw Error('String expected - nothing to capitalize');
	    }
	    return str.charAt(0).toUpperCase() + str.substring(1);
	  };

	  Helpers.prototype.parseRand = function(string) {
	    var rand, randArr, units;
	    randArr = string.split(/rand\(|\,|\)/);
	    units = this.parseUnit(randArr[2]);
	    rand = this.rand(parseFloat(randArr[1]), parseFloat(randArr[2]));
	    if (units.unit && randArr[2].match(units.unit)) {
	      return rand + units.unit;
	    } else {
	      return rand;
	    }
	  };

	  Helpers.prototype.parseStagger = function(string, index) {
	    var base, number, splittedValue, unit, unitValue, value;
	    value = string.split(/stagger\(|\)$/)[1].toLowerCase();
	    splittedValue = value.split(/(rand\(.*?\)|[^\(,\s]+)(?=\s*,|\s*$)/gim);
	    value = splittedValue.length > 3 ? (base = this.parseUnit(this.parseIfRand(splittedValue[1])), splittedValue[3]) : (base = this.parseUnit(0), splittedValue[1]);
	    value = this.parseIfRand(value);
	    unitValue = this.parseUnit(value);
	    number = index * unitValue.value + base.value;
	    unit = base.isStrict ? base.unit : unitValue.isStrict ? unitValue.unit : '';
	    if (unit) {
	      return "" + number + unit;
	    } else {
	      return number;
	    }
	  };

	  Helpers.prototype.parseIfStagger = function(value, i) {
	    if (!(typeof value === 'string' && value.match(/stagger/g))) {
	      return value;
	    } else {
	      return this.parseStagger(value, i);
	    }
	  };

	  Helpers.prototype.parseIfRand = function(str) {
	    if (typeof str === 'string' && str.match(/rand\(/)) {
	      return this.parseRand(str);
	    } else {
	      return str;
	    }
	  };

	  Helpers.prototype.parseDelta = function(key, value, index) {
	    var curve, delta, easing, end, endArr, endColorObj, i, j, len1, start, startArr, startColorObj;
	    value = this.cloneObj(value);
	    easing = value.easing;
	    if (easing != null) {
	      easing = mojs.easing.parseEasing(easing);
	    }
	    delete value.easing;
	    curve = value.curve;
	    if (curve != null) {
	      curve = mojs.easing.parseEasing(curve);
	    }
	    delete value.curve;
	    start = Object.keys(value)[0];
	    end = value[start];
	    delta = {
	      start: start
	    };
	    if (isNaN(parseFloat(start)) && !start.match(/rand\(/) && !start.match(/stagger\(/)) {
	      if (key === 'strokeLinecap') {
	        this.warn("Sorry, stroke-linecap property is not animatable yet, using the start(" + start + ") value instead", value);
	        return delta;
	      }
	      startColorObj = this.makeColorObj(start);
	      endColorObj = this.makeColorObj(end);
	      delta = {
	        type: 'color',
	        name: key,
	        start: startColorObj,
	        end: endColorObj,
	        easing: easing,
	        curve: curve,
	        delta: {
	          r: endColorObj.r - startColorObj.r,
	          g: endColorObj.g - startColorObj.g,
	          b: endColorObj.b - startColorObj.b,
	          a: endColorObj.a - startColorObj.a
	        }
	      };
	    } else if (key === 'strokeDasharray' || key === 'strokeDashoffset' || key === 'origin') {
	      startArr = this.strToArr(start);
	      endArr = this.strToArr(end);
	      this.normDashArrays(startArr, endArr);
	      for (i = j = 0, len1 = startArr.length; j < len1; i = ++j) {
	        start = startArr[i];
	        end = endArr[i];
	        this.mergeUnits(start, end, key);
	      }
	      delta = {
	        type: 'array',
	        name: key,
	        start: startArr,
	        end: endArr,
	        delta: this.calcArrDelta(startArr, endArr),
	        easing: easing,
	        curve: curve
	      };
	    } else {
	      if (!this.callbacksMap[key] && !this.tweenOptionMap[key]) {
	        if (this.unitOptionMap[key]) {
	          end = this.parseUnit(this.parseStringOption(end, index));
	          start = this.parseUnit(this.parseStringOption(start, index));
	          this.mergeUnits(start, end, key);
	          delta = {
	            type: 'unit',
	            name: key,
	            start: start,
	            end: end,
	            delta: end.value - start.value,
	            easing: easing,
	            curve: curve
	          };
	        } else {
	          end = parseFloat(this.parseStringOption(end, index));
	          start = parseFloat(this.parseStringOption(start, index));
	          delta = {
	            type: 'number',
	            name: key,
	            start: start,
	            end: end,
	            delta: end - start,
	            easing: easing,
	            curve: curve
	          };
	        }
	      }
	    }
	    return delta;
	  };

	  Helpers.prototype.mergeUnits = function(start, end, key) {
	    if (!end.isStrict && start.isStrict) {
	      end.unit = start.unit;
	      return end.string = "" + end.value + end.unit;
	    } else if (end.isStrict && !start.isStrict) {
	      start.unit = end.unit;
	      return start.string = "" + start.value + start.unit;
	    } else if (end.isStrict && start.isStrict) {
	      if (end.unit !== start.unit) {
	        start.unit = end.unit;
	        start.string = "" + start.value + start.unit;
	        return this.warn("Two different units were specified on \"" + key + "\" delta property, mo · js will fallback to end \"" + end.unit + "\" unit ");
	      }
	    }
	  };

	  Helpers.prototype.rand = function(min, max) {
	    return (Math.random() * (max - min)) + min;
	  };

	  Helpers.prototype.isDOM = function(o) {
	    var isNode;
	    if (o == null) {
	      return false;
	    }
	    isNode = typeof o.nodeType === 'number' && typeof o.nodeName === 'string';
	    return typeof o === 'object' && isNode;
	  };

	  Helpers.prototype.getChildElements = function(element) {
	    var childNodes, children, i;
	    childNodes = element.childNodes;
	    children = [];
	    i = childNodes.length;
	    while (i--) {
	      if (childNodes[i].nodeType === 1) {
	        children.unshift(childNodes[i]);
	      }
	    }
	    return children;
	  };

	  Helpers.prototype.delta = function(start, end) {
	    var isType1, isType2, obj, type1, type2;
	    type1 = typeof start;
	    type2 = typeof end;
	    isType1 = type1 === 'string' || type1 === 'number' && !isNaN(start);
	    isType2 = type2 === 'string' || type2 === 'number' && !isNaN(end);
	    if (!isType1 || !isType2) {
	      this.error("delta method expects Strings or Numbers at input but got - " + start + ", " + end);
	      return;
	    }
	    obj = {};
	    obj[start] = end;
	    return obj;
	  };

	  Helpers.prototype.getUniqID = function() {
	    return ++this.uniqIDs;
	  };

	  Helpers.prototype.parsePath = function(path) {
	    var domPath;
	    if (typeof path === 'string') {
	      if (path.charAt(0).toLowerCase() === 'm') {
	        domPath = document.createElementNS(this.NS, 'path');
	        domPath.setAttributeNS(null, 'd', path);
	        return domPath;
	      } else {
	        return document.querySelector(path);
	      }
	    }
	    if (path.style) {
	      return path;
	    }
	  };

	  Helpers.prototype.closeEnough = function(num1, num2, eps) {
	    return Math.abs(num1 - num2) < eps;
	  };

	  Helpers.prototype.checkIf3d = function() {
	    var div, prefixed, style, tr;
	    div = document.createElement('div');
	    this.style(div, 'transform', 'translateZ(0)');
	    style = div.style;
	    prefixed = this.prefix.css + "transform";
	    tr = style[prefixed] != null ? style[prefixed] : style.transform;
	    return tr !== '';
	  };


	  /*
	    Method to check if variable holds pointer to an object.
	    @param {Any} Variable to test
	    @returns {Boolean} If variable is object.
	   */

	  Helpers.prototype.isObject = function(variable) {
	    return variable !== null && typeof variable === 'object';
	  };


	  /*
	    Method to get first value of the object.
	    Used to get end value on ∆s.
	    @param {Object} Object to get the value of.
	    @returns {Any} The value of the first object' property.
	   */

	  Helpers.prototype.getDeltaEnd = function(obj) {
	    var key;
	    key = Object.keys(obj)[0];
	    return obj[key];
	  };


	  /*
	    Method to get first key of the object.
	    Used to get start value on ∆s.
	    @param {Object} Object to get the value of.
	    @returns {String} The key of the first object' property.
	   */

	  Helpers.prototype.getDeltaStart = function(obj) {
	    var key;
	    key = Object.keys(obj)[0];
	    return key;
	  };


	  /*
	    Method to check if propery exists in callbacksMap or tweenOptionMap.
	    @param {String} Property name to check for
	    @returns {Boolean} If property is tween property.
	   */

	  Helpers.prototype.isTweenProp = function(keyName) {
	    return this.tweenOptionMap[keyName] || this.callbacksMap[keyName];
	  };


	  /*
	    Method to parse string property value
	    which can include both `rand` and `stagger `
	    value in various positions.
	    @param {String} Property name to check for.
	    @param {Number} Optional index for stagger.
	    @returns {Number} Parsed option value.
	   */

	  Helpers.prototype.parseStringOption = function(value, index) {
	    if (index == null) {
	      index = 0;
	    }
	    if (typeof value === 'string') {
	      value = this.parseIfStagger(value, index);
	      value = this.parseIfRand(value);
	    }
	    return value;
	  };


	  /*
	    Method to get the last item of array.
	    @private
	    @param {Array} Array to get the last item in.
	    @returns {Any} The last item of array.
	   */

	  Helpers.prototype.getLastItem = function(arr) {
	    return arr[arr.length - 1];
	  };


	  /*
	    Method parse HTMLElement.
	    @private
	    @param {String, Object} Selector string or HTMLElement.
	    @returns {Object} HTMLElement.
	   */

	  Helpers.prototype.parseEl = function(el) {
	    if (h.isDOM(el)) {
	      return el;
	    } else if (typeof el === 'string') {
	      el = document.querySelector(el);
	    }
	    if (el === null) {
	      h.error("Can't parse HTML element: ", el);
	    }
	    return el;
	  };


	  /*
	    Method force compositor layer on HTMLElement.
	    @private
	    @param {Object} HTMLElement.
	    @returns {Object} HTMLElement.
	   */

	  Helpers.prototype.force3d = function(el) {
	    this.setPrefixedStyle(el, 'backface-visibility', 'hidden');
	    return el;
	  };


	  /*
	    Method to check if value is delta.
	    @private
	    @param {Any} Property to check.
	    @returns {Boolean} If value is delta.
	   */

	  Helpers.prototype.isDelta = function(optionsValue) {
	    var isObject;
	    isObject = this.isObject(optionsValue);
	    isObject = isObject && !optionsValue.unit;
	    return !(!isObject || this.isArray(optionsValue) || this.isDOM(optionsValue));
	  };

	  return Helpers;

	})();

	h = new Helpers;

	module.exports = h;


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

	var Bit, BitsMap, Circle, Cross, Curve, Custom, Equal, Line, Polygon, Rect, Zigzag, h;

	Bit = __webpack_require__(73)["default"] || __webpack_require__(73);

	Custom = __webpack_require__(85)["default"] || __webpack_require__(85);

	Circle = __webpack_require__(86);

	Line = __webpack_require__(87);

	Zigzag = __webpack_require__(88);

	Rect = __webpack_require__(89);

	Polygon = __webpack_require__(90);

	Cross = __webpack_require__(91);

	Curve = __webpack_require__(92)["default"] || __webpack_require__(92);

	Equal = __webpack_require__(93);

	h = __webpack_require__(71);

	BitsMap = (function() {
	  function BitsMap() {
	    this.addShape = h.bind(this.addShape, this);
	  }

	  BitsMap.prototype.bit = Bit;

	  BitsMap.prototype.custom = Custom;

	  BitsMap.prototype.circle = Circle;

	  BitsMap.prototype.line = Line;

	  BitsMap.prototype.zigzag = Zigzag;

	  BitsMap.prototype.rect = Rect;

	  BitsMap.prototype.polygon = Polygon;

	  BitsMap.prototype.cross = Cross;

	  BitsMap.prototype.equal = Equal;

	  BitsMap.prototype.curve = Curve;

	  BitsMap.prototype.getShape = function(name) {
	    return this[name] || h.error("no \"" + name + "\" shape available yet, please choose from this list:", ['circle', 'line', 'zigzag', 'rect', 'polygon', 'cross', 'equal', 'curve']);
	  };


	  /*
	    Method to add shape to the map.
	    @public
	    @param {String} Name of the shape module.
	    @param {Object} Shape module class.
	   */

	  BitsMap.prototype.addShape = function(name, Module) {
	    return this[name] = Module;
	  };

	  return BitsMap;

	})();

	module.exports = new BitsMap;


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _typeof2 = __webpack_require__(3);

	var _typeof3 = _interopRequireDefault(_typeof2);

	var _classCallCheck2 = __webpack_require__(74);

	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

	var _possibleConstructorReturn2 = __webpack_require__(75);

	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

	var _inherits2 = __webpack_require__(76);

	var _inherits3 = _interopRequireDefault(_inherits2);

	var _module = __webpack_require__(84);

	var _module2 = _interopRequireDefault(_module);

	var _h = __webpack_require__(71);

	var _h2 = _interopRequireDefault(_h);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var Bit = function (_Module) {
	  (0, _inherits3.default)(Bit, _Module);

	  function Bit() {
	    (0, _classCallCheck3.default)(this, Bit);
	    return (0, _possibleConstructorReturn3.default)(this, _Module.apply(this, arguments));
	  }

	  /*
	    Method to declare module's defaults.
	    @private
	  */
	  Bit.prototype._declareDefaults = function _declareDefaults() {
	    this._defaults = {
	      'ns': 'http://www.w3.org/2000/svg',
	      'tag': 'ellipse',
	      'parent': document.body,
	      'ratio': 1,
	      'radius': 50,
	      'radiusX': null,
	      'radiusY': null,
	      'stroke': 'hotpink',
	      'stroke-dasharray': '',
	      'stroke-dashoffset': '',
	      'stroke-linecap': '',
	      'stroke-width': 2,
	      'stroke-opacity': 1,
	      'fill': 'transparent',
	      'fill-opacity': 1,
	      'width': 0,
	      'height': 0
	    };
	    this._drawMap = ['stroke', 'stroke-width', 'stroke-opacity', 'stroke-dasharray', 'fill', 'stroke-dashoffset', 'stroke-linecap', 'fill-opacity', 'transform'];
	  };

	  Bit.prototype._vars = function _vars() {
	    this._state = {};
	    this._drawMapLength = this._drawMap.length;
	  };
	  /*
	    Method for initial render of the shape.
	    @private
	  */


	  Bit.prototype._render = function _render() {
	    if (this._isRendered) {
	      return;
	    }
	    // set `_isRendered` hatch
	    this._isRendered = true;
	    // create `SVG` canvas to draw in
	    this._createSVGCanvas();
	    // set canvas size
	    this._setCanvasSize();
	    // draw the initial state
	    // this._draw();
	    // append the canvas to the parent from props
	    this._props.parent.appendChild(this._canvas);
	  };
	  /*
	    Method to create `SVG` canvas to draw in.
	    @private
	  */


	  Bit.prototype._createSVGCanvas = function _createSVGCanvas() {
	    var p = this._props;
	    // create canvas - `svg` element to draw in
	    this._canvas = document.createElementNS(p.ns, 'svg');
	    // create the element shape element and add it to the canvas
	    this.el = document.createElementNS(p.ns, p.tag);
	    this._canvas.appendChild(this.el);
	  };
	  /*
	    Method to set size of the _canvas.
	    @private
	  */


	  Bit.prototype._setCanvasSize = function _setCanvasSize() {
	    var p = this._props,
	        style = this._canvas.style;

	    style.display = 'block';
	    style.width = '100%';
	    style.height = '100%';
	    style.left = '0px';
	    style.top = '0px';
	  };
	  /*
	    Method to draw the shape.
	    Called on every frame.
	    @private
	  */


	  Bit.prototype._draw = function _draw() {
	    this._props.length = this._getLength();

	    var state = this._state,
	        props = this._props;

	    var len = this._drawMapLength;
	    while (len--) {
	      var name = this._drawMap[len];
	      switch (name) {
	        case 'stroke-dasharray':
	        case 'stroke-dashoffset':
	          this.castStrokeDash(name);
	      }
	      this._setAttrIfChanged(name, this._props[name]);
	    }
	    this._state.radius = this._props.radius;
	  };

	  Bit.prototype.castStrokeDash = function castStrokeDash(name) {
	    // # if array of values
	    var p = this._props;
	    if (_h2.default.isArray(p[name])) {
	      var stroke = '';
	      for (var i = 0; i < p[name].length; i++) {
	        var dash = p[name][i],
	            cast = dash.unit === '%' ? this.castPercent(dash.value) : dash.value;
	        stroke += cast + ' ';
	      }
	      p[name] = stroke === '0 ' ? stroke = '' : stroke;
	      return p[name] = stroke;
	    }
	    // # if single value
	    if ((0, _typeof3.default)(p[name]) === 'object') {
	      stroke = p[name].unit === '%' ? this.castPercent(p[name].value) : p[name].value;
	      p[name] = stroke === 0 ? stroke = '' : stroke;
	    }
	  };

	  Bit.prototype.castPercent = function castPercent(percent) {
	    return percent * (this._props.length / 100);
	  };

	  /*
	    Method to set props to attributes and cache the values.
	    @private
	  */


	  Bit.prototype._setAttrIfChanged = function _setAttrIfChanged(name, value) {
	    if (this._state[name] !== value) {
	      // this.el.style[name] = value;
	      this.el.setAttribute(name, value);
	      this._state[name] = value;
	    }
	  };
	  /*
	    Method to length of the shape.
	    @private
	    @returns {Number} Length of the shape.
	  */


	  Bit.prototype._getLength = function _getLength() {
	    var p = this._props,
	        len = 0,
	        isGetLength = !!(this.el && this.el.getTotalLength);

	    if (isGetLength && this.el.getAttribute('d')) {
	      len = this.el.getTotalLength();
	    } else {
	      len = 2 * (p.radiusX != null ? p.radiusX : p.radius);
	    }
	    return len;
	  };
	  /*
	    Method to calculate total sum between points.
	    @private
	    @param {Array} Array of points.
	    @returns {Number} Distance bewtween all points.
	  */


	  Bit.prototype._getPointsPerimiter = function _getPointsPerimiter(points) {
	    var sum = 0;

	    for (var i = 1; i < points.length; i++) {
	      sum += this._pointsDelta(points[i - 1], points[i]);
	    }

	    sum += this._pointsDelta(points[0], _h2.default.getLastItem(points));
	    return sum;
	  };
	  /*
	    Method to get delta from two points.
	    @private
	    @param {Object} Point 1.
	    @param {Object} Point 2.
	    @returns {Number} Distance between the pooints.
	  */


	  Bit.prototype._pointsDelta = function _pointsDelta(point1, point2) {
	    var dx = Math.abs(point1.x - point2.x),
	        dy = Math.abs(point1.y - point2.y);
	    return Math.sqrt(dx * dx + dy * dy);
	  };
	  /*
	    Method to set module's size.
	    @private
	    @param {Number} Module width.
	    @param {Number} Module height.
	  */


	  Bit.prototype._setSize = function _setSize(width, height) {
	    var p = this._props;
	    p.width = width;
	    p.height = height;
	    this._draw();
	  };

	  return Bit;
	}(_module2.default);

	exports.default = Bit;

/***/ }),
/* 74 */
/***/ (function(module, exports) {

	"use strict";

	exports.__esModule = true;

	exports.default = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	};

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;

	var _typeof2 = __webpack_require__(3);

	var _typeof3 = _interopRequireDefault(_typeof2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = function (self, call) {
	  if (!self) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }

	  return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
	};

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;

	var _setPrototypeOf = __webpack_require__(77);

	var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

	var _create = __webpack_require__(81);

	var _create2 = _interopRequireDefault(_create);

	var _typeof2 = __webpack_require__(3);

	var _typeof3 = _interopRequireDefault(_typeof2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = function (subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));
	  }

	  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      enumerable: false,
	      writable: true,
	      configurable: true
	    }
	  });
	  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
	};

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(78), __esModule: true };

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(79);
	module.exports = __webpack_require__(14).Object.setPrototypeOf;

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.3.19 Object.setPrototypeOf(O, proto)
	var $export = __webpack_require__(12);
	$export($export.S, 'Object', {setPrototypeOf: __webpack_require__(80).set});

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */
	var isObject = __webpack_require__(20)
	  , anObject = __webpack_require__(19);
	var check = function(O, proto){
	  anObject(O);
	  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
	};
	module.exports = {
	  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
	    function(test, buggy, set){
	      try {
	        set = __webpack_require__(15)(Function.call, __webpack_require__(67).f(Object.prototype, '__proto__').set, 2);
	        set(test, []);
	        buggy = !(test instanceof Array);
	      } catch(e){ buggy = true; }
	      return function setPrototypeOf(O, proto){
	        check(O, proto);
	        if(buggy)O.__proto__ = proto;
	        else set(O, proto);
	        return O;
	      };
	    }({}, false) : undefined),
	  check: check
	};

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(82), __esModule: true };

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(83);
	var $Object = __webpack_require__(14).Object;
	module.exports = function create(P, D){
	  return $Object.create(P, D);
	};

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(12)
	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	$export($export.S, 'Object', {create: __webpack_require__(31)});

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _typeof2 = __webpack_require__(3);

	var _typeof3 = _interopRequireDefault(_typeof2);

	var _classCallCheck2 = __webpack_require__(74);

	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

	var _h = __webpack_require__(71);

	var _h2 = _interopRequireDefault(_h);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/*
	  Base class for module. Extends and parses defaults.
	*/
	var Module = function () {
	  function Module() {
	    var o = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    (0, _classCallCheck3.default)(this, Module);

	    // this._isIt = o.isIt;
	    // delete o.isIt;
	    this._o = o;
	    this._index = this._o.index || 0;
	    // map of props that should be
	    // parsed to arrays of values
	    this._arrayPropertyMap = {
	      strokeDashoffset: 1,
	      strokeDasharray: 1,
	      origin: 1
	    };

	    this._skipPropsDelta = {
	      timeline: 1,
	      prevChainModule: 1,
	      callbacksContext: 1
	    };

	    this._declareDefaults();
	    this._extendDefaults();

	    this._vars();
	    this._render();
	  }
	  /*
	    Method to declare defaults.
	    @private
	  */


	  Module.prototype._declareDefaults = function _declareDefaults() {
	    this._defaults = {};
	  };
	  /*
	    Method to declare module's variables.
	    @private
	  */


	  Module.prototype._vars = function _vars() {
	    this._progress = 0;
	    this._strokeDasharrayBuffer = [];
	  };
	  /*
	    Method to render on initialization.
	    @private
	  */


	  Module.prototype._render = function _render() {};
	  /*
	    Method to set property on the module.
	    @private
	    @param {String, Object} Name of the property to set
	                            or object with properties to set.
	    @param {Any} Value for the property to set. Could be
	                  undefined if the first param is object.
	  */


	  Module.prototype._setProp = function _setProp(attr, value) {
	    if ((typeof attr === 'undefined' ? 'undefined' : (0, _typeof3.default)(attr)) === 'object') {
	      for (var key in attr) {
	        this._assignProp(key, attr[key]);
	      }
	    } else {
	      this._assignProp(attr, value);
	    }
	  };
	  /*
	    Method to assign single property's value.
	    @private
	    @param {String} Property name.
	    @param {Any}    Property value.
	  */


	  Module.prototype._assignProp = function _assignProp(key, value) {
	    this._props[key] = value;
	  };
	  /*
	    Method to show element.
	    @private
	  */


	  Module.prototype._show = function _show() {
	    var p = this._props;
	    if (!this.el) {
	      return;
	    }

	    if (p.isSoftHide) {
	      // this.el.style.opacity = p.opacity;
	      this._showByTransform();
	    } else {
	      this.el.style.display = 'block';
	    }

	    this._isShown = true;
	  };
	  /*
	    Method to hide element.
	    @private
	  */


	  Module.prototype._hide = function _hide() {
	    if (!this.el) {
	      return;
	    }

	    if (this._props.isSoftHide) {
	      // this.el.style.opacity = 0;
	      _h2.default.setPrefixedStyle(this.el, 'transform', 'scale(0)');
	    } else {
	      this.el.style.display = 'none';
	    }

	    this._isShown = false;
	  };
	  /*
	    Method to show element by applying transform back to normal.
	    @private
	  */


	  Module.prototype._showByTransform = function _showByTransform() {};
	  /*
	    Method to parse option string.
	    Searches for stagger and rand values and parses them.
	    Leaves the value unattended otherwise.
	    @param {Any} Option value to parse.
	    @returns {Number} Parsed options value.
	  */


	  Module.prototype._parseOptionString = function _parseOptionString(value) {
	    if (typeof value === 'string') {
	      if (value.match(/stagger/)) {
	        value = _h2.default.parseStagger(value, this._index);
	      }
	    }
	    if (typeof value === 'string') {
	      if (value.match(/rand/)) {
	        value = _h2.default.parseRand(value);
	      }
	    }
	    return value;
	  };
	  /*
	    Method to parse postion option.
	    @param {String} Property name.
	    @param {Any} Property Value.
	    @returns {String} Parsed options value.
	  */


	  Module.prototype._parsePositionOption = function _parsePositionOption(key, value) {
	    if (_h2.default.unitOptionMap[key]) {
	      value = _h2.default.parseUnit(value).string;
	    }
	    return value;
	  };
	  /*
	    Method to parse strokeDash.. option.
	    @param {String} Property name.
	    @param {Any}    Property value.
	    @returns {String} Parsed options value.
	  */


	  Module.prototype._parseStrokeDashOption = function _parseStrokeDashOption(key, value) {
	    var result = value;
	    // parse numeric/percent values for strokeDash.. properties
	    if (this._arrayPropertyMap[key]) {
	      var result = [];
	      switch (typeof value === 'undefined' ? 'undefined' : (0, _typeof3.default)(value)) {
	        case 'number':
	          result.push(_h2.default.parseUnit(value));
	          break;
	        case 'string':
	          var array = value.split(' ');
	          for (var i = 0; i < array.length; i++) {
	            result.push(_h2.default.parseUnit(array[i]));
	          }
	          break;
	      }
	    }
	    return result;
	  };
	  /*
	    Method to check if the property is delta property.
	    @private
	    @param {Any} Parameter value to check.
	    @returns {Boolean}
	  */


	  Module.prototype._isDelta = function _isDelta(optionsValue) {
	    var isObject = _h2.default.isObject(optionsValue);
	    isObject = isObject && !optionsValue.unit;
	    return !(!isObject || _h2.default.isArray(optionsValue) || _h2.default.isDOM(optionsValue));
	  };
	  /*
	    Method to get delta from property and set
	    the property's start value to the props object.
	    @private
	    @param {String} Key name to get delta for.
	    @param {Object} Option value to get the delta for.
	  */


	  Module.prototype._getDelta = function _getDelta(key, optionsValue) {
	    var delta;
	    if ((key === 'left' || key === 'top') && !this._o.ctx) {
	      _h2.default.warn('Consider to animate x/y properties instead of left/top,\n        as it would be much more performant', optionsValue);
	    }
	    // skip delta calculation for a property if it is listed
	    // in skipPropsDelta object
	    if (this._skipPropsDelta && this._skipPropsDelta[key]) {
	      return;
	    }
	    // get delta
	    delta = _h2.default.parseDelta(key, optionsValue, this._index);
	    // if successfully parsed - save it
	    if (delta.type != null) {
	      this._deltas[key] = delta;
	    }

	    var deltaEnd = (0, _typeof3.default)(delta.end) === 'object' ? delta.end.value === 0 ? 0 : delta.end.string : delta.end;
	    // set props to end value of the delta
	    // 0 should be 0 regardless units
	    this._props[key] = deltaEnd;
	  };
	  /*
	    Method to copy `_o` options to `_props` object
	    with fallback to `_defaults`.
	    @private
	  */


	  Module.prototype._extendDefaults = function _extendDefaults() {
	    this._props = {};
	    this._deltas = {};
	    for (var key in this._defaults) {
	      // skip property if it is listed in _skipProps
	      // if (this._skipProps && this._skipProps[key]) { continue; }
	      // copy the properties to the _o object
	      var value = this._o[key] != null ? this._o[key] : this._defaults[key];
	      // parse option
	      this._parseOption(key, value);
	    }
	  };
	  /*
	    Method to tune new oprions to _o and _props object.
	    @private
	    @param {Object} Options object to tune to.
	  */


	  Module.prototype._tuneNewOptions = function _tuneNewOptions(o) {
	    // hide the module before tuning it's options
	    // cuz the user could see the change
	    this._hide();
	    for (var key in o) {
	      // skip property if it is listed in _skipProps
	      // if (this._skipProps && this._skipProps[key]) { continue; }
	      // copy the properties to the _o object
	      // delete the key from deltas
	      o && delete this._deltas[key];
	      // rewrite _o record
	      this._o[key] = o[key];
	      // save the options to _props
	      this._parseOption(key, o[key]);
	    }
	  };
	  /*
	    Method to parse option value.
	    @private
	    @param {String} Option name.
	    @param {Any} Option value.
	  */


	  Module.prototype._parseOption = function _parseOption(name, value) {
	    // if delta property
	    if (this._isDelta(value) && !this._skipPropsDelta[name]) {
	      this._getDelta(name, value);
	      var deltaEnd = _h2.default.getDeltaEnd(value);
	      return this._assignProp(name, this._parseProperty(name, deltaEnd));
	    }

	    this._assignProp(name, this._parseProperty(name, value));
	  };
	  /*
	    Method to parse postion and string props.
	    @private
	    @param {String} Property name.
	    @param {Any}    Property value.
	    @returns {Any}  Parsed property value.
	  */


	  Module.prototype._parsePreArrayProperty = function _parsePreArrayProperty(name, value) {
	    // parse stagger and rand values
	    value = this._parseOptionString(value);
	    // parse units for position properties
	    return this._parsePositionOption(name, value);
	  };
	  /*
	    Method to parse property value.
	    @private
	    @param {String} Property name.
	    @param {Any}    Property value.
	    @returns {Any}  Parsed property value.
	  */


	  Module.prototype._parseProperty = function _parseProperty(name, value) {
	    // parse `HTML` element in `parent` option
	    if (name === 'parent') {
	      return _h2.default.parseEl(value);
	    }
	    // parse `stagger`, `rand` and `position`
	    value = this._parsePreArrayProperty(name, value);
	    // parse numeric/percent values for strokeDash.. properties
	    return this._parseStrokeDashOption(name, value);
	  };
	  /*
	    Method to parse values inside ∆.
	    @private
	    @param {String} Key name.
	    @param {Object} Delta.
	    @returns {Object} Delta with parsed parameters.
	  */


	  Module.prototype._parseDeltaValues = function _parseDeltaValues(name, delta) {
	    // return h.parseDelta( name, delta, this._index );

	    var d = {};
	    for (var key in delta) {
	      var value = delta[key];

	      // delete delta[key];
	      // add parsed properties
	      var newEnd = this._parsePreArrayProperty(name, value);
	      d[this._parsePreArrayProperty(name, key)] = newEnd;
	    }
	    return d;
	  };
	  /*
	    Method to parse delta and nondelta properties.
	    @private
	    @param {String} Property name.
	    @param {Any}    Property value.
	    @returns {Any}  Parsed property value.
	  */


	  Module.prototype._preparsePropValue = function _preparsePropValue(key, value) {
	    return this._isDelta(value) ? this._parseDeltaValues(key, value) : this._parsePreArrayProperty(key, value);
	  };
	  /*
	    Method to calculate current progress of the deltas.
	    @private
	    @param {Number} Eased progress to calculate - [0..1].
	    @param {Number} Progress to calculate - [0..1].
	  */


	  Module.prototype._calcCurrentProps = function _calcCurrentProps(easedProgress, p) {

	    for (var key in this._deltas) {

	      var value = this._deltas[key];

	      // get eased progress from delta easing if defined and not curve
	      var isCurve = !!value.curve;
	      var ep = value.easing != null && !isCurve ? value.easing(p) : easedProgress;

	      if (value.type === 'array') {
	        var arr;
	        // if prop property is array - reuse it else - create an array
	        if (_h2.default.isArray(this._props[key])) {
	          arr = this._props[key];
	          arr.length = 0;
	        } else {
	          arr = [];
	        }

	        // just optimization to prevent curve
	        // calculations on every array item
	        var proc = isCurve ? value.curve(p) : null;

	        for (var i = 0; i < value.delta.length; i++) {
	          var item = value.delta[i],
	              dash = !isCurve ? value.start[i].value + ep * item.value : proc * (value.start[i].value + p * item.value);
	          arr.push({
	            string: '' + dash + item.unit,
	            value: dash,
	            unit: item.unit
	          });
	        }

	        this._props[key] = arr;
	      } else if (value.type === 'number') {
	        this._props[key] = !isCurve ? value.start + ep * value.delta : value.curve(p) * (value.start + p * value.delta);
	      } else if (value.type === 'unit') {
	        var currentValue = !isCurve ? value.start.value + ep * value.delta : value.curve(p) * (value.start.value + p * value.delta);

	        this._props[key] = '' + currentValue + value.end.unit;
	      } else if (value.type === 'color') {
	        var r, g, b, a;
	        if (!isCurve) {
	          r = parseInt(value.start.r + ep * value.delta.r, 10);
	          g = parseInt(value.start.g + ep * value.delta.g, 10);
	          b = parseInt(value.start.b + ep * value.delta.b, 10);
	          a = parseFloat(value.start.a + ep * value.delta.a);
	        } else {
	          var cp = value.curve(p);
	          r = parseInt(cp * (value.start.r + p * value.delta.r), 10);
	          g = parseInt(cp * (value.start.g + p * value.delta.g), 10);
	          b = parseInt(cp * (value.start.b + p * value.delta.b), 10);
	          a = parseFloat(cp * (value.start.a + p * value.delta.a));
	        }
	        this._props[key] = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
	      }
	    }
	  };
	  /*
	    Method to calculate current progress and probably draw it in children.
	    @private
	    @param {Number} Eased progress to set - [0..1].
	    @param {Number} Progress to set - [0..1].
	  */


	  Module.prototype._setProgress = function _setProgress(easedProgress, progress) {
	    this._progress = easedProgress;
	    this._calcCurrentProps(easedProgress, progress);
	  };

	  return Module;
	}();

	exports.default = Module;

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _classCallCheck2 = __webpack_require__(74);

	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

	var _possibleConstructorReturn2 = __webpack_require__(75);

	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

	var _inherits2 = __webpack_require__(76);

	var _inherits3 = _interopRequireDefault(_inherits2);

	var _bit = __webpack_require__(73);

	var _bit2 = _interopRequireDefault(_bit);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var Custom = function (_Bit) {
	  (0, _inherits3.default)(Custom, _Bit);

	  function Custom() {
	    (0, _classCallCheck3.default)(this, Custom);
	    return (0, _possibleConstructorReturn3.default)(this, _Bit.apply(this, arguments));
	  }

	  /*
	    Method to declare module's defaults.
	    @private
	    @overrides @ Bit
	  */
	  Custom.prototype._declareDefaults = function _declareDefaults() {
	    _Bit.prototype._declareDefaults.call(this);

	    this._defaults.tag = 'path';
	    this._defaults.parent = null;

	    // remove `stroke-width` from `_drawMap`
	    // because we need to recal strokeWidth size regarding scale
	    for (var i = 0; i < this._drawMap.length; i++) {
	      if (this._drawMap[i] === 'stroke-width') {
	        this._drawMap.splice(i, 1);
	      }
	    }
	  };
	  /*
	    Method to get shape to set on module's path.
	    @public
	    @returns {String} Empty string.
	  */


	  Custom.prototype.getShape = function getShape() {
	    return '';
	  };
	  /*
	    Method to get shape perimeter length.
	    @public
	    @returns {Number} Default length string.
	  */


	  Custom.prototype.getLength = function getLength() {
	    return 100;
	  };
	  /*
	    Method to draw the shape.
	    Called on every frame.
	    @private
	    @overrides @ Bit
	  */


	  Custom.prototype._draw = function _draw() {
	    var p = this._props,
	        state = this._state,
	        radiusXChange = state['radiusX'] !== p.radiusX,
	        radiusYChange = state['radiusY'] !== p.radiusY,
	        radiusChange = state['radius'] !== p.radius;

	    // update transform only if one of radiuses changed
	    if (radiusXChange || radiusYChange || radiusChange) {
	      this.el.setAttribute('transform', this._getScale());
	      state['radiusX'] = p.radiusX;
	      state['radiusY'] = p.radiusY;
	      state['radius'] = p.radius;
	    }

	    this._setAttrIfChanged('stroke-width', p['stroke-width'] / p.maxScale);

	    _Bit.prototype._draw.call(this);
	  };
	  /*
	    Method for initial render of the shape.
	    @private
	    @overrides @ Bit
	  */


	  Custom.prototype._render = function _render() {
	    if (this._isRendered) {
	      return;
	    }
	    this._isRendered = true;

	    this._length = this.getLength();

	    var p = this._props;
	    p.parent.innerHTML = '<svg id="js-mojs-shape-canvas" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink"><g id="js-mojs-shape-el">' + this.getShape() + '</g></svg>';

	    this._canvas = p.parent.querySelector('#js-mojs-shape-canvas');
	    this.el = p.parent.querySelector('#js-mojs-shape-el');
	    this._setCanvasSize();
	  };
	  /*
	    Method to get scales for the shape.
	    @private
	    @mutates @props
	  */


	  Custom.prototype._getScale = function _getScale() {
	    var p = this._props,
	        radiusX = p.radiusX ? p.radiusX : p.radius,
	        radiusY = p.radiusY ? p.radiusY : p.radius;

	    p.scaleX = 2 * radiusX / 100;
	    p.scaleY = 2 * radiusY / 100;
	    p.maxScale = Math.max(p.scaleX, p.scaleY);

	    p.shiftX = p.width / 2 - 50 * p.scaleX;
	    p.shiftY = p.height / 2 - 50 * p.scaleY;

	    var translate = 'translate(' + p.shiftX + ', ' + p.shiftY + ')';
	    return translate + ' scale(' + p.scaleX + ', ' + p.scaleY + ')';
	  };
	  /*
	    Method to length of the shape.
	    @private
	    @returns {Number} Length of the shape.
	  */


	  Custom.prototype._getLength = function _getLength() {
	    return this._length;
	  };

	  return Custom;
	}(_bit2.default);

	exports.default = Custom;

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

	
	/* istanbul ignore next */
	var Bit, Circle,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Bit = __webpack_require__(73)["default"] || __webpack_require__(73);

	Circle = (function(superClass) {
	  extend(Circle, superClass);

	  function Circle() {
	    return Circle.__super__.constructor.apply(this, arguments);
	  }

	  Circle.prototype._declareDefaults = function() {
	    Circle.__super__._declareDefaults.apply(this, arguments);
	    return this._defaults.shape = 'ellipse';
	  };

	  Circle.prototype._draw = function() {
	    var rx, ry;
	    rx = this._props.radiusX != null ? this._props.radiusX : this._props.radius;
	    ry = this._props.radiusY != null ? this._props.radiusY : this._props.radius;
	    this._setAttrIfChanged('rx', rx);
	    this._setAttrIfChanged('ry', ry);
	    this._setAttrIfChanged('cx', this._props.width / 2);
	    this._setAttrIfChanged('cy', this._props.height / 2);
	    return Circle.__super__._draw.apply(this, arguments);
	  };

	  Circle.prototype._getLength = function() {
	    var radiusX, radiusY;
	    radiusX = this._props.radiusX != null ? this._props.radiusX : this._props.radius;
	    radiusY = this._props.radiusY != null ? this._props.radiusY : this._props.radius;
	    return 2 * Math.PI * Math.sqrt((radiusX * radiusX + radiusY * radiusY) / 2);
	  };

	  return Circle;

	})(Bit);

	module.exports = Circle;


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

	
	/* istanbul ignore next */
	var Bit, Line,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Bit = __webpack_require__(73)["default"] || __webpack_require__(73);

	Line = (function(superClass) {
	  extend(Line, superClass);

	  function Line() {
	    return Line.__super__.constructor.apply(this, arguments);
	  }

	  Line.prototype._declareDefaults = function() {
	    Line.__super__._declareDefaults.apply(this, arguments);
	    return this._defaults.tag = 'line';
	  };

	  Line.prototype._draw = function() {
	    var radiusX, x, y;
	    radiusX = this._props.radiusX != null ? this._props.radiusX : this._props.radius;
	    x = this._props.width / 2;
	    y = this._props.height / 2;
	    this._setAttrIfChanged('x1', x - radiusX);
	    this._setAttrIfChanged('x2', x + radiusX);
	    this._setAttrIfChanged('y1', y);
	    this._setAttrIfChanged('y2', y);
	    return Line.__super__._draw.apply(this, arguments);
	  };

	  return Line;

	})(Bit);

	module.exports = Line;


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

	
	/* istanbul ignore next */
	var Bit, Zigzag,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Bit = __webpack_require__(73)["default"] || __webpack_require__(73);

	Zigzag = (function(superClass) {
	  extend(Zigzag, superClass);

	  function Zigzag() {
	    return Zigzag.__super__.constructor.apply(this, arguments);
	  }

	  Zigzag.prototype._declareDefaults = function() {
	    Zigzag.__super__._declareDefaults.apply(this, arguments);
	    this._defaults.tag = 'path';
	    return this._defaults.points = 3;
	  };

	  Zigzag.prototype._draw = function() {
	    var currentX, currentY, delta, i, isPoints, isRadiusX, isRadiusY, j, length, p, points, radiusX, radiusY, ref, stepX, x, y, yFlip;
	    Zigzag.__super__._draw.apply(this, arguments);
	    p = this._props;
	    if (!this._props.points) {
	      return;
	    }
	    radiusX = this._props.radiusX != null ? this._props.radiusX : this._props.radius;
	    radiusY = this._props.radiusY != null ? this._props.radiusY : this._props.radius;
	    isRadiusX = radiusX === this._prevRadiusX;
	    isRadiusY = radiusY === this._prevRadiusY;
	    isPoints = p.points === this._prevPoints;
	    if (isRadiusX && isRadiusY && isPoints) {
	      return;
	    }
	    x = p.width / 2;
	    y = p.height / 2;
	    currentX = x - radiusX;
	    currentY = y;
	    stepX = (2 * radiusX) / (p.points - 1);
	    yFlip = -1;
	    delta = Math.sqrt(stepX * stepX + radiusY * radiusY);
	    length = -delta;
	    points = "M" + currentX + ", " + y + " ";
	    for (i = j = 0, ref = p.points; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
	      points += "L" + currentX + ", " + currentY + " ";
	      currentX += stepX;
	      length += delta;
	      currentY = yFlip === -1 ? y - radiusY : y;
	      yFlip = -yFlip;
	    }
	    this._length = length;
	    this.el.setAttribute('d', points);
	    this._prevPoints = p.points;
	    this._prevRadiusX = radiusX;
	    return this._prevRadiusY = radiusY;
	  };

	  Zigzag.prototype._getLength = function() {
	    return this._length;
	  };

	  return Zigzag;

	})(Bit);

	module.exports = Zigzag;


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

	
	/* istanbul ignore next */
	var Bit, Rect,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Bit = __webpack_require__(73)["default"] || __webpack_require__(73);

	Rect = (function(superClass) {
	  extend(Rect, superClass);

	  function Rect() {
	    return Rect.__super__.constructor.apply(this, arguments);
	  }

	  Rect.prototype._declareDefaults = function() {
	    Rect.__super__._declareDefaults.apply(this, arguments);
	    this._defaults.tag = 'rect';
	    this._defaults.rx = 0;
	    return this._defaults.ry = 0;
	  };

	  Rect.prototype._draw = function() {
	    var p, radiusX, radiusY;
	    Rect.__super__._draw.apply(this, arguments);
	    p = this._props;
	    radiusX = p.radiusX != null ? p.radiusX : p.radius;
	    radiusY = p.radiusY != null ? p.radiusY : p.radius;
	    this._setAttrIfChanged('width', 2 * radiusX);
	    this._setAttrIfChanged('height', 2 * radiusY);
	    this._setAttrIfChanged('x', (p.width / 2) - radiusX);
	    this._setAttrIfChanged('y', (p.height / 2) - radiusY);
	    this._setAttrIfChanged('rx', p.rx);
	    return this._setAttrIfChanged('ry', p.ry);
	  };

	  Rect.prototype._getLength = function() {
	    var radiusX, radiusY;
	    radiusX = this._props.radiusX != null ? this._props.radiusX : this._props.radius;
	    radiusY = this._props.radiusY != null ? this._props.radiusY : this._props.radius;
	    return 2 * (2 * radiusX + 2 * radiusY);
	  };

	  return Rect;

	})(Bit);

	module.exports = Rect;


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

	
	/* istanbul ignore next */
	var Bit, Polygon, h,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Bit = __webpack_require__(73)["default"] || __webpack_require__(73);

	h = __webpack_require__(71);

	Polygon = (function(superClass) {
	  extend(Polygon, superClass);

	  function Polygon() {
	    return Polygon.__super__.constructor.apply(this, arguments);
	  }


	  /*
	    Method to declare defaults.
	    @overrides @ Bit
	   */

	  Polygon.prototype._declareDefaults = function() {
	    Polygon.__super__._declareDefaults.apply(this, arguments);
	    this._defaults.tag = 'path';
	    return this._defaults.points = 3;
	  };


	  /*
	    Method to draw the shape.
	    @overrides @ Bit
	   */

	  Polygon.prototype._draw = function() {
	    var char, d, i, isPoints, isRadiusX, isRadiusY, j, k, len, p, point, radiusX, radiusY, ref, ref1, step;
	    p = this._props;
	    radiusX = this._props.radiusX != null ? this._props.radiusX : this._props.radius;
	    radiusY = this._props.radiusY != null ? this._props.radiusY : this._props.radius;
	    isRadiusX = radiusX === this._prevRadiusX;
	    isRadiusY = radiusY === this._prevRadiusY;
	    isPoints = p.points === this._prevPoints;
	    if (!(isRadiusX && isRadiusY && isPoints)) {
	      step = 360 / this._props.points;
	      if (this._radialPoints == null) {
	        this._radialPoints = [];
	      } else {
	        this._radialPoints.length = 0;
	      }
	      for (i = j = 0, ref = this._props.points; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
	        this._radialPoints.push(h.getRadialPoint({
	          radius: this._props.radius,
	          radiusX: this._props.radiusX,
	          radiusY: this._props.radiusY,
	          angle: i * step,
	          center: {
	            x: p.width / 2,
	            y: p.height / 2
	          }
	        }));
	      }
	      d = '';
	      ref1 = this._radialPoints;
	      for (i = k = 0, len = ref1.length; k < len; i = ++k) {
	        point = ref1[i];
	        char = i === 0 ? 'M' : 'L';
	        d += "" + char + (point.x.toFixed(4)) + "," + (point.y.toFixed(4)) + " ";
	      }
	      this._prevPoints = p.points;
	      this._prevRadiusX = radiusX;
	      this._prevRadiusY = radiusY;
	      this.el.setAttribute('d', (d += 'z'));
	    }
	    return Polygon.__super__._draw.apply(this, arguments);
	  };


	  /*
	    Method to get length of the shape.
	    @overrides @ Bit
	   */

	  Polygon.prototype._getLength = function() {
	    return this._getPointsPerimiter(this._radialPoints);
	  };

	  return Polygon;

	})(Bit);

	module.exports = Polygon;


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

	
	/* istanbul ignore next */
	var Bit, Cross,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Bit = __webpack_require__(73)["default"] || __webpack_require__(73);

	Cross = (function(superClass) {
	  extend(Cross, superClass);

	  function Cross() {
	    return Cross.__super__.constructor.apply(this, arguments);
	  }

	  Cross.prototype._declareDefaults = function() {
	    Cross.__super__._declareDefaults.apply(this, arguments);
	    return this._defaults.tag = 'path';
	  };

	  Cross.prototype._draw = function() {
	    var d, isRadiusX, isRadiusY, line1, line2, p, radiusX, radiusY, x, x1, x2, y, y1, y2;
	    Cross.__super__._draw.apply(this, arguments);
	    p = this._props;
	    radiusX = this._props.radiusX != null ? this._props.radiusX : this._props.radius;
	    radiusY = this._props.radiusY != null ? this._props.radiusY : this._props.radius;
	    isRadiusX = radiusX === this._prevRadiusX;
	    isRadiusY = radiusY === this._prevRadiusY;
	    if (isRadiusX && isRadiusY) {
	      return;
	    }
	    x = this._props.width / 2;
	    y = this._props.height / 2;
	    x1 = x - radiusX;
	    x2 = x + radiusX;
	    line1 = "M" + x1 + "," + y + " L" + x2 + "," + y;
	    y1 = y - radiusY;
	    y2 = y + radiusY;
	    line2 = "M" + x + "," + y1 + " L" + x + "," + y2;
	    d = line1 + " " + line2;
	    this.el.setAttribute('d', d);
	    this._prevRadiusX = radiusX;
	    return this._prevRadiusY = radiusY;
	  };

	  Cross.prototype._getLength = function() {
	    var radiusX, radiusY;
	    radiusX = this._props.radiusX != null ? this._props.radiusX : this._props.radius;
	    radiusY = this._props.radiusY != null ? this._props.radiusY : this._props.radius;
	    return 2 * (radiusX + radiusY);
	  };

	  return Cross;

	})(Bit);

	module.exports = Cross;


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _classCallCheck2 = __webpack_require__(74);

	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

	var _possibleConstructorReturn2 = __webpack_require__(75);

	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

	var _inherits2 = __webpack_require__(76);

	var _inherits3 = _interopRequireDefault(_inherits2);

	var _bit = __webpack_require__(73);

	var _bit2 = _interopRequireDefault(_bit);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var Curve = function (_Bit) {
	  (0, _inherits3.default)(Curve, _Bit);

	  function Curve() {
	    (0, _classCallCheck3.default)(this, Curve);
	    return (0, _possibleConstructorReturn3.default)(this, _Bit.apply(this, arguments));
	  }

	  /*
	    Method to declare module's defaults.
	    @private
	    @overrides @ Bit
	  */
	  Curve.prototype._declareDefaults = function _declareDefaults() {
	    _Bit.prototype._declareDefaults.call(this);
	    this._defaults.tag = 'path';
	  };
	  /*
	    Method to draw the module.
	    @private
	    @overrides @ Bit
	  */


	  Curve.prototype._draw = function _draw() {
	    _Bit.prototype._draw.call(this);
	    var p = this._props;

	    var radiusX = p.radiusX != null ? p.radiusX : p.radius;
	    var radiusY = p.radiusY != null ? p.radiusY : p.radius;

	    var isRadiusX = radiusX === this._prevRadiusX;
	    var isRadiusY = radiusY === this._prevRadiusY;
	    var isPoints = p.points === this._prevPoints;
	    // skip if nothing changed
	    if (isRadiusX && isRadiusY && isPoints) {
	      return;
	    }

	    var x = p.width / 2;
	    var y = p.height / 2;
	    var x1 = x - radiusX;
	    var x2 = x + radiusX;

	    var d = 'M' + x1 + ' ' + y + ' Q ' + x + ' ' + (y - 2 * radiusY) + ' ' + x2 + ' ' + y;

	    // set the `d` attribute and save it to `_prevD`
	    this.el.setAttribute('d', d);
	    // save the properties
	    this._prevPoints = p.points;
	    this._prevRadiusX = radiusX;
	    this._prevRadiusY = radiusY;
	  };

	  Curve.prototype._getLength = function _getLength() {
	    var p = this._props;

	    var radiusX = p.radiusX != null ? p.radiusX : p.radius;
	    var radiusY = p.radiusY != null ? p.radiusY : p.radius;

	    var dRadius = radiusX + radiusY;
	    var sqrt = Math.sqrt((3 * radiusX + radiusY) * (radiusX + 3 * radiusY));

	    return .5 * Math.PI * (3 * dRadius - sqrt);
	  };

	  return Curve;
	}(_bit2.default); // istanbul ignore next


	exports.default = Curve;

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

	
	/* istanbul ignore next */
	var Bit, Equal,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Bit = __webpack_require__(73)["default"] || __webpack_require__(73);

	Equal = (function(superClass) {
	  extend(Equal, superClass);

	  function Equal() {
	    return Equal.__super__.constructor.apply(this, arguments);
	  }

	  Equal.prototype._declareDefaults = function() {
	    Equal.__super__._declareDefaults.apply(this, arguments);
	    this._defaults.tag = 'path';
	    return this._defaults.points = 2;
	  };

	  Equal.prototype._draw = function() {
	    var d, i, isPoints, isRadiusX, isRadiusY, j, p, radiusX, radiusY, ref, x, x1, x2, y, yStart, yStep;
	    Equal.__super__._draw.apply(this, arguments);
	    p = this._props;
	    if (!this._props.points) {
	      return;
	    }
	    radiusX = this._props.radiusX != null ? this._props.radiusX : this._props.radius;
	    radiusY = this._props.radiusY != null ? this._props.radiusY : this._props.radius;
	    isRadiusX = radiusX === this._prevRadiusX;
	    isRadiusY = radiusY === this._prevRadiusY;
	    isPoints = p.points === this._prevPoints;
	    if (isRadiusX && isRadiusY && isPoints) {
	      return;
	    }
	    x = this._props.width / 2;
	    y = this._props.height / 2;
	    x1 = x - radiusX;
	    x2 = x + radiusX;
	    d = '';
	    yStep = 2 * radiusY / (this._props.points - 1);
	    yStart = y - radiusY;
	    for (i = j = 0, ref = this._props.points; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
	      y = "" + (i * yStep + yStart);
	      d += "M" + x1 + ", " + y + " L" + x2 + ", " + y + " ";
	    }
	    this.el.setAttribute('d', d);
	    this._prevPoints = p.points;
	    this._prevRadiusX = radiusX;
	    return this._prevRadiusY = radiusY;
	  };

	  Equal.prototype._getLength = function() {
	    return 2 * (this._props.radiusX != null ? this._props.radiusX : this._props.radius);
	  };

	  return Equal;

	})(Bit);

	module.exports = Equal;


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _keys = __webpack_require__(95);

	var _keys2 = _interopRequireDefault(_keys);

	var _classCallCheck2 = __webpack_require__(74);

	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

	var _possibleConstructorReturn2 = __webpack_require__(75);

	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

	var _inherits2 = __webpack_require__(76);

	var _inherits3 = _interopRequireDefault(_inherits2);

	var _module = __webpack_require__(84);

	var _module2 = _interopRequireDefault(_module);

	var _thenable = __webpack_require__(99);

	var _thenable2 = _interopRequireDefault(_thenable);

	var _tunable = __webpack_require__(116);

	var _tunable2 = _interopRequireDefault(_tunable);

	var _tweenable = __webpack_require__(100);

	var _tweenable2 = _interopRequireDefault(_tweenable);

	var _tween = __webpack_require__(101);

	var _tween2 = _interopRequireDefault(_tween);

	var _timeline = __webpack_require__(110);

	var _timeline2 = _interopRequireDefault(_timeline);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var h = __webpack_require__(71);
	var Bit = __webpack_require__(73);
	var shapesMap = __webpack_require__(72);

	// TODO
	//  - refactor
	//    - add setIfChanged to Module
	//  --
	//  - tween for every prop

	var Shape = function (_Tunable) {
	  (0, _inherits3.default)(Shape, _Tunable);

	  function Shape() {
	    (0, _classCallCheck3.default)(this, Shape);
	    return (0, _possibleConstructorReturn3.default)(this, _Tunable.apply(this, arguments));
	  }

	  /*
	    Method to declare module's defaults.
	    @private
	  */
	  Shape.prototype._declareDefaults = function _declareDefaults() {
	    // DEFAULTS / APIs
	    this._defaults = {
	      // where to append the module to [selector, HTMLElement]
	      parent: document.body,
	      // class name for the `el`
	      className: '',
	      // Possible values: [circle, line, zigzag, rect, polygon, cross, equal ]
	      shape: 'circle',
	      // ∆ :: Possible values: [color name, rgb, rgba, hex]
	      stroke: 'transparent',
	      // ∆ :: Possible values: [ 0..1 ]
	      strokeOpacity: 1,
	      // Possible values: ['butt' | 'round' | 'square']
	      strokeLinecap: '',
	      // ∆ :: Possible values: [ number ]
	      strokeWidth: 2,
	      // ∆ :: Units :: Possible values: [ number, string ]
	      strokeDasharray: 0,
	      // ∆ :: Units :: Possible values: [ number, string ]
	      strokeDashoffset: 0,
	      // ∆ :: Possible values: [color name, rgb, rgba, hex]
	      fill: 'deeppink',
	      // ∆ :: Possible values: [ 0..1 ]
	      fillOpacity: 1,
	      // {Boolean} - if should hide module with `opacity` instead of `display`
	      isSoftHide: true,
	      // {Boolean} - if should trigger composite layer for the `el`
	      isForce3d: false,
	      // ∆ :: Units :: Possible values: [ number, string ]
	      left: '50%',
	      // ∆ :: Units :: Possible values: [ number, string ]
	      top: '50%',
	      // ∆ :: Units :: Possible values: [ number, string ]
	      x: 0,
	      // ∆ :: Units :: Possible values: [ number, string ]
	      y: 0,
	      // ∆ :: Possible values: [ number ]
	      angle: 0,
	      // ∆ :: Possible values: [ number ]
	      scale: 1,
	      // ∆ :: Possible values: [ number ] Fallbacks to `scale`.
	      scaleX: null,
	      // ∆ :: Possible values: [ number ] Fallbacks to `scale`.
	      scaleY: null,
	      // ∆ :: Possible values: [ number, string ]
	      origin: '50% 50%',
	      // ∆ :: Possible values: [ 0..1 ]
	      opacity: 1,
	      // ∆ :: Units :: Possible values: [ number, string ]
	      rx: 0,
	      // ∆ :: Units :: Possible values: [ number, string ]
	      ry: 0,
	      // ∆ :: Possible values: [ number ]
	      points: 3,
	      // ∆ :: Possible values: [ number ]
	      radius: 50,
	      // ∆ :: Possible values: [ number ]
	      radiusX: null,
	      // ∆ :: Possible values: [ number ]
	      radiusY: null,
	      // Possible values: [ boolean ]
	      isShowStart: false,
	      // Possible values: [ boolean ]
	      isShowEnd: true,
	      // Possible values: [ boolean ]
	      isRefreshState: true,
	      // Possible values: [ number > 0 ]
	      duration: 400,
	      // Possible values: [ number ]

	      /* technical ones: */
	      // explicit width of the module canvas
	      width: null,
	      // explicit height of the module canvas
	      height: null,
	      // Possible values: [ number ]
	      // sizeGap:          0,
	      /* [boolean] :: If should have child shape. */
	      isWithShape: true,
	      // context for all the callbacks
	      callbacksContext: this
	    };
	  };
	  /*
	    Method to start the animation with optional new options.
	    @public
	    @overrides @ Tunable
	    @param {Object} New options to set on the run.
	    @returns {Object} this.
	  */


	  Shape.prototype.tune = function tune(o) {
	    _Tunable.prototype.tune.call(this, o);
	    // update shapeModule's size to the max in `then` chain
	    this._getMaxSizeInChain();
	    return this;
	  };
	  /*
	    Method to create a then record for the module.
	    @public
	    @overrides @ Thenable
	    @param    {Object} Options for the next animation.
	    @returns  {Object} this.
	  */


	  Shape.prototype.then = function then(o) {
	    // this._makeTimeline()
	    _Tunable.prototype.then.call(this, o);
	    // update shapeModule's size to the max in `then` chain
	    this._getMaxSizeInChain();
	    return this;
	  };

	  // ^ PUBLIC  METHOD(S) ^
	  // v PRIVATE METHOD(S) v

	  /*
	    Method to declare variables.
	    @overrides Thenable
	  */


	  Shape.prototype._vars = function _vars() {
	    // call _vars method on Thenable
	    _Tunable.prototype._vars.call(this);
	    this._lastSet = {};
	    // save previous module in the chain
	    this._prevChainModule = this._o.prevChainModule;
	    // should draw on foreign svg canvas
	    this.isForeign = !!this._o.ctx;
	    // this._o.isTimelineLess = true;
	    // should take an svg element as self bit
	    return this.isForeignBit = !!this._o.shape;
	  };
	  /*
	    Method to initialize modules presentation.
	    @private
	    @overrides Module
	  */


	  Shape.prototype._render = function _render() {
	    if (!this._isRendered && !this._isChained) {
	      // create `mojs` shape element
	      this.el = document.createElement('div');
	      // set name on the `el`
	      this.el.setAttribute('data-name', 'mojs-shape');
	      // set class on the `el`
	      this.el.setAttribute('class', this._props.className);
	      // create shape module
	      this._createShape();
	      // append `el` to parent
	      this._props.parent.appendChild(this.el);
	      // set position styles on the el
	      this._setElStyles();
	      // set initial position for the first module in the chain
	      this._setProgress(0, 0);
	      // show at start if `isShowStart`
	      if (this._props.isShowStart) {
	        this._show();
	      } else {
	        this._hide();
	      }
	      // set `_isRendered` hatch
	      this._isRendered = true;
	    } else if (this._isChained) {
	      // save elements from master module
	      this.el = this._masterModule.el;
	      this.shapeModule = this._masterModule.shapeModule;
	    }

	    return this;
	  };
	  /*
	    Method to set el styles on initialization.
	    @private
	  */


	  Shape.prototype._setElStyles = function _setElStyles() {
	    if (!this.el) {
	      return;
	    }
	    // if (!this.isForeign) {
	    var p = this._props,
	        style = this.el.style,
	        width = p.shapeWidth,
	        height = p.shapeHeight;

	    style.position = 'absolute';
	    this._setElSizeStyles(width, height);

	    if (p.isForce3d) {
	      var name = 'backface-visibility';
	      style['' + name] = 'hidden';
	      style['' + h.prefix.css + name] = 'hidden';
	    }
	    // }
	  };
	  /*
	    Method to set `width`/`height`/`margins` to the `el` styles.
	    @param {Number} Width.
	    @param {height} Height.
	  */


	  Shape.prototype._setElSizeStyles = function _setElSizeStyles(width, height) {
	    var style = this.el.style;
	    style.width = width + 'px';
	    style.height = height + 'px';
	    style['margin-left'] = -width / 2 + 'px';
	    style['margin-top'] = -height / 2 + 'px';
	  };
	  /*
	    Method to draw shape.
	    @private
	  */


	  Shape.prototype._draw = function _draw() {
	    if (!this.shapeModule) {
	      return;
	    }

	    var p = this._props,
	        bP = this.shapeModule._props;
	    // set props on bit
	    // bP.x                    = this._origin.x;
	    // bP.y                    = this._origin.y;
	    bP.rx = p.rx;
	    bP.ry = p.ry;
	    bP.stroke = p.stroke;
	    bP['stroke-width'] = p.strokeWidth;
	    bP['stroke-opacity'] = p.strokeOpacity;
	    bP['stroke-dasharray'] = p.strokeDasharray;
	    bP['stroke-dashoffset'] = p.strokeDashoffset;
	    bP['stroke-linecap'] = p.strokeLinecap;
	    bP['fill'] = p.fill;
	    bP['fill-opacity'] = p.fillOpacity;
	    bP.radius = p.radius;
	    bP.radiusX = p.radiusX;
	    bP.radiusY = p.radiusY;
	    bP.points = p.points;

	    this.shapeModule._draw();
	    this._drawEl();
	  };
	  /*
	    Method to set current modules props to main div el.
	    @private
	  */


	  Shape.prototype._drawEl = function _drawEl() {
	    // return;
	    if (this.el == null) {
	      return true;
	    }
	    var p = this._props;
	    var style = this.el.style;

	    // style.opacity = p.opacity;
	    this._isPropChanged('opacity') && (style.opacity = p.opacity);
	    if (!this.isForeign) {
	      this._isPropChanged('left') && (style.left = p.left);
	      this._isPropChanged('top') && (style.top = p.top);

	      var isX = this._isPropChanged('x'),
	          isY = this._isPropChanged('y'),
	          isTranslate = isX || isY,
	          isScaleX = this._isPropChanged('scaleX'),
	          isScaleY = this._isPropChanged('scaleY'),
	          isScale = this._isPropChanged('scale'),
	          isScale = isScale || isScaleX || isScaleY,
	          isRotate = this._isPropChanged('angle');

	      if (isTranslate || isScale || isRotate) {
	        var transform = this._fillTransform();
	        style[h.prefix.css + 'transform'] = transform;
	        style['transform'] = transform;
	      }

	      if (this._isPropChanged('origin') || this._deltas['origin']) {
	        var origin = this._fillOrigin();
	        style[h.prefix.css + 'transform-origin'] = origin;
	        style['transform-origin'] = origin;
	      }
	    }
	  };
	  /*
	    Method to check if property changed after the latest check.
	    @private
	    @param {String} Name of the property to check.
	    @returns {Boolean}
	  */


	  Shape.prototype._isPropChanged = function _isPropChanged(name) {
	    // if there is no recod for the property - create it
	    if (this._lastSet[name] == null) {
	      this._lastSet[name] = {};
	    }
	    if (this._lastSet[name].value !== this._props[name]) {
	      this._lastSet[name].value = this._props[name];
	      return true;
	    } else {
	      return false;
	    }
	  };
	  /*
	    Method to tune new option on run.
	    @private
	    @override @ Module
	    @param {Object}  Option to tune on run.
	  */


	  Shape.prototype._tuneNewOptions = function _tuneNewOptions(o) {
	    // call super on Module
	    _Tunable.prototype._tuneNewOptions.call(this, o);
	    // return if empty object
	    if (!(o != null && (0, _keys2.default)(o).length)) {
	      return 1;
	    }

	    // this._calcSize();
	    this._setElStyles();
	  };
	  /*
	    Method to get max radiusX value.
	    @private
	    @param {String} Radius name.
	  */


	  Shape.prototype._getMaxRadius = function _getMaxRadius(name) {
	    var selfSize, selfSizeX;
	    selfSize = this._getRadiusSize('radius');
	    return this._getRadiusSize(name, selfSize);
	  };
	  /*
	    Method to increase calculated size based on easing.
	    @private
	  */


	  Shape.prototype._increaseSizeWithEasing = function _increaseSizeWithEasing() {
	    var p = this._props,
	        easing = this._o.easing,
	        isStringEasing = easing && typeof easing === 'string';

	    switch (isStringEasing && easing.toLowerCase()) {
	      case 'elastic.out':
	      case 'elastic.inout':
	        p.size *= 1.25;
	        break;
	      case 'back.out':
	      case 'back.inout':
	        p.size *= 1.1;
	    }
	  };
	  /*
	    Method to increase calculated size based on bit ratio.
	    @private
	  */
	  // _increaseSizeWithBitRatio () {
	  //   var p   = this._props;
	  //   // p.size *= this.shape._props.ratio;
	  //   p.size += 2 * p.sizeGap;
	  // }
	  /*
	    Method to get maximum radius size with optional fallback.
	    @private
	    @param {Object}
	      @param key {String} Name of the radius - [radius|radiusX|radiusY].
	      @param @optional fallback {Number}  Optional number to set if there
	                                          is no value for the key.
	  */


	  Shape.prototype._getRadiusSize = function _getRadiusSize(name) {
	    var fallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

	    var delta = this._deltas[name];
	    // if value is delta value
	    if (delta != null) {
	      // get maximum number between start and end values of the delta
	      return Math.max(Math.abs(delta.end), Math.abs(delta.start));
	    } else if (this._props[name] != null) {
	      // else get the value from props object
	      return parseFloat(this._props[name]);
	    } else {
	      return fallback;
	    }
	  };
	  /*
	    Method to get max shape canvas size and save it to _props.
	    @private
	  */


	  Shape.prototype._getShapeSize = function _getShapeSize() {
	    var p = this._props,

	    // get maximum stroke value
	    stroke = this._getMaxStroke();
	    // save shape `width` and `height` to `_props`
	    p.shapeWidth = p.width != null ? p.width : 2 * this._getMaxRadius('radiusX') + stroke;

	    p.shapeHeight = p.height != null ? p.height : 2 * this._getMaxRadius('radiusY') + stroke;
	  };
	  /*
	    Method to create shape.
	    @private
	  */


	  Shape.prototype._createShape = function _createShape() {
	    // calculate max shape canvas size and set to _props
	    this._getShapeSize();
	    // don't create actual shape if !`isWithShape`
	    if (!this._props.isWithShape) {
	      return;
	    }

	    var p = this._props;
	    // get shape's class
	    var Shape = shapesMap.getShape(this._props.shape);
	    // create `_shape` module
	    this.shapeModule = new Shape({
	      width: p.shapeWidth,
	      height: p.shapeHeight,
	      parent: this.el
	    });
	  };
	  /*
	    Method to get max size in `then` chain
	    @private
	  */


	  Shape.prototype._getMaxSizeInChain = function _getMaxSizeInChain() {
	    var p = this._props,
	        maxW = 0,
	        maxH = 0;

	    for (var i = 0; i < this._modules.length; i++) {
	      this._modules[i]._getShapeSize();
	      maxW = Math.max(maxW, this._modules[i]._props.shapeWidth);
	      maxH = Math.max(maxH, this._modules[i]._props.shapeHeight);
	    }

	    this.shapeModule && this.shapeModule._setSize(maxW, maxH);
	    this._setElSizeStyles(maxW, maxH);
	  };
	  /*
	    Method to get max value of the strokeWidth.
	    @private
	  */


	  Shape.prototype._getMaxStroke = function _getMaxStroke() {
	    var p = this._props;
	    var dStroke = this._deltas['strokeWidth'];
	    return dStroke != null ? Math.max(dStroke.start, dStroke.end) : p.strokeWidth;
	  };
	  /*
	    Method to draw current progress of the deltas.
	    @private
	    @override @ Module
	    @param   {Number}  EasedProgress to set - [0..1].
	    @param   {Number}  Progress to set - [0..1].
	  */


	  Shape.prototype._setProgress = function _setProgress(easedProgress, progress) {
	    // call the super on Module
	    _module2.default.prototype._setProgress.call(this, easedProgress, progress);
	    // draw current progress
	    this._draw(easedProgress);
	  };
	  /*
	    Method to add callback overrides to passed object.
	    @private
	    @param {Object} Object to add the overrides to.
	  */


	  Shape.prototype._applyCallbackOverrides = function _applyCallbackOverrides(obj) {
	    var it = this,
	        p = this._props;
	    // specify control functions for the module
	    obj.callbackOverrides = {
	      onUpdate: function onUpdate(ep, p) {
	        return it._setProgress(ep, p);
	      },
	      onStart: function onStart(isFwd) {
	        // don't touch main `el` onStart in chained elements
	        if (it._isChained) {
	          return;
	        };
	        if (isFwd) {
	          it._show();
	        } else {
	          if (!p.isShowStart) {
	            it._hide();
	          }
	        }
	      },
	      onComplete: function onComplete(isFwd) {
	        // don't touch main `el` if not the last in `then` chain
	        if (!it._isLastInChain()) {
	          return;
	        }
	        if (isFwd) {
	          if (!p.isShowEnd) {
	            it._hide();
	          }
	        } else {
	          it._show();
	        }
	      },
	      onRefresh: function onRefresh(isBefore) {
	        p.isRefreshState && isBefore && it._refreshBefore();
	      }
	    };
	  };
	  /*
	    Method to setup tween and timeline options before creating them.
	    @override @ Tweenable
	    @private
	  */


	  Shape.prototype._transformTweenOptions = function _transformTweenOptions() {
	    this._applyCallbackOverrides(this._o);
	  };
	  /*
	    Method to create transform string.
	    @private
	    @returns {String} Transform string.
	  */


	  Shape.prototype._fillTransform = function _fillTransform() {
	    var p = this._props,
	        scaleX = p.scaleX != null ? p.scaleX : p.scale,
	        scaleY = p.scaleY != null ? p.scaleY : p.scale,
	        scale = scaleX + ', ' + scaleY;
	    return 'translate(' + p.x + ', ' + p.y + ') rotate(' + p.angle + 'deg) scale(' + scale + ')';
	  };
	  /*
	    Method to create transform-origin string.
	    @private
	    @returns {String} Transform string.
	  */


	  Shape.prototype._fillOrigin = function _fillOrigin() {
	    var p = this._props,
	        str = '';
	    for (var i = 0; i < p.origin.length; i++) {
	      str += p.origin[i].string + ' ';
	    }
	    return str;
	  };
	  /*
	    Method to refresh state befor startTime.
	    @private
	  */


	  Shape.prototype._refreshBefore = function _refreshBefore() {
	    // call setProgress with eased and normal progress
	    this._setProgress(this.tween._props.easing(0), 0);

	    if (this._props.isShowStart) {
	      this._show();
	    } else {
	      this._hide();
	    }
	  };
	  /*
	    Method that gets called on `soft` show of the module,
	    it should restore transform styles of the module.
	    @private
	    @overrides @ Module
	  */


	  Shape.prototype._showByTransform = function _showByTransform() {
	    // reset the cache of the scale prop
	    this._lastSet.scale = null;
	    // draw el accroding to it's props
	    this._drawEl();
	  };

	  return Shape;
	}(_tunable2.default);

	exports.default = Shape;

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(96), __esModule: true };

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(97);
	module.exports = __webpack_require__(14).Object.keys;

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.14 Object.keys(O)
	var toObject = __webpack_require__(49)
	  , $keys    = __webpack_require__(33);

	__webpack_require__(98)('keys', function(){
	  return function keys(it){
	    return $keys(toObject(it));
	  };
	});

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

	// most Object methods by ES6 should accept primitives
	var $export = __webpack_require__(12)
	  , core    = __webpack_require__(14)
	  , fails   = __webpack_require__(23);
	module.exports = function(KEY, exec){
	  var fn  = (core.Object || {})[KEY] || Object[KEY]
	    , exp = {};
	  exp[KEY] = exec(fn);
	  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
	};

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _keys = __webpack_require__(95);

	var _keys2 = _interopRequireDefault(_keys);

	var _classCallCheck2 = __webpack_require__(74);

	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

	var _possibleConstructorReturn2 = __webpack_require__(75);

	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

	var _inherits2 = __webpack_require__(76);

	var _inherits3 = _interopRequireDefault(_inherits2);

	var _tweenable = __webpack_require__(100);

	var _tweenable2 = _interopRequireDefault(_tweenable);

	var _h = __webpack_require__(71);

	var _h2 = _interopRequireDefault(_h);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/*
	  The Thenable class adds .then public method and
	  the ability to chain API calls.
	*/
	var Thenable = function (_Tweenable) {
	  (0, _inherits3.default)(Thenable, _Tweenable);

	  function Thenable() {
	    (0, _classCallCheck3.default)(this, Thenable);
	    return (0, _possibleConstructorReturn3.default)(this, _Tweenable.apply(this, arguments));
	  }

	  /*
	    Method to create a then record for the module.
	    @public
	    @param    {Object} Options for the next animation.
	    @returns  {Object} this.
	  */
	  Thenable.prototype.then = function then(o) {
	    // return if nothing was passed
	    if (o == null || !(0, _keys2.default)(o).length) {
	      return 1;
	    }
	    // merge then options with the current ones
	    var prevRecord = this._history[this._history.length - 1],
	        prevModule = this._modules[this._modules.length - 1],
	        merged = this._mergeThenOptions(prevRecord, o);

	    this._resetMergedFlags(merged);
	    // create a submodule of the same type as the master module
	    var module = new this.constructor(merged);
	    // set `this` as amster module of child module
	    module._masterModule = this;
	    // save the modules to the _modules array
	    this._modules.push(module);
	    // add module's tween into master timeline
	    this.timeline.append(module);

	    return this;
	  };

	  // ^ PUBLIC  METHOD(S) ^
	  // v PRIVATE METHOD(S) v

	  /*
	    Method to reset some flags on merged options object.
	    @private
	    @param   {Object} Options object.
	    @returns {Object} Options object.
	  */


	  Thenable.prototype._resetMergedFlags = function _resetMergedFlags(obj) {
	    // set the submodule to be without timeline for perf reasons
	    obj.isTimelineLess = true;
	    // reset isShowStart flag for the submodules
	    obj.isShowStart = false;
	    // reset isRefreshState flag for the submodules
	    obj.isRefreshState = false;
	    // set the submodule callbacks context
	    obj.callbacksContext = this._props.callbacksContext || this;
	    // set previous module
	    obj.prevChainModule = _h2.default.getLastItem(this._modules);
	    // pass the `this` as master module
	    obj.masterModule = this;
	    return obj;
	  };
	  /*
	    Method to initialize properties.
	    @private
	  */


	  Thenable.prototype._vars = function _vars() {
	    _Tweenable.prototype._vars.call(this);
	    // save _master module
	    this._masterModule = this._o.masterModule;
	    // set isChained flag based on prevChainModule option
	    this._isChained = !!this._masterModule;
	    // we are expect that the _o object
	    // have been already extended by defaults
	    var initialRecord = _h2.default.cloneObj(this._props);
	    for (var key in this._arrayPropertyMap) {
	      if (this._o[key]) {
	        var preParsed = this._parsePreArrayProperty(key, this._o[key]);
	        initialRecord[key] = preParsed;
	      }
	    }

	    this._history = [initialRecord];
	    // the array holds all modules in the then chain
	    this._modules = [this];
	    // the props that to exclude from then merge
	    this._nonMergeProps = { shape: 1 };
	  };
	  /*
	    Method to merge two options into one. Used in .then chains.
	    @private
	    @param {Object} Start options for the merge.
	    @param {Object} End options for the merge.
	    @returns {Object} Merged options.
	  */


	  Thenable.prototype._mergeThenOptions = function _mergeThenOptions(start, end) {
	    var o = {};
	    this._mergeStartLoop(o, start);
	    this._mergeEndLoop(o, start, end);
	    this._history.push(o);
	    return o;
	  };
	  /*
	    Method to pipe startValue of the delta.
	    @private
	    @param {String} Start property name.
	    @param {Any} Start property value.
	    @returns {Any} Start property value.
	  */


	  Thenable.prototype._checkStartValue = function _checkStartValue(name, value) {
	    return value;
	  };
	  /*
	    Originally part of the _mergeThenOptions.
	    Loops thru start object and copies all the props from it.
	    @param {Object} An object to copy in.
	    @parma {Object} Start options object.
	  */


	  Thenable.prototype._mergeStartLoop = function _mergeStartLoop(o, start) {
	    // loop thru start options object
	    for (var key in start) {
	      var value = start[key];
	      if (start[key] == null) {
	        continue;
	      };
	      // copy all values from start if not tween prop or duration
	      if (!_h2.default.isTweenProp(key) || key === 'duration') {
	        // if delta - copy only the end value
	        if (this._isDelta(value)) {
	          o[key] = _h2.default.getDeltaEnd(value);
	        } else {
	          o[key] = value;
	        }
	      }
	    }
	  };
	  /*
	    Originally part of the _mergeThenOptions.
	    Loops thru start object and merges all the props from it.
	    @param {Object} An object to copy in.
	    @parma {Object} Start options object.
	    @parma {Object} End options object.
	  */


	  Thenable.prototype._mergeEndLoop = function _mergeEndLoop(o, start, end) {
	    var endKeys = (0, _keys2.default)(end);

	    for (var key in end) {
	      // just copy parent option
	      if (key == 'parent') {
	        o[key] = end[key];continue;
	      };

	      // get key/value of the end object
	      // endKey - name of the property, endValue - value of the property
	      var endValue = end[key],
	          startValue = start[key] != null ? start[key] : this._defaults[key];

	      startValue = this._checkStartValue(key, startValue);
	      if (endValue == null) {
	        continue;
	      };
	      // make ∆ of start -> end
	      // if key name is radiusX/radiusY and
	      // the startValue is not set fallback to radius value
	      var isSubRadius = key === 'radiusX' || key === 'radiusY';
	      if (isSubRadius && startValue == null) {
	        startValue = start.radius;
	      }

	      var isSubRadius = key === 'scaleX' || key === 'scaleY';
	      if (isSubRadius && startValue == null) {
	        startValue = start.scale;
	      }

	      o[key] = this._mergeThenProperty(key, startValue, endValue);
	    }
	  };
	  /*
	    Method to merge `start` and `end` for a property in then record.
	    @private
	    @param {String} Property name.
	    @param {Any}    Start value of the property.
	    @param {Any}    End value of the property.
	  */


	  Thenable.prototype._mergeThenProperty = function _mergeThenProperty(key, startValue, endValue) {
	    // if isnt tween property
	    var isBoolean = typeof endValue === 'boolean',
	        curve,
	        easing;

	    if (!_h2.default.isTweenProp(key) && !this._nonMergeProps[key] && !isBoolean) {

	      if (_h2.default.isObject(endValue) && endValue.to != null) {
	        curve = endValue.curve;
	        easing = endValue.easing;
	        endValue = endValue.to;
	      }

	      // if end value is delta - just save it
	      if (this._isDelta(endValue)) {
	        return this._parseDeltaValues(key, endValue);
	      } else {
	        var parsedEndValue = this._parsePreArrayProperty(key, endValue);
	        // if end value is not delta - merge with start value
	        if (this._isDelta(startValue)) {
	          var _ref;

	          // if start value is delta - take the end value
	          // as start value of the new delta
	          return _ref = {}, _ref[_h2.default.getDeltaEnd(startValue)] = parsedEndValue, _ref.easing = easing, _ref.curve = curve, _ref;
	          // if both start and end value are not ∆ - make ∆
	        } else {
	          var _ref2;

	          return _ref2 = {}, _ref2[startValue] = parsedEndValue, _ref2.easing = easing, _ref2.curve = curve, _ref2;
	        }
	      }
	      // copy the tween values unattended
	    } else {
	      return endValue;
	    }
	  };
	  /*
	    Method to retreive array's length and return -1 for
	    all other types.
	    @private
	    @param {Array, Any} Array to get the width for.
	    @returns {Number} Array length or -1 if not array.
	  */


	  Thenable.prototype._getArrayLength = function _getArrayLength(arr) {
	    return _h2.default.isArray(arr) ? arr.length : -1;
	  };
	  /*
	    Method to check if the property is delta property.
	    @private
	    @param {Any} Parameter value to check.
	    @returns {Boolean}
	  */


	  Thenable.prototype._isDelta = function _isDelta(optionsValue) {
	    var isObject = _h2.default.isObject(optionsValue);
	    isObject = isObject && !optionsValue.unit;
	    return !(!isObject || _h2.default.isArray(optionsValue) || _h2.default.isDOM(optionsValue));
	  };
	  /*
	    Method to check if the module is first in `then` chain.
	    @private
	    @returns {Boolean} If the module is the first in module chain.
	  */


	  Thenable.prototype._isFirstInChain = function _isFirstInChain() {
	    return !this._masterModule;
	  };
	  /*
	    Method to check if the module is last in `then` chain.
	    @private
	    @returns {Boolean} If the module is the last in module chain.
	  */


	  Thenable.prototype._isLastInChain = function _isLastInChain() {
	    var master = this._masterModule;
	    // if there is no master field - check the modules length
	    // if module length is 1 thus there is no modules chain 
	    // it is the last one, otherwise it isnt
	    if (!master) {
	      return this._modules.length === 1;
	    }
	    // if there is master - check if it is the last item in _modules chain
	    return this === _h2.default.getLastItem(master._modules);
	  };

	  return Thenable;
	}(_tweenable2.default);

	exports.default = Thenable;

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _classCallCheck2 = __webpack_require__(74);

	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

	var _possibleConstructorReturn2 = __webpack_require__(75);

	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

	var _inherits2 = __webpack_require__(76);

	var _inherits3 = _interopRequireDefault(_inherits2);

	var _tween = __webpack_require__(101);

	var _tween2 = _interopRequireDefault(_tween);

	var _timeline = __webpack_require__(110);

	var _timeline2 = _interopRequireDefault(_timeline);

	var _module = __webpack_require__(84);

	var _module2 = _interopRequireDefault(_module);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/*
	  Class to define a module ancestor
	  with timeline and tween options and functionality.
	  All runable modules should inherit from this class.

	  @class Tweenable
	*/
	var Tweenable = function (_Module) {
	  (0, _inherits3.default)(Tweenable, _Module);

	  /*
	    `play` method for the timeline.
	    @public
	    @param {Number} Time shift.
	    @returns this.
	  */
	  Tweenable.prototype.play = function play() {
	    this.timeline.play.apply(this.timeline, arguments);
	    return this;
	  };
	  /*
	    `playBackward` method for the timeline.
	    @public
	    @param {Number} Time shift.
	    @returns this.
	  */


	  Tweenable.prototype.playBackward = function playBackward() {
	    this.timeline.playBackward.apply(this.timeline, arguments);
	    return this;
	  };
	  /*
	    `pause` method for the timeline.
	    @public
	    @returns this.
	  */


	  Tweenable.prototype.pause = function pause() {
	    this.timeline.pause.apply(this.timeline, arguments);
	    return this;
	  };
	  /*
	    `stop` method for the timeline.
	    @public
	    @param {Number} [0...1] Progress to set on stop.
	                            *Default* is `0` if `play`
	                            and `1` if `playBAckward`.
	    @returns this.
	  */


	  Tweenable.prototype.stop = function stop() {
	    this.timeline.stop.apply(this.timeline, arguments);
	    return this;
	  };
	  /*
	    `reset` method for the timeline.
	    @public
	    @returns this.
	  */


	  Tweenable.prototype.reset = function reset() {
	    this.timeline.reset.apply(this.timeline, arguments);
	    return this;
	  };
	  /*
	    `replay` method for the timeline.
	    @public
	    @returns this.
	  */


	  Tweenable.prototype.replay = function replay() {
	    this.timeline.replay.apply(this.timeline, arguments);
	    return this;
	  };
	  /*
	    `replay` method for the timeline.
	    @public
	    @returns this.
	  */


	  Tweenable.prototype.replayBackward = function replayBackward() {
	    this.timeline.replayBackward.apply(this.timeline, arguments);
	    return this;
	  };
	  /*
	    `resume` method for the timeline.
	    @public
	    @param {Number} Time shift.
	    @returns this.
	  */


	  Tweenable.prototype.resume = function resume() {
	    var shift = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

	    this.timeline.resume.apply(this.timeline, arguments);
	    return this;
	  };
	  /*
	    `setProgress` method for the timeline.
	    @public
	    @param {Number} [0...1] Progress value.
	    @returns this.
	  */


	  Tweenable.prototype.setProgress = function setProgress() {
	    this.timeline.setProgress.apply(this.timeline, arguments);
	    return this;
	  };
	  /*
	    setSpeed method for the timeline.
	    @param {Number} Speed value.
	    @returns this.
	  */


	  Tweenable.prototype.setSpeed = function setSpeed(speed) {
	    this.timeline.setSpeed.apply(this.timeline, arguments);
	    return this;
	  };

	  // ^ PUBLIC  METHOD(S) ^
	  // v PRIVATE METHOD(S) v

	  function Tweenable() {
	    var o = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    (0, _classCallCheck3.default)(this, Tweenable);

	    // pipe function for _o object
	    // before creating tween/timeline
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Module.call(this, o));
	    // super of Module


	    _this._transformTweenOptions();
	    // make tween only if isTweenLess option is not set
	    !_this._o.isTweenLess && _this._makeTween();
	    // make timeline only if isTimelineLess option is not set
	    !_this._o.isTimelineLess && _this._makeTimeline();
	    return _this;
	  }
	  /*
	    Placeholder method that should be overrided
	    and will be called before tween/timeline creation.
	    @private
	  */


	  Tweenable.prototype._transformTweenOptions = function _transformTweenOptions() {};
	  /*
	    Method to create tween.
	    @private
	  */


	  Tweenable.prototype._makeTween = function _makeTween() {
	    // pass callbacks context
	    this._o.callbacksContext = this._o.callbacksContext || this;
	    this.tween = new _tween2.default(this._o);
	    // make timeline property point to tween one is "no timeline" mode
	    this._o.isTimelineLess && (this.timeline = this.tween);
	  };
	  /*
	    Method to create timeline.
	    @private
	    @param {Object} Timeline's options.
	                    An object which contains "timeline" property with
	                    timeline options.
	  */


	  Tweenable.prototype._makeTimeline = function _makeTimeline() {
	    // pass callbacks context
	    this._o.timeline = this._o.timeline || {};
	    this._o.timeline.callbacksContext = this._o.callbacksContext || this;
	    this.timeline = new _timeline2.default(this._o.timeline);
	    // set the flag to indicate that real timeline is present
	    this._isTimeline = true;
	    // if tween exist - add it to the timeline there is some
	    // modules like burst and stagger that have no tween
	    this.tween && this.timeline.add(this.tween);
	  };

	  return Tweenable;
	}(_module2.default);

	exports.default = Tweenable;

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _classCallCheck2 = __webpack_require__(74);

	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

	var _possibleConstructorReturn2 = __webpack_require__(75);

	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

	var _inherits2 = __webpack_require__(76);

	var _inherits3 = _interopRequireDefault(_inherits2);

	var _h = __webpack_require__(71);

	var _h2 = _interopRequireDefault(_h);

	var _tweener = __webpack_require__(102);

	var _tweener2 = _interopRequireDefault(_tweener);

	var _easing = __webpack_require__(105);

	var _easing2 = _interopRequireDefault(_easing);

	var _module = __webpack_require__(84);

	var _module2 = _interopRequireDefault(_module);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// import h from '../h';
	var Tween = function (_Module) {
	  (0, _inherits3.default)(Tween, _Module);

	  /*
	    Method do declare defaults with this._defaults object.
	    @private
	  */
	  Tween.prototype._declareDefaults = function _declareDefaults() {
	    // DEFAULTS
	    this._defaults = {
	      /* duration of the tween [0..∞] */
	      duration: 350,
	      /* delay of the tween [-∞..∞] */
	      delay: 0,
	      /* repeat of the tween [0..∞], means how much to
	         repeat the tween regardless first run,
	         for instance repeat: 2 will make the tween run 3 times */
	      repeat: 0,
	      /* speed of playback [0..∞], speed that is less then 1
	         will slowdown playback, for instance .5 will make tween
	         run 2x slower. Speed of 2 will speedup the tween to 2x. */
	      speed: 1,
	      /*  flip onUpdate's progress on each even period.
	          note that callbacks order won't flip at least
	          for now (under consideration). */
	      isYoyo: false,
	      /* easing for the tween, could be any easing type [link to easing-types.md] */
	      easing: 'Sin.Out',
	      /*
	        Easing for backward direction of the tweenthe tween,
	        if `null` - fallbacks to `easing` property.
	        forward direction in `yoyo` period is treated as backward for the easing.
	      */
	      backwardEasing: null,
	      /* custom tween's name */
	      name: null,
	      /* custom tween's base name */
	      nameBase: 'Tween',
	      /*
	        onProgress callback runs before any other callback.
	        @param {Number}   The entire, not eased, progress
	                          of the tween regarding repeat option.
	        @param {Boolean}  The direction of the tween.
	                          `true` for forward direction.
	                          `false` for backward direction(tween runs in reverse).
	      */
	      onProgress: null,
	      /*
	        onStart callback runs on very start of the tween just after onProgress
	        one. Runs on very end of the tween if tween is reversed.
	        @param {Boolean}  Direction of the tween.
	                          `true` for forward direction.
	                          `false` for backward direction(tween runs in reverse).
	      */
	      onStart: null,
	      onRefresh: null,
	      onComplete: null,
	      onRepeatStart: null,
	      onRepeatComplete: null,
	      onFirstUpdate: null,
	      onUpdate: null,
	      isChained: false,
	      // playback callbacks
	      onPlaybackStart: null,
	      onPlaybackPause: null,
	      onPlaybackStop: null,
	      onPlaybackComplete: null,
	      // context which all callbacks will be called with
	      callbacksContext: null
	    };
	  };
	  /*
	    API method to play the Tween.
	    @public
	    @param  {Number} Shift time in milliseconds.
	    @return {Object} Self.
	  */


	  Tween.prototype.play = function play() {
	    var shift = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

	    if (this._state === 'play' && this._isRunning) {
	      return this;
	    }
	    this._props.isReversed = false;
	    this._subPlay(shift, 'play');
	    this._setPlaybackState('play');
	    return this;
	  };
	  /*
	    API method to play the Tween in reverse.
	    @public
	    @param  {Number} Shift time in milliseconds.
	    @return {Object} Self.
	  */


	  Tween.prototype.playBackward = function playBackward() {
	    var shift = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

	    if (this._state === 'reverse' && this._isRunning) {
	      return this;
	    }
	    this._props.isReversed = true;
	    this._subPlay(shift, 'reverse');
	    this._setPlaybackState('reverse');
	    return this;
	  };
	  /*
	    API method to pause Tween.
	    @public
	    @returns {Object} Self.
	  */


	  Tween.prototype.pause = function pause() {
	    if (this._state === 'pause' || this._state === 'stop') {
	      return this;
	    }
	    this._removeFromTweener();
	    this._setPlaybackState('pause');
	    return this;
	  };
	  /*
	    API method to stop the Tween.
	    @public
	    @param   {Number} Progress [0..1] to set when stopped.
	    @returns {Object} Self.
	  */


	  Tween.prototype.stop = function stop(progress) {
	    if (this._state === 'stop') {
	      return this;
	    }

	    this._wasUknownUpdate = undefined;

	    var stopProc = progress != null ? progress
	    /* if no progress passsed - set 1 if tween
	       is playingBackward, otherwise set to 0 */
	    : this._state === 'reverse' ? 1 : 0;

	    this.setProgress(stopProc);

	    this.reset();
	    return this;
	  };
	  /*
	    API method to replay(restart) the Tween.
	    @public
	    @param   {Number} Shift time in milliseconds.
	    @returns {Object} Self.
	  */


	  Tween.prototype.replay = function replay() {
	    var shift = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

	    this.reset();
	    this.play(shift);
	    return this;
	  };
	  /*
	    API method to replay(restart) backward the Tween.
	    @public
	    @param   {Number} Shift time in milliseconds.
	    @returns {Object} Self.
	  */


	  Tween.prototype.replayBackward = function replayBackward() {
	    var shift = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

	    this.reset();
	    this.playBackward(shift);
	    return this;
	  };
	  /*
	    API method to resume the Tween.
	    @public
	    @param  {Number} Shift time in milliseconds.
	    @return {Object} Self.
	  */


	  Tween.prototype.resume = function resume() {
	    var shift = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

	    if (this._state !== 'pause') {
	      return this;
	    }

	    switch (this._prevState) {
	      case 'play':
	        this.play(shift);
	        break;
	      case 'reverse':
	        this.playBackward(shift);
	        break;
	    }

	    return this;
	  };
	  /*
	    API method to set progress on tween.
	    @public
	    @param {Number} Progress to set.
	    @returns {Object} Self.
	  */


	  Tween.prototype.setProgress = function setProgress(progress) {
	    var p = this._props;
	    // set start time if there is no one yet.
	    !p.startTime && this._setStartTime();
	    // reset play time
	    this._playTime = null;
	    // progress should be in range of [0..1]
	    progress < 0 && (progress = 0);
	    progress > 1 && (progress = 1);
	    // update self with calculated time
	    this._update(p.startTime - p.delay + progress * p.repeatTime);
	    return this;
	  };
	  /*
	    Method to set tween's speed.
	    @public
	    @param {Number} Speed value.
	    @returns this.
	  */


	  Tween.prototype.setSpeed = function setSpeed(speed) {
	    this._props.speed = speed;
	    // if playing - normalize _startTime and _prevTime to the current point.
	    if (this._state === 'play' || this._state === 'reverse') {
	      this._setResumeTime(this._state);
	    }
	    return this;
	  };
	  /*
	    Method to reset tween's state and properties.
	    @public
	    @returns this.
	  */


	  Tween.prototype.reset = function reset() {
	    this._removeFromTweener();
	    this._setPlaybackState('stop');
	    this._progressTime = 0;
	    this._isCompleted = false;
	    this._isStarted = false;
	    this._isFirstUpdate = false;
	    this._wasUknownUpdate = undefined;
	    this._prevTime = undefined;
	    this._prevYoyo = undefined;
	    // this._props.startTime  = undefined;
	    this._props.isReversed = false;
	    return this;
	  };

	  // ^ PUBLIC  METHOD(S) ^
	  // v PRIVATE METHOD(S) v

	  /*
	    Method to launch play. Used as launch
	    method for bothplay and reverse methods.
	    @private
	    @param  {Number} Shift time in milliseconds.
	    @param  {String} Play or reverse state.
	    @return {Object} Self.
	  */


	  Tween.prototype._subPlay = function _subPlay() {
	    var shift = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	    var state = arguments[1];

	    var resumeTime,
	        startTime,
	        p = this._props,

	    // check if direction of playback changes,
	    // if so, the _progressTime needs to be flipped
	    _state = this._state,
	        _prevState = this._prevState,
	        isPause = _state === 'pause',
	        wasPlay = _state === 'play' || isPause && _prevState === 'play',
	        wasReverse = _state === 'reverse' || isPause && _prevState === 'reverse',
	        isFlip = wasPlay && state === 'reverse' || wasReverse && state === 'play';

	    // if tween was ended, set progress to 0 if not, set to elapsed progress
	    this._progressTime = this._progressTime >= p.repeatTime ? 0 : this._progressTime;
	    // flip the _progressTime if playback direction changed
	    if (isFlip) {
	      this._progressTime = p.repeatTime - this._progressTime;
	    }
	    // set resume time and normalize prev/start times
	    this._setResumeTime(state, shift);
	    // add self to tweener = play
	    _tweener2.default.add(this);
	    return this;
	  };
	  /*
	    Method to set _resumeTime, _startTime and _prevTime.
	    @private
	    @param {String} Current state. [play, reverse]
	    @param {Number} Time shift. *Default* is 0.
	  */


	  Tween.prototype._setResumeTime = function _setResumeTime(state) {
	    var shift = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

	    // get current moment as resume time
	    this._resumeTime = performance.now();
	    // set start time regarding passed `shift` and `procTime`
	    var startTime = this._resumeTime - Math.abs(shift) - this._progressTime;
	    this._setStartTime(startTime, false);
	    // if we have prevTime - we need to normalize
	    // it for the current resume time
	    if (this._prevTime != null) {
	      this._prevTime = state === 'play' ? this._normPrevTimeForward() : this._props.endTime - this._progressTime;
	    }
	  };
	  /*
	    Method recalculate _prevTime for forward direction.
	    @private
	    @return {Number} Normalized prev time.
	  */


	  Tween.prototype._normPrevTimeForward = function _normPrevTimeForward() {
	    var p = this._props;
	    return p.startTime + this._progressTime - p.delay;
	  };
	  /*
	    Constructor of the class.
	    @private
	  */


	  function Tween() {
	    var _ret;

	    var o = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    (0, _classCallCheck3.default)(this, Tween);

	    var _this = (0, _possibleConstructorReturn3.default)(this, _Module.call(this, o));

	    _this._props.name == null && _this._setSelfName();
	    return _ret = _this, (0, _possibleConstructorReturn3.default)(_this, _ret);
	  }
	  /*
	    Method to set self name to generic one.
	    @private
	  */


	  Tween.prototype._setSelfName = function _setSelfName() {
	    var globalName = '_' + this._props.nameBase + 's';
	    // track amount of tweens globally
	    _tweener2.default[globalName] = _tweener2.default[globalName] == null ? 1 : ++_tweener2.default[globalName];
	    // and set generic tween's name  || Tween # ||
	    this._props.name = this._props.nameBase + ' ' + _tweener2.default[globalName];
	  };
	  /*
	    Method set playback state string.
	    @private
	    @param {String} State name
	  */


	  Tween.prototype._setPlaybackState = function _setPlaybackState(state) {
	    // save previous state
	    this._prevState = this._state;
	    this._state = state;

	    // callbacks
	    var wasPause = this._prevState === 'pause',
	        wasStop = this._prevState === 'stop',
	        wasPlay = this._prevState === 'play',
	        wasReverse = this._prevState === 'reverse',
	        wasPlaying = wasPlay || wasReverse,
	        wasStill = wasStop || wasPause;

	    if ((state === 'play' || state === 'reverse') && wasStill) {
	      this._playbackStart();
	    }
	    if (state === 'pause' && wasPlaying) {
	      this._playbackPause();
	    }
	    if (state === 'stop' && (wasPlaying || wasPause)) {
	      this._playbackStop();
	    }
	  };
	  /*
	    Method to declare some vars.
	    @private
	  */


	  Tween.prototype._vars = function _vars() {
	    this.progress = 0;
	    this._prevTime = undefined;
	    this._progressTime = 0;
	    this._negativeShift = 0;
	    this._state = 'stop';
	    // if negative delay was specified,
	    // save it to _negativeShift property and
	    // reset it back to 0
	    if (this._props.delay < 0) {
	      this._negativeShift = this._props.delay;
	      this._props.delay = 0;
	    }

	    return this._calcDimentions();
	  };
	  /*
	    Method to calculate tween's dimentions.
	    @private
	  */


	  Tween.prototype._calcDimentions = function _calcDimentions() {
	    this._props.time = this._props.duration + this._props.delay;
	    this._props.repeatTime = this._props.time * (this._props.repeat + 1);
	  };
	  /*
	    Method to extend defaults by options and put them in _props.
	    @private
	  */


	  Tween.prototype._extendDefaults = function _extendDefaults() {
	    // save callback overrides object with fallback to empty one
	    this._callbackOverrides = this._o.callbackOverrides || {};
	    delete this._o.callbackOverrides;
	    // call the _extendDefaults @ Module
	    _Module.prototype._extendDefaults.call(this);

	    var p = this._props;
	    p.easing = _easing2.default.parseEasing(p.easing);
	    p.easing._parent = this;

	    // parse only present backward easing to prevent parsing as `linear.none`
	    // because we need to fallback to `easing` in `_setProgress` method
	    if (p.backwardEasing != null) {
	      p.backwardEasing = _easing2.default.parseEasing(p.backwardEasing);
	      p.backwardEasing._parent = this;
	    }
	  };
	  /*
	    Method for setting start and end time to props.
	    @private
	    @param {Number(Timestamp)}, {Null} Start time.
	    @param {Boolean} Should reset flags.
	    @returns this
	  */


	  Tween.prototype._setStartTime = function _setStartTime(time) {
	    var isResetFlags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

	    var p = this._props,
	        shiftTime = p.shiftTime || 0;
	    // reset flags
	    if (isResetFlags) {
	      this._isCompleted = false;this._isRepeatCompleted = false;
	      this._isStarted = false;
	    }
	    // set start time to passed time or to the current moment
	    var startTime = time == null ? performance.now() : time;
	    // calculate bounds
	    // - negativeShift is negative delay in options hash
	    // - shift time is shift of the parent
	    p.startTime = startTime + p.delay + this._negativeShift + shiftTime;
	    p.endTime = p.startTime + p.repeatTime - p.delay;
	    // set play time to the startTimes
	    // if playback controls are used - use _resumeTime as play time,
	    // else use shifted startTime -- shift is needed for timelines append chains
	    this._playTime = this._resumeTime != null ? this._resumeTime : startTime + shiftTime;
	    this._resumeTime = null;

	    return this;
	  };
	  /*
	    Method to update tween's progress.
	    @private
	    @param {Number} Current update time.
	    -- next params only present when parent Timeline calls the method.
	    @param {Number} Previous Timeline's update time.
	    @param {Boolean} Was parent in yoyo period.
	    @param {Number} [-1, 0, 1] If update is on edge.
	                   -1 = edge jump in negative direction.
	                    0 = no edge jump.
	                    1 = edge jump in positive direction.
	  */


	  Tween.prototype._update = function _update(time, timelinePrevTime, wasYoyo, onEdge) {
	    var p = this._props;
	    // if we don't the _prevTime thus the direction we are heading to,
	    // but prevTime was passed thus we are child of a Timeline
	    // set _prevTime to passed one and pretent that there was unknown
	    // update to not to block start/complete callbacks
	    if (this._prevTime == null && timelinePrevTime != null) {

	      if (this._props.speed && this._playTime) {
	        // play point + ( speed * delta )
	        this._prevTime = this._playTime + this._props.speed * (timelinePrevTime - this._playTime);
	      }
	      // this._prevTime = timelinePrevTime;
	      this._wasUknownUpdate = true;
	    }

	    // var before = time;
	    // cache vars
	    var startPoint = p.startTime - p.delay;
	    // if speed param was defined - calculate
	    // new time regarding speed
	    if (p.speed && this._playTime) {
	      // play point + ( speed * delta )
	      time = this._playTime + p.speed * (time - this._playTime);
	    }

	    // due to javascript precision issues, after speed mapping
	    // we can get very close number that was made from progress of 1
	    // and in fact represents `endTime` if so, set the time to `endTime`
	    if (Math.abs(p.endTime - time) < 0.00000001) {
	      time = p.endTime;
	    }

	    // if parent is onEdge but not very start nor very end
	    if (onEdge && wasYoyo != null) {
	      var T = this._getPeriod(time),
	          isYoyo = !!(p.isYoyo && this._props.repeat && T % 2 === 1);

	      // for timeline
	      // notify children about edge jump
	      if (this._timelines) {
	        for (var i = 0; i < this._timelines.length; i++) {
	          this._timelines[i]._update(time, timelinePrevTime, wasYoyo, onEdge);
	        }
	      }
	      // forward edge direction
	      if (onEdge === 1) {
	        // jumped from yoyo period?
	        if (wasYoyo) {
	          this._prevTime = time + 1;
	          this._repeatStart(time, isYoyo);
	          this._start(time, isYoyo);
	        } else {
	          this._prevTime = time - 1;
	          this._repeatComplete(time, isYoyo);
	          this._complete(time, isYoyo);
	        }
	        // backward edge direction
	      } else if (onEdge === -1) {
	        // jumped from yoyo period?
	        if (wasYoyo) {
	          this._prevTime = time - 1;
	          this._repeatComplete(time, isYoyo);
	          this._complete(time, isYoyo);
	        } else {
	          // call _start callbacks only if prev time was in active area
	          // not always true for append chains
	          if (this._prevTime >= p.startTime && this._prevTime <= p.endTime) {
	            this._prevTime = time + 1;
	            this._repeatStart(time, isYoyo);
	            this._start(time, isYoyo);
	            // reset isCOmpleted immediately to prevent onComplete cb
	            this._isCompleted = true;
	          }
	        }
	      }
	      // reset the _prevTime - drop one frame to undestand
	      // where we are heading
	      this._prevTime = undefined;
	    }
	    // if in active area and not ended - save progress time
	    // for pause/play purposes.
	    if (time > startPoint && time < p.endTime) {
	      this._progressTime = time - startPoint;
	    }
	    // else if not started or ended set progress time to 0
	    else if (time <= startPoint) {
	        this._progressTime = 0;
	      } else if (time >= p.endTime) {
	        // set progress time to repeat time + tiny cofficient
	        // to make it extend further than the end time
	        this._progressTime = p.repeatTime + .00000000001;
	      }
	    // reverse time if _props.isReversed is set
	    if (p.isReversed) {
	      time = p.endTime - this._progressTime;
	    }
	    // We need to know what direction we are heading to,
	    // so if we don't have the previous update value - this is very first
	    // update, - skip it entirely and wait for the next value
	    if (this._prevTime == null) {
	      this._prevTime = time;
	      this._wasUknownUpdate = true;
	      return false;
	    }

	    // ====== AFTER SKIPPED FRAME ======

	    // handle onProgress callback
	    if (time >= startPoint && time <= p.endTime) {
	      this._progress((time - startPoint) / p.repeatTime, time);
	    }
	    /*
	      if time is inside the active area of the tween.
	      active area is the area from start time to end time,
	      with all the repeat and delays in it
	    */
	    if (time >= p.startTime && time <= p.endTime) {
	      this._updateInActiveArea(time);
	    } else {
	      // if was in active area - update in inactive area but just once -
	      // right after the active area
	      if (this._isInActiveArea) {
	        this._updateInInactiveArea(time);
	      } else if (!this._isRefreshed) {
	        // onRefresh callback
	        // before startTime
	        if (time < p.startTime && this.progress !== 0) {
	          this._refresh(true);
	          this._isRefreshed = true;
	          // after endTime
	        }
	        // else if ( time > p.endTime ) { }
	      }
	    }

	    this._prevTime = time;
	    return time >= p.endTime || time <= startPoint;
	  };
	  /*
	    Method to handle tween's progress in inactive area.
	    @private
	    @param {Number} Current update time.
	  */


	  Tween.prototype._updateInInactiveArea = function _updateInInactiveArea(time) {
	    if (!this._isInActiveArea) {
	      return;
	    }
	    var p = this._props;
	    // complete if time is larger then end time
	    if (time > p.endTime && !this._isCompleted) {
	      this._progress(1, time);
	      // get period number
	      var T = this._getPeriod(p.endTime),
	          isYoyo = p.isYoyo && T % 2 === 0;

	      this._setProgress(isYoyo ? 0 : 1, time, isYoyo);
	      this._repeatComplete(time, isYoyo);
	      this._complete(time, isYoyo);
	    }
	    // if was active and went to - inactive area "-"
	    if (time < this._prevTime && time < p.startTime && !this._isStarted && !this._isCompleted) {
	      // if was in active area and didn't fire onStart callback
	      this._progress(0, time, false);
	      this._setProgress(0, time, false);
	      this._isRepeatStart = false;
	      this._repeatStart(time, false);
	      this._start(time, false);
	    }
	    this._isInActiveArea = false;
	  };
	  /*
	    Method to handle tween's progress in active area.
	    @private
	    @param {Number} Current update time.
	  */


	  Tween.prototype._updateInActiveArea = function _updateInActiveArea(time) {

	    var props = this._props,
	        delayDuration = props.delay + props.duration,
	        startPoint = props.startTime - props.delay,
	        elapsed = (time - props.startTime + props.delay) % delayDuration,
	        TCount = Math.round((props.endTime - props.startTime + props.delay) / delayDuration),
	        T = this._getPeriod(time),
	        TValue = this._delayT,
	        prevT = this._getPeriod(this._prevTime),
	        TPrevValue = this._delayT;

	    // "zero" and "one" value regarding yoyo and it's period
	    var isYoyo = props.isYoyo && T % 2 === 1,
	        isYoyoPrev = props.isYoyo && prevT % 2 === 1,
	        yoyoZero = isYoyo ? 1 : 0,
	        yoyoOne = 1 - yoyoZero;

	    if (time === props.endTime) {
	      this._wasUknownUpdate = false;
	      // if `time` is equal to `endTime`, T represents the next period,
	      // so we need to decrement T and calculate "one" value regarding yoyo
	      var isYoyo = props.isYoyo && (T - 1) % 2 === 1;
	      this._setProgress(isYoyo ? 0 : 1, time, isYoyo);
	      if (time > this._prevTime) {
	        this._isRepeatCompleted = false;
	      }
	      this._repeatComplete(time, isYoyo);
	      return this._complete(time, isYoyo);
	    }

	    // reset callback flags
	    this._isCompleted = false;
	    this._isRefreshed = false;
	    // if time is inside the duration area of the tween
	    if (startPoint + elapsed >= props.startTime) {
	      this._isInActiveArea = true;this._isRepeatCompleted = false;
	      this._isRepeatStart = false;this._isStarted = false;
	      // active zone or larger then end
	      var elapsed2 = (time - props.startTime) % delayDuration,
	          proc = elapsed2 / props.duration;
	      // |=====|=====|=====| >>>
	      //      ^1^2
	      var isOnEdge = T > 0 && prevT < T;
	      // |=====|=====|=====| <<<
	      //      ^2^1
	      var isOnReverseEdge = prevT > T;

	      // for use in timeline
	      this._onEdge = 0;
	      isOnEdge && (this._onEdge = 1);
	      isOnReverseEdge && (this._onEdge = -1);

	      if (this._wasUknownUpdate) {
	        if (time > this._prevTime) {
	          this._start(time, isYoyo);
	          this._repeatStart(time, isYoyo);
	          this._firstUpdate(time, isYoyo);
	        }
	        // if backward direction and 
	        // if ( time < this._prevTime && time !== this._props.startTime ) {
	        if (time < this._prevTime) {
	          this._complete(time, isYoyo);
	          this._repeatComplete(time, isYoyo);
	          this._firstUpdate(time, isYoyo);
	          // reset isCompleted immediately
	          this._isCompleted = false;
	        }
	      }

	      if (isOnEdge) {
	        // if not just after delay
	        // |---=====|---=====|---=====| >>>
	        //            ^1 ^2
	        // because we have already handled
	        // 1 and onRepeatComplete in delay gap
	        if (this.progress !== 1) {
	          // prevT
	          var isThisYoyo = props.isYoyo && (T - 1) % 2 === 1;
	          this._repeatComplete(time, isThisYoyo);
	        }
	        // if on edge but not at very start
	        // |=====|=====|=====| >>>
	        // ^!    ^here ^here 
	        if (prevT >= 0) {
	          this._repeatStart(time, isYoyo);
	        }
	      }

	      if (time > this._prevTime) {
	        //  |=====|=====|=====| >>>
	        // ^1  ^2
	        if (!this._isStarted && this._prevTime <= props.startTime) {
	          this._start(time, isYoyo);
	          this._repeatStart(time, isYoyo);
	          // it was zero anyways

	          // restart flags immediately in case if we will
	          // return to '-' inactive area on the next step
	          this._isStarted = false;
	          this._isRepeatStart = false;
	        }
	        this._firstUpdate(time, isYoyo);
	      }

	      if (isOnReverseEdge) {
	        // if on edge but not at very end
	        // |=====|=====|=====| <<<
	        //       ^here ^here ^not here
	        if (this.progress !== 0 && this.progress !== 1 && prevT != TCount) {
	          this._repeatStart(time, isYoyoPrev);
	        }
	        // if on very end edge
	        // |=====|=====|=====| <<<
	        //       ^!    ^! ^2 ^1
	        // we have handled the case in this._wasUknownUpdate
	        // block so filter that
	        if (prevT === TCount && !this._wasUknownUpdate) {
	          this._complete(time, isYoyo);
	          this._repeatComplete(time, isYoyo);
	          this._firstUpdate(time, isYoyo);
	          // reset isComplete flag call
	          // cuz we returned to active area
	          // this._isRepeatCompleted = false;
	          this._isCompleted = false;
	        }
	        this._repeatComplete(time, isYoyo);
	      }

	      if (prevT === 'delay') {
	        // if just before delay gap
	        // |---=====|---=====|---=====| <<<
	        //               ^2    ^1
	        if (T < TPrevValue) {
	          this._repeatComplete(time, isYoyo);
	        }
	        // if just after delay gap
	        // |---=====|---=====|---=====| >>>
	        //            ^1  ^2
	        if (T === TPrevValue && T > 0) {
	          this._repeatStart(time, isYoyo);
	        }
	      }

	      // swap progress and repeatStart based on direction
	      if (time > this._prevTime) {
	        // if progress is equal 0 and progress grows
	        if (proc === 0) {
	          this._repeatStart(time, isYoyo);
	        }
	        if (time !== props.endTime) {
	          this._setProgress(isYoyo ? 1 - proc : proc, time, isYoyo);
	        }
	      } else {
	        if (time !== props.endTime) {
	          this._setProgress(isYoyo ? 1 - proc : proc, time, isYoyo);
	        }
	        // if progress is equal 0 and progress grows
	        if (proc === 0) {
	          this._repeatStart(time, isYoyo);
	        }
	      }

	      if (time === props.startTime) {
	        this._start(time, isYoyo);
	      }
	      // delay gap - react only once
	    } else if (this._isInActiveArea) {
	      // because T will be string of "delay" here,
	      // let's normalize it be setting to TValue
	      var t = T === 'delay' ? TValue : T,
	          isGrows = time > this._prevTime;
	      // decrement period if forward direction of update
	      isGrows && t--;
	      // calculate normalized yoyoZero value
	      yoyoZero = props.isYoyo && t % 2 === 1 ? 1 : 0;
	      // if was in active area and previous time was larger
	      // |---=====|---=====|---=====| <<<
	      //   ^2 ^1    ^2 ^1    ^2 ^1
	      if (time < this._prevTime) {
	        this._setProgress(yoyoZero, time, yoyoZero === 1);
	        this._repeatStart(time, yoyoZero === 1);
	      }
	      // set 1 or 0 regarding direction and yoyo
	      this._setProgress(isGrows ? 1 - yoyoZero : yoyoZero, time, yoyoZero === 1);
	      // if time grows
	      if (time > this._prevTime) {
	        // if reverse direction and in delay gap, then progress will be 0
	        // if so we don't need to call the onRepeatComplete callback
	        // |---=====|---=====|---=====| <<<
	        //   ^0       ^0       ^0   
	        // OR we have flipped 0 to 1 regarding yoyo option
	        if (this.progress !== 0 || yoyoZero === 1) {
	          // since we repeatComplete for previous period
	          // invert isYoyo option
	          // is elapsed is 0 - count as previous period
	          this._repeatComplete(time, yoyoZero === 1);
	        }
	      }
	      // set flag to indicate inactive area
	      this._isInActiveArea = false;
	    }
	    // we've got the first update now
	    this._wasUknownUpdate = false;
	  };
	  /*
	    Method to remove the Tween from the tweener.
	    @private
	    @returns {Object} Self.
	  */


	  Tween.prototype._removeFromTweener = function _removeFromTweener() {
	    _tweener2.default.remove(this);return this;
	  };
	  /*
	    Method to get current period number.
	    @private
	    @param {Number} Time to get the period for.
	    @returns {Number} Current period number.
	  */


	  Tween.prototype._getPeriod = function _getPeriod(time) {
	    var p = this._props,
	        TTime = p.delay + p.duration,
	        dTime = p.delay + time - p.startTime,
	        T = dTime / TTime,

	    // if time if equal to endTime we need to set the elapsed
	    // time to 0 to fix the occasional precision js bug, which
	    // causes 0 to be something like 1e-12
	    elapsed = time < p.endTime ? dTime % TTime : 0;
	    // If the latest period, round the result, otherwise floor it.
	    // Basically we always can floor the result, but because of js
	    // precision issues, sometimes the result is 2.99999998 which
	    // will result in 2 instead of 3 after the floor operation.
	    T = time >= p.endTime ? Math.round(T) : Math.floor(T);
	    // if time is larger then the end time
	    if (time > p.endTime) {
	      // set equal to the periods count
	      T = Math.round((p.endTime - p.startTime + p.delay) / TTime);
	      // if in delay gap, set _delayT to current
	      // period number and return "delay"
	    } else if (elapsed > 0 && elapsed < p.delay) {
	      this._delayT = T;T = 'delay';
	    }
	    // if the end of period and there is a delay
	    return T;
	  };
	  /*
	    Method to set Tween's progress and call onUpdate callback.
	    @private
	    @override @ Module
	    @param {Number} Progress to set.
	    @param {Number} Current update time.
	    @param {Boolean} Is yoyo perido. Used in Timeline to pass to Tween.
	    @returns {Object} Self.
	  */


	  Tween.prototype._setProgress = function _setProgress(proc, time, isYoyo) {
	    var p = this._props,
	        isYoyoChanged = p.wasYoyo !== isYoyo,
	        isForward = time > this._prevTime;

	    this.progress = proc;
	    // get the current easing for `forward` direction regarding `yoyo`
	    if (isForward && !isYoyo || !isForward && isYoyo) {
	      this.easedProgress = p.easing(proc);
	      // get the current easing for `backward` direction regarding `yoyo`
	    } else if (!isForward && !isYoyo || isForward && isYoyo) {
	      var easing = p.backwardEasing != null ? p.backwardEasing : p.easing;

	      this.easedProgress = easing(proc);
	    }

	    if (p.prevEasedProgress !== this.easedProgress || isYoyoChanged) {
	      if (p.onUpdate != null && typeof p.onUpdate === 'function') {
	        p.onUpdate.call(p.callbacksContext || this, this.easedProgress, this.progress, isForward, isYoyo);
	      }
	    }
	    p.prevEasedProgress = this.easedProgress;
	    p.wasYoyo = isYoyo;
	    return this;
	  };
	  /*
	    Method to set tween's state to start and call onStart callback.
	    @method _start
	    @private
	    @param {Number} Progress to set.
	    @param {Boolean} Is yoyo period.
	  */


	  Tween.prototype._start = function _start(time, isYoyo) {
	    if (this._isStarted) {
	      return;
	    }
	    var p = this._props;
	    if (p.onStart != null && typeof p.onStart === 'function') {
	      p.onStart.call(p.callbacksContext || this, time > this._prevTime, isYoyo);
	    }
	    this._isCompleted = false;this._isStarted = true;
	    this._isFirstUpdate = false;
	  };
	  /*
	    Method to call onPlaybackStart callback
	    @private
	  */


	  Tween.prototype._playbackStart = function _playbackStart() {
	    var p = this._props;
	    if (p.onPlaybackStart != null && typeof p.onPlaybackStart === 'function') {
	      p.onPlaybackStart.call(p.callbacksContext || this);
	    }
	  };
	  /*
	    Method to call onPlaybackPause callback
	    @private
	  */


	  Tween.prototype._playbackPause = function _playbackPause() {
	    var p = this._props;
	    if (p.onPlaybackPause != null && typeof p.onPlaybackPause === 'function') {
	      p.onPlaybackPause.call(p.callbacksContext || this);
	    }
	  };
	  /*
	    Method to call onPlaybackStop callback
	    @private
	  */


	  Tween.prototype._playbackStop = function _playbackStop() {
	    var p = this._props;
	    if (p.onPlaybackStop != null && typeof p.onPlaybackStop === 'function') {
	      p.onPlaybackStop.call(p.callbacksContext || this);
	    }
	  };
	  /*
	    Method to call onPlaybackComplete callback
	    @private
	  */


	  Tween.prototype._playbackComplete = function _playbackComplete() {
	    var p = this._props;
	    if (p.onPlaybackComplete != null && typeof p.onPlaybackComplete === 'function') {
	      p.onPlaybackComplete.call(p.callbacksContext || this);
	    }
	  };
	  /*
	    Method to set tween's state to complete.
	    @method _complete
	    @private
	    @param {Number} Current time.
	    @param {Boolean} Is yoyo period.
	  */


	  Tween.prototype._complete = function _complete(time, isYoyo) {
	    if (this._isCompleted) {
	      return;
	    }
	    var p = this._props;
	    if (p.onComplete != null && typeof p.onComplete === 'function') {
	      p.onComplete.call(p.callbacksContext || this, time > this._prevTime, isYoyo);
	    }

	    this._isCompleted = true;this._isStarted = false;
	    this._isFirstUpdate = false;
	    // reset _prevYoyo for timeline usage
	    this._prevYoyo = undefined;
	  };

	  /*
	    Method to run onFirstUpdate callback.
	    @method _firstUpdate
	    @private
	    @param {Number} Current update time.
	    @param {Boolean} Is yoyo period.
	  */


	  Tween.prototype._firstUpdate = function _firstUpdate(time, isYoyo) {
	    if (this._isFirstUpdate) {
	      return;
	    }
	    var p = this._props;
	    if (p.onFirstUpdate != null && typeof p.onFirstUpdate === 'function') {
	      // onFirstUpdate should have tween pointer
	      p.onFirstUpdate.tween = this;
	      p.onFirstUpdate.call(p.callbacksContext || this, time > this._prevTime, isYoyo);
	    }
	    this._isFirstUpdate = true;
	  };
	  /*
	    Method call onRepeatComplete calback and set flags.
	    @private
	    @param {Number} Current update time.
	    @param {Boolean} Is repeat period.
	  */


	  Tween.prototype._repeatComplete = function _repeatComplete(time, isYoyo) {
	    if (this._isRepeatCompleted) {
	      return;
	    }
	    var p = this._props;
	    if (p.onRepeatComplete != null && typeof p.onRepeatComplete === 'function') {
	      p.onRepeatComplete.call(p.callbacksContext || this, time > this._prevTime, isYoyo);
	    }
	    this._isRepeatCompleted = true;
	    // this._prevYoyo = null;
	  };

	  /*
	    Method call onRepeatStart calback and set flags.
	    @private
	    @param {Number} Current update time.
	    @param {Boolean} Is yoyo period.
	  */


	  Tween.prototype._repeatStart = function _repeatStart(time, isYoyo) {
	    if (this._isRepeatStart) {
	      return;
	    }
	    var p = this._props;
	    if (p.onRepeatStart != null && typeof p.onRepeatStart === 'function') {
	      p.onRepeatStart.call(p.callbacksContext || this, time > this._prevTime, isYoyo);
	    }
	    this._isRepeatStart = true;
	  };
	  /*
	    Method to launch onProgress callback.
	    @method _progress
	    @private
	    @param {Number} Progress to set.
	  */


	  Tween.prototype._progress = function _progress(progress, time) {
	    var p = this._props;
	    if (p.onProgress != null && typeof p.onProgress === 'function') {
	      p.onProgress.call(p.callbacksContext || this, progress, time > this._prevTime);
	    }
	  };
	  /*
	    Method to launch onRefresh callback.
	    @method _refresh
	    @private
	    @param {Boolean} If refresh even before start time.
	  */


	  Tween.prototype._refresh = function _refresh(isBefore) {
	    var p = this._props;
	    if (p.onRefresh != null) {
	      var context = p.callbacksContext || this,
	          progress = isBefore ? 0 : 1;

	      p.onRefresh.call(context, isBefore, p.easing(progress), progress);
	    }
	  };
	  /*
	    Method which is called when the tween is removed from tweener.
	    @private
	  */


	  Tween.prototype._onTweenerRemove = function _onTweenerRemove() {};
	  /*
	    Method which is called when the tween is removed
	    from tweener when finished.
	    @private
	  */


	  Tween.prototype._onTweenerFinish = function _onTweenerFinish() {
	    this._setPlaybackState('stop');
	    this._playbackComplete();
	  };
	  /*
	    Method to set property[s] on Tween.
	    @private
	    @override @ Module
	    @param {Object, String} Hash object of key/value pairs, or property name.
	    @param {_} Property's value to set.
	  */


	  Tween.prototype._setProp = function _setProp(obj, value) {
	    _Module.prototype._setProp.call(this, obj, value);
	    this._calcDimentions();
	  };
	  /*
	    Method to set single property.
	    @private
	    @override @ Module
	    @param {String} Name of the property.
	    @param {Any} Value for the property.
	  */


	  Tween.prototype._assignProp = function _assignProp(key, value) {
	    // fallback to defaults
	    if (value == null) {
	      value = this._defaults[key];
	    }
	    // parse easing
	    if (key === 'easing') {
	      value = _easing2.default.parseEasing(value);
	      value._parent = this;
	    }
	    // handle control callbacks overrides
	    var control = this._callbackOverrides[key],
	        isntOverriden = !value || !value.isMojsCallbackOverride;
	    if (control && isntOverriden) {
	      value = this._overrideCallback(value, control);
	    }
	    // call super on Module
	    _Module.prototype._assignProp.call(this, key, value);
	  };
	  /*
	    Method to override callback for controll pupropes.
	    @private
	    @param {String}    Callback name.
	    @parma {Function}  Method to call  
	  */


	  Tween.prototype._overrideCallback = function _overrideCallback(callback, fun) {
	    var isCallback = callback && typeof callback === 'function',
	        override = function callbackOverride() {
	      // call overriden callback if it exists
	      isCallback && callback.apply(this, arguments);
	      // call the passed cleanup function
	      fun.apply(this, arguments);
	    };
	    // add overridden flag
	    override.isMojsCallbackOverride = true;
	    return override;
	  };

	  // _visualizeProgress(time) {
	  //   var str = '|',
	  //       procStr = ' ',
	  //       p = this._props,
	  //       proc = p.startTime - p.delay;

	  //   while ( proc < p.endTime ) {
	  //     if (p.delay > 0 ) {
	  //       var newProc = proc + p.delay;
	  //       if ( time > proc && time < newProc ) {
	  //         procStr += ' ^ ';
	  //       } else {
	  //         procStr += '   ';
	  //       }
	  //       proc = newProc;
	  //       str  += '---';
	  //     }
	  //     var newProc = proc + p.duration;
	  //     if ( time > proc && time < newProc ) {
	  //       procStr += '  ^   ';
	  //     } else if (time === proc) {
	  //       procStr += '^     ';
	  //     } else if (time === newProc) {
	  //       procStr += '    ^ ';
	  //     } else {
	  //       procStr += '      ';
	  //     }
	  //     proc = newProc;
	  //     str += '=====|';
	  //   }

	  //   console.log(str);
	  //   console.log(procStr);
	  // }


	  return Tween;
	}(_module2.default);

	exports.default = Tween;

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _classCallCheck2 = __webpack_require__(74);

	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

	__webpack_require__(103);

	__webpack_require__(104);

	var _h = __webpack_require__(71);

	var _h2 = _interopRequireDefault(_h);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var Tweener = function () {
	  function Tweener() {
	    (0, _classCallCheck3.default)(this, Tweener);

	    this._vars();
	    this._listenVisibilityChange();
	    return this;
	  }

	  Tweener.prototype._vars = function _vars() {
	    this.tweens = [];
	    this._savedTweens = [];
	    this._loop = this._loop.bind(this);
	    this._onVisibilityChange = this._onVisibilityChange.bind(this);
	  };
	  /*
	    Main animation loop. Should have only one concurrent loop.
	    @private
	    @returns this
	  */


	  Tweener.prototype._loop = function _loop() {
	    if (!this._isRunning) {
	      return false;
	    }
	    this._update(window.performance.now());
	    if (!this.tweens.length) {
	      return this._isRunning = false;
	    }
	    requestAnimationFrame(this._loop);
	    return this;
	  };
	  /*
	    Method to start animation loop.
	    @private
	  */


	  Tweener.prototype._startLoop = function _startLoop() {
	    if (this._isRunning) {
	      return;
	    };this._isRunning = true;
	    requestAnimationFrame(this._loop);
	  };
	  /*
	    Method to stop animation loop.
	    @private
	  */


	  Tweener.prototype._stopLoop = function _stopLoop() {
	    this._isRunning = false;
	  };
	  /*
	    Method to update every tween/timeline on animation frame.
	    @private
	  */


	  Tweener.prototype._update = function _update(time) {
	    var i = this.tweens.length;
	    while (i--) {
	      // cache the current tween
	      var tween = this.tweens[i];
	      if (tween && tween._update(time) === true) {
	        this.remove(tween);
	        tween._onTweenerFinish();
	        tween._prevTime = undefined;
	      }
	    }
	  };
	  /*
	    Method to add a Tween/Timeline to loop pool.
	    @param {Object} Tween/Timeline to add.
	  */


	  Tweener.prototype.add = function add(tween) {
	    // return if tween is already running
	    if (tween._isRunning) {
	      return;
	    }
	    tween._isRunning = true;
	    this.tweens.push(tween);
	    this._startLoop();
	  };
	  /*
	    Method stop updating all the child tweens/timelines.
	    @private
	  */


	  Tweener.prototype.removeAll = function removeAll() {
	    this.tweens.length = 0;
	  };
	  /*
	    Method to remove specific tween/timeline form updating.
	    @private
	  */


	  Tweener.prototype.remove = function remove(tween) {
	    var index = typeof tween === 'number' ? tween : this.tweens.indexOf(tween);

	    if (index !== -1) {
	      tween = this.tweens[index];
	      if (tween) {
	        tween._isRunning = false;
	        this.tweens.splice(index, 1);
	        tween._onTweenerRemove();
	      }
	    }
	  };

	  /*
	    Method to initialize event listeners to visibility change events.
	    @private
	  */


	  Tweener.prototype._listenVisibilityChange = function _listenVisibilityChange() {
	    if (typeof document.hidden !== "undefined") {
	      this._visibilityHidden = "hidden";
	      this._visibilityChange = "visibilitychange";
	    } else if (typeof document.mozHidden !== "undefined") {
	      this._visibilityHidden = "mozHidden";
	      this._visibilityChange = "mozvisibilitychange";
	    } else if (typeof document.msHidden !== "undefined") {
	      this._visibilityHidden = "msHidden";
	      this._visibilityChange = "msvisibilitychange";
	    } else if (typeof document.webkitHidden !== "undefined") {
	      this._visibilityHidden = "webkitHidden";
	      this._visibilityChange = "webkitvisibilitychange";
	    }

	    document.addEventListener(this._visibilityChange, this._onVisibilityChange, false);
	  };
	  /*
	    Method that will fire on visibility change.
	  */


	  Tweener.prototype._onVisibilityChange = function _onVisibilityChange() {
	    if (document[this._visibilityHidden]) {
	      this._savePlayingTweens();
	    } else {
	      this._restorePlayingTweens();
	    }
	  };
	  /*
	    Method to save all playing tweens.
	    @private
	  */


	  Tweener.prototype._savePlayingTweens = function _savePlayingTweens() {
	    this._savedTweens = this.tweens.slice(0);
	    for (var i = 0; i < this._savedTweens.length; i++) {
	      this._savedTweens[i].pause();
	    }
	  };
	  /*
	    Method to restore all playing tweens.
	    @private
	  */


	  Tweener.prototype._restorePlayingTweens = function _restorePlayingTweens() {
	    for (var i = 0; i < this._savedTweens.length; i++) {
	      this._savedTweens[i].resume();
	    }
	  };

	  return Tweener;
	}();

	var t = new Tweener();
	exports.default = t;

/***/ }),
/* 103 */
/***/ (function(module, exports) {

	
	/* istanbul ignore next */
	(function() {
	  'use strict';
	  var cancel, i, isOldBrowser, lastTime, vendors, vp, w;
	  vendors = ['webkit', 'moz'];
	  i = 0;
	  w = window;
	  while (i < vendors.length && !w.requestAnimationFrame) {
	    vp = vendors[i];
	    w.requestAnimationFrame = w[vp + 'RequestAnimationFrame'];
	    cancel = w[vp + 'CancelAnimationFrame'];
	    w.cancelAnimationFrame = cancel || w[vp + 'CancelRequestAnimationFrame'];
	    ++i;
	  }
	  isOldBrowser = !w.requestAnimationFrame || !w.cancelAnimationFrame;
	  if (/iP(ad|hone|od).*OS 6/.test(w.navigator.userAgent) || isOldBrowser) {
	    lastTime = 0;
	    w.requestAnimationFrame = function(callback) {
	      var nextTime, now;
	      now = Date.now();
	      nextTime = Math.max(lastTime + 16, now);
	      return setTimeout((function() {
	        callback(lastTime = nextTime);
	      }), nextTime - now);
	    };
	    w.cancelAnimationFrame = clearTimeout;
	  }
	})();


/***/ }),
/* 104 */
/***/ (function(module, exports) {

	
	/* istanbul ignore next */
	(function(root) {
	  var offset, ref, ref1;
	  if (root.performance == null) {
	    root.performance = {};
	  }
	  Date.now = Date.now || function() {
	    return (new Date).getTime();
	  };
	  if (root.performance.now == null) {
	    offset = ((ref = root.performance) != null ? (ref1 = ref.timing) != null ? ref1.navigationStart : void 0 : void 0) ? performance.timing.navigationStart : Date.now();
	    return root.performance.now = function() {
	      return Date.now() - offset;
	    };
	  }
	})(window);


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

	var Easing, PI, PathEasing, approximate, bezier, easing, h, mix, sin;

	bezier = __webpack_require__(106);

	PathEasing = __webpack_require__(107);

	mix = __webpack_require__(108);

	h = __webpack_require__(71);

	approximate = __webpack_require__(109)["default"] || __webpack_require__(109);

	sin = Math.sin;

	PI = Math.PI;

	Easing = (function() {
	  function Easing() {}

	  Easing.prototype.bezier = bezier;

	  Easing.prototype.PathEasing = PathEasing;

	  Easing.prototype.path = (new PathEasing('creator')).create;

	  Easing.prototype.approximate = approximate;

	  Easing.prototype.inverse = function(p) {
	    return 1 - p;
	  };

	  Easing.prototype.linear = {
	    none: function(k) {
	      return k;
	    }
	  };

	  Easing.prototype.ease = {
	    "in": bezier.apply(Easing, [0.42, 0, 1, 1]),
	    out: bezier.apply(Easing, [0, 0, 0.58, 1]),
	    inout: bezier.apply(Easing, [0.42, 0, 0.58, 1])
	  };

	  Easing.prototype.sin = {
	    "in": function(k) {
	      return 1 - Math.cos(k * PI / 2);
	    },
	    out: function(k) {
	      return sin(k * PI / 2);
	    },
	    inout: function(k) {
	      return 0.5 * (1 - Math.cos(PI * k));
	    }
	  };

	  Easing.prototype.quad = {
	    "in": function(k) {
	      return k * k;
	    },
	    out: function(k) {
	      return k * (2 - k);
	    },
	    inout: function(k) {
	      if ((k *= 2) < 1) {
	        return 0.5 * k * k;
	      }
	      return -0.5 * (--k * (k - 2) - 1);
	    }
	  };

	  Easing.prototype.cubic = {
	    "in": function(k) {
	      return k * k * k;
	    },
	    out: function(k) {
	      return --k * k * k + 1;
	    },
	    inout: function(k) {
	      if ((k *= 2) < 1) {
	        return 0.5 * k * k * k;
	      }
	      return 0.5 * ((k -= 2) * k * k + 2);
	    }
	  };

	  Easing.prototype.quart = {
	    "in": function(k) {
	      return k * k * k * k;
	    },
	    out: function(k) {
	      return 1 - (--k * k * k * k);
	    },
	    inout: function(k) {
	      if ((k *= 2) < 1) {
	        return 0.5 * k * k * k * k;
	      }
	      return -0.5 * ((k -= 2) * k * k * k - 2);
	    }
	  };

	  Easing.prototype.quint = {
	    "in": function(k) {
	      return k * k * k * k * k;
	    },
	    out: function(k) {
	      return --k * k * k * k * k + 1;
	    },
	    inout: function(k) {
	      if ((k *= 2) < 1) {
	        return 0.5 * k * k * k * k * k;
	      }
	      return 0.5 * ((k -= 2) * k * k * k * k + 2);
	    }
	  };

	  Easing.prototype.expo = {
	    "in": function(k) {
	      if (k === 0) {
	        return 0;
	      } else {
	        return Math.pow(1024, k - 1);
	      }
	    },
	    out: function(k) {
	      if (k === 1) {
	        return 1;
	      } else {
	        return 1 - Math.pow(2, -10 * k);
	      }
	    },
	    inout: function(k) {
	      if (k === 0) {
	        return 0;
	      }
	      if (k === 1) {
	        return 1;
	      }
	      if ((k *= 2) < 1) {
	        return 0.5 * Math.pow(1024, k - 1);
	      }
	      return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
	    }
	  };

	  Easing.prototype.circ = {
	    "in": function(k) {
	      return 1 - Math.sqrt(1 - k * k);
	    },
	    out: function(k) {
	      return Math.sqrt(1 - (--k * k));
	    },
	    inout: function(k) {
	      if ((k *= 2) < 1) {
	        return -0.5 * (Math.sqrt(1 - k * k) - 1);
	      }
	      return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
	    }
	  };

	  Easing.prototype.back = {
	    "in": function(k) {
	      var s;
	      s = 1.70158;
	      return k * k * ((s + 1) * k - s);
	    },
	    out: function(k) {
	      var s;
	      s = 1.70158;
	      return --k * k * ((s + 1) * k + s) + 1;
	    },
	    inout: function(k) {
	      var s;
	      s = 1.70158 * 1.525;
	      if ((k *= 2) < 1) {
	        return 0.5 * (k * k * ((s + 1) * k - s));
	      }
	      return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
	    }
	  };

	  Easing.prototype.elastic = {
	    "in": function(k) {
	      var a, p, s;
	      s = void 0;
	      p = 0.4;
	      if (k === 0) {
	        return 0;
	      }
	      if (k === 1) {
	        return 1;
	      }
	      a = 1;
	      s = p / 4;
	      return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
	    },
	    out: function(k) {
	      var a, p, s;
	      s = void 0;
	      p = 0.4;
	      if (k === 0) {
	        return 0;
	      }
	      if (k === 1) {
	        return 1;
	      }
	      a = 1;
	      s = p / 4;
	      return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;
	    },
	    inout: function(k) {
	      var a, p, s;
	      s = void 0;
	      p = 0.4;
	      if (k === 0) {
	        return 0;
	      }
	      if (k === 1) {
	        return 1;
	      }
	      a = 1;
	      s = p / 4;
	      if ((k *= 2) < 1) {
	        return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
	      }
	      return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
	    }
	  };

	  Easing.prototype.bounce = {
	    "in": function(k) {
	      return 1 - easing.bounce.out(1 - k);
	    },
	    out: function(k) {
	      if (k < (1 / 2.75)) {
	        return 7.5625 * k * k;
	      } else if (k < (2 / 2.75)) {
	        return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
	      } else if (k < (2.5 / 2.75)) {
	        return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
	      } else {
	        return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
	      }
	    },
	    inout: function(k) {
	      if (k < 0.5) {
	        return easing.bounce["in"](k * 2) * 0.5;
	      }
	      return easing.bounce.out(k * 2 - 1) * 0.5 + 0.5;
	    }
	  };

	  Easing.prototype.parseEasing = function(easing) {
	    var easingParent, type;
	    if (easing == null) {
	      easing = 'linear.none';
	    }
	    type = typeof easing;
	    if (type === 'string') {
	      if (easing.charAt(0).toLowerCase() === 'm') {
	        return this.path(easing);
	      } else {
	        easing = this._splitEasing(easing);
	        easingParent = this[easing[0]];
	        if (!easingParent) {
	          h.error("Easing with name \"" + easing[0] + "\" was not found, fallback to \"linear.none\" instead");
	          return this['linear']['none'];
	        }
	        return easingParent[easing[1]];
	      }
	    }
	    if (h.isArray(easing)) {
	      return this.bezier.apply(this, easing);
	    }
	    if ('function') {
	      return easing;
	    }
	  };

	  Easing.prototype._splitEasing = function(string) {
	    var firstPart, secondPart, split;
	    if (typeof string === 'function') {
	      return string;
	    }
	    if (typeof string === 'string' && string.length) {
	      split = string.split('.');
	      firstPart = split[0].toLowerCase() || 'linear';
	      secondPart = split[1].toLowerCase() || 'none';
	      return [firstPart, secondPart];
	    } else {
	      return ['linear', 'none'];
	    }
	  };

	  return Easing;

	})();

	easing = new Easing;

	easing.mix = mix(easing);

	module.exports = easing;


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {var BezierEasing, bezierEasing, h,
	  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

	h = __webpack_require__(71);


	/**
	 * Copyright (c) 2014 Gaëtan Renaudeau http://goo.gl/El3k7u
	 * Adopted from https://github.com/gre/bezier-easing
	 */

	BezierEasing = (function() {
	  function BezierEasing(o) {
	    this.vars();
	    return this.generate;
	  }

	  BezierEasing.prototype.vars = function() {
	    return this.generate = h.bind(this.generate, this);
	  };

	  BezierEasing.prototype.generate = function(mX1, mY1, mX2, mY2) {
	    var A, B, C, NEWTON_ITERATIONS, NEWTON_MIN_SLOPE, SUBDIVISION_MAX_ITERATIONS, SUBDIVISION_PRECISION, _precomputed, arg, binarySubdivide, calcBezier, calcSampleValues, f, float32ArraySupported, getSlope, getTForX, i, j, kSampleStepSize, kSplineTableSize, mSampleValues, newtonRaphsonIterate, precompute, str;
	    if (arguments.length < 4) {
	      return this.error('Bezier function expects 4 arguments');
	    }
	    for (i = j = 0; j < 4; i = ++j) {
	      arg = arguments[i];
	      if (typeof arg !== "number" || isNaN(arg) || !isFinite(arg)) {
	        return this.error('Bezier function expects 4 arguments');
	      }
	    }
	    if (mX1 < 0 || mX1 > 1 || mX2 < 0 || mX2 > 1) {
	      return this.error('Bezier x values should be > 0 and < 1');
	    }
	    NEWTON_ITERATIONS = 4;
	    NEWTON_MIN_SLOPE = 0.001;
	    SUBDIVISION_PRECISION = 0.0000001;
	    SUBDIVISION_MAX_ITERATIONS = 10;
	    kSplineTableSize = 11;
	    kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);
	    float32ArraySupported = indexOf.call(global, 'Float32Array') >= 0;
	    A = function(aA1, aA2) {
	      return 1.0 - 3.0 * aA2 + 3.0 * aA1;
	    };
	    B = function(aA1, aA2) {
	      return 3.0 * aA2 - 6.0 * aA1;
	    };
	    C = function(aA1) {
	      return 3.0 * aA1;
	    };
	    calcBezier = function(aT, aA1, aA2) {
	      return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
	    };
	    getSlope = function(aT, aA1, aA2) {
	      return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
	    };
	    newtonRaphsonIterate = function(aX, aGuessT) {
	      var currentSlope, currentX;
	      i = 0;
	      while (i < NEWTON_ITERATIONS) {
	        currentSlope = getSlope(aGuessT, mX1, mX2);

	        /* istanbul ignore if */
	        if (currentSlope === 0.0) {
	          return aGuessT;
	        }
	        currentX = calcBezier(aGuessT, mX1, mX2) - aX;
	        aGuessT -= currentX / currentSlope;
	        ++i;
	      }
	      return aGuessT;
	    };
	    calcSampleValues = function() {
	      i = 0;
	      while (i < kSplineTableSize) {
	        mSampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
	        ++i;
	      }
	    };

	    /* istanbul ignore next */
	    binarySubdivide = function(aX, aA, aB) {
	      var currentT, currentX, isBig;
	      currentX = void 0;
	      currentT = void 0;
	      i = 0;
	      while (true) {
	        currentT = aA + (aB - aA) / 2.0;
	        currentX = calcBezier(currentT, mX1, mX2) - aX;
	        if (currentX > 0.0) {
	          aB = currentT;
	        } else {
	          aA = currentT;
	        }
	        isBig = Math.abs(currentX) > SUBDIVISION_PRECISION;
	        if (!(isBig && ++i < SUBDIVISION_MAX_ITERATIONS)) {
	          break;
	        }
	      }
	      return currentT;
	    };
	    getTForX = function(aX) {
	      var currentSample, delta, dist, guessForT, initialSlope, intervalStart, lastSample;
	      intervalStart = 0.0;
	      currentSample = 1;
	      lastSample = kSplineTableSize - 1;
	      while (currentSample !== lastSample && mSampleValues[currentSample] <= aX) {
	        intervalStart += kSampleStepSize;
	        ++currentSample;
	      }
	      --currentSample;
	      delta = mSampleValues[currentSample + 1] - mSampleValues[currentSample];
	      dist = (aX - mSampleValues[currentSample]) / delta;
	      guessForT = intervalStart + dist * kSampleStepSize;
	      initialSlope = getSlope(guessForT, mX1, mX2);
	      if (initialSlope >= NEWTON_MIN_SLOPE) {
	        return newtonRaphsonIterate(aX, guessForT);
	      } else {

	        /* istanbul ignore next */
	        if (initialSlope === 0.0) {
	          return guessForT;
	        } else {
	          return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize);
	        }
	      }
	    };
	    precompute = function() {
	      var _precomputed;
	      _precomputed = true;
	      if (mX1 !== mY1 || mX2 !== mY2) {
	        return calcSampleValues();
	      }
	    };
	    mSampleValues = !float32ArraySupported ? new Array(kSplineTableSize) : new Float32Array(kSplineTableSize);
	    _precomputed = false;
	    f = function(aX) {
	      if (!_precomputed) {
	        precompute();
	      }
	      if (mX1 === mY1 && mX2 === mY2) {
	        return aX;
	      }
	      if (aX === 0) {
	        return 0;
	      }
	      if (aX === 1) {
	        return 1;
	      }
	      return calcBezier(getTForX(aX), mY1, mY2);
	    };
	    str = "bezier(" + [mX1, mY1, mX2, mY2] + ")";
	    f.toStr = function() {
	      return str;
	    };
	    return f;
	  };

	  BezierEasing.prototype.error = function(msg) {
	    return h.error(msg);
	  };

	  return BezierEasing;

	})();

	bezierEasing = new BezierEasing;

	module.exports = bezierEasing;

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

	var PathEasing, h;

	h = __webpack_require__(71);

	PathEasing = (function() {
	  PathEasing.prototype._vars = function() {
	    this._precompute = h.clamp(this.o.precompute || 1450, 100, 10000);
	    this._step = 1 / this._precompute;
	    this._rect = this.o.rect || 100;
	    this._approximateMax = this.o.approximateMax || 5;
	    this._eps = this.o.eps || 0.001;
	    return this._boundsPrevProgress = -1;
	  };

	  function PathEasing(path, o1) {
	    this.o = o1 != null ? o1 : {};
	    if (path === 'creator') {
	      return;
	    }
	    this.path = h.parsePath(path);
	    if (this.path == null) {
	      return h.error('Error while parsing the path');
	    }
	    this._vars();
	    this.path.setAttribute('d', this._normalizePath(this.path.getAttribute('d')));
	    this.pathLength = this.path.getTotalLength();
	    this.sample = h.bind(this.sample, this);
	    this._hardSample = h.bind(this._hardSample, this);
	    this._preSample();
	    this;
	  }

	  PathEasing.prototype._preSample = function() {
	    var i, j, length, point, progress, ref, results;
	    this._samples = [];
	    results = [];
	    for (i = j = 0, ref = this._precompute; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
	      progress = i * this._step;
	      length = this.pathLength * progress;
	      point = this.path.getPointAtLength(length);
	      results.push(this._samples[i] = {
	        point: point,
	        length: length,
	        progress: progress
	      });
	    }
	    return results;
	  };

	  PathEasing.prototype._findBounds = function(array, p) {
	    var buffer, direction, end, i, j, len, loopEnd, pointP, pointX, ref, ref1, start, value;
	    if (p === this._boundsPrevProgress) {
	      return this._prevBounds;
	    }
	    if (this._boundsStartIndex == null) {
	      this._boundsStartIndex = 0;
	    }
	    len = array.length;
	    if (this._boundsPrevProgress > p) {
	      loopEnd = 0;
	      direction = 'reverse';
	    } else {
	      loopEnd = len;
	      direction = 'forward';
	    }
	    if (direction === 'forward') {
	      start = array[0];
	      end = array[array.length - 1];
	    } else {
	      start = array[array.length - 1];
	      end = array[0];
	    }
	    for (i = j = ref = this._boundsStartIndex, ref1 = loopEnd; ref <= ref1 ? j < ref1 : j > ref1; i = ref <= ref1 ? ++j : --j) {
	      value = array[i];
	      pointX = value.point.x / this._rect;
	      pointP = p;
	      if (direction === 'reverse') {
	        buffer = pointX;
	        pointX = pointP;
	        pointP = buffer;
	      }
	      if (pointX < pointP) {
	        start = value;
	        this._boundsStartIndex = i;
	      } else {
	        end = value;
	        break;
	      }
	    }
	    this._boundsPrevProgress = p;
	    return this._prevBounds = {
	      start: start,
	      end: end
	    };
	  };

	  PathEasing.prototype.sample = function(p) {
	    var bounds, res;
	    p = h.clamp(p, 0, 1);
	    bounds = this._findBounds(this._samples, p);
	    res = this._checkIfBoundsCloseEnough(p, bounds);
	    if (res != null) {
	      return res;
	    }
	    return this._findApproximate(p, bounds.start, bounds.end);
	  };

	  PathEasing.prototype._checkIfBoundsCloseEnough = function(p, bounds) {
	    var point, y;
	    point = void 0;
	    y = this._checkIfPointCloseEnough(p, bounds.start.point);
	    if (y != null) {
	      return y;
	    }
	    return this._checkIfPointCloseEnough(p, bounds.end.point);
	  };

	  PathEasing.prototype._checkIfPointCloseEnough = function(p, point) {
	    if (h.closeEnough(p, point.x / this._rect, this._eps)) {
	      return this._resolveY(point);
	    }
	  };

	  PathEasing.prototype._approximate = function(start, end, p) {
	    var deltaP, percentP;
	    deltaP = end.point.x - start.point.x;
	    percentP = (p - (start.point.x / this._rect)) / (deltaP / this._rect);
	    return start.length + percentP * (end.length - start.length);
	  };

	  PathEasing.prototype._findApproximate = function(p, start, end, approximateMax) {
	    var approximation, args, newPoint, point, x;
	    if (approximateMax == null) {
	      approximateMax = this._approximateMax;
	    }
	    approximation = this._approximate(start, end, p);
	    point = this.path.getPointAtLength(approximation);
	    x = point.x / this._rect;
	    if (h.closeEnough(p, x, this._eps)) {
	      return this._resolveY(point);
	    } else {
	      if (--approximateMax < 1) {
	        return this._resolveY(point);
	      }
	      newPoint = {
	        point: point,
	        length: approximation
	      };
	      args = p < x ? [p, start, newPoint, approximateMax] : [p, newPoint, end, approximateMax];
	      return this._findApproximate.apply(this, args);
	    }
	  };

	  PathEasing.prototype._resolveY = function(point) {
	    return 1 - (point.y / this._rect);
	  };

	  PathEasing.prototype._normalizePath = function(path) {
	    var commands, endIndex, normalizedPath, points, startIndex, svgCommandsRegexp;
	    svgCommandsRegexp = /[M|L|H|V|C|S|Q|T|A]/gim;
	    points = path.split(svgCommandsRegexp);
	    points.shift();
	    commands = path.match(svgCommandsRegexp);
	    startIndex = 0;
	    points[startIndex] = this._normalizeSegment(points[startIndex]);
	    endIndex = points.length - 1;
	    points[endIndex] = this._normalizeSegment(points[endIndex], this._rect || 100);
	    return normalizedPath = this._joinNormalizedPath(commands, points);
	  };

	  PathEasing.prototype._joinNormalizedPath = function(commands, points) {
	    var command, i, j, len1, normalizedPath, space;
	    normalizedPath = '';
	    for (i = j = 0, len1 = commands.length; j < len1; i = ++j) {
	      command = commands[i];
	      space = i === 0 ? '' : ' ';
	      normalizedPath += "" + space + command + (points[i].trim());
	    }
	    return normalizedPath;
	  };

	  PathEasing.prototype._normalizeSegment = function(segment, value) {
	    var i, j, lastPoint, len1, nRgx, pairs, parsedX, point, space, x;
	    if (value == null) {
	      value = 0;
	    }
	    segment = segment.trim();
	    nRgx = /(-|\+)?((\d+(\.(\d|\e(-|\+)?)+)?)|(\.?(\d|\e|(\-|\+))+))/gim;
	    pairs = this._getSegmentPairs(segment.match(nRgx));
	    lastPoint = pairs[pairs.length - 1];
	    x = lastPoint[0];
	    parsedX = Number(x);
	    if (parsedX !== value) {
	      segment = '';
	      lastPoint[0] = value;
	      for (i = j = 0, len1 = pairs.length; j < len1; i = ++j) {
	        point = pairs[i];
	        space = i === 0 ? '' : ' ';
	        segment += "" + space + point[0] + "," + point[1];
	      }
	    }
	    return segment;
	  };

	  PathEasing.prototype._getSegmentPairs = function(array) {
	    var i, j, len1, newArray, pair, value;
	    if (array.length % 2 !== 0) {
	      h.error('Failed to parse the path - segment pairs are not even.', array);
	    }
	    newArray = [];
	    for (i = j = 0, len1 = array.length; j < len1; i = j += 2) {
	      value = array[i];
	      pair = [array[i], array[i + 1]];
	      newArray.push(pair);
	    }
	    return newArray;
	  };

	  PathEasing.prototype.create = function(path, o) {
	    var handler;
	    handler = new PathEasing(path, o);
	    handler.sample.path = handler.path;
	    return handler.sample;
	  };

	  return PathEasing;

	})();

	module.exports = PathEasing;


/***/ }),
/* 108 */
/***/ (function(module, exports) {

	var create, easing, getNearest, mix, parseIfEasing, sort,
	  slice = [].slice;

	easing = null;

	parseIfEasing = function(item) {
	  if (typeof item.value === 'number') {
	    return item.value;
	  } else {
	    return easing.parseEasing(item.value);
	  }
	};

	sort = function(a, b) {
	  var returnValue;
	  a.value = parseIfEasing(a);
	  b.value = parseIfEasing(b);
	  returnValue = 0;
	  a.to < b.to && (returnValue = -1);
	  a.to > b.to && (returnValue = 1);
	  return returnValue;
	};

	getNearest = function(array, progress) {
	  var i, index, j, len, value;
	  index = 0;
	  for (i = j = 0, len = array.length; j < len; i = ++j) {
	    value = array[i];
	    index = i;
	    if (value.to > progress) {
	      break;
	    }
	  }
	  return index;
	};

	mix = function() {
	  var args;
	  args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
	  if (args.length > 1) {
	    args = args.sort(sort);
	  } else {
	    args[0].value = parseIfEasing(args[0]);
	  }
	  return function(progress) {
	    var index, value;
	    index = getNearest(args, progress);
	    if (index !== -1) {
	      value = args[index].value;
	      if (index === args.length - 1 && progress > args[index].to) {
	        return 1;
	      }
	      if (typeof value === 'function') {
	        return value(progress);
	      } else {
	        return value;
	      }
	    }
	  };
	};

	create = function(e) {
	  easing = e;
	  return mix;
	};

	module.exports = create;


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _typeof2 = __webpack_require__(3);

	var _typeof3 = _interopRequireDefault(_typeof2);

	var _h = __webpack_require__(71);

	var _h2 = _interopRequireDefault(_h);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/*
	  Method to bootstrap approximation function.
	  @private
	  @param   {Object} Samples Object.
	  @returns {Function} Approximate function.
	*/
	var _proximate = function _proximate(samples) {
	  var n = samples.base,
	      samplesAmount = Math.pow(10, n),
	      samplesStep = 1 / samplesAmount;

	  function RoundNumber(input, numberDecimals) {
	    numberDecimals = +numberDecimals || 0; // +var magic!

	    var multiplyer = Math.pow(10.0, numberDecimals);

	    return Math.round(input * multiplyer) / multiplyer;
	  }

	  var cached = function cached(p) {
	    var newKey = RoundNumber(p, n),
	        sample = samples[newKey.toString()];

	    if (Math.abs(p - newKey) < samplesStep) {
	      return sample;
	    }

	    if (p > newKey) {
	      var nextIndex = newKey + samplesStep;
	      var nextValue = samples[nextIndex];
	    } else {
	      var nextIndex = newKey - samplesStep;
	      var nextValue = samples[nextIndex];
	    }

	    var dLength = nextIndex - newKey;
	    var dValue = nextValue - sample;
	    if (dValue < samplesStep) {
	      return sample;
	    }

	    var progressScale = (p - newKey) / dLength;
	    var coef = nextValue > sample ? -1 : 1;
	    var scaledDifference = coef * progressScale * dValue;

	    return sample + scaledDifference;
	  };

	  cached.getSamples = function () {
	    return samples;
	  };

	  return cached;
	};
	/*
	    Method to take samples of the function and call the _proximate
	    method with the dunction and samples. Or if samples passed - pipe
	    them to the _proximate method without sampling.
	    @private
	    @param {Function} Function to sample.
	    @param {Number, Object, String} Precision or precomputed samples.
	  */
	var _sample = function _sample(fn) {
	  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 4;


	  var nType = typeof n === 'undefined' ? 'undefined' : (0, _typeof3.default)(n);

	  var samples = {};
	  if (nType === 'number') {
	    var p = 0,
	        samplesCount = Math.pow(10, n),
	        step = 1 / samplesCount;

	    samples[0] = fn(0);
	    for (var i = 0; i < samplesCount - 1; i++) {
	      p += step;

	      var index = parseFloat(p.toFixed(n));
	      samples[index] = fn(p);
	    }
	    samples[1] = fn(1);

	    samples.base = n;
	  } else if (nType === 'object') {
	    samples = n;
	  } else if (nType === 'string') {
	    samples = JSON.parse(n);
	  }

	  return Approximate._sample._proximate(samples);
	};

	var Approximate = { _sample: _sample, _proximate: _proximate };
	Approximate._sample._proximate = Approximate._proximate;

	exports.default = Approximate._sample;

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _getIterator2 = __webpack_require__(111);

	var _getIterator3 = _interopRequireDefault(_getIterator2);

	var _classCallCheck2 = __webpack_require__(74);

	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

	var _possibleConstructorReturn2 = __webpack_require__(75);

	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

	var _inherits2 = __webpack_require__(76);

	var _inherits3 = _interopRequireDefault(_inherits2);

	var _h = __webpack_require__(71);

	var _h2 = _interopRequireDefault(_h);

	var _tweener = __webpack_require__(102);

	var _tweener2 = _interopRequireDefault(_tweener);

	var _tween = __webpack_require__(101);

	var _tween2 = _interopRequireDefault(_tween);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var Timeline = function (_Tween) {
	  (0, _inherits3.default)(Timeline, _Tween);

	  /*
	    API method to add child tweens/timelines.
	    @public
	    @param {Object, Array} Tween/Timeline or an array of such.
	    @returns {Object} Self.
	  */
	  Timeline.prototype.add = function add() {
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    this._pushTimelineArray(args);
	    this._calcDimentions();
	    return this;
	  };
	  /*
	    API method to append the Tween/Timeline to the end of the
	    timeline. Each argument is treated as a new append.
	    Array of tweens is treated as a parallel sequence. 
	    @public
	    @param {Object, Array} Tween/Timeline to append or array of such.
	    @returns {Object} Self.
	  */


	  Timeline.prototype.append = function append() {
	    for (var _len2 = arguments.length, timeline = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	      timeline[_key2] = arguments[_key2];
	    }

	    for (var _iterator = timeline, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
	      var _ref;

	      if (_isArray) {
	        if (_i >= _iterator.length) break;
	        _ref = _iterator[_i++];
	      } else {
	        _i = _iterator.next();
	        if (_i.done) break;
	        _ref = _i.value;
	      }

	      var tm = _ref;

	      if (_h2.default.isArray(tm)) {
	        this._appendTimelineArray(tm);
	      } else {
	        this._appendTimeline(tm, this._timelines.length);
	      }
	      this._calcDimentions();
	    }
	    return this;
	  };
	  /*
	    API method to stop the Tween.
	    @public
	    @param   {Number} Progress [0..1] to set when stopped.
	    @returns {Object} Self.
	  */


	  Timeline.prototype.stop = function stop(progress) {
	    _Tween.prototype.stop.call(this, progress);
	    this._stopChildren(progress);
	    return this;
	  };
	  /*
	    Method to reset tween's state and properties.
	    @public
	    @overrides @ Tween
	    @returns this.
	  */


	  Timeline.prototype.reset = function reset() {
	    _Tween.prototype.reset.call(this);
	    this._resetChildren();
	    return this;
	  };
	  /*
	    Method to call `reset` method on all children.
	    @private
	  */


	  Timeline.prototype._resetChildren = function _resetChildren() {
	    for (var i = 0; i < this._timelines.length; i++) {
	      this._timelines[i].reset();
	    }
	  };
	  /*
	    Method to call `stop` method on all children.
	    @private
	    @param   {Number} Progress [0..1] to set when stopped.
	  */


	  Timeline.prototype._stopChildren = function _stopChildren(progress) {
	    for (var i = this._timelines.length - 1; i >= 0; i--) {
	      this._timelines[i].stop(progress);
	    }
	  };
	  /*
	    Method to set tween's state to complete.
	    @private
	    @overrides @ Tween
	    @param {Number} Current time.
	    @param {Boolean} Is yoyo period.
	  */
	  // _complete ( time, isYoyo ) {
	  //   // this._updateChildren( 1, time, isYoyo );
	  //   // this._setProgress( 1, time, isYoyo );
	  //   super._complete( time, isYoyo );
	  //   // this._resetChildren();
	  // }

	  // ^ PUBLIC  METHOD(S) ^
	  // v PRIVATE METHOD(S) v

	  /*
	    Method to append Tween/Timeline array or mix of such.
	    @private
	    @param {Array} Array of Tweens/Timelines.
	  */


	  Timeline.prototype._appendTimelineArray = function _appendTimelineArray(timelineArray) {
	    var i = timelineArray.length,
	        time = this._props.repeatTime - this._props.delay,
	        len = this._timelines.length;

	    while (i--) {
	      this._appendTimeline(timelineArray[i], len, time);
	    }
	  };
	  /*
	    Method to append a single timeline to the Timeline.
	    @private
	    @param {Object} Tween/Timline to append.
	    @param {Number} Index of the append.
	    @param {Number} Shift time.
	  */


	  Timeline.prototype._appendTimeline = function _appendTimeline(timeline, index, time) {
	    // if timeline is a module with timeline property then extract it
	    if (timeline.timeline instanceof Timeline) {
	      timeline = timeline.timeline;
	    }
	    if (timeline.tween instanceof _tween2.default) {
	      timeline = timeline.tween;
	    }

	    var shift = time != null ? time : this._props.duration;
	    shift += timeline._props.shiftTime || 0;
	    timeline.index = index;this._pushTimeline(timeline, shift);
	  };
	  /*
	    PrivateMethod to push Tween/Timeline array.
	    @private
	    @param {Array} Array of Tweens/Timelines.
	  */


	  Timeline.prototype._pushTimelineArray = function _pushTimelineArray(array) {
	    for (var i = 0; i < array.length; i++) {
	      var tm = array[i];
	      // recursive push to handle arrays of arrays
	      if (_h2.default.isArray(tm)) {
	        this._pushTimelineArray(tm);
	      } else {
	        this._pushTimeline(tm);
	      }
	    };
	  };
	  /*
	    Method to push a single Tween/Timeline.
	    @private
	    @param {Object} Tween or Timeline to push.
	    @param {Number} Number of milliseconds to shift the start time
	                    of the Tween/Timeline.
	  */


	  Timeline.prototype._pushTimeline = function _pushTimeline(timeline, shift) {
	    // if timeline is a module with timeline property then extract it
	    if (timeline.timeline instanceof Timeline) {
	      timeline = timeline.timeline;
	    }
	    if (timeline.tween instanceof _tween2.default) {
	      timeline = timeline.tween;
	    }
	    // add self delay to the timeline
	    shift != null && timeline._setProp({ 'shiftTime': shift });
	    this._timelines.push(timeline);
	    this._recalcDuration(timeline);
	  };
	  /*
	    Method set progress on self and child Tweens/Timelines.
	    @private
	    @param {Number} Progress to set.
	    @param {Number} Current update time.
	  */


	  Timeline.prototype._setProgress = function _setProgress(p, time, isYoyo) {
	    // we need to pass self previous time to children
	    // to prevent initial _wasUnknownUpdate nested waterfall
	    // if not yoyo option set, pass the previous time
	    // otherwise, pass previous or next time regarding yoyo period.

	    // COVER CURRENT SWAPPED ORDER
	    this._updateChildren(p, time, isYoyo);

	    _tween2.default.prototype._setProgress.call(this, p, time);
	  };

	  Timeline.prototype._updateChildren = function _updateChildren(p, time, isYoyo) {
	    var coef = time > this._prevTime ? -1 : 1;
	    if (this._props.isYoyo && isYoyo) {
	      coef *= -1;
	    }
	    var timeToTimelines = this._props.startTime + p * this._props.duration,
	        prevTimeToTimelines = timeToTimelines + coef,
	        len = this._timelines.length;

	    for (var i = 0; i < len; i++) {
	      // specify the children's array update loop direction
	      // if time > prevTime go from 0->length else from length->0
	      // var j = ( time > this._prevTime ) ? i : (len-1) - i ;
	      var j = timeToTimelines > prevTimeToTimelines ? i : len - 1 - i;
	      this._timelines[j]._update(timeToTimelines, prevTimeToTimelines, this._prevYoyo, this._onEdge);
	    }
	    this._prevYoyo = isYoyo;
	  };
	  /*
	    Method calculate self duration based on timeline's duration.
	    @private
	    @param {Object} Tween or Timeline to calculate.
	  */


	  Timeline.prototype._recalcDuration = function _recalcDuration(timeline) {
	    var p = timeline._props,
	        timelineTime = p.repeatTime / p.speed + (p.shiftTime || 0) + timeline._negativeShift;

	    this._props.duration = Math.max(timelineTime, this._props.duration);
	  };
	  /*
	    Method calculate self duration from skretch.
	    @private
	  */


	  Timeline.prototype._recalcTotalDuration = function _recalcTotalDuration() {
	    var i = this._timelines.length;
	    this._props.duration = 0;
	    while (i--) {
	      var tm = this._timelines[i];
	      // recalc total duration on child timelines
	      tm._recalcTotalDuration && tm._recalcTotalDuration();
	      // add the timeline's duration to selft duration
	      this._recalcDuration(tm);
	    }
	    this._calcDimentions();
	  };
	  /*
	    Method set start and end times.
	    @private
	    @param {Number, Null} Time to start with.
	  */


	  Timeline.prototype._setStartTime = function _setStartTime(time) {
	    var isReset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

	    _Tween.prototype._setStartTime.call(this, time);
	    this._startTimelines(this._props.startTime, isReset);
	  };
	  /*
	    Method calculate self duration based on timeline's duration.
	    @private
	    @param {Number, Null} Time to start with.
	  */


	  Timeline.prototype._startTimelines = function _startTimelines(time) {
	    var isReset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

	    var p = this._props,
	        isStop = this._state === 'stop';

	    time == null && (time = this._props.startTime);

	    for (var i = 0; i < this._timelines.length; i++) {
	      var tm = this._timelines[i];
	      tm._setStartTime(time, isReset);
	      // if from `_subPlay` and `_prevTime` is set and state is `stop`
	      // prevTime normalizing is for play/pause functionality, so no
	      // need to normalize if the timeline is in `stop` state.
	      if (!isReset && tm._prevTime != null && !isStop) {
	        tm._prevTime = tm._normPrevTimeForward();
	      }
	    }
	  };
	  /*
	    Method to launch onRefresh callback.
	    @method _refresh
	    @private
	    @overrides @ Tween
	    @param {Boolean} If refresh even before start time.
	  */


	  Timeline.prototype._refresh = function _refresh(isBefore) {
	    var len = this._timelines.length;
	    for (var i = 0; i < len; i++) {
	      this._timelines[i]._refresh(isBefore);
	    }
	    _Tween.prototype._refresh.call(this, isBefore);
	  };
	  /*
	    Method do declare defaults by this._defaults object
	    @private
	  */


	  Timeline.prototype._declareDefaults = function _declareDefaults() {
	    // if duration was passed on initialization stage, warn user and reset it.
	    if (this._o.duration != null) {
	      _h2.default.error('Duration can not be declared on Timeline, but "' + this._o.duration + '" is. You probably want to use Tween instead.');
	      this._o.duration = 0;
	    }
	    _Tween.prototype._declareDefaults.call(this);
	    // remove default 
	    this._defaults.duration = 0;
	    this._defaults.easing = 'Linear.None';
	    this._defaults.backwardEasing = 'Linear.None';
	    this._defaults.nameBase = 'Timeline';
	  };

	  function Timeline() {
	    var o = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    (0, _classCallCheck3.default)(this, Timeline);
	    return (0, _possibleConstructorReturn3.default)(this, _Tween.call(this, o));
	  }
	  /*
	    Method to declare some vars.
	    @private
	  */


	  Timeline.prototype._vars = function _vars() {
	    this._timelines = [];
	    _Tween.prototype._vars.call(this);
	  };

	  return Timeline;
	}(_tween2.default);

	exports.default = Timeline;

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(112), __esModule: true };

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(50);
	__webpack_require__(6);
	module.exports = __webpack_require__(113);

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

	var anObject = __webpack_require__(19)
	  , get      = __webpack_require__(114);
	module.exports = __webpack_require__(14).getIterator = function(it){
	  var iterFn = get(it);
	  if(typeof iterFn != 'function')throw TypeError(it + ' is not iterable!');
	  return anObject(iterFn.call(it));
	};

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

	var classof   = __webpack_require__(115)
	  , ITERATOR  = __webpack_require__(47)('iterator')
	  , Iterators = __webpack_require__(29);
	module.exports = __webpack_require__(14).getIteratorMethod = function(it){
	  if(it != undefined)return it[ITERATOR]
	    || it['@@iterator']
	    || Iterators[classof(it)];
	};

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

	// getting tag from 19.1.3.6 Object.prototype.toString()
	var cof = __webpack_require__(37)
	  , TAG = __webpack_require__(47)('toStringTag')
	  // ES3 wrong here
	  , ARG = cof(function(){ return arguments; }()) == 'Arguments';

	// fallback for IE11 Script Access Denied error
	var tryGet = function(it, key){
	  try {
	    return it[key];
	  } catch(e){ /* empty */ }
	};

	module.exports = function(it){
	  var O, T, B;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
	    // builtinTag case
	    : ARG ? cof(O)
	    // ES3 arguments fallback
	    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
	};

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _keys = __webpack_require__(95);

	var _keys2 = _interopRequireDefault(_keys);

	var _classCallCheck2 = __webpack_require__(74);

	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

	var _possibleConstructorReturn2 = __webpack_require__(75);

	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

	var _inherits2 = __webpack_require__(76);

	var _inherits3 = _interopRequireDefault(_inherits2);

	var _h = __webpack_require__(71);

	var _h2 = _interopRequireDefault(_h);

	var _thenable = __webpack_require__(99);

	var _thenable2 = _interopRequireDefault(_thenable);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var Tuneable = function (_Thenable) {
	  (0, _inherits3.default)(Tuneable, _Thenable);

	  function Tuneable() {
	    (0, _classCallCheck3.default)(this, Tuneable);
	    return (0, _possibleConstructorReturn3.default)(this, _Thenable.apply(this, arguments));
	  }

	  /*
	    Method to start the animation with optional new options.
	    @public
	    @param {Object} New options to set on the run.
	    @returns {Object} this.
	  */
	  Tuneable.prototype.tune = function tune(o) {
	    // if options object was passed
	    if (o && (0, _keys2.default)(o).length) {
	      this._transformHistory(o);
	      this._tuneNewOptions(o);
	      // restore array prop values because _props
	      // contain them as parsed arrays
	      // but we need the as strings to store in history
	      // and merge in history chains
	      this._history[0] = _h2.default.cloneObj(this._props);
	      for (var key in this._arrayPropertyMap) {
	        if (o[key] != null) {
	          this._history[0][key] = this._preparsePropValue(key, o[key]);
	        }
	      }

	      this._tuneSubModules();
	      this._resetTweens();
	    }
	    return this;
	  };
	  /*
	    Method to regenerate all the random properties form initial object.
	    @public
	    @returns this.
	  */


	  Tuneable.prototype.generate = function generate() {
	    return this.tune(this._o);
	  };

	  // ^ PUBLIC  METHOD(S) ^
	  // v PRIVATE METHOD(S) v

	  /*
	    Method to preparse options in object.
	    @private
	    @param {Object} Object to preparse properties on.
	    @returns {Object} Passed object with preparsed props.
	  */
	  // _preParseOptions ( o ) {
	  //   for (var key in o) {
	  //     o[key] = this._preparsePropValue( key, o[key] );
	  //   }
	  //   return o;
	  // }
	  /*
	    Method to transform history rewrite new options object chain on run.
	    @private
	    @param {Object} New options to tune for.
	  */


	  Tuneable.prototype._transformHistory = function _transformHistory(o) {
	    for (var key in o) {
	      var value = o[key];
	      // don't transform for childOptions
	      // if ( key === 'childOptions' ) { continue; }
	      this._transformHistoryFor(key, this._preparsePropValue(key, value));
	    }
	  };
	  /*
	    Method to transform history chain for specific key/value.
	    @param {String} Name of the property to transform history for.
	    @param {Any} The new property's value.
	  */


	  Tuneable.prototype._transformHistoryFor = function _transformHistoryFor(key, value) {
	    for (var i = 0; i < this._history.length; i++) {
	      if (value = this._transformHistoryRecord(i, key, value)) {
	        // break if no further history modifications needed
	        if (value == null) {
	          break;
	        }
	      }
	    }
	  };
	  /*
	    Method to transform history recod with key/value.
	    @param {Number} Index of the history record to transform.
	    @param {String} Property name to transform.
	    @param {Any} Property value to transform to.
	    @param {Object} Optional the current history record.
	    @param {Object} Optional the next history record.
	    @returns {Boolean} Returns true if no further
	                       history modifications is needed.
	  */


	  Tuneable.prototype._transformHistoryRecord = function _transformHistoryRecord(index, key, newVal, currRecord, nextRecord) {
	    // newVal = this._parseProperty( key, newVal );
	    if (newVal == null) {
	      return null;
	    }

	    // fallback to history records, if wasn't specified
	    currRecord = currRecord == null ? this._history[index] : currRecord;
	    nextRecord = nextRecord == null ? this._history[index + 1] : nextRecord;

	    var oldVal = currRecord[key],
	        nextVal = nextRecord == null ? null : nextRecord[key];

	    // if index is 0 - always save the newVal
	    // and return non-delta for subsequent modifications
	    if (index === 0) {
	      currRecord[key] = newVal;
	      // always return on tween properties
	      if (_h2.default.isTweenProp(key) && key !== 'duration') {
	        return null;
	      }
	      // nontween properties
	      var isRewriteNext = this._isRewriteNext(oldVal, nextVal),
	          returnVal = this._isDelta(newVal) ? _h2.default.getDeltaEnd(newVal) : newVal;
	      return isRewriteNext ? returnVal : null;
	    } else {
	      // if was delta and came none-deltta - rewrite
	      // the start of the delta and stop
	      if (this._isDelta(oldVal)) {
	        var _currRecord$key;

	        currRecord[key] = (_currRecord$key = {}, _currRecord$key[newVal] = _h2.default.getDeltaEnd(oldVal), _currRecord$key);
	        return null;
	      } else {
	        // if the old value is not delta and the new one is
	        currRecord[key] = newVal;
	        // if the next item has the same value - return the
	        // item for subsequent modifications or stop
	        return this._isRewriteNext(oldVal, nextVal) ? newVal : null;
	      }
	    }
	  };
	  /*
	    Method to check if the next item should
	    be rewrited in transform history operation.
	    @private
	    @param {Any} Current value.
	    @param {Any} Next value.
	    @returns {Boolean} If need to rewrite the next value.
	  */


	  Tuneable.prototype._isRewriteNext = function _isRewriteNext(currVal, nextVal) {
	    // return false if nothing to rewrite next
	    if (nextVal == null && currVal != null) {
	      return false;
	    }

	    var isEqual = currVal === nextVal,
	        isNextDelta = this._isDelta(nextVal),
	        isDelta = this._isDelta(currVal),
	        isValueDeltaChain = false,
	        isDeltaChain = false;

	    if (isDelta && isNextDelta) {
	      if (_h2.default.getDeltaEnd(currVal) == _h2.default.getDeltaStart(nextVal)) {
	        isDeltaChain = true;
	      }
	    } else if (isNextDelta) {
	      isValueDeltaChain = _h2.default.getDeltaStart(nextVal) === '' + currVal;
	    }

	    return isEqual || isValueDeltaChain || isDeltaChain;
	  };
	  /*
	    Method to tune new history options to all the submodules.
	    @private
	  */


	  Tuneable.prototype._tuneSubModules = function _tuneSubModules() {
	    for (var i = 1; i < this._modules.length; i++) {
	      this._modules[i]._tuneNewOptions(this._history[i]);
	    }
	  };
	  /*
	    Method to set new options on run.
	    @param {Boolean} If foreign context.
	    @private
	  */


	  Tuneable.prototype._resetTweens = function _resetTweens() {
	    var i = 0,
	        shift = 0,
	        tweens = this.timeline._timelines;

	    // if `isTimelineLess` return
	    if (tweens == null) {
	      return;
	    }

	    for (var i = 0; i < tweens.length; i++) {
	      var tween = tweens[i],
	          prevTween = tweens[i - 1];

	      shift += prevTween ? prevTween._props.repeatTime : 0;
	      this._resetTween(tween, this._history[i], shift);
	    }
	    this.timeline._setProp(this._props.timeline);
	    this.timeline._recalcTotalDuration();
	  };
	  /*
	    Method to reset tween with new options.
	    @param {Object} Tween to reset.
	    @param {Object} Tween's to reset tween with.
	    @param {Number} Optional number to shift tween start time.
	  */


	  Tuneable.prototype._resetTween = function _resetTween(tween, o) {
	    var shift = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

	    o.shiftTime = shift;tween._setProp(o);
	  };

	  return Tuneable;
	}(_thenable2.default);

	exports.default = Tuneable;

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _classCallCheck2 = __webpack_require__(74);

	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

	var _possibleConstructorReturn2 = __webpack_require__(75);

	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

	var _inherits2 = __webpack_require__(76);

	var _inherits3 = _interopRequireDefault(_inherits2);

	var _shape = __webpack_require__(94);

	var _shape2 = _interopRequireDefault(_shape);

	var _h = __webpack_require__(71);

	var _h2 = _interopRequireDefault(_h);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/*
	  *TODO:*
	  ---
	  - tweak then chains
	*/

	var ShapeSwirl = function (_Shape) {
	  (0, _inherits3.default)(ShapeSwirl, _Shape);

	  function ShapeSwirl() {
	    (0, _classCallCheck3.default)(this, ShapeSwirl);
	    return (0, _possibleConstructorReturn3.default)(this, _Shape.apply(this, arguments));
	  }

	  /*
	    Method to declare _defaults and other default objects.
	    @private
	    @override @ Shape
	  */
	  ShapeSwirl.prototype._declareDefaults = function _declareDefaults() {
	    _Shape.prototype._declareDefaults.call(this);

	    /* _DEFAULTS ARE - Shape DEFAULTS + THESE: */

	    /* [boolean] :: If shape should follow sinusoidal path. */
	    this._defaults.isSwirl = true;
	    /* ∆ :: [number > 0] :: Degree size of the sinusoidal path. */
	    this._defaults.swirlSize = 10;
	    /* ∆ :: [number > 0] :: Frequency of the sinusoidal path. */
	    this._defaults.swirlFrequency = 3;
	    /* ∆ :: [number > 0] :: Sinusoidal path length scale. */
	    this._defaults.pathScale = 1;
	    /* ∆ :: [number] :: Degree shift for the sinusoidal path. */
	    this._defaults.degreeShift = 0;
	    /* ∆ :: [number] :: Radius of the shape. */
	    this._defaults.radius = 5;
	    // ∆ :: Units :: Possible values: [ number, string ]
	    this._defaults.x = 0;
	    // ∆ :: Units :: Possible values: [ number, string ]
	    this._defaults.y = 0;
	    // ∆ :: Possible values: [ number ]
	    this._defaults.scale = { 1: 0 };
	    /* [number: -1, 1] :: Directon of Swirl. */
	    this._defaults.direction = 1;
	  };

	  // ^ PUBLIC  METHOD(S) ^
	  // v PRIVATE METHOD(S) v

	  /*
	    Method to copy _o options to _props with
	    fallback to _defaults.
	    @private
	    @override @ Module
	  */


	  ShapeSwirl.prototype._extendDefaults = function _extendDefaults() {
	    _Shape.prototype._extendDefaults.call(this);
	    this._calcPosData();
	  };
	  /*
	    Method to tune new oprions to _o and _props object.
	    @private
	    @overrides @ Module
	    @param {Object} Options object to tune to.
	  */


	  ShapeSwirl.prototype._tuneNewOptions = function _tuneNewOptions(o) {
	    if (o == null) {
	      return;
	    }

	    _Shape.prototype._tuneNewOptions.call(this, o);
	    if (o.x != null || o.y != null) {
	      this._calcPosData();
	    }
	  };
	  /*
	    Method to calculate Swirl's position data.
	    @private
	  */


	  ShapeSwirl.prototype._calcPosData = function _calcPosData() {
	    var x = this._getPosValue('x'),
	        y = this._getPosValue('y'),
	        angle = 90 + Math.atan(y.delta / x.delta || 0) * _h2.default.RAD_TO_DEG;

	    this._posData = {
	      radius: Math.sqrt(x.delta * x.delta + y.delta * y.delta),
	      angle: x.delta < 0 ? angle + 180 : angle,
	      x: x, y: y
	    };
	    // set the last position to _props
	    // this._calcSwirlXY( 1 );
	  };
	  /*
	    Gets `x` or `y` position value.
	    @private
	    @param {String} Name of the property.
	  */


	  ShapeSwirl.prototype._getPosValue = function _getPosValue(name) {
	    var delta = this._deltas[name];
	    if (delta) {
	      // delete from deltas to prevent normal
	      delete this._deltas[name];
	      return {
	        start: delta.start.value,
	        end: delta.end.value,
	        delta: delta.delta,
	        units: delta.end.unit
	      };
	    } else {
	      var pos = _h2.default.parseUnit(this._props[name]);
	      return { start: pos.value, end: pos.value, delta: 0, units: pos.unit };
	    }
	  };
	  /*
	    Method to calculate the progress of the Swirl.
	    @private
	    @overrides @ Shape
	    @param {Numer} Eased progress of the Swirl in range of [0..1]
	    @param {Numer} Progress of the Swirl in range of [0..1]
	  */


	  ShapeSwirl.prototype._setProgress = function _setProgress(easedProgress, progress) {
	    this._progress = easedProgress;
	    this._calcCurrentProps(easedProgress, progress);
	    this._calcSwirlXY(easedProgress);
	    // this._calcOrigin();
	    this._draw(easedProgress);
	  };
	  /*
	    Method to calculate x/y for Swirl's progress
	    @private
	    @mutates _props
	    @param {Number} Current progress in [0...1]
	  */


	  ShapeSwirl.prototype._calcSwirlXY = function _calcSwirlXY(proc) {
	    var p = this._props,
	        angle = this._posData.angle + p.degreeShift,
	        point = _h2.default.getRadialPoint({
	      angle: p.isSwirl ? angle + this._getSwirl(proc) : angle,
	      radius: proc * this._posData.radius * p.pathScale,
	      center: {
	        x: this._posData.x.start,
	        y: this._posData.y.start
	      }
	    });
	    // if foreign svg canvas - set position without units
	    var x = point.x,
	        y = point.y,
	        smallNumber = 0.000001;

	    // remove very small numbers to prevent exponential forms
	    if (x > 0 && x < smallNumber) {
	      x = smallNumber;
	    }
	    if (y > 0 && y < smallNumber) {
	      y = smallNumber;
	    }
	    if (x < 0 && x > -smallNumber) {
	      x = -smallNumber;
	    }
	    if (y < 0 && y > -smallNumber) {
	      y = -smallNumber;
	    }

	    p.x = this._o.ctx ? x : '' + x + this._posData.x.units;
	    p.y = this._o.ctx ? y : '' + y + this._posData.y.units;
	  };
	  /*
	    Method to get progress of the swirl.
	    @private
	    @param {Number} Progress of the Swirl.
	    @returns {Number} Progress of the swirl.
	  */


	  ShapeSwirl.prototype._getSwirl = function _getSwirl(proc) {
	    var p = this._props;
	    return p.direction * p.swirlSize * Math.sin(p.swirlFrequency * proc);
	  };
	  /*
	    Method to draw shape.
	    If !isWithShape - draw self el only, but not shape.
	    @private
	    @overrides @ Shape.
	  */


	  ShapeSwirl.prototype._draw = function _draw() {
	    // call _draw or just _drawEl @ Shape depending if there is `shape`
	    var methodName = this._props.isWithShape ? '_draw' : '_drawEl';
	    _shape2.default.prototype[methodName].call(this);
	  };

	  return ShapeSwirl;
	}(_shape2.default);

	exports.default = ShapeSwirl;

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _keys = __webpack_require__(95);

	var _keys2 = _interopRequireDefault(_keys);

	var _classCallCheck2 = __webpack_require__(74);

	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

	var _possibleConstructorReturn2 = __webpack_require__(75);

	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

	var _inherits2 = __webpack_require__(76);

	var _inherits3 = _interopRequireDefault(_inherits2);

	var _timeline = __webpack_require__(110);

	var _timeline2 = _interopRequireDefault(_timeline);

	var _shapeSwirl = __webpack_require__(117);

	var _shapeSwirl2 = _interopRequireDefault(_shapeSwirl);

	var _tunable = __webpack_require__(116);

	var _tunable2 = _interopRequireDefault(_tunable);

	var _h = __webpack_require__(71);

	var _h2 = _interopRequireDefault(_h);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// import Shape    from './shape';
	var Burst = function (_Tunable) {
	  (0, _inherits3.default)(Burst, _Tunable);

	  function Burst() {
	    (0, _classCallCheck3.default)(this, Burst);
	    return (0, _possibleConstructorReturn3.default)(this, _Tunable.apply(this, arguments));
	  }

	  /*
	    Method to declare defaults.
	    @override @ ShapeSwirl.
	  */
	  Burst.prototype._declareDefaults = function _declareDefaults() {
	    this._defaults = {
	      /* [number > 0] :: Quantity of Burst particles. */
	      count: 5,
	      /* [0 < number < 360] :: Degree of the Burst. */
	      degree: 360,
	      /* ∆ :: [number > 0] :: Radius of the Burst. */
	      radius: { 0: 50 },
	      /* ∆ :: [number > 0] :: X radius of the Burst. */
	      radiusX: null,
	      /* ∆ :: [number > 0] :: Y radius of the Burst. */
	      radiusY: null,
	      /* [number >= 0] :: width of the main swirl. */
	      width: 0,
	      /* [number >= 0] :: height of the main swirl. */
	      height: 0
	    };
	  };
	  /*
	    Method to create a then record for the module.
	    @public
	    overrides @ Thenable
	    @param    {Object} Options for the next animation.
	    @returns  {Object} this.
	  */


	  Burst.prototype.then = function then(o) {
	    // remove tween properties (not callbacks)
	    this._removeTweenProperties(o);

	    var newMaster = this._masterThen(o),
	        newSwirls = this._childThen(o);

	    this._setSwirlDuration(newMaster, this._calcPackTime(newSwirls));

	    this.timeline._recalcTotalDuration();
	    return this;
	  };
	  /*
	    Method to start the animation with optional new options.
	    @public
	    @param {Object} New options to set on the run.
	    @returns {Object} this.
	  */


	  Burst.prototype.tune = function tune(o) {
	    if (o == null) {
	      return this;
	    }
	    // save timeline options to _timelineOptions
	    // and delete the timeline options on o
	    // cuz masterSwirl should not get them
	    this._saveTimelineOptions(o);

	    // add new timeline properties to timeline
	    this.timeline._setProp(this._timelineOptions);

	    // remove tween options (not callbacks)
	    this._removeTweenProperties(o);

	    // tune _props
	    this._tuneNewOptions(o);

	    // tune master swirl
	    this.masterSwirl.tune(o);

	    // tune child swirls
	    this._tuneSwirls(o);

	    // recalc time for modules
	    this._recalcModulesTime();
	    return this;
	  };

	  // ^ PUBLIC  METHODS ^
	  // v PRIVATE METHODS v

	  /*
	    Method to copy `_o` options to `_props` object
	    with fallback to `_defaults`.
	    @private
	    @overrides @ Module
	  */


	  Burst.prototype._extendDefaults = function _extendDefaults() {
	    // remove tween properties (not callbacks)
	    this._removeTweenProperties(this._o);
	    _Tunable.prototype._extendDefaults.call(this);
	  };
	  /*
	    Method to remove all tween (excluding
	    callbacks) props from object.
	    @private
	    @param {Object} Object which should be cleaned
	                    up from tween properties.
	  */


	  Burst.prototype._removeTweenProperties = function _removeTweenProperties(o) {
	    for (var key in _h2.default.tweenOptionMap) {
	      // remove all items that are not declared in _defaults
	      if (this._defaults[key] == null) {
	        delete o[key];
	      }
	    }
	  };
	  /*
	    Method to recalc modules chain tween
	    times after tuning new options.
	    @private
	  */


	  Burst.prototype._recalcModulesTime = function _recalcModulesTime() {
	    var modules = this.masterSwirl._modules,
	        swirls = this._swirls,
	        shiftTime = 0;

	    for (var i = 0; i < modules.length; i++) {
	      var tween = modules[i].tween,
	          packTime = this._calcPackTime(swirls[i]);
	      tween._setProp({ 'duration': packTime, 'shiftTime': shiftTime });
	      shiftTime += packTime;
	    }

	    this.timeline._recalcTotalDuration();
	  };
	  /*
	    Method to tune Swirls with new options.
	    @private
	    @param {Object} New options.
	  */


	  Burst.prototype._tuneSwirls = function _tuneSwirls(o) {
	    // get swirls in first pack
	    var pack0 = this._swirls[0];
	    for (var i = 0; i < pack0.length; i++) {
	      var swirl = pack0[i],
	          option = this._getChildOption(o || {}, i);

	      // since the `degreeShift` participate in
	      // children position calculations, we need to keep
	      // the old `degreeShift` value if new not set
	      var isDegreeShift = option.degreeShift != null;
	      if (!isDegreeShift) {
	        option.degreeShift = this._swirls[0][i]._props.degreeShift;
	      }

	      this._addBurstProperties(option, i);

	      // after burst position calculation - delete the old `degreeShift`
	      // from the options, since anyways we have copied it from the swirl
	      if (!isDegreeShift) {
	        delete option.degreeShift;
	      }

	      swirl.tune(option);
	      this._refreshBurstOptions(swirl._modules, i);
	    }
	  };
	  /*
	    Method to refresh burst x/y/angle options on further chained 
	    swirls, because they will be overriden after `tune` call on
	    very first swirl.
	    @param {Array} Chained modules array
	    param {Number} Index of the first swirl in the chain.
	  */


	  Burst.prototype._refreshBurstOptions = function _refreshBurstOptions(modules, i) {
	    for (var j = 1; j < modules.length; j++) {
	      var module = modules[j],
	          options = {};
	      this._addBurstProperties(options, i, j);
	      module._tuneNewOptions(options);
	    }
	  };
	  /*
	    Method to call then on masterSwirl.
	    @param {Object} Then options.
	    @returns {Object} New master swirl.
	  */


	  Burst.prototype._masterThen = function _masterThen(o) {
	    this.masterSwirl.then(o);
	    // get the latest master swirl in then chain
	    var newMasterSwirl = _h2.default.getLastItem(this.masterSwirl._modules);
	    // save to masterSwirls
	    this._masterSwirls.push(newMasterSwirl);
	    return newMasterSwirl;
	  };
	  /*
	    Method to call then on child swilrs.
	    @param {Object} Then options.
	    @return {Array} Array of new Swirls.
	  */


	  Burst.prototype._childThen = function _childThen(o) {
	    var pack = this._swirls[0],
	        newPack = [];

	    for (var i = 0; i < pack.length; i++) {
	      // get option by modulus
	      var options = this._getChildOption(o, i);
	      var swirl = pack[i];
	      var lastSwirl = _h2.default.getLastItem(swirl._modules);
	      // add new Master Swirl as parent of new childswirl
	      options.parent = this.el;

	      this._addBurstProperties(options, i, this._masterSwirls.length - 1);

	      swirl.then(options);

	      // save the new item in `then` chain
	      newPack.push(_h2.default.getLastItem(swirl._modules));
	    }
	    // save the pack to _swirls object
	    this._swirls[this._masterSwirls.length - 1] = newPack;
	    return newPack;
	  };
	  /*
	    Method to initialize properties.
	    @private
	    @overrides @ Thenable
	  */


	  Burst.prototype._vars = function _vars() {
	    _Tunable.prototype._vars.call(this);
	    // just buffer timeline for calculations
	    this._bufferTimeline = new _timeline2.default();
	  };
	  /*
	    Method for initial render of the module.
	  */


	  Burst.prototype._render = function _render() {
	    this._o.isWithShape = false;
	    this._o.isSwirl = this._props.isSwirl;
	    this._o.callbacksContext = this;
	    // save timeline options and remove from _o
	    // cuz the master swirl should not get them
	    this._saveTimelineOptions(this._o);

	    this.masterSwirl = new MainSwirl(this._o);
	    this._masterSwirls = [this.masterSwirl];
	    this.el = this.masterSwirl.el;

	    this._renderSwirls();
	  };
	  /*
	    Method for initial render of swirls.
	    @private
	  */


	  Burst.prototype._renderSwirls = function _renderSwirls() {
	    var p = this._props,
	        pack = [];

	    for (var i = 0; i < p.count; i++) {
	      var option = this._getChildOption(this._o, i);
	      pack.push(new ChildSwirl(this._addOptionalProps(option, i)));
	    }
	    this._swirls = { 0: pack };
	    this._setSwirlDuration(this.masterSwirl, this._calcPackTime(pack));
	  };
	  /*
	    Method to save timeline options to _timelineOptions
	    and delete the property on the object.
	    @private
	    @param {Object} The object to save the timeline options from.
	  */


	  Burst.prototype._saveTimelineOptions = function _saveTimelineOptions(o) {
	    this._timelineOptions = o.timeline;
	    delete o.timeline;
	  };
	  /*
	    Method to calculate total time of array of
	    concurrent tweens.
	    @param   {Array}  Pack to calculate the total time for.
	    @returns {Number} Total pack duration.
	  */


	  Burst.prototype._calcPackTime = function _calcPackTime(pack) {
	    var maxTime = 0;
	    for (var i = 0; i < pack.length; i++) {
	      var tween = pack[i].tween,
	          p = tween._props;

	      maxTime = Math.max(p.repeatTime / p.speed, maxTime);
	    }

	    return maxTime;
	  };
	  /*
	    Method to set duration for Swirl.
	    @param {Object} Swirl instance to set the duration to.
	    @param {Number} Duration to set.
	  */


	  Burst.prototype._setSwirlDuration = function _setSwirlDuration(swirl, duration) {
	    swirl.tween._setProp('duration', duration);
	    var isRecalc = swirl.timeline && swirl.timeline._recalcTotalDuration;
	    isRecalc && swirl.timeline._recalcTotalDuration();
	  };
	  /*
	    Method to get childOption form object call by modulus.
	    @private
	    @param   {Object} Object to look in.
	    @param   {Number} Index of the current Swirl.
	    @returns {Object} Options for the current swirl.
	  */


	  Burst.prototype._getChildOption = function _getChildOption(obj, i) {
	    var options = {};
	    for (var key in obj.children) {
	      options[key] = this._getPropByMod(key, i, obj.children);
	    }
	    return options;
	  };
	  /*
	    Method to get property by modulus.
	    @private
	    @param {String} Name of the property.
	    @param {Number} Index for the modulus.
	    @param {Object} Source object to check in.
	    @returns {Any} Property.
	  */


	  Burst.prototype._getPropByMod = function _getPropByMod(name, index) {
	    var sourceObj = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	    var prop = sourceObj[name];
	    return _h2.default.isArray(prop) ? prop[index % prop.length] : prop;
	  };
	  /*
	    Method to add optional Swirls' properties to passed object.
	    @private
	    @param {Object} Object to add the properties to.
	    @param {Number} Index of the property.
	  */


	  Burst.prototype._addOptionalProps = function _addOptionalProps(options, index) {
	    options.index = index;
	    options.parent = this.masterSwirl.el;

	    this._addBurstProperties(options, index);

	    return options;
	  };
	  /*
	    Method to add Burst options to object.
	    @private
	    @param {Object} Options to add the properties to.
	    @param {Number} Index of the Swirl.
	    @param {Number} Index of the main swirl.
	  */


	  Burst.prototype._addBurstProperties = function _addBurstProperties(options, index, i) {
	    // save index of the module
	    var mainIndex = this._index;
	    // temporary change the index to parse index based properties like stagger
	    this._index = index;
	    // parse degree shift for the bit
	    var degreeShift = this._parseProperty('degreeShift', options.degreeShift || 0);
	    // put the index of the module back
	    this._index = mainIndex;

	    var p = this._props,
	        degreeCnt = p.degree % 360 === 0 ? p.count : p.count - 1 || 1,
	        step = p.degree / degreeCnt,
	        pointStart = this._getSidePoint('start', index * step + degreeShift, i),
	        pointEnd = this._getSidePoint('end', index * step + degreeShift, i);

	    options.x = this._getDeltaFromPoints('x', pointStart, pointEnd);
	    options.y = this._getDeltaFromPoints('y', pointStart, pointEnd);

	    options.angle = this._getBitAngle(options.angle || 0, degreeShift, index);
	  };
	  /* 
	    Method to get shapes angle in burst so
	    it will follow circular shape.
	     
	     @param    {Number, Object} Base angle.
	     @param    {Number}         Angle shift for the bit
	     @param    {Number}         Shape's index in burst.
	     @returns  {Number}         Angle in burst.
	  */


	  Burst.prototype._getBitAngle = function _getBitAngle() {
	    var angleProperty = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	    var angleShift = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	    var i = arguments[2];

	    var p = this._props,
	        degCnt = p.degree % 360 === 0 ? p.count : p.count - 1 || 1,
	        step = p.degree / degCnt,
	        angle = i * step + 90;

	    angle += angleShift;
	    // if not delta option
	    if (!this._isDelta(angleProperty)) {
	      angleProperty += angle;
	    } else {
	      var delta = {},
	          keys = (0, _keys2.default)(angleProperty),
	          start = keys[0],
	          end = angleProperty[start];

	      start = _h2.default.parseStringOption(start, i);
	      end = _h2.default.parseStringOption(end, i);
	      // new start = newEnd
	      delta[parseFloat(start) + angle] = parseFloat(end) + angle;

	      angleProperty = delta;
	    }
	    return angleProperty;
	  };
	  /*
	    Method to get radial point on `start` or `end`.
	    @private
	    @param {String} Name of the side - [start, end].
	    @param {Number} Angle of the radial point.
	    @param {Number} Index of the main swirl.
	    @returns radial point.
	  */


	  Burst.prototype._getSidePoint = function _getSidePoint(side, angle, i) {
	    var p = this._props,
	        sideRadius = this._getSideRadius(side, i);

	    return _h2.default.getRadialPoint({
	      radius: sideRadius.radius,
	      radiusX: sideRadius.radiusX,
	      radiusY: sideRadius.radiusY,
	      angle: angle,
	      // center:  { x: p.center, y: p.center }
	      center: { x: 0, y: 0 }
	    });
	  };
	  /*
	    Method to get radius of the side.
	    @private
	    @param {String} Name of the side - [start, end].
	    @param {Number} Index of the main swirl.
	    @returns {Object} Radius.
	  */


	  Burst.prototype._getSideRadius = function _getSideRadius(side, i) {
	    return {
	      radius: this._getRadiusByKey('radius', side, i),
	      radiusX: this._getRadiusByKey('radiusX', side, i),
	      radiusY: this._getRadiusByKey('radiusY', side, i)
	    };
	  };
	  /*
	    Method to get radius from ∆ or plain property.
	    @private
	    @param {String} Key name.
	    @param {String} Side name - [start, end].
	    @param {Number} Index of the main swirl.
	    @returns {Number} Radius value.
	  */


	  Burst.prototype._getRadiusByKey = function _getRadiusByKey(key, side) {
	    var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

	    var swirl = this._masterSwirls[i],
	        deltas = swirl._deltas,
	        props = swirl._props;

	    if (deltas[key] != null) {
	      return deltas[key][side];
	    } else if (props[key] != null) {
	      return props[key];
	    }
	  };
	  /*
	    Method to get delta from start and end position points.
	    @private
	    @param {String} Key name.
	    @param {Object} Start position point.
	    @param {Object} End position point.
	    @returns {Object} Delta of the end/start.
	  */


	  Burst.prototype._getDeltaFromPoints = function _getDeltaFromPoints(key, pointStart, pointEnd) {
	    var delta = {};
	    if (pointStart[key] === pointEnd[key]) {
	      delta = pointStart[key];
	    } else {
	      delta[pointStart[key]] = pointEnd[key];
	    }
	    return delta;
	  };
	  /*
	    Method to create timeline.
	    @private
	    @override @ Tweenable
	  */


	  Burst.prototype._makeTimeline = function _makeTimeline() {
	    // restore timeline options that were deleted in _render method
	    this._o.timeline = this._timelineOptions;
	    _Tunable.prototype._makeTimeline.call(this);
	    this.timeline.add(this.masterSwirl, this._swirls[0]);
	  };
	  /*
	    Method to make Tween for the module.
	    @private
	    @override @ Tweenable
	  */


	  Burst.prototype._makeTween = function _makeTween() {} /* don't create any tween */
	  /*
	    Override `_hide` and `_show` methods on module
	    since we don't have to hide nor show on the module.
	  */
	  ;

	  Burst.prototype._hide = function _hide() {/* do nothing */};

	  Burst.prototype._show = function _show() {/* do nothing */};

	  return Burst;
	}(_tunable2.default);

	var ChildSwirl = function (_ShapeSwirl) {
	  (0, _inherits3.default)(ChildSwirl, _ShapeSwirl);

	  function ChildSwirl() {
	    (0, _classCallCheck3.default)(this, ChildSwirl);
	    return (0, _possibleConstructorReturn3.default)(this, _ShapeSwirl.apply(this, arguments));
	  }

	  ChildSwirl.prototype._declareDefaults = function _declareDefaults() {
	    _ShapeSwirl.prototype._declareDefaults.call(this);
	    this._defaults.isSwirl = false;
	    this._o.duration = this._o.duration != null ? this._o.duration : 700;
	  };
	  // disable degreeshift calculations


	  ChildSwirl.prototype._calcSwirlXY = function _calcSwirlXY(proc) {
	    var degreeShift = this._props.degreeShift;

	    this._props.degreeShift = 0;
	    _ShapeSwirl.prototype._calcSwirlXY.call(this, proc);
	    this._props.degreeShift = degreeShift;
	  };

	  return ChildSwirl;
	}(_shapeSwirl2.default);

	var MainSwirl = function (_ChildSwirl) {
	  (0, _inherits3.default)(MainSwirl, _ChildSwirl);

	  function MainSwirl() {
	    (0, _classCallCheck3.default)(this, MainSwirl);
	    return (0, _possibleConstructorReturn3.default)(this, _ChildSwirl.apply(this, arguments));
	  }

	  MainSwirl.prototype._declareDefaults = function _declareDefaults() {
	    _ChildSwirl.prototype._declareDefaults.call(this);
	    this._defaults.scale = 1;
	    this._defaults.width = 0;
	    this._defaults.height = 0;
	    this._defaults.radius = { 25: 75 };
	    // this._defaults.duration = 2000;
	  };

	  return MainSwirl;
	}(ChildSwirl);

	Burst.ChildSwirl = ChildSwirl;
	Burst.MainSwirl = MainSwirl;

	exports.default = Burst;

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _extends4 = __webpack_require__(120);

	var _extends5 = _interopRequireDefault(_extends4);

	var _classCallCheck2 = __webpack_require__(74);

	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

	var _possibleConstructorReturn2 = __webpack_require__(75);

	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

	var _inherits2 = __webpack_require__(76);

	var _inherits3 = _interopRequireDefault(_inherits2);

	var _keys = __webpack_require__(95);

	var _keys2 = _interopRequireDefault(_keys);

	var _thenable = __webpack_require__(99);

	var _thenable2 = _interopRequireDefault(_thenable);

	var _tween = __webpack_require__(101);

	var _tween2 = _interopRequireDefault(_tween);

	var _deltas = __webpack_require__(125);

	var _deltas2 = _interopRequireDefault(_deltas);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var h = __webpack_require__(71);


	// get tween properties
	var obj = {};
	_tween2.default.prototype._declareDefaults.call(obj);
	var keys = (0, _keys2.default)(obj._defaults);
	for (var i = 0; i < keys.length; i++) {
	  obj._defaults[keys[i]] = 1;
	}
	obj._defaults['timeline'] = 1;
	var TWEEN_PROPERTIES = obj._defaults;

	/*
	  TODO:

	    - change _props to _propsObj for animations
	    - current values in deltas
	*/

	var Html = function (_Thenable) {
	  (0, _inherits3.default)(Html, _Thenable);

	  function Html() {
	    (0, _classCallCheck3.default)(this, Html);
	    return (0, _possibleConstructorReturn3.default)(this, _Thenable.apply(this, arguments));
	  }

	  Html.prototype._declareDefaults = function _declareDefaults() {
	    this._defaults = {
	      x: 0,
	      y: 0,
	      z: 0,

	      skewX: 0,
	      skewY: 0,

	      // angle:      0,
	      angleX: 0,
	      angleY: 0,
	      angleZ: 0,

	      scale: 1,
	      scaleX: 1,
	      scaleY: 1,

	      isSoftHide: true,
	      isShowStart: true,
	      isShowEnd: true,
	      isForce3d: false,
	      isRefreshState: true

	    };
	    // exclude from automatic drawing
	    this._drawExclude = { el: 1 };
	    // properties that cause 3d layer
	    this._3dProperties = ['angleX', 'angleY', 'z'];
	    // properties that have array values
	    this._arrayPropertyMap = { transformOrigin: 1, backgroundPosition: 1 };
	    // properties that have no units
	    this._numberPropertyMap = {
	      opacity: 1, scale: 1, scaleX: 1, scaleY: 1,
	      // angle: 1,
	      angleX: 1, angleY: 1, angleZ: 1,
	      skewX: 1, skewY: 1
	    };
	    // properties that should be prefixed 
	    this._prefixPropertyMap = { transform: 1, transformOrigin: 1 };
	    // save prefix
	    this._prefix = h.prefix.css;
	  };

	  Html.prototype.then = function then(o) {
	    // return if nothing was passed
	    if (o == null || !(0, _keys2.default)(o).length) {
	      return 1;
	    }

	    // get the last item in `then` chain
	    var prevModule = h.getLastItem(this._modules);
	    // set deltas to the finish state
	    prevModule.deltas.refresh(false);
	    // copy finish state to the last history record
	    this._history[this._history.length - 1] = prevModule._o;
	    // call super
	    _Thenable.prototype.then.call(this, o);
	    // restore the _props
	    prevModule.deltas.restore();

	    return this;
	  };
	  /*
	    Method to pipe startValue of the delta.
	    @private
	    @ovarrides @ Thenable
	    @param {String} Start property name.
	    @param {Any} Start property value.
	    @returns {Any} Start property value.
	  */


	  Html.prototype._checkStartValue = function _checkStartValue(key, value) {
	    if (value == null) {
	      // return default value for transforms
	      if (this._defaults[key] != null) {
	        return this._defaults[key];
	      }
	      // return default value from _customProps
	      if (this._customProps[key] != null) {
	        return this._customProps[key];
	      }
	      // try to get the default value
	      if (h.defaultStyles[key] != null) {
	        return h.defaultStyles[key];
	      }
	      // at the end return 0
	      return 0;
	    }

	    return value;
	  };
	  /*
	    Method to draw _props to el.
	    @private
	  */


	  Html.prototype._draw = function _draw() {
	    var p = this._props;
	    for (var i = 0; i < this._drawProps.length; i++) {
	      var name = this._drawProps[i];
	      this._setStyle(name, p[name]);
	    }
	    // draw transforms
	    this._drawTransform();
	    // call custom transform callback if exist
	    this._customDraw && this._customDraw(this._props.el, this._props);
	  };
	  /*
	    Method to set transform on element.
	    @private
	  */


	  Html.prototype._drawTransform = function _drawTransform() {
	    var p = this._props;
	    var string = !this._is3d ? 'translate(' + p.x + ', ' + p.y + ')\n          rotate(' + p.angleZ + 'deg)\n          skew(' + p.skewX + 'deg, ' + p.skewY + 'deg)\n          scale(' + p.scaleX + ', ' + p.scaleY + ')' : 'translate3d(' + p.x + ', ' + p.y + ', ' + p.z + ')\n          rotateX(' + p.angleX + 'deg)\n          rotateY(' + p.angleY + 'deg)\n          rotateZ(' + p.angleZ + 'deg)\n          skew(' + p.skewX + 'deg, ' + p.skewY + 'deg)\n          scale(' + p.scaleX + ', ' + p.scaleY + ')';

	    this._setStyle('transform', string);
	  };
	  /*
	    Method to render on initialization.
	    @private
	    @overrides @ Module
	  */


	  Html.prototype._render = function _render() {
	    // return immediately if not the first in `then` chain
	    if (this._o.prevChainModule) {
	      return;
	    }

	    var p = this._props;

	    for (var i = 0; i < this._renderProps.length; i++) {
	      var name = this._renderProps[i],
	          value = p[name];

	      value = typeof value === 'number' ? value + 'px' : value;
	      this._setStyle(name, value);
	    }

	    this._draw();

	    if (!p.isShowStart) {
	      this._hide();
	    }
	  };
	  /*
	    Method to set style on el.
	    @private
	    @param {String} Style property name.
	    @param {String} Style property value.
	  */


	  Html.prototype._setStyle = function _setStyle(name, value) {
	    if (this._state[name] !== value) {
	      var style = this._props.el.style;
	      // set style
	      style[name] = value;
	      // if prefix needed - set it
	      if (this._prefixPropertyMap[name]) {
	        style['' + this._prefix + name] = value;
	      }
	      // cache the last set value
	      this._state[name] = value;
	    }
	  };
	  /*
	    Method to copy `_o` options to `_props` object.
	    @private
	  */


	  Html.prototype._extendDefaults = function _extendDefaults() {
	    this._props = this._o.props || {};
	    // props for intial render only
	    this._renderProps = [];
	    // props for draw on every frame update
	    this._drawProps = [];
	    // save custom properties if present
	    this._saveCustomProperties(this._o);
	    // copy the options
	    var o = (0, _extends5.default)({}, this._o);
	    // extend options with defaults
	    o = this._addDefaults(o);

	    var keys = (0, _keys2.default)(o);
	    for (var i = 0; i < keys.length; i++) {
	      var key = keys[i];
	      // include the property if it is not in drawExclude object
	      // and not in defaults = not a transform
	      var isInclude = !this._drawExclude[key] && // not in exclude map
	      this._defaults[key] == null && // not transform property
	      !TWEEN_PROPERTIES[key]; // not tween property

	      var isCustom = this._customProps[key];
	      // copy all non-delta properties to the props
	      // if not delta then add the property to render
	      // list that is called on initialization
	      // otherwise add it to the draw list that will
	      // be drawed on each frame
	      if (!h.isDelta(o[key]) && !TWEEN_PROPERTIES[key]) {
	        this._parseOption(key, o[key]);
	        if (key === 'el') {
	          this._props.el = h.parseEl(o.el);
	          this.el = this._props.el;
	        }
	        if (isInclude && !isCustom) {
	          this._renderProps.push(key);
	        }
	        // copy delta prop but not transforms
	        // otherwise push it to draw list that gets traversed on every draw
	      } else if (isInclude && !isCustom) {
	        this._drawProps.push(key);
	      }
	    }

	    this._createDeltas(o);
	  };
	  /*
	    Method to save customProperties to _customProps.
	    @param {Object} Options of the module.
	  */


	  Html.prototype._saveCustomProperties = function _saveCustomProperties() {
	    var o = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    this._customProps = o.customProperties || {};
	    this._customProps = (0, _extends5.default)({}, this._customProps);
	    this._customDraw = this._customProps.draw;
	    delete this._customProps.draw;
	    delete o.customProperties;

	    this._copyDefaultCustomProps();

	    // if ( this._customProps ) {}
	    // this._customProps = this._customProps || {};
	  };

	  Html.prototype._copyDefaultCustomProps = function _copyDefaultCustomProps() {
	    for (var key in this._customProps) {
	      if (this._o[key] == null) {
	        this._o[key] = this._customProps[key];
	      }
	    }
	  };
	  /*
	    Method to reset some flags on merged options object.
	    @private
	    @overrides @ Thenable
	    @param   {Object} Options object.
	    @returns {Object} Options object.
	  */


	  Html.prototype._resetMergedFlags = function _resetMergedFlags(o) {
	    _Thenable.prototype._resetMergedFlags.call(this, o);
	    o.props = this._props;
	    o.customProperties = this._customProps;
	    return o;
	  };
	  /*
	    Method to parse option value.
	    @private
	    @param {String} Option name.
	    @param {Any} Option value.
	  */


	  Html.prototype._parseOption = function _parseOption(key, value) {
	    _Thenable.prototype._parseOption.call(this, key, value);
	    // at this point the property is parsed
	    var parsed = this._props[key];
	    // cast it to string if it is array
	    if (h.isArray(parsed)) {
	      this._props[key] = this._arrToString(parsed);
	    }
	  };
	  /*
	    Method cast array to string value.
	    @private
	    @param {Array} Array of parsed numbers with units.
	    @returns {String} Casted array.
	  */


	  Html.prototype._arrToString = function _arrToString(arr) {
	    var string = '';
	    for (var i = 0; i < arr.length; i++) {
	      string += arr[i].string + ' ';
	    }
	    return string;
	  };
	  /*
	    Method to add defauls to passed object.
	    @private
	    @param {Object} Object to add defaults to.
	  */


	  Html.prototype._addDefaults = function _addDefaults(obj) {
	    // flag that after all defaults are set will indicate
	    // if user have set the 3d transform
	    this._is3d = false;

	    for (var key in this._defaults) {
	      // skip property if it is listed in _skipProps
	      // if (this._skipProps && this._skipProps[key]) { continue; }

	      // copy the properties to the _o object
	      // if it's null - set the default value
	      if (obj[key] == null) {
	        // scaleX and scaleY should fallback to scale
	        if (key === 'scaleX' || key === 'scaleY') {
	          obj[key] = obj['scale'] != null ? obj['scale'] : this._defaults['scale'];
	        } else {
	          obj[key] = this._defaults[key];
	        }
	      } else {
	        // get if 3d property was set.
	        if (this._3dProperties.indexOf(key) !== -1) {
	          this._is3d = true;
	        }
	      }
	    }

	    if (this._o.isForce3d) {
	      this._is3d = true;
	    }

	    return obj;
	  };
	  /*
	    Lifecycle method to declare variables.
	    @private
	  */


	  Html.prototype._vars = function _vars() {
	    // set deltas to the last value, so the _props with
	    // end values will be copied to the _history, it is
	    // crucial for `then` chaining
	    this.deltas.refresh(false);
	    // call super vars
	    _Thenable.prototype._vars.call(this);
	    // state of set properties
	    this._state = {};
	    // restore delta values that we have refreshed before
	    this.deltas.restore(false);
	  };
	  /*
	    Method to create deltas from passed object.
	    @private
	    @param {Object} Options object to pass to the Deltas.
	  */


	  Html.prototype._createDeltas = function _createDeltas(options) {
	    this.deltas = new _deltas2.default({
	      options: options,
	      props: this._props,
	      arrayPropertyMap: this._arrayPropertyMap,
	      numberPropertyMap: this._numberPropertyMap,
	      customProps: this._customProps,
	      callbacksContext: options.callbacksContext || this,
	      isChained: !!this._o.prevChainModule
	    });

	    // if chained module set timeline to deltas' timeline 
	    if (this._o.prevChainModule) {
	      this.timeline = this.deltas.timeline;
	    }
	  };
	  /* @overrides @ Tweenable */


	  Html.prototype._makeTween = function _makeTween() {};

	  Html.prototype._makeTimeline = function _makeTimeline() {
	    // do not create timeline if module if chained
	    if (this._o.prevChainModule) {
	      return;
	    }
	    // add callbacks overrides
	    this._o.timeline = this._o.timeline || {};
	    this._addCallbackOverrides(this._o.timeline);
	    _Thenable.prototype._makeTimeline.call(this);
	    this.timeline.add(this.deltas);
	  };
	  /*
	    Method to add callback overrides to passed object object.
	    @param {Object} Object to add overrides on.
	  */


	  Html.prototype._addCallbackOverrides = function _addCallbackOverrides(o) {
	    var it = this;
	    var p = this._props;
	    o.callbackOverrides = {
	      onUpdate: this._draw,
	      onRefresh: this._props.isRefreshState ? this._draw : void 0,
	      onStart: function onStart(isFwd) {
	        // don't touch main `el` onStart in chained elements
	        if (it._isChained) {
	          return;
	        };
	        // show if was hidden at start
	        if (isFwd && !p.isShowStart) {
	          it._show();
	        }
	        // hide if should be hidden at start
	        else {
	            if (!p.isShowStart) {
	              it._hide();
	            }
	          }
	      },
	      onComplete: function onComplete(isFwd) {
	        // don't touch main `el` if not the last in `then` chain
	        if (it._isChained) {
	          return;
	        }
	        if (isFwd) {
	          if (!p.isShowEnd) {
	            it._hide();
	          }
	        } else if (!p.isShowEnd) {
	          it._show();
	        }
	      }
	    };
	  };

	  /*
	    Method that gets called on `soft` show of the module,
	    it should restore transform styles of the module.
	    @private
	    @overrides @ Module
	  */


	  Html.prototype._showByTransform = function _showByTransform() {
	    this._drawTransform();
	  };

	  /*
	    Method to merge `start` and `end` for a property in then record.
	    @private
	    @param {String} Property name.
	    @param {Any}    Start value of the property.
	    @param {Any}    End value of the property.
	  */
	  // !! COVER !!


	  Html.prototype._mergeThenProperty = function _mergeThenProperty(key, startValue, endValue) {
	    // if isnt tween property
	    var isBoolean = typeof endValue === 'boolean',
	        curve,
	        easing;

	    if (!h.isTweenProp(key) && !this._nonMergeProps[key] && !isBoolean) {

	      var TWEEN_PROPS = {};
	      if (h.isObject(endValue) && endValue.to != null) {
	        for (var _key in endValue) {
	          if (TWEEN_PROPERTIES[_key] || _key === 'curve') {
	            TWEEN_PROPS[_key] = endValue[_key];
	            delete endValue[_key];
	          }
	        }
	        // curve    = endValue.curve;
	        // easing   = endValue.easing;
	        endValue = endValue.to;
	      }

	      // if end value is delta - just save it
	      if (this._isDelta(endValue)) {

	        var _TWEEN_PROPS = {};
	        for (var _key2 in endValue) {
	          if (TWEEN_PROPERTIES[_key2] || _key2 === 'curve') {
	            _TWEEN_PROPS[_key2] = endValue[_key2];
	            delete endValue[_key2];
	          }
	        }
	        var result = this._parseDeltaValues(key, endValue);

	        return (0, _extends5.default)({}, result, _TWEEN_PROPS);
	      } else {
	        var parsedEndValue = this._parsePreArrayProperty(key, endValue);
	        // if end value is not delta - merge with start value
	        if (this._isDelta(startValue)) {
	          var _extends2;

	          // if start value is delta - take the end value
	          // as start value of the new delta
	          return (0, _extends5.default)((_extends2 = {}, _extends2[h.getDeltaEnd(startValue)] = parsedEndValue, _extends2), TWEEN_PROPS);
	          // if both start and end value are not ∆ - make ∆
	        } else {
	          var _extends3;

	          return (0, _extends5.default)((_extends3 = {}, _extends3[startValue] = parsedEndValue, _extends3), TWEEN_PROPS);
	        }
	      }
	      // copy the tween values unattended
	    } else {
	      return endValue;
	    }
	  };

	  return Html;
	}(_thenable2.default);

	exports.default = Html;

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;

	var _assign = __webpack_require__(121);

	var _assign2 = _interopRequireDefault(_assign);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _assign2.default || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];

	    for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }

	  return target;
	};

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(122), __esModule: true };

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(123);
	module.exports = __webpack_require__(14).Object.assign;

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.3.1 Object.assign(target, source)
	var $export = __webpack_require__(12);

	$export($export.S + $export.F, 'Object', {assign: __webpack_require__(124)});

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// 19.1.2.1 Object.assign(target, source, ...)
	var getKeys  = __webpack_require__(33)
	  , gOPS     = __webpack_require__(62)
	  , pIE      = __webpack_require__(63)
	  , toObject = __webpack_require__(49)
	  , IObject  = __webpack_require__(36)
	  , $assign  = Object.assign;

	// should work with symbols and should have deterministic property order (V8 bug)
	module.exports = !$assign || __webpack_require__(23)(function(){
	  var A = {}
	    , B = {}
	    , S = Symbol()
	    , K = 'abcdefghijklmnopqrst';
	  A[S] = 7;
	  K.split('').forEach(function(k){ B[k] = k; });
	  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
	}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
	  var T     = toObject(target)
	    , aLen  = arguments.length
	    , index = 1
	    , getSymbols = gOPS.f
	    , isEnum     = pIE.f;
	  while(aLen > index){
	    var S      = IObject(arguments[index++])
	      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
	      , length = keys.length
	      , j      = 0
	      , key;
	    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
	  } return T;
	} : $assign;

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _extends2 = __webpack_require__(120);

	var _extends3 = _interopRequireDefault(_extends2);

	var _classCallCheck2 = __webpack_require__(74);

	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

	var _keys = __webpack_require__(95);

	var _keys2 = _interopRequireDefault(_keys);

	var _timeline = __webpack_require__(110);

	var _timeline2 = _interopRequireDefault(_timeline);

	var _tween = __webpack_require__(101);

	var _tween2 = _interopRequireDefault(_tween);

	var _delta = __webpack_require__(126);

	var _delta2 = _interopRequireDefault(_delta);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/*
	  This module's target is to parse options object,
	  find deltas in it and send them to `Delta` classes.
	  The `Delta` class is dull - they expect actual parsed deltas
	  and separated tween options, so we should parse them here.
	  The timeline of the module controls the `Delta` modules' tweens.

	  @param {Object} props Object to set deltas result to (pass to the Delta classes).
	  @param {Object} options Object to parse the deltas from.
	  @param {Function} onUpdate onUpdate callback.
	  @param optional {Object} arrayPropertyMap List of properties with truthy
	                                            values which describe properties
	                                            that should be parsed as arrays.
	  @param optional {Object} numberPropertyMap List of properties with truthy
	                                            values which describe properties
	                                            that should be parsed as numbers
	                                            without units.
	*/

	// TODO:
	// - colors with curves change alpha level too
	// const html = new mojs.Html({
	//   el: '#js-el',
	//   x: { 0: 100 },
	//   onUpdate () {
	//     console.log(this._props.originX);
	//   },
	//   originX: { 'white': 'black', curve: 'M0,100 L100, 0' },
	//   customProperties: {
	//     originX: {
	//       type: 'color',
	//       default: 'cyan'
	//     },
	//     draw() { console.log('draw'); }
	//   }
	// });


	var easing = __webpack_require__(105);
	var h = __webpack_require__(71);


	// get tween properties
	var obj = {};
	_tween2.default.prototype._declareDefaults.call(obj);
	var keys = (0, _keys2.default)(obj._defaults);
	for (var i = 0; i < keys.length; i++) {
	  obj._defaults[keys[i]] = 1;
	}
	obj._defaults['timeline'] = 1;
	var TWEEN_PROPERTIES = obj._defaults;

	var Deltas = function () {
	  function Deltas() {
	    var o = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    (0, _classCallCheck3.default)(this, Deltas);

	    this._o = o;

	    this._shortColors = {
	      transparent: 'rgba(0,0,0,0)',
	      none: 'rgba(0,0,0,0)',
	      aqua: 'rgb(0,255,255)',
	      black: 'rgb(0,0,0)',
	      blue: 'rgb(0,0,255)',
	      fuchsia: 'rgb(255,0,255)',
	      gray: 'rgb(128,128,128)',
	      green: 'rgb(0,128,0)',
	      lime: 'rgb(0,255,0)',
	      maroon: 'rgb(128,0,0)',
	      navy: 'rgb(0,0,128)',
	      olive: 'rgb(128,128,0)',
	      purple: 'rgb(128,0,128)',
	      red: 'rgb(255,0,0)',
	      silver: 'rgb(192,192,192)',
	      teal: 'rgb(0,128,128)',
	      white: 'rgb(255,255,255)',
	      yellow: 'rgb(255,255,0)',
	      orange: 'rgb(255,128,0)'
	    };

	    this._ignoreDeltasMap = { prevChainModule: 1, masterModule: 1 };

	    this._parseDeltas(o.options);
	    this._createDeltas();
	    this._createTimeline(this._mainTweenOptions);
	  }
	  /*
	    Method to call `refresh` on all child `delta` objects.
	    @public
	    @param {Boolean} If before start time (true) or after end time (false).
	  */


	  Deltas.prototype.refresh = function refresh(isBefore) {
	    for (var i = 0; i < this._deltas.length; i++) {
	      this._deltas[i].refresh(isBefore);
	    }
	    return this;
	  };
	  /*
	    Method to call `restore` on all child `delta` objects.
	    @public
	  */


	  Deltas.prototype.restore = function restore() {
	    for (var i = 0; i < this._deltas.length; i++) {
	      this._deltas[i].restore();
	    }
	    return this;
	  };
	  /*
	    Method to create Timeline.
	    @private
	    @param {Object} Timeline options.
	  */


	  Deltas.prototype._createTimeline = function _createTimeline() {
	    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    // const o = this._o;
	    // opts.timeline = opts.timeline || {};
	    // opts.timeline.callbackOverrides = {
	    //   onUpdate:   o.onUpdate,
	    //   onRefresh:  o.onUpdate
	    // }
	    // send callbacksContext to timeline if set
	    // o.callbacksContext && (opts.timeline.callbacksContext = o.callbacksContext);
	    // opts.timeline
	    this.timeline = new _timeline2.default();
	    this.timeline.add(this._deltas);
	  };
	  /*
	    Method to create Deltas from parsed options.
	    @private
	  */


	  Deltas.prototype._createDeltas = function _createDeltas() {
	    this._deltas = [];

	    // create main delta object
	    this._deltas.push(this._createDelta(this._mainDeltas, this._mainTweenOptions));

	    // create child delta object
	    for (var i = 0; i < this._childDeltas.length; i++) {
	      var delta = this._childDeltas[i];
	      this._deltas.push(this._createDelta([delta.delta], delta.tweenOptions));
	    }
	  };
	  /*
	    Method to create Delta object with passed options.
	    @private
	    @param {Array} Array of deltas.
	    @param {Object} Tween properties.
	    @returns {Object} Delta object
	  */


	  Deltas.prototype._createDelta = function _createDelta(deltas, tweenOptions) {
	    var o = this._o;
	    return new _delta2.default({
	      deltas: deltas, tweenOptions: tweenOptions,
	      props: o.props,
	      isChained: o.isChained,
	      callbacksContext: o.callbacksContext
	    });
	  };
	  /*
	    Method to parse delta objects from options.
	    @private
	    @param {Object} Options object to parse the deltas from.
	  */


	  Deltas.prototype._parseDeltas = function _parseDeltas(obj) {
	    // spilt main animation properties and main tween properties
	    var mainSplit = this._splitTweenOptions(obj);
	    // main animation properties
	    var opts = mainSplit.delta;
	    // main tween properties
	    this._mainTweenOptions = mainSplit.tweenOptions;

	    this._mainDeltas = [];
	    this._childDeltas = [];
	    var keys = (0, _keys2.default)(opts);
	    // loop thru all properties without tween ones
	    for (var i = 0; i < keys.length; i++) {
	      var key = keys[i];
	      // is property is delta - parse it
	      if (this._isDelta(opts[key]) && !this._ignoreDeltasMap[key]) {
	        var delta = this._splitAndParseDelta(key, opts[key]);
	        // if parsed object has no tween values - it's delta of the main object
	        if (!delta.tweenOptions) {
	          this._mainDeltas.push(delta.delta);
	        }
	        // otherwise it is distinct delta object
	        else {
	            this._childDeltas.push(delta);
	          }
	      }
	    }
	  };
	  /*
	    Method to split tween values and parse single delta record.
	    @private
	    @param {String} Property name.
	    @param {Object} Raw delta object.
	    @returns {Object} Split object.
	                @param {Object} tweenOptions Tween properties.
	                @param {Object} delta Parsed delta.
	  */


	  Deltas.prototype._splitAndParseDelta = function _splitAndParseDelta(name, object) {
	    var split = this._splitTweenOptions(object);
	    // parse delta in the object
	    split.delta = this._parseDelta(name, split.delta);
	    return split;
	  };
	  /*
	    Method to parse delta by delegating the variables to _parse*Delta methods.
	    @private
	    @param {String} Property name.
	    @param {Object} Raw delta object.
	    @param {Number} Module index.
	  */


	  Deltas.prototype._parseDelta = function _parseDelta(name, object, index) {
	    // if name is in _o.customProps - parse it regarding the type
	    return this._o.customProps && this._o.customProps[name] != null ? this._parseDeltaByCustom(name, object, index) : this._parseDeltaByGuess(name, object, index);
	  };
	  /**
	    Method to parse delta by taking the type from the customProps object.
	    @private
	    @param {String} Property name.
	    @param {Object} Raw delta object.
	    @param {Number} Module index.
	  */


	  Deltas.prototype._parseDeltaByCustom = function _parseDeltaByCustom(name, object, index) {
	    return this._parseNumberDelta(name, object, index);
	    // const customRecord = this._o.customProps[name];
	    // switch ( customRecord.type.toLowerCase() ) {
	    //   case 'color':  { return this._parseColorDelta( name, object ); }
	    //   case 'array':  { return this._parseArrayDelta( name, object ); }
	    //   case 'number': { return this._parseNumberDelta( name, object, index ); }
	    //   case 'unit':   { return this._parseUnitDelta( name, object, index ); }
	    // }
	  };
	  /**
	    Method to parse delta by reasoning about it's value.
	    @private
	    @param {String} Property name.
	    @param {Object} Raw delta object.
	    @param {Number} Module index.
	  */


	  Deltas.prototype._parseDeltaByGuess = function _parseDeltaByGuess(name, object, index) {
	    var _preparseDelta2 = this._preparseDelta(object),
	        start = _preparseDelta2.start;

	    var o = this._o;

	    // color values
	    if (isNaN(parseFloat(start)) && !start.match(/rand\(/) && !start.match(/stagger\(/)) {
	      return this._parseColorDelta(name, object);
	      // array values
	    } else if (o.arrayPropertyMap && o.arrayPropertyMap[name]) {
	      return this._parseArrayDelta(name, object);
	      // unit or number values
	    } else {
	      return o.numberPropertyMap && o.numberPropertyMap[name] ?
	      // if the property is in the number property map - parse it like number
	      this._parseNumberDelta(name, object, index)
	      // otherwise - like number with units
	      : this._parseUnitDelta(name, object, index);
	    }
	  };
	  /*
	    Method to separate tween options from delta properties.
	    @param {Object} Object for separation.
	    @returns {Object} Object that contains 2 objects
	                        - one delta options
	                        - one tween options ( could be empty if no tween opts )
	  */


	  Deltas.prototype._splitTweenOptions = function _splitTweenOptions(delta) {
	    delta = (0, _extends3.default)({}, delta);

	    var keys = (0, _keys2.default)(delta),
	        tweenOptions = {};
	    var isTween = null;

	    for (var i = 0; i < keys.length; i++) {
	      var key = keys[i];
	      if (TWEEN_PROPERTIES[key]) {
	        if (delta[key] != null) {
	          tweenOptions[key] = delta[key];
	          isTween = true;
	        }
	        delete delta[key];
	      }
	    }
	    return {
	      delta: delta,
	      tweenOptions: isTween ? tweenOptions : undefined
	    };
	  };
	  /*
	    Method to check if the property is delta property.
	    @private
	    @param {Any} Parameter value to check.
	    @returns {Boolean}
	  */


	  Deltas.prototype._isDelta = function _isDelta(optionsValue) {
	    var isObject = h.isObject(optionsValue);
	    isObject = isObject && !optionsValue.unit;
	    return !(!isObject || h.isArray(optionsValue) || h.isDOM(optionsValue));
	  };
	  /*
	    Method to parse color delta values.
	    @private
	    @param {String} Name of the property.
	    @param {Any} Property value.
	    @returns {Object} Parsed delta.
	  */


	  Deltas.prototype._parseColorDelta = function _parseColorDelta(key, value) {
	    if (key === 'strokeLinecap') {
	      h.warn('Sorry, stroke-linecap property is not animatable yet, using the start(#{start}) value instead', value);
	      return {};
	    }
	    var preParse = this._preparseDelta(value);

	    var startColorObj = this._makeColorObj(preParse.start),
	        endColorObj = this._makeColorObj(preParse.end);

	    var delta = {
	      type: 'color',
	      name: key,
	      start: startColorObj,
	      end: endColorObj,
	      curve: preParse.curve,
	      delta: {
	        r: endColorObj.r - startColorObj.r,
	        g: endColorObj.g - startColorObj.g,
	        b: endColorObj.b - startColorObj.b,
	        a: endColorObj.a - startColorObj.a
	      }
	    };
	    return delta;
	  };
	  /*
	    Method to parse array delta values.
	    @private
	    @param {String} Name of the property.
	    @param {Any} Property value.
	    @returns {Object} Parsed delta.
	  */


	  Deltas.prototype._parseArrayDelta = function _parseArrayDelta(key, value) {
	    var preParse = this._preparseDelta(value);

	    var startArr = this._strToArr(preParse.start),
	        endArr = this._strToArr(preParse.end);

	    h.normDashArrays(startArr, endArr);

	    for (var i = 0; i < startArr.length; i++) {
	      var end = endArr[i];
	      h.mergeUnits(startArr[i], end, key);
	    }

	    var delta = {
	      type: 'array',
	      name: key,
	      start: startArr,
	      end: endArr,
	      delta: h.calcArrDelta(startArr, endArr),
	      curve: preParse.curve
	    };

	    return delta;
	  };
	  /*
	    Method to parse numeric delta values with units.
	    @private
	    @param {String} Name of the property.
	    @param {Any} Property value.
	    @param {Number} Index of the module.
	    @returns {Object} Parsed delta.
	  */


	  Deltas.prototype._parseUnitDelta = function _parseUnitDelta(key, value, index) {
	    var preParse = this._preparseDelta(value);

	    var end = h.parseUnit(h.parseStringOption(preParse.end, index)),
	        start = h.parseUnit(h.parseStringOption(preParse.start, index));

	    h.mergeUnits(start, end, key);
	    var delta = {
	      type: 'unit',
	      name: key,
	      start: start,
	      end: end,
	      delta: end.value - start.value,
	      curve: preParse.curve
	    };
	    return delta;
	  };
	  /*
	    Method to parse numeric delta values without units.
	    @private
	    @param {String} Name of the property.
	    @param {Any} Property value.
	    @param {Number} Index of the module.
	    @returns {Object} Parsed delta.
	  */


	  Deltas.prototype._parseNumberDelta = function _parseNumberDelta(key, value, index) {
	    var preParse = this._preparseDelta(value);

	    var end = parseFloat(h.parseStringOption(preParse.end, index)),
	        start = parseFloat(h.parseStringOption(preParse.start, index));

	    var delta = {
	      type: 'number',
	      name: key,
	      start: start,
	      end: end,
	      delta: end - start,
	      curve: preParse.curve
	    };

	    return delta;
	  };
	  /*
	    Method to extract `curve` and `start`/`end` values.
	    @private
	    @param {Object} Delta object.
	    @returns {Object} Preparsed delta.
	              @property {String} Start value.
	              @property {String, Number} End value.
	  */


	  Deltas.prototype._preparseDelta = function _preparseDelta(value) {
	    // clone value object
	    value = (0, _extends3.default)({}, value);
	    // parse curve if exist
	    var curve = value.curve;
	    if (curve != null) {
	      curve = easing.parseEasing(curve);
	      curve._parent = this;
	    }
	    delete value.curve;
	    // parse start and end values
	    var start = (0, _keys2.default)(value)[0],
	        end = value[start];

	    return { start: start, end: end, curve: curve };
	  };
	  /*
	    Method to parse color into usable object.
	    @private
	    @param {String} Color string.
	    @returns {Object} Parsed color value.
	  */


	  Deltas.prototype._makeColorObj = function _makeColorObj(color) {
	    // HEX
	    var colorObj = {};
	    if (color[0] === '#') {
	      var result = /^#?([a-f\d]{1,2})([a-f\d]{1,2})([a-f\d]{1,2})$/i.exec(color);
	      if (result) {
	        var r = result[1].length === 2 ? result[1] : result[1] + result[1],
	            g = result[2].length === 2 ? result[2] : result[2] + result[2],
	            b = result[3].length === 2 ? result[3] : result[3] + result[3];

	        colorObj = {
	          r: parseInt(r, 16), g: parseInt(g, 16), b: parseInt(b, 16), a: 1
	        };
	      }
	    }

	    // not HEX
	    // shorthand color and rgb()
	    if (color[0] !== '#') {
	      var isRgb = color[0] === 'r' && color[1] === 'g' && color[2] === 'b';
	      var rgbColor = void 0;
	      // rgb color
	      if (isRgb) {
	        rgbColor = color;
	      };
	      // shorthand color name
	      if (!isRgb) {
	        if (!this._shortColors[color]) {
	          h.div.style.color = color;
	          rgbColor = h.computedStyle(h.div).color;
	        } else {
	          rgbColor = this._shortColors[color];
	        }
	      }

	      var regexString1 = '^rgba?\\((\\d{1,3}),\\s?(\\d{1,3}),',
	          regexString2 = '\\s?(\\d{1,3}),?\\s?(\\d{1}|0?\\.\\d{1,})?\\)$',
	          _result = new RegExp(regexString1 + regexString2, 'gi').exec(rgbColor),
	          alpha = parseFloat(_result[4] || 1);

	      if (_result) {
	        colorObj = {
	          r: parseInt(_result[1], 10),
	          g: parseInt(_result[2], 10),
	          b: parseInt(_result[3], 10),
	          a: alpha != null && !isNaN(alpha) ? alpha : 1
	        };
	      }
	    }

	    return colorObj;
	  };
	  /*
	    Method to parse string into array.
	    @private
	    @param {String, Number} String or number to parse.
	    @returns {Array} Parsed array.
	  */


	  Deltas.prototype._strToArr = function _strToArr(string) {
	    var arr = [];
	    // plain number
	    if (typeof string === 'number' && !isNaN(string)) {
	      arr.push(h.parseUnit(string));
	      return arr;
	    }
	    // string array
	    string.trim().split(/\s+/gim).forEach(function (str) {
	      arr.push(h.parseUnit(h.parseIfRand(str)));
	    });
	    return arr;
	  };

	  return Deltas;
	}();

	exports.default = Deltas;

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _classCallCheck2 = __webpack_require__(74);

	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

	var _tween = __webpack_require__(101);

	var _tween2 = _interopRequireDefault(_tween);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var h = __webpack_require__(71);

	var Delta = function () {
	  function Delta() {
	    var o = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    (0, _classCallCheck3.default)(this, Delta);

	    this._o = o;
	    this._createTween(o.tweenOptions);
	    // initial properties render
	    !this._o.isChained && this.refresh(true);
	  }
	  /*
	    Method to call `_refresh` method on `tween`.
	    Use switch between `0` and `1` progress for delta value.
	    @public
	    @param {Boolean} If refresh before start time or after.
	    @returns this.
	  */


	  Delta.prototype.refresh = function refresh(isBefore) {
	    this._previousValues = [];

	    var deltas = this._o.deltas;
	    for (var i = 0; i < deltas.length; i++) {
	      var name = deltas[i].name;
	      this._previousValues.push({
	        name: name, value: this._o.props[name]
	      });
	    }

	    this.tween._refresh(isBefore);
	    return this;
	  };
	  /*
	    Method to restore all saved properties from `_previousValues` array.
	    @public
	    @returns this.
	  */


	  Delta.prototype.restore = function restore() {
	    var prev = this._previousValues;
	    for (var i = 0; i < prev.length; i++) {
	      var record = prev[i];
	      this._o.props[record.name] = record.value;
	    }
	    return this;
	  };
	  /*
	    Method to create tween of the delta.
	    @private
	    @param {Object} Options object.
	  */


	  Delta.prototype._createTween = function _createTween() {
	    var o = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    var it = this;
	    o.callbackOverrides = {
	      onUpdate: function onUpdate(ep, p) {
	        it._calcCurrentProps(ep, p);
	      }
	    };

	    // if not chained - add the onRefresh callback
	    // to refresh the tween when needed
	    if (!this._o.isChained) {
	      o.callbackOverrides.onRefresh = function (isBefore, ep, p) {
	        it._calcCurrentProps(ep, p);
	      };
	    }

	    o.callbacksContext = this._o.callbacksContext;
	    this.tween = new _tween2.default(o);
	  };
	  /*
	    Method to calculate current progress of the deltas.
	    @private
	    @param {Number} Eased progress to calculate - [0..1].
	    @param {Number} Progress to calculate - [0..1].
	  */


	  Delta.prototype._calcCurrentProps = function _calcCurrentProps(easedProgress, p) {
	    var deltas = this._o.deltas;
	    for (var i = 0; i < deltas.length; i++) {
	      var type = deltas[i].type;
	      this['_calcCurrent_' + type](deltas[i], easedProgress, p);
	    }
	  };
	  /*
	    Method to calc the current color delta value.
	    @param {Object} Delta
	    @param {Number} Eased progress [0..1].
	    @param {Number} Plain progress [0..1].
	  */


	  Delta.prototype._calcCurrent_color = function _calcCurrent_color(delta, ep, p) {
	    var r,
	        g,
	        b,
	        a,
	        start = delta.start,
	        d = delta.delta;
	    if (!delta.curve) {
	      r = parseInt(start.r + ep * d.r, 10);
	      g = parseInt(start.g + ep * d.g, 10);
	      b = parseInt(start.b + ep * d.b, 10);
	      a = parseFloat(start.a + ep * d.a);
	    } else {
	      var cp = delta.curve(p);
	      r = parseInt(cp * (start.r + p * d.r), 10);
	      g = parseInt(cp * (start.g + p * d.g), 10);
	      b = parseInt(cp * (start.b + p * d.b), 10);
	      a = parseFloat(cp * (start.a + p * d.a));
	    }
	    this._o.props[delta.name] = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
	  };
	  /*
	    Method to calc the current number delta value.
	    @param {Object} Delta
	    @param {Number} Eased progress [0..1].
	    @param {Number} Plain progress [0..1].
	  */


	  Delta.prototype._calcCurrent_number = function _calcCurrent_number(delta, ep, p) {
	    this._o.props[delta.name] = !delta.curve ? delta.start + ep * delta.delta : delta.curve(p) * (delta.start + p * delta.delta);
	  };
	  /*
	    Method to calc the current number with units delta value.
	    @param {Object} Delta
	    @param {Number} Eased progress [0..1].
	    @param {Number} Plain progress [0..1].
	  */


	  Delta.prototype._calcCurrent_unit = function _calcCurrent_unit(delta, ep, p) {
	    var currentValue = !delta.curve ? delta.start.value + ep * delta.delta : delta.curve(p) * (delta.start.value + p * delta.delta);

	    this._o.props[delta.name] = '' + currentValue + delta.end.unit;
	  };
	  /*
	    Method to calc the current array delta value.
	    @param {Object} Delta
	    @param {Number} Eased progress [0..1].
	    @param {Number} Plain progress [0..1].
	  */


	  Delta.prototype._calcCurrent_array = function _calcCurrent_array(delta, ep, p) {
	    // var arr,
	    var name = delta.name,
	        props = this._o.props,
	        string = '';

	    // to prevent GC bothering with arrays garbage
	    // if ( h.isArray( props[name] ) ) {
	    //   arr = props[name];
	    //   arr.length = 0;
	    // } else { arr = []; }

	    // just optimization to prevent curve
	    // calculations on every array item
	    var proc = delta.curve ? delta.curve(p) : null;

	    for (var i = 0; i < delta.delta.length; i++) {
	      var item = delta.delta[i],
	          dash = !delta.curve ? delta.start[i].value + ep * item.value : proc * (delta.start[i].value + p * item.value);

	      string += '' + dash + item.unit + ' ';
	      // arr.push({
	      //   string: `${dash}${item.unit}`,
	      //   value:  dash,
	      //   unit:   item.unit,
	      // });
	    }
	    props[name] = string;
	  };

	  return Delta;
	}();

	exports.default = Delta;

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _keys = __webpack_require__(95);

	var _keys2 = _interopRequireDefault(_keys);

	var _classCallCheck2 = __webpack_require__(74);

	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

	var _possibleConstructorReturn2 = __webpack_require__(75);

	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

	var _inherits2 = __webpack_require__(76);

	var _inherits3 = _interopRequireDefault(_inherits2);

	var _h = __webpack_require__(71);

	var _h2 = _interopRequireDefault(_h);

	var _timeline = __webpack_require__(110);

	var _timeline2 = _interopRequireDefault(_timeline);

	var _tunable = __webpack_require__(116);

	var _tunable2 = _interopRequireDefault(_tunable);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var Stagger = function (_Tunable) {
	  (0, _inherits3.default)(Stagger, _Tunable);

	  function Stagger(options, Module) {
	    var _ret;

	    (0, _classCallCheck3.default)(this, Stagger);

	    var _this = (0, _possibleConstructorReturn3.default)(this, _Tunable.call(this));

	    return _ret = _this._init(options, Module), (0, _possibleConstructorReturn3.default)(_this, _ret);
	  }
	  /*
	    Method to create then chain on child modules.
	    @param {Object} Then options.
	    @return {Object} this.
	  */


	  Stagger.prototype.then = function then(o) {
	    if (o == null) {
	      return this;
	    }
	    for (var i = 0; i < this._modules.length; i++) {
	      // get child module's option and pass to the child `then`
	      this._modules[i].then(this._getOptionByIndex(i, o));
	    }
	    this.timeline._recalcTotalDuration();
	    return this;
	  };
	  /*
	    Method to tune child modules.
	    @param {Object} Tune options.
	    @return {Object} this.
	  */


	  Stagger.prototype.tune = function tune(o) {
	    if (o == null) {
	      return this;
	    }
	    for (var i = 0; i < this._modules.length; i++) {
	      // get child module's option and pass to the child `then`
	      this._modules[i].tune(this._getOptionByIndex(i, o));
	    }
	    this.timeline._recalcTotalDuration();
	    return this;
	  };
	  /*
	    Method to generate child modules.
	    @return {Object} this.
	  */


	  Stagger.prototype.generate = function generate() {
	    for (var i = 0; i < this._modules.length; i++) {
	      // get child module's option and pass to the child `then`
	      this._modules[i].generate();
	    }
	    this.timeline._recalcTotalDuration();
	    return this;
	  };
	  /*
	    Method to get an option by modulo and name.
	    @param {String} Name of the property to get.
	    @param {Number} Index for the modulo calculation.
	    @param {Object} Options hash to look in.
	    @return {Any} Property.
	  */


	  Stagger.prototype._getOptionByMod = function _getOptionByMod(name, i, store) {
	    var props = store[name];
	    // if not dom list then clone it to array
	    if (props + '' === '[object NodeList]' || props + '' === '[object HTMLCollection]') props = Array.prototype.slice.call(props, 0);
	    // get the value in array or return the value itself
	    var value = _h2.default.isArray(props) ? props[i % props.length] : props;
	    // check if value has the stagger expression, if so parse it
	    return _h2.default.parseIfStagger(value, i);
	  };
	  /*
	    Method to get option by modulo of index.
	    @param {Number} Index for modulo calculations.
	    @param {Object} Options hash to look in.
	  */


	  Stagger.prototype._getOptionByIndex = function _getOptionByIndex(i, store) {
	    var _this2 = this;

	    var options = {};
	    (0, _keys2.default)(store).forEach(function (key) {
	      return options[key] = _this2._getOptionByMod(key, i, store);
	    });
	    return options;
	  };
	  /*
	    Method to get total child modules quantity.
	    @param  {String} Name of quantifier in options hash.
	    @param  {Object} Options hash object.
	    @return {Number} Number of child object that should be defined.
	  */


	  Stagger.prototype._getChildQuantity = function _getChildQuantity(name, store) {
	    // if number was set
	    if (typeof name === 'number') {
	      return name;
	    }

	    var quantifier = store[name];
	    if (_h2.default.isArray(quantifier)) {
	      return quantifier.length;
	    } else if (quantifier + '' === '[object NodeList]') {
	      return quantifier.length;
	    } else if (quantifier + '' === '[object HTMLCollection]') {
	      return Array.prototype.slice.call(quantifier, 0).length;
	    } else if (quantifier instanceof HTMLElement) {
	      return 1;
	    } else if (typeof quantifier == 'string') {
	      return 1;
	    }
	  };
	  /*
	    Method to make stagger form options
	    @param {Object} Options.
	    @param {Object} Child class.
	  */


	  Stagger.prototype._init = function _init(options, Module) {
	    var count = this._getChildQuantity(options.quantifier || 'el', options);
	    this._createTimeline(options);this._modules = [];
	    for (var i = 0; i < count; i++) {
	      // get child module's option
	      var option = this._getOptionByIndex(i, options);
	      option.isRunLess = true;
	      // set index of the module
	      option.index = i;
	      // create child module
	      var module = new Module(option);this._modules.push(module);
	      // add child module's timeline to the self timeline
	      this.timeline.add(module);
	    }
	    return this;
	  };
	  /*
	    Method to create timeline.
	    @param {Object} Timeline options.
	  */


	  Stagger.prototype._createTimeline = function _createTimeline() {
	    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    this.timeline = new _timeline2.default(options.timeline);
	  };

	  /* @overrides @ Tweenable */


	  Stagger.prototype._makeTween = function _makeTween() {};

	  Stagger.prototype._makeTimeline = function _makeTimeline() {};

	  return Stagger;
	}(_tunable2.default);

	module.exports = function (Module) {
	  return function (options) {
	    return new Stagger(options, Module);
	  };
	};

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _classCallCheck2 = __webpack_require__(74);

	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

	var _h = __webpack_require__(71);

	var _h2 = _interopRequireDefault(_h);

	var _tween = __webpack_require__(101);

	var _tween2 = _interopRequireDefault(_tween);

	var _timeline = __webpack_require__(110);

	var _timeline2 = _interopRequireDefault(_timeline);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/*
	  Class for toggling opacity on bunch of elements
	  @class Spriter
	  @todo
	    - add isForce3d option
	    - add run new option merging
	    - add then chains
	*/
	var Spriter = function () {
	  /*
	    Defaults/APIs
	  */
	  Spriter.prototype._declareDefaults = function _declareDefaults() {
	    this._defaults = {
	      /*
	        Duration
	        @property duration
	        @type     {Number}
	      */
	      duration: 500,
	      /*
	        Delay
	        @property delay
	        @type     {Number}
	      */
	      delay: 0,
	      /*
	        Easing. Please see the 
	        [timeline module parseEasing function](timeline.coffee.html#parseEasing)
	        for all avaliable options.
	          @property easing
	        @type     {String, Function}
	      */
	      easing: 'linear.none',
	      /*
	        Repeat times count
	        
	        @property repeat
	        @type     {Number}
	      */
	      repeat: 0,
	      /*
	        Yoyo option defines if animation should be altered on repeat.
	        
	        @property yoyo
	        @type     {Boolean}
	      */
	      yoyo: false,
	      /*
	        isRunLess option prevents animation from running immediately after
	        initialization.
	        
	        @property isRunLess
	        @type     {Boolean}
	      */
	      isRunLess: false,
	      /*
	        isShowEnd option defines if the last frame should be shown when
	        animation completed.
	        
	        @property isShowEnd
	        @type     {Boolean}
	      */
	      isShowEnd: false,
	      /*
	        onStart callback will be called once on animation start.
	        
	        @property onStart
	        @type     {Function}
	      */
	      onStart: null,
	      /*
	        onUpdate callback will be called on every frame of the animation.
	        The current progress in range **[0,1]** will be passed to the callback.
	        
	        @property onUpdate
	        @type     {Function}
	      */
	      onUpdate: null,
	      /*
	        onComplete callback will be called once on animation complete.
	        
	        @property onComplete
	        @type     {Function}
	      */
	      onComplete: null
	    };
	  };

	  function Spriter() {
	    var o = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    (0, _classCallCheck3.default)(this, Spriter);

	    this.o = o;
	    if (!this.o.el) {
	      return _h2.default.error('No "el" option specified, aborting');
	    }
	    this._vars();this._declareDefaults();this._extendDefaults();this._parseFrames();
	    if (this._frames.length <= 2) _h2.default.warn('Spriter: only ' + this._frames.length + ' frames found');
	    if (this._frames.length < 1) _h2.default.error("Spriter: there is no frames to animate, aborting");
	    this._createTween();
	    return this;
	  }
	  /*
	    Method to declare some variables.
	    
	    @method run
	    @param  {Object} New options
	    @todo   Implement new object merging
	  */


	  Spriter.prototype._vars = function _vars() {
	    this._props = _h2.default.cloneObj(this.o);
	    this.el = this.o.el;
	    this._frames = [];
	  };
	  /*
	    Method to run the spriter on demand.
	    
	    @method run
	    @param  {Object} New options
	    @todo   Implement new object merging
	  */


	  Spriter.prototype.run = function run(o) {
	    return this.timeline.play();
	  };
	  /*
	    Method to extend _props by options(this.o)
	    
	    @method _extendDefaults
	  */


	  Spriter.prototype._extendDefaults = function _extendDefaults() {
	    return _h2.default.extend(this._props, this._defaults);
	  };
	  /*
	    Method to parse frames as child nodes of el.
	    
	    @method _parseFrames
	  */


	  Spriter.prototype._parseFrames = function _parseFrames() {
	    this._frames = Array.prototype.slice.call(this.el.children, 0);
	    this._frames.forEach(function (frame, i) {
	      return frame.style.opacity = 0;
	    });
	    this._frameStep = 1 / this._frames.length;
	  };

	  /*
	    Method to create tween and timeline and supply callbacks.
	    
	    @method _createTween
	  */


	  Spriter.prototype._createTween = function _createTween() {
	    var _this = this;

	    this._tween = new _tween2.default({
	      duration: this._props.duration,
	      delay: this._props.delay,
	      yoyo: this._props.yoyo,
	      repeat: this._props.repeat,
	      easing: this._props.easing,
	      onStart: function onStart() {
	        return _this._props.onStart && _this._props.onStart();
	      },
	      onComplete: function onComplete() {
	        return _this._props.onComplete && _this._props.onComplete();
	      },
	      onUpdate: function onUpdate(p) {
	        return _this._setProgress(p);
	      }
	    });
	    this.timeline = new _timeline2.default();this.timeline.add(this._tween);
	    if (!this._props.isRunLess) this._startTween();
	  };

	  /*
	    Method to start tween
	    
	    @method _startTween
	  */


	  Spriter.prototype._startTween = function _startTween() {
	    var _this2 = this;

	    setTimeout(function () {
	      return _this2.timeline.play();
	    }, 1);
	  };
	  /*
	    Method to set progress of the sprite
	    
	    @method _setProgress
	    @param  {Number} Progress in range **[0,1]**
	  */


	  Spriter.prototype._setProgress = function _setProgress(p) {
	    // get the frame number
	    var proc = Math.floor(p / this._frameStep);
	    // react only if frame changes
	    if (this._prevFrame != this._frames[proc]) {
	      // if previous frame isnt current one, hide it
	      if (this._prevFrame) {
	        this._prevFrame.style.opacity = 0;
	      }
	      // if end of animation and isShowEnd flag was specified
	      // then show the last frame else show current frame
	      var currentNum = p === 1 && this._props.isShowEnd ? proc - 1 : proc;
	      // show the current frame
	      if (this._frames[currentNum]) {
	        this._frames[currentNum].style.opacity = 1;
	      }
	      // set previous frame as current
	      this._prevFrame = this._frames[proc];
	    }
	    if (this._props.onUpdate) {
	      this._props.onUpdate(p);
	    }
	  };

	  return Spriter;
	}();

	exports.default = Spriter;

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

	var MotionPath, Timeline, Tween, h, resize,
	  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

	h = __webpack_require__(71);

	resize = __webpack_require__(130);

	Tween = __webpack_require__(101)["default"];

	Timeline = __webpack_require__(110)["default"];

	MotionPath = (function() {
	  MotionPath.prototype.defaults = {
	    path: null,
	    curvature: {
	      x: '75%',
	      y: '50%'
	    },
	    isCompositeLayer: true,
	    delay: 0,
	    duration: 1000,
	    easing: null,
	    repeat: 0,
	    yoyo: false,
	    onStart: null,
	    onComplete: null,
	    onUpdate: null,
	    offsetX: 0,
	    offsetY: 0,
	    angleOffset: null,
	    pathStart: 0,
	    pathEnd: 1,
	    motionBlur: 0,
	    transformOrigin: null,
	    isAngle: false,
	    isReverse: false,
	    isRunLess: false,
	    isPresetPosition: true
	  };

	  function MotionPath(o1) {
	    this.o = o1 != null ? o1 : {};
	    this.calcHeight = bind(this.calcHeight, this);
	    if (this.vars()) {
	      return;
	    }
	    this.createTween();
	    this;
	  }

	  MotionPath.prototype.vars = function() {
	    this.getScaler = h.bind(this.getScaler, this);
	    this.resize = resize;
	    this.props = h.cloneObj(this.defaults);
	    this.extendOptions(this.o);
	    this.isMotionBlurReset = h.isSafari || h.isIE;
	    this.isMotionBlurReset && (this.props.motionBlur = 0);
	    this.history = [h.cloneObj(this.props)];
	    return this.postVars();
	  };

	  MotionPath.prototype.curveToPath = function(o) {
	    var angle, curvature, curvatureX, curvatureY, curvePoint, curveXPoint, dX, dY, endPoint, path, percent, radius, start;
	    path = document.createElementNS(h.NS, 'path');
	    start = o.start;
	    endPoint = {
	      x: start.x + o.shift.x,
	      y: start.x + o.shift.y
	    };
	    curvature = o.curvature;
	    dX = o.shift.x;
	    dY = o.shift.y;
	    radius = Math.sqrt(dX * dX + dY * dY);
	    percent = radius / 100;
	    angle = Math.atan(dY / dX) * (180 / Math.PI) + 90;
	    if (o.shift.x < 0) {
	      angle = angle + 180;
	    }
	    curvatureX = h.parseUnit(curvature.x);
	    curvatureX = curvatureX.unit === '%' ? curvatureX.value * percent : curvatureX.value;
	    curveXPoint = h.getRadialPoint({
	      center: {
	        x: start.x,
	        y: start.y
	      },
	      radius: curvatureX,
	      angle: angle
	    });
	    curvatureY = h.parseUnit(curvature.y);
	    curvatureY = curvatureY.unit === '%' ? curvatureY.value * percent : curvatureY.value;
	    curvePoint = h.getRadialPoint({
	      center: {
	        x: curveXPoint.x,
	        y: curveXPoint.y
	      },
	      radius: curvatureY,
	      angle: angle + 90
	    });
	    path.setAttribute('d', "M" + start.x + "," + start.y + " Q" + curvePoint.x + "," + curvePoint.y + " " + endPoint.x + "," + endPoint.y);
	    return path;
	  };

	  MotionPath.prototype.postVars = function() {
	    this.props.pathStart = h.clamp(this.props.pathStart, 0, 1);
	    this.props.pathEnd = h.clamp(this.props.pathEnd, this.props.pathStart, 1);
	    this.angle = 0;
	    this.speedX = 0;
	    this.speedY = 0;
	    this.blurX = 0;
	    this.blurY = 0;
	    this.prevCoords = {};
	    this.blurAmount = 20;
	    this.props.motionBlur = h.clamp(this.props.motionBlur, 0, 1);
	    this.onUpdate = this.props.onUpdate;
	    if (!this.o.el) {
	      h.error('Missed "el" option. It could be a selector, DOMNode or another module.');
	      return true;
	    }
	    this.el = this.parseEl(this.props.el);
	    this.props.motionBlur > 0 && this.createFilter();
	    this.path = this.getPath();
	    if (!this.path.getAttribute('d')) {
	      h.error('Path has no coordinates to work with, aborting');
	      return true;
	    }
	    this.len = this.path.getTotalLength();
	    this.slicedLen = this.len * (this.props.pathEnd - this.props.pathStart);
	    this.startLen = this.props.pathStart * this.len;
	    this.fill = this.props.fill;
	    if (this.fill != null) {
	      this.container = this.parseEl(this.props.fill.container);
	      this.fillRule = this.props.fill.fillRule || 'all';
	      this.getScaler();
	      if (this.container != null) {
	        this.removeEvent(this.container, 'onresize', this.getScaler);
	        return this.addEvent(this.container, 'onresize', this.getScaler);
	      }
	    }
	  };

	  MotionPath.prototype.addEvent = function(el, type, handler) {
	    return el.addEventListener(type, handler, false);
	  };

	  MotionPath.prototype.removeEvent = function(el, type, handler) {
	    return el.removeEventListener(type, handler, false);
	  };

	  MotionPath.prototype.createFilter = function() {
	    var div, svg;
	    div = document.createElement('div');
	    this.filterID = "filter-" + (h.getUniqID());
	    div.innerHTML = "<svg id=\"svg-" + this.filterID + "\"\n    style=\"visibility:hidden; width:0px; height:0px\">\n  <filter id=\"" + this.filterID + "\" y=\"-20\" x=\"-20\" width=\"40\" height=\"40\">\n    <feOffset\n      id=\"blur-offset\" in=\"SourceGraphic\"\n      dx=\"0\" dy=\"0\" result=\"offset2\"></feOffset>\n    <feGaussianblur\n      id=\"blur\" in=\"offset2\"\n      stdDeviation=\"0,0\" result=\"blur2\"></feGaussianblur>\n    <feMerge>\n      <feMergeNode in=\"SourceGraphic\"></feMergeNode>\n      <feMergeNode in=\"blur2\"></feMergeNode>\n    </feMerge>\n  </filter>\n</svg>";
	    svg = div.querySelector("#svg-" + this.filterID);
	    this.filter = svg.querySelector('#blur');
	    this.filterOffset = svg.querySelector('#blur-offset');
	    document.body.insertBefore(svg, document.body.firstChild);
	    this.el.style['filter'] = "url(#" + this.filterID + ")";
	    return this.el.style[h.prefix.css + "filter"] = "url(#" + this.filterID + ")";
	  };

	  MotionPath.prototype.parseEl = function(el) {
	    if (typeof el === 'string') {
	      return document.querySelector(el);
	    }
	    if (el instanceof HTMLElement) {
	      return el;
	    }
	    if (el._setProp != null) {
	      this.isModule = true;
	      return el;
	    }
	  };

	  MotionPath.prototype.getPath = function() {
	    var path;
	    path = h.parsePath(this.props.path);
	    if (path) {
	      return path;
	    }
	    if (this.props.path.x || this.props.path.y) {
	      return this.curveToPath({
	        start: {
	          x: 0,
	          y: 0
	        },
	        shift: {
	          x: this.props.path.x || 0,
	          y: this.props.path.y || 0
	        },
	        curvature: {
	          x: this.props.curvature.x || this.defaults.curvature.x,
	          y: this.props.curvature.y || this.defaults.curvature.y
	        }
	      });
	    }
	  };

	  MotionPath.prototype.getScaler = function() {
	    var end, size, start;
	    this.cSize = {
	      width: this.container.offsetWidth || 0,
	      height: this.container.offsetHeight || 0
	    };
	    start = this.path.getPointAtLength(0);
	    end = this.path.getPointAtLength(this.len);
	    size = {};
	    this.scaler = {};
	    size.width = end.x >= start.x ? end.x - start.x : start.x - end.x;
	    size.height = end.y >= start.y ? end.y - start.y : start.y - end.y;
	    switch (this.fillRule) {
	      case 'all':
	        this.calcWidth(size);
	        return this.calcHeight(size);
	      case 'width':
	        this.calcWidth(size);
	        return this.scaler.y = this.scaler.x;
	      case 'height':
	        this.calcHeight(size);
	        return this.scaler.x = this.scaler.y;
	    }
	  };

	  MotionPath.prototype.calcWidth = function(size) {
	    this.scaler.x = this.cSize.width / size.width;
	    return !isFinite(this.scaler.x) && (this.scaler.x = 1);
	  };

	  MotionPath.prototype.calcHeight = function(size) {
	    this.scaler.y = this.cSize.height / size.height;
	    return !isFinite(this.scaler.y) && (this.scaler.y = 1);
	  };

	  MotionPath.prototype.run = function(o) {
	    var fistItem, key, value;
	    if (o) {
	      fistItem = this.history[0];
	      for (key in o) {
	        value = o[key];
	        if (h.callbacksMap[key] || h.tweenOptionMap[key]) {
	          h.warn("the property \"" + key + "\" property can not be overridden on run yet");
	          delete o[key];
	        } else {
	          this.history[0][key] = value;
	        }
	      }
	      this.tuneOptions(o);
	    }
	    return this.startTween();
	  };

	  MotionPath.prototype.createTween = function() {
	    this.tween = new Tween({
	      duration: this.props.duration,
	      delay: this.props.delay,
	      yoyo: this.props.yoyo,
	      repeat: this.props.repeat,
	      easing: this.props.easing,
	      onStart: (function(_this) {
	        return function() {
	          var ref;
	          return (ref = _this.props.onStart) != null ? ref.apply(_this) : void 0;
	        };
	      })(this),
	      onComplete: (function(_this) {
	        return function() {
	          var ref;
	          _this.props.motionBlur && _this.setBlur({
	            blur: {
	              x: 0,
	              y: 0
	            },
	            offset: {
	              x: 0,
	              y: 0
	            }
	          });
	          return (ref = _this.props.onComplete) != null ? ref.apply(_this) : void 0;
	        };
	      })(this),
	      onUpdate: (function(_this) {
	        return function(p) {
	          return _this.setProgress(p);
	        };
	      })(this),
	      onFirstUpdate: (function(_this) {
	        return function(isForward, isYoyo) {
	          if (!isForward) {
	            return _this.history.length > 1 && _this.tuneOptions(_this.history[0]);
	          }
	        };
	      })(this)
	    });
	    this.timeline = new Timeline;
	    this.timeline.add(this.tween);
	    !this.props.isRunLess && this.startTween();
	    return this.props.isPresetPosition && this.setProgress(0, true);
	  };

	  MotionPath.prototype.startTween = function() {
	    return setTimeout(((function(_this) {
	      return function() {
	        var ref;
	        return (ref = _this.timeline) != null ? ref.play() : void 0;
	      };
	    })(this)), 1);
	  };

	  MotionPath.prototype.setProgress = function(p, isInit) {
	    var len, point, x, y;
	    len = this.startLen + (!this.props.isReverse ? p * this.slicedLen : (1 - p) * this.slicedLen);
	    point = this.path.getPointAtLength(len);
	    x = point.x + this.props.offsetX;
	    y = point.y + this.props.offsetY;
	    this._getCurrentAngle(point, len, p);
	    this._setTransformOrigin(p);
	    this._setTransform(x, y, p, isInit);
	    return this.props.motionBlur && this.makeMotionBlur(x, y);
	  };

	  MotionPath.prototype.setElPosition = function(x, y, p) {
	    var composite, isComposite, rotate, transform;
	    rotate = this.angle !== 0 ? "rotate(" + this.angle + "deg)" : '';
	    isComposite = this.props.isCompositeLayer && h.is3d;
	    composite = isComposite ? 'translateZ(0)' : '';
	    transform = "translate(" + x + "px," + y + "px) " + rotate + " " + composite;
	    return h.setPrefixedStyle(this.el, 'transform', transform);
	  };

	  MotionPath.prototype.setModulePosition = function(x, y) {
	    this.el._setProp({
	      shiftX: x + "px",
	      shiftY: y + "px",
	      angle: this.angle
	    });
	    return this.el._draw();
	  };

	  MotionPath.prototype._getCurrentAngle = function(point, len, p) {
	    var atan, isTransformFunOrigin, prevPoint, x1, x2;
	    isTransformFunOrigin = typeof this.props.transformOrigin === 'function';
	    if (this.props.isAngle || (this.props.angleOffset != null) || isTransformFunOrigin) {
	      prevPoint = this.path.getPointAtLength(len - 1);
	      x1 = point.y - prevPoint.y;
	      x2 = point.x - prevPoint.x;
	      atan = Math.atan(x1 / x2);
	      !isFinite(atan) && (atan = 0);
	      this.angle = atan * h.RAD_TO_DEG;
	      if ((typeof this.props.angleOffset) !== 'function') {
	        return this.angle += this.props.angleOffset || 0;
	      } else {
	        return this.angle = this.props.angleOffset.call(this, this.angle, p);
	      }
	    } else {
	      return this.angle = 0;
	    }
	  };

	  MotionPath.prototype._setTransform = function(x, y, p, isInit) {
	    var transform;
	    if (this.scaler) {
	      x *= this.scaler.x;
	      y *= this.scaler.y;
	    }
	    transform = null;
	    if (!isInit) {
	      transform = typeof this.onUpdate === "function" ? this.onUpdate(p, {
	        x: x,
	        y: y,
	        angle: this.angle
	      }) : void 0;
	    }
	    if (this.isModule) {
	      return this.setModulePosition(x, y);
	    } else {
	      if (typeof transform !== 'string') {
	        return this.setElPosition(x, y, p);
	      } else {
	        return h.setPrefixedStyle(this.el, 'transform', transform);
	      }
	    }
	  };

	  MotionPath.prototype._setTransformOrigin = function(p) {
	    var isTransformFunOrigin, tOrigin;
	    if (this.props.transformOrigin) {
	      isTransformFunOrigin = typeof this.props.transformOrigin === 'function';
	      tOrigin = !isTransformFunOrigin ? this.props.transformOrigin : this.props.transformOrigin(this.angle, p);
	      return h.setPrefixedStyle(this.el, 'transform-origin', tOrigin);
	    }
	  };

	  MotionPath.prototype.makeMotionBlur = function(x, y) {
	    var absoluteAngle, coords, dX, dY, signX, signY, tailAngle;
	    tailAngle = 0;
	    signX = 1;
	    signY = 1;
	    if ((this.prevCoords.x == null) || (this.prevCoords.y == null)) {
	      this.speedX = 0;
	      this.speedY = 0;
	    } else {
	      dX = x - this.prevCoords.x;
	      dY = y - this.prevCoords.y;
	      if (dX > 0) {
	        signX = -1;
	      }
	      if (signX < 0) {
	        signY = -1;
	      }
	      this.speedX = Math.abs(dX);
	      this.speedY = Math.abs(dY);
	      tailAngle = Math.atan(dY / dX) * (180 / Math.PI) + 90;
	    }
	    absoluteAngle = tailAngle - this.angle;
	    coords = this.angToCoords(absoluteAngle);
	    this.blurX = h.clamp((this.speedX / 16) * this.props.motionBlur, 0, 1);
	    this.blurY = h.clamp((this.speedY / 16) * this.props.motionBlur, 0, 1);
	    this.setBlur({
	      blur: {
	        x: 3 * this.blurX * this.blurAmount * Math.abs(coords.x),
	        y: 3 * this.blurY * this.blurAmount * Math.abs(coords.y)
	      },
	      offset: {
	        x: 3 * signX * this.blurX * coords.x * this.blurAmount,
	        y: 3 * signY * this.blurY * coords.y * this.blurAmount
	      }
	    });
	    this.prevCoords.x = x;
	    return this.prevCoords.y = y;
	  };

	  MotionPath.prototype.setBlur = function(o) {
	    if (!this.isMotionBlurReset) {
	      this.filter.setAttribute('stdDeviation', o.blur.x + "," + o.blur.y);
	      this.filterOffset.setAttribute('dx', o.offset.x);
	      return this.filterOffset.setAttribute('dy', o.offset.y);
	    }
	  };

	  MotionPath.prototype.extendDefaults = function(o) {
	    var key, results, value;
	    results = [];
	    for (key in o) {
	      value = o[key];
	      results.push(this[key] = value);
	    }
	    return results;
	  };

	  MotionPath.prototype.extendOptions = function(o) {
	    var key, results, value;
	    results = [];
	    for (key in o) {
	      value = o[key];
	      results.push(this.props[key] = value);
	    }
	    return results;
	  };

	  MotionPath.prototype.then = function(o) {
	    var it, key, opts, prevOptions, value;
	    prevOptions = this.history[this.history.length - 1];
	    opts = {};
	    for (key in prevOptions) {
	      value = prevOptions[key];
	      if (!h.callbacksMap[key] && !h.tweenOptionMap[key] || key === 'duration') {
	        if (o[key] == null) {
	          o[key] = value;
	        }
	      } else {
	        if (o[key] == null) {
	          o[key] = void 0;
	        }
	      }
	      if (h.tweenOptionMap[key]) {
	        opts[key] = key !== 'duration' ? o[key] : o[key] != null ? o[key] : prevOptions[key];
	      }
	    }
	    this.history.push(o);
	    it = this;
	    opts.onUpdate = (function(_this) {
	      return function(p) {
	        return _this.setProgress(p);
	      };
	    })(this);
	    opts.onStart = (function(_this) {
	      return function() {
	        var ref;
	        return (ref = _this.props.onStart) != null ? ref.apply(_this) : void 0;
	      };
	    })(this);
	    opts.onComplete = (function(_this) {
	      return function() {
	        var ref;
	        return (ref = _this.props.onComplete) != null ? ref.apply(_this) : void 0;
	      };
	    })(this);
	    opts.onFirstUpdate = function() {
	      return it.tuneOptions(it.history[this.index]);
	    };
	    opts.isChained = !o.delay;
	    this.timeline.append(new Tween(opts));
	    return this;
	  };

	  MotionPath.prototype.tuneOptions = function(o) {
	    this.extendOptions(o);
	    return this.postVars();
	  };

	  MotionPath.prototype.angToCoords = function(angle) {
	    var radAngle, x, y;
	    angle = angle % 360;
	    radAngle = ((angle - 90) * Math.PI) / 180;
	    x = Math.cos(radAngle);
	    y = Math.sin(radAngle);
	    x = x < 0 ? Math.max(x, -0.7) : Math.min(x, .7);
	    y = y < 0 ? Math.max(y, -0.7) : Math.min(y, .7);
	    return {
	      x: x * 1.428571429,
	      y: y * 1.428571429
	    };
	  };

	  return MotionPath;

	})();

	module.exports = MotionPath;


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
	/*!
	  LegoMushroom @legomushroom http://legomushroom.com
	  MIT License 2014
	 */

	/* istanbul ignore next */
	(function() {
	  var Main;
	  Main = (function() {
	    function Main(o) {
	      this.o = o != null ? o : {};
	      if (window.isAnyResizeEventInited) {
	        return;
	      }
	      this.vars();
	      this.redefineProto();
	    }

	    Main.prototype.vars = function() {
	      window.isAnyResizeEventInited = true;
	      this.allowedProtos = [HTMLDivElement, HTMLFormElement, HTMLLinkElement, HTMLBodyElement, HTMLParagraphElement, HTMLFieldSetElement, HTMLLegendElement, HTMLLabelElement, HTMLButtonElement, HTMLUListElement, HTMLOListElement, HTMLLIElement, HTMLHeadingElement, HTMLQuoteElement, HTMLPreElement, HTMLBRElement, HTMLFontElement, HTMLHRElement, HTMLModElement, HTMLParamElement, HTMLMapElement, HTMLTableElement, HTMLTableCaptionElement, HTMLImageElement, HTMLTableCellElement, HTMLSelectElement, HTMLInputElement, HTMLTextAreaElement, HTMLAnchorElement, HTMLObjectElement, HTMLTableColElement, HTMLTableSectionElement, HTMLTableRowElement];
	      return this.timerElements = {
	        img: 1,
	        textarea: 1,
	        input: 1,
	        embed: 1,
	        object: 1,
	        svg: 1,
	        canvas: 1,
	        tr: 1,
	        tbody: 1,
	        thead: 1,
	        tfoot: 1,
	        a: 1,
	        select: 1,
	        option: 1,
	        optgroup: 1,
	        dl: 1,
	        dt: 1,
	        br: 1,
	        basefont: 1,
	        font: 1,
	        col: 1,
	        iframe: 1
	      };
	    };

	    Main.prototype.redefineProto = function() {
	      var i, it, proto, t;
	      it = this;
	      return t = (function() {
	        var j, len, ref, results;
	        ref = this.allowedProtos;
	        results = [];
	        for (i = j = 0, len = ref.length; j < len; i = ++j) {
	          proto = ref[i];
	          if (proto.prototype == null) {
	            continue;
	          }
	          results.push((function(proto) {
	            var listener, remover;
	            listener = proto.prototype.addEventListener || proto.prototype.attachEvent;
	            (function(listener) {
	              var wrappedListener;
	              wrappedListener = function() {
	                var option;
	                if (this !== window || this !== document) {
	                  option = arguments[0] === 'onresize' && !this.isAnyResizeEventInited;
	                  option && it.handleResize({
	                    args: arguments,
	                    that: this
	                  });
	                }
	                return listener.apply(this, arguments);
	              };
	              if (proto.prototype.addEventListener) {
	                return proto.prototype.addEventListener = wrappedListener;
	              } else if (proto.prototype.attachEvent) {
	                return proto.prototype.attachEvent = wrappedListener;
	              }
	            })(listener);
	            remover = proto.prototype.removeEventListener || proto.prototype.detachEvent;
	            return (function(remover) {
	              var wrappedRemover;
	              wrappedRemover = function() {
	                this.isAnyResizeEventInited = false;
	                this.iframe && this.removeChild(this.iframe);
	                return remover.apply(this, arguments);
	              };
	              if (proto.prototype.removeEventListener) {
	                return proto.prototype.removeEventListener = wrappedRemover;
	              } else if (proto.prototype.detachEvent) {
	                return proto.prototype.detachEvent = wrappedListener;
	              }
	            })(remover);
	          })(proto));
	        }
	        return results;
	      }).call(this);
	    };

	    Main.prototype.handleResize = function(args) {
	      var computedStyle, el, iframe, isEmpty, isNoPos, isStatic, ref;
	      el = args.that;
	      if (!this.timerElements[el.tagName.toLowerCase()]) {
	        iframe = document.createElement('iframe');
	        el.appendChild(iframe);
	        iframe.style.width = '100%';
	        iframe.style.height = '100%';
	        iframe.style.position = 'absolute';
	        iframe.style.zIndex = -999;
	        iframe.style.opacity = 0;
	        iframe.style.top = 0;
	        iframe.style.left = 0;
	        computedStyle = window.getComputedStyle ? getComputedStyle(el) : el.currentStyle;
	        isNoPos = el.style.position === '';
	        isStatic = computedStyle.position === 'static' && isNoPos;
	        isEmpty = computedStyle.position === '' && el.style.position === '';
	        if (isStatic || isEmpty) {
	          el.style.position = 'relative';
	        }
	        if ((ref = iframe.contentWindow) != null) {
	          ref.onresize = (function(_this) {
	            return function(e) {
	              return _this.dispatchEvent(el);
	            };
	          })(this);
	        }
	        el.iframe = iframe;
	      } else {
	        this.initTimer(el);
	      }
	      return el.isAnyResizeEventInited = true;
	    };

	    Main.prototype.initTimer = function(el) {
	      var height, width;
	      width = 0;
	      height = 0;
	      return this.interval = setInterval((function(_this) {
	        return function() {
	          var newHeight, newWidth;
	          newWidth = el.offsetWidth;
	          newHeight = el.offsetHeight;
	          if (newWidth !== width || newHeight !== height) {
	            _this.dispatchEvent(el);
	            width = newWidth;
	            return height = newHeight;
	          }
	        };
	      })(this), this.o.interval || 62.5);
	    };

	    Main.prototype.dispatchEvent = function(el) {
	      var e;
	      if (document.createEvent) {
	        e = document.createEvent('HTMLEvents');
	        e.initEvent('onresize', false, false);
	        return el.dispatchEvent(e);
	      } else if (document.createEventObject) {
	        e = document.createEventObject();
	        return el.fireEvent('onresize', e);
	      } else {
	        return false;
	      }
	    };

	    Main.prototype.destroy = function() {
	      var i, it, j, len, proto, ref, results;
	      clearInterval(this.interval);
	      this.interval = null;
	      window.isAnyResizeEventInited = false;
	      it = this;
	      ref = this.allowedProtos;
	      results = [];
	      for (i = j = 0, len = ref.length; j < len; i = ++j) {
	        proto = ref[i];
	        if (proto.prototype == null) {
	          continue;
	        }
	        results.push((function(proto) {
	          var listener;
	          listener = proto.prototype.addEventListener || proto.prototype.attachEvent;
	          if (proto.prototype.addEventListener) {
	            proto.prototype.addEventListener = Element.prototype.addEventListener;
	          } else if (proto.prototype.attachEvent) {
	            proto.prototype.attachEvent = Element.prototype.attachEvent;
	          }
	          if (proto.prototype.removeEventListener) {
	            return proto.prototype.removeEventListener = Element.prototype.removeEventListener;
	          } else if (proto.prototype.detachEvent) {
	            return proto.prototype.detachEvent = Element.prototype.detachEvent;
	          }
	        })(proto));
	      }
	      return results;
	    };

	    return Main;

	  })();
	  if (true) {
	    return !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return new Main;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if ((typeof module === "object") && (typeof module.exports === "object")) {
	    return module.exports = new Main;
	  } else {
	    if (typeof window !== "undefined" && window !== null) {
	      window.AnyResizeEvent = Main;
	    }
	    return typeof window !== "undefined" && window !== null ? window.anyResizeEvent = new Main : void 0;
	  }
	})();


/***/ })
/******/ ])
});
;

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYzVmZTdlOGRjYjM0MWM4NGQ2NGQiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMvamF2YXNjcmlwdHMvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9saWIvYW1iZXIvYXNzZXRzL2pzL2FtYmVyLmpzIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMvamF2YXNjcmlwdHMvdG91cm5hbWVudC1ncmFwaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3l0b3NjYXBlL2Rpc3QvY3l0b3NjYXBlLmNqcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLmRlYm91bmNlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oZWFwL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oZWFwL2xpYi9oZWFwLmpzIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMvamF2YXNjcmlwdHMvcGFydHktcG9wcGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tby1qcy9idWlsZC9tby5qcyJdLCJuYW1lcyI6WyJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJmb3JFYWNoIiwiZm9ybSIsInN1Ym1pc3Npb25FbGVtIiwiY29uZmlybWF0aW9uTWVzc2FnZSIsImdldEF0dHJpYnV0ZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJlIiwicHJldmVudERlZmF1bHQiLCJjb25maXJtIiwic3VibWl0IiwiRVZFTlRTIiwiam9pbiIsImxlYXZlIiwibWVzc2FnZSIsIlNUQUxFX0NPTk5FQ1RJT05fVEhSRVNIT0xEX1NFQ09ORFMiLCJTT0NLRVRfUE9MTElOR19SQVRFIiwibm93IiwiRGF0ZSIsImdldFRpbWUiLCJzZWNvbmRzU2luY2UiLCJ0aW1lIiwiQ2hhbm5lbCIsInRvcGljIiwic29ja2V0Iiwib25NZXNzYWdlSGFuZGxlcnMiLCJ3cyIsInNlbmQiLCJKU09OIiwic3RyaW5naWZ5IiwiZXZlbnQiLCJtc2ciLCJoYW5kbGVyIiwic3ViamVjdCIsImNhbGxiYWNrIiwicGF5bG9hZCIsInB1c2giLCJTb2NrZXQiLCJlbmRwb2ludCIsImNoYW5uZWxzIiwibGFzdFBpbmciLCJyZWNvbm5lY3RUcmllcyIsImF0dGVtcHRSZWNvbm5lY3QiLCJjbGVhclRpbWVvdXQiLCJyZWNvbm5lY3RUaW1lb3V0Iiwic2V0VGltZW91dCIsImNvbm5lY3QiLCJwYXJhbXMiLCJfcmVjb25uZWN0IiwiX3JlY29ubmVjdEludGVydmFsIiwicG9sbGluZ1RpbWVvdXQiLCJfY29ubmVjdGlvbklzU3RhbGUiLCJfcG9sbCIsIl9zdGFydFBvbGxpbmciLCJvcHRzIiwibG9jYXRpb24iLCJ3aW5kb3ciLCJob3N0bmFtZSIsInBvcnQiLCJwcm90b2NvbCIsIk9iamVjdCIsImFzc2lnbiIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiV2ViU29ja2V0Iiwib25tZXNzYWdlIiwiaGFuZGxlTWVzc2FnZSIsIm9uY2xvc2UiLCJvbm9wZW4iLCJfcmVzZXQiLCJjbG9zZSIsImNoYW5uZWwiLCJkYXRhIiwiX2hhbmRsZVBpbmciLCJwYXJzZWRfbXNnIiwicGFyc2UiLCJtb2R1bGUiLCJleHBvcnRzIiwiZWxlbWVudCIsImNyZWF0ZUVsZW1lbnQiLCJpbnB1dCIsInNldEF0dHJpYnV0ZSIsImFwcGVuZENoaWxkIiwiYm9keSIsInRvdXJuYW1lbnRHcmFwaEVsZW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsInRvdXJuYW1lbnREYXRhVXJsIiwiZmV0Y2giLCJ0aGVuIiwicmVzcG9uc2UiLCJqc29uIiwiZmlsdGVyZWRNYXRjaERhdGEiLCJ0b3VybmFtZW50RGF0YSIsIm1hdGNoZXMiLCJmaWx0ZXIiLCJtYXRjaCIsImxldmVsIiwicGxheWVyX2FfaWQiLCJwbGF5ZXJfYl9pZCIsInNvcnQiLCJhIiwiYiIsImlkIiwibWF0Y2hOb2RlcyIsIm1hcCIsInBsYXllcl9hIiwicGxheWVycyIsImZpbmQiLCJwbGF5ZXIiLCJwbGF5ZXJfYiIsIndpbm5lciIsIndpbm5lcl9pZCIsIm91dGxpbmVDb2xvciIsInBsYXllcnNMYWJlbCIsInRhZyIsIm5hbWUiLCJocmVmIiwidXJsIiwicGxheWVyc192cyIsImJhY2tncm91bmQiLCJpbWFnZV91cmwiLCJvdXRsaW5lIiwibWF0Y2hFZGdlcyIsIm5leHRfbWF0Y2hfaWQiLCJ0YXJnZXQiLCJzb3VyY2UiLCJjb2xvciIsInBsYXllck5vZGVzIiwicGxheWVyX2lkIiwiY3kiLCJjb250YWluZXIiLCJib3hTZWxlY3Rpb25FbmFibGVkIiwiYXV0b3Vuc2VsZWN0aWZ5IiwibWF4Wm9vbSIsIm1pblpvb20iLCJzdHlsZSIsImN5dG9zY2FwZSIsInN0eWxlc2hlZXQiLCJzZWxlY3RvciIsImNzcyIsImVsZW1lbnRzIiwibm9kZXMiLCJlZGdlcyIsImxheW91dCIsImRpcmVjdGVkIiwicGFkZGluZyIsIm9uIiwibm9kZSIsIl9wcml2YXRlIiwiY2F0Y2giLCJlcnJvciIsImlubmVyVGV4dCIsInBhcnR5UG9wcGVyIiwiY29sb3JzIiwidG9yc2FkZUJ1cnN0IiwibW9qcyIsIkJ1cnN0IiwicGFyZW50IiwicmFkaXVzIiwiY291bnQiLCJkZWdyZWUiLCJjaGlsZHJlbiIsInNoYXBlIiwicG9pbnRzIiwicmFkaXVzWSIsInN0cm9rZUxpbmVjYXAiLCJzdHJva2VXaWR0aCIsImZpbGwiLCJzdHJva2UiLCJhbmdsZSIsImlzU3dpcmwiLCJzd2lybFNpemUiLCJzd2lybEZyZXF1ZW5jeSIsImRpcmVjdGlvbiIsImRlZ3JlZVNoaWZ0IiwiZHVyYXRpb24iLCJlYXNpbmciLCJwYXRoU2NhbGUiLCJiZW50QnVyc3QiLCJmbGFrZUJ1cnN0IiwicGxheSIsInF1ZXJ5U2VsZWN0b3IiLCJlbGVtIl0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBc0QsK0RBQStEOztBQUVySDtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUM3REE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUM7Ozs7Ozs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLG1CQUFPLENBQUMsQ0FBYztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDOURBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyxzQkFBc0IsRUFBRTtBQUNsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7QUN6TEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNB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QUFtQztBQUN2RjtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVk7QUFDWjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHFCQUFxQixXQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsa0NBQWtDO0FBQ25EOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQix3QkFBd0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0I7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLHVCQUF1Qjs7QUFFeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsbUJBQW1CLGtDQUFrQztBQUNyRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLHdCQUF3Qjs7QUFFMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsV0FBVztBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixhQUFhO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixhQUFhO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxpQkFBaUIsV0FBVztBQUM1Qjs7QUFFQSwyQ0FBMkM7QUFDM0MsZ0RBQWdEO0FBQ2hEOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0EsK0RBQStEOztBQUUvRCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixrQkFBa0I7O0FBRTNDOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQSxvR0FBb0csbUJBQW1CLEVBQUUsbUJBQW1CLDhIQUE4SDs7QUFFMVE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQjtBQUN0Qix3QkFBd0I7QUFDeEIsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLGdDQUFnQztBQUNoQyxnQ0FBZ0M7QUFDaEMsd0JBQXdCO0FBQ3hCLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLGtFQUFrRTtBQUNsRSwrREFBK0Q7QUFDL0Q7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrRkFBK0Y7QUFDL0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLDZEQUE2RDtBQUM3RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixnQkFBZ0I7QUFDN0M7QUFDQSxtRUFBbUU7QUFDbkUsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsNkJBQTZCLGdCQUFnQjtBQUM3QztBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixlQUFlO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLGdFQUFnRTs7QUFFaEUsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gseURBQXlEO0FBQ3pEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGVBQWUsdUJBQXVCO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBLGVBQWUsdUJBQXVCO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLGlDQUFpQztBQUNoRDtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxzQkFBc0I7QUFDckM7QUFDQTtBQUNBOztBQUVBLGVBQWUsMEJBQTBCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGFBQWEsaUJBQWlCO0FBQzlCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDLE9BQU87QUFDL0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaURBQWlELGVBQWU7QUFDaEU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnREFBZ0Q7QUFDaEQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFF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QztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQiwyQkFBMkI7QUFDOUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxrQkFBa0I7O0FBRWxCLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVB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Qjs7QUFFbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsT0FBTztBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLE9BQU87QUFDMUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLE9BQU87QUFDMUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHlCQUF5QixxQkFBcUI7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMkJBQTJCLEVBQUU7QUFDN0IsMkJBQTJCLEVBQUU7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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TztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsb0JBQW9CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLG9CQUFvQjtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxFQUFFOztBQUVGOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCO0FBQ3ZCOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCO0FBQ3ZCOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FB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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLDJCQUEyQjtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNB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QUVBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUEsdUJBQXVCLGdCQUFnQjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLHVCQUF1Qjs7QUFFdkIsaUJBQWlCLGlCQUFpQjtBQUNsQzs7QUFFQTtBQUNBOztBQUVBLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBOztBQUVBLG9EQUFvRDtBQUNwRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCOztBQUVyQjs7QUFFQSw2QkFBNkIsa0JBQWtCOztBQUUvQztBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLHFCQUFxQjs7QUFFckI7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLHFCQUFxQixpQkFBaUI7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RUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0EsS0FBSzs7QUFFTDtB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QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0I7O0FBRS9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFL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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0NBQWdDO0FBQ3JEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLGNBQWM7QUFDckM7O0FBRUEsNkJBQTZCLGNBQWM7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQixPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FB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O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUI7QUFDbkIsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRTs7QUFFL0U7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixxQkFBcUI7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUMsdUJBQXVCLEdBQUcsdUJBQXVCLEdBQUcsdUJBQXVCO0FBQzlHLG1DQUFtQyx1QkFBdUIsR0FBRyx1QkFBdUIsR0FBRyx1QkFBdUI7QUFDOUcsbUNBQW1DLHVCQUF1QixHQUFHLHVCQUF1QixHQUFHLHVCQUF1Qjs7QUFFOUc7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLHlCQUF5QjtBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekI7QUFDQTs7QUFFQSxtQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsWUFBWTtBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVB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O0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQ0FBaUM7QUFDakMsbUNBQW1DLFFBQVE7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5QkFBeUIsNkJBQTZCOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpQkFBaUIsbUJBQW1CO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQix1QkFBdUI7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixhQUFhO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsYUFBYTtBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsaUJBQWlCO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQjs7QUFFL0I7QUFDQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1CQUFtQjtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBLHFCQUFxQixtQkFBbUI7QUFDeEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLG1CQUFtQjtBQUN4Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixtQkFBbUI7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsbUJBQW1CO0FBQ3hDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLG1CQUFtQjtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixpQkFBaUI7QUFDbEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLGlCQUFpQjtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsaUJBQWlCO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBLHFCQUFxQixvQkFBb0I7QUFDekM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQzs7QUFFbkM7QUFDQTs7QUFFQSxtQ0FBbUM7QUFDbkM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7O0FBRW5EO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsaUJBQWlCLDRCQUE0QjtBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWlFOztBQUVqRTtBQUNBO0FB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QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7OztBQ3hYQSxpQkFBaUIsbUJBQU8sQ0FBQyxFQUFZOzs7Ozs7O0FDQXJDO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FB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VUFBVTtBQUNkO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7Ozs7QUFJQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHVEQUF1RCxjQUFjLGtCQUFrQixzQkFBc0IsMkJBQTJCOztBQUV4STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsVUFBVTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyw4QkFBOEI7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxzQ0FBc0MsaUNBQWlDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsSUFBSSxVQUFVLElBQUksVUFBVSxJQUFJO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxJQUFJLFdBQVcsSUFBSTtBQUN4RCxnQ0FBZ0MsSUFBSSxZQUFZLEVBQUUsVUFBVSxHQUFHO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsVUFBVTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBdUMsdUNBQXVDLGdCQUFnQjs7QUFFOUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsT0FBTztBQUN0Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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QUU5RjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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QUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtCQUFrQixHQUFHLEtBQUs7QUFDdkMsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDRCQUE0QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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Q3BCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLG9CQUFvQiw4QkFBOEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0Esb0JBQW9CLDhCQUE4QjtBQUNsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0YsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLCtDQUErQztBQUMvQywyQ0FBMkMsaUNBQWlDLE9BQU8sT0FBTyw2Q0FBNkMsRUFBRSxXQUFXOztBQUVwSjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsNkJBQTZCLDRCQUE0QixhQUFhLEVBQUU7O0FBRXhFLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGdDQUFnQztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsbUNBQW1DO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsVUFBVTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxVQUFVO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxVQUFVO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHVDQUF1Qyx1Q0FBdUMsZ0JBQWdCOztBQUU5RjtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkM7O0FBRTNDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsdUJBQXVCO0FBQ3BDO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQjtBQUNwQjs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBdUMsdUNBQXVDLGdCQUFnQjs7QUFFOUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0IsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQSxvRUFBb0UsYUFBYTtBQUNqRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQixlQUFlLE9BQU87QUFDdEI7OztBQUdBO0FBQ0EsMkVBQTJFLGVBQWU7QUFDMUY7QUFDQTs7QUFFQSwySkFBMko7QUFDM0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLG9CQUFvQiw0QkFBNEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCOzs7QUFHQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25COzs7QUFHQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxxQkFBcUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUI7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CLDRCQUE0QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7OztBQUdBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSxtQkFBbUI7O0FBRW5CLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtCQUFrQixFQUFFOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksVUFBVTtBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHVDQUF1Qyx1Q0FBdUMsZ0JBQWdCOztBQUU5RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFVBQVU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLElBQUk7QUFDakI7OztBQUdBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxJQUFJO0FBQ2pCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdEQUFnRDtBQUNoRDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLElBQUk7QUFDakIsYUFBYSxJQUFJO0FBQ2pCLGVBQWUsUUFBUTtBQUN2Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCOzs7QUFHQTtBQUNBOztBQUVBLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLHVDQUF1QyxnQkFBZ0I7O0FBRTlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQixhQUFhLE1BQU07QUFDbkI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlLE9BQU87QUFDdEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBdUMsdUNBQXVDLGdCQUFnQjs7QUFFOUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkI7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlLE9BQU87QUFDdEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBLHVCQUF1QiwrQ0FBK0M7QUFDdEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0EsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsWUFBWSxPQUFPO0FBQ25COzs7QUFHQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlLE9BQU87QUFDdEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsTUFBTTtBQUNwQjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsT0FBTztBQUN0Qjs7O0FBR0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsSUFBSTtBQUNuQjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLGVBQWU7QUFDaEMsaUJBQWlCLE9BQU87QUFDeEIsaUJBQWlCLE9BQU87QUFDeEIsaUJBQWlCLE9BQU87QUFDeEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixnQkFBZ0I7QUFDaEIsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixlQUFlLE9BQU87QUFDdEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsZUFBZSxPQUFPO0FBQ3RCOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsT0FBTztBQUN0Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkM7O0FBRTdDLDZDQUE2Qzs7QUFFN0M7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBdUMsdUNBQXVDLGdCQUFnQjs7QUFFOUY7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLElBQUk7QUFDakIsZUFBZSxJQUFJO0FBQ25COzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLG9CQUFvQiw0QkFBNEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CLDhCQUE4QjtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxJQUFJO0FBQ2pCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsZUFBZSxPQUFPO0FBQ3RCOzs7QUFHQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdEQUF3RCxVQUFVOztBQUVsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxJQUFJO0FBQ2pCLGFBQWEsSUFBSTtBQUNqQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDO0FBQ3pDLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0EsVUFBVTtBQUNWOztBQUVBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBdUMsdUNBQXVDLGdCQUFnQjs7QUFFOUY7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBLG1CQUFtQjs7QUFFbkIsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDJDQUEyQyxpQ0FBaUM7O0FBRTVFLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsVUFBVSxFQUFFO0FBQy9DLG9CQUFvQixzQ0FBc0M7QUFDMUQsRUFBRSxvQ0FBb0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEVBQUU7O0FBRUYsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLHVDQUF1QyxnQkFBZ0I7O0FBRTlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBLE9BQU87QUFDUCxnQkFBZ0IsNENBQTRDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQSxLQUFLOzs7QUFHTDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7OztBQUdBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQiw4QkFBOEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsT0FBTztBQUN0Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsT0FBTztBQUN0Qix5QkFBeUIsT0FBTztBQUNoQyx5QkFBeUIsT0FBTztBQUNoQzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDhDQUE4QztBQUN4RSwwQkFBMEIsOENBQThDO0FBQ3hFLDBCQUEwQixzREFBc0Q7QUFDaEYsMEJBQTBCLG9EQUFvRDtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsSUFBSTtBQUNqQixlQUFlO0FBQ2Y7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxJQUFJO0FBQ2pCLGVBQWUsT0FBTztBQUN0Qjs7O0FBR0E7QUFDQTtBQUNBLHVGQUF1RixNQUFNO0FBQzdGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLElBQUk7QUFDakIsZUFBZSxPQUFPO0FBQ3RCOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsSUFBSTtBQUNqQixhQUFhLE9BQU87QUFDcEIsZUFBZSxPQUFPO0FBQ3RCOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLElBQUk7QUFDakIsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsT0FBTztBQUN0Qjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlLE9BQU87QUFDdEIsMEJBQTBCLE9BQU87QUFDakMsMEJBQTBCLGVBQWU7QUFDekM7OztBQUdBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsT0FBTztBQUN0Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsSUFBSSxVQUFVLElBQUksVUFBVSxJQUFJO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDLElBQUksV0FBVyxJQUFJO0FBQzVELG9DQUFvQyxJQUFJLFlBQVksRUFBRSxVQUFVLEdBQUc7QUFDbkU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QixlQUFlLE1BQU07QUFDckI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHVDQUF1Qyx1Q0FBdUMsZ0JBQWdCOztBQUU5Rjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7OztBQUdBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLE9BQU8sVUFBVTs7QUFFMUI7QUFDQTtBQUNBOztBQUVBLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLEtBQUssRUFBRSxVQUFVO0FBQ3hDO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBdUMsdUNBQXVDLGdCQUFnQjs7QUFFOUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsT0FBTztBQUNyQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYyxPQUFPO0FBQ3JCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjs7O0FBR0E7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixjQUFjLElBQUk7QUFDbEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjs7O0FBR0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLHVDQUF1QyxnQkFBZ0I7O0FBRTlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isd0JBQXdCLHVCQUF1QjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiw4Q0FBOEM7QUFDOUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLE9BQU87QUFDckI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLG1CQUFtQixnQ0FBZ0MsR0FBRzs7QUFFakY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGLFdBQVc7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsY0FBYztBQUNkLFlBQVk7QUFDWjtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRixPQUFPO0FBQ1A7QUFDQSxDQUFDO0FBQ0QsQyIsImZpbGUiOiJtYWluLmJ1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIi9kaXN0XCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gNCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgYzVmZTdlOGRjYjM0MWM4NGQ2NGQiLCJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgc2NvcGUgPSAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwpIHx8XG4gICAgICAgICAgICAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZikgfHxcbiAgICAgICAgICAgIHdpbmRvdztcbnZhciBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHNjb3BlLCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHNjb3BlLCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7XG4gIGlmICh0aW1lb3V0KSB7XG4gICAgdGltZW91dC5jbG9zZSgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHNjb3BlLCB0aGlzLl9pZCk7XG59O1xuXG4vLyBEb2VzIG5vdCBzdGFydCB0aGUgdGltZSwganVzdCBzZXRzIHVwIHRoZSBtZW1iZXJzIG5lZWRlZC5cbmV4cG9ydHMuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSwgbXNlY3MpIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IG1zZWNzO1xufTtcblxuZXhwb3J0cy51bmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IC0xO1xufTtcblxuZXhwb3J0cy5fdW5yZWZBY3RpdmUgPSBleHBvcnRzLmFjdGl2ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuXG4gIHZhciBtc2VjcyA9IGl0ZW0uX2lkbGVUaW1lb3V0O1xuICBpZiAobXNlY3MgPj0gMCkge1xuICAgIGl0ZW0uX2lkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAgIGlmIChpdGVtLl9vblRpbWVvdXQpXG4gICAgICAgIGl0ZW0uX29uVGltZW91dCgpO1xuICAgIH0sIG1zZWNzKTtcbiAgfVxufTtcblxuLy8gc2V0aW1tZWRpYXRlIGF0dGFjaGVzIGl0c2VsZiB0byB0aGUgZ2xvYmFsIG9iamVjdFxucmVxdWlyZShcInNldGltbWVkaWF0ZVwiKTtcbi8vIE9uIHNvbWUgZXhvdGljIGVudmlyb25tZW50cywgaXQncyBub3QgY2xlYXIgd2hpY2ggb2JqZWN0IGBzZXRpbW1lZGlhdGVgIHdhc1xuLy8gYWJsZSB0byBpbnN0YWxsIG9udG8uICBTZWFyY2ggZWFjaCBwb3NzaWJpbGl0eSBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGVcbi8vIGBzZXRpbW1lZGlhdGVgIGxpYnJhcnkuXG5leHBvcnRzLnNldEltbWVkaWF0ZSA9ICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLnNldEltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLnNldEltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5zZXRJbW1lZGlhdGUpO1xuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9ICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLmNsZWFySW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodGhpcyAmJiB0aGlzLmNsZWFySW1tZWRpYXRlKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3RpbWVycy1icm93c2VyaWZ5L21haW4uanNcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIoZnVuY3Rpb24gKGdsb2JhbCwgdW5kZWZpbmVkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZiAoZ2xvYmFsLnNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5leHRIYW5kbGUgPSAxOyAvLyBTcGVjIHNheXMgZ3JlYXRlciB0aGFuIHplcm9cbiAgICB2YXIgdGFza3NCeUhhbmRsZSA9IHt9O1xuICAgIHZhciBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICB2YXIgZG9jID0gZ2xvYmFsLmRvY3VtZW50O1xuICAgIHZhciByZWdpc3RlckltbWVkaWF0ZTtcblxuICAgIGZ1bmN0aW9uIHNldEltbWVkaWF0ZShjYWxsYmFjaykge1xuICAgICAgLy8gQ2FsbGJhY2sgY2FuIGVpdGhlciBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBuZXcgRnVuY3Rpb24oXCJcIiArIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIC8vIENvcHkgZnVuY3Rpb24gYXJndW1lbnRzXG4gICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2kgKyAxXTtcbiAgICAgIH1cbiAgICAgIC8vIFN0b3JlIGFuZCByZWdpc3RlciB0aGUgdGFza1xuICAgICAgdmFyIHRhc2sgPSB7IGNhbGxiYWNrOiBjYWxsYmFjaywgYXJnczogYXJncyB9O1xuICAgICAgdGFza3NCeUhhbmRsZVtuZXh0SGFuZGxlXSA9IHRhc2s7XG4gICAgICByZWdpc3RlckltbWVkaWF0ZShuZXh0SGFuZGxlKTtcbiAgICAgIHJldHVybiBuZXh0SGFuZGxlKys7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaGFuZGxlKSB7XG4gICAgICAgIGRlbGV0ZSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuKHRhc2spIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdGFzay5jYWxsYmFjaztcbiAgICAgICAgdmFyIGFyZ3MgPSB0YXNrLmFyZ3M7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuSWZQcmVzZW50KGhhbmRsZSkge1xuICAgICAgICAvLyBGcm9tIHRoZSBzcGVjOiBcIldhaXQgdW50aWwgYW55IGludm9jYXRpb25zIG9mIHRoaXMgYWxnb3JpdGhtIHN0YXJ0ZWQgYmVmb3JlIHRoaXMgb25lIGhhdmUgY29tcGxldGVkLlwiXG4gICAgICAgIC8vIFNvIGlmIHdlJ3JlIGN1cnJlbnRseSBydW5uaW5nIGEgdGFzaywgd2UnbGwgbmVlZCB0byBkZWxheSB0aGlzIGludm9jYXRpb24uXG4gICAgICAgIGlmIChjdXJyZW50bHlSdW5uaW5nQVRhc2spIHtcbiAgICAgICAgICAgIC8vIERlbGF5IGJ5IGRvaW5nIGEgc2V0VGltZW91dC4gc2V0SW1tZWRpYXRlIHdhcyB0cmllZCBpbnN0ZWFkLCBidXQgaW4gRmlyZWZveCA3IGl0IGdlbmVyYXRlZCBhXG4gICAgICAgICAgICAvLyBcInRvbyBtdWNoIHJlY3Vyc2lvblwiIGVycm9yLlxuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGFzayA9IHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICAgICAgICAgIGlmICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBydW4odGFzayk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbW1lZGlhdGUoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHsgcnVuSWZQcmVzZW50KGhhbmRsZSk7IH0pO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhblVzZVBvc3RNZXNzYWdlKCkge1xuICAgICAgICAvLyBUaGUgdGVzdCBhZ2FpbnN0IGBpbXBvcnRTY3JpcHRzYCBwcmV2ZW50cyB0aGlzIGltcGxlbWVudGF0aW9uIGZyb20gYmVpbmcgaW5zdGFsbGVkIGluc2lkZSBhIHdlYiB3b3JrZXIsXG4gICAgICAgIC8vIHdoZXJlIGBnbG9iYWwucG9zdE1lc3NhZ2VgIG1lYW5zIHNvbWV0aGluZyBjb21wbGV0ZWx5IGRpZmZlcmVudCBhbmQgY2FuJ3QgYmUgdXNlZCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgICBpZiAoZ2xvYmFsLnBvc3RNZXNzYWdlICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgICAgICAgICAgdmFyIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG9sZE9uTWVzc2FnZSA9IGdsb2JhbC5vbm1lc3NhZ2U7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShcIlwiLCBcIipcIik7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gb2xkT25NZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgLy8gSW5zdGFsbHMgYW4gZXZlbnQgaGFuZGxlciBvbiBgZ2xvYmFsYCBmb3IgdGhlIGBtZXNzYWdlYCBldmVudDogc2VlXG4gICAgICAgIC8vICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRE9NL3dpbmRvdy5wb3N0TWVzc2FnZVxuICAgICAgICAvLyAqIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL2NvbW1zLmh0bWwjY3Jvc3NEb2N1bWVudE1lc3NhZ2VzXG5cbiAgICAgICAgdmFyIG1lc3NhZ2VQcmVmaXggPSBcInNldEltbWVkaWF0ZSRcIiArIE1hdGgucmFuZG9tKCkgKyBcIiRcIjtcbiAgICAgICAgdmFyIG9uR2xvYmFsTWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlID09PSBnbG9iYWwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZXZlbnQuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuaW5kZXhPZihtZXNzYWdlUHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudCgrZXZlbnQuZGF0YS5zbGljZShtZXNzYWdlUHJlZml4Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsLmF0dGFjaEV2ZW50KFwib25tZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKG1lc3NhZ2VQcmVmaXggKyBoYW5kbGUsIFwiKlwiKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZShoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIDxzY3JpcHQ+IGVsZW1lbnQ7IGl0cyByZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdpbGwgYmUgZmlyZWQgYXN5bmNocm9ub3VzbHkgb25jZSBpdCBpcyBpbnNlcnRlZFxuICAgICAgICAgICAgLy8gaW50byB0aGUgZG9jdW1lbnQuIERvIHNvLCB0aHVzIHF1ZXVpbmcgdXAgdGhlIHRhc2suIFJlbWVtYmVyIHRvIGNsZWFuIHVwIG9uY2UgaXQncyBiZWVuIGNhbGxlZC5cbiAgICAgICAgICAgIHZhciBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaHRtbC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgICAgIHNjcmlwdCA9IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaHRtbC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBJZiBzdXBwb3J0ZWQsIHdlIHNob3VsZCBhdHRhY2ggdG8gdGhlIHByb3RvdHlwZSBvZiBnbG9iYWwsIHNpbmNlIHRoYXQgaXMgd2hlcmUgc2V0VGltZW91dCBldCBhbC4gbGl2ZS5cbiAgICB2YXIgYXR0YWNoVG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGdsb2JhbCk7XG4gICAgYXR0YWNoVG8gPSBhdHRhY2hUbyAmJiBhdHRhY2hUby5zZXRUaW1lb3V0ID8gYXR0YWNoVG8gOiBnbG9iYWw7XG5cbiAgICAvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IGUuZy4gYnJvd3NlcmlmeSBlbnZpcm9ubWVudHMuXG4gICAgaWYgKHt9LnRvU3RyaW5nLmNhbGwoZ2xvYmFsLnByb2Nlc3MpID09PSBcIltvYmplY3QgcHJvY2Vzc11cIikge1xuICAgICAgICAvLyBGb3IgTm9kZS5qcyBiZWZvcmUgMC45XG4gICAgICAgIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGNhblVzZVBvc3RNZXNzYWdlKCkpIHtcbiAgICAgICAgLy8gRm9yIG5vbi1JRTEwIG1vZGVybiBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChnbG9iYWwuTWVzc2FnZUNoYW5uZWwpIHtcbiAgICAgICAgLy8gRm9yIHdlYiB3b3JrZXJzLCB3aGVyZSBzdXBwb3J0ZWRcbiAgICAgICAgaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZG9jICYmIFwib25yZWFkeXN0YXRlY2hhbmdlXCIgaW4gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIikpIHtcbiAgICAgICAgLy8gRm9yIElFIDbigJM4XG4gICAgICAgIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBvbGRlciBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCk7XG4gICAgfVxuXG4gICAgYXR0YWNoVG8uc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlO1xuICAgIGF0dGFjaFRvLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG59KHR5cGVvZiBzZWxmID09PSBcInVuZGVmaW5lZFwiID8gdHlwZW9mIGdsb2JhbCA9PT0gXCJ1bmRlZmluZWRcIiA/IHRoaXMgOiBnbG9iYWwgOiBzZWxmKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBBbWJlciBmcm9tICdhbWJlcidcblxuaW1wb3J0IFwiLi90b3VybmFtZW50LWdyYXBoLmpzXCJcbmltcG9ydCBcIi4vcGFydHktcG9wcGVyLmpzXCJcblxuLypcbiAqIEVuc3VyZSB0aGUgZGF0YS1jb25maXJtIGVsZW1lbnRzIHNob3cgcG9wdXAgY29uZmlybWF0aW9uc1xuICovXG5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiZm9ybVwiKS5mb3JFYWNoKChmb3JtKSA9PiB7XG4gIGZvcm0ucXVlcnlTZWxlY3RvckFsbChcImZvcm0gaW5wdXRbdHlwZT1zdWJtaXRdXCIpLmZvckVhY2goKHN1Ym1pc3Npb25FbGVtKSA9PiB7XG4gICAgbGV0IGNvbmZpcm1hdGlvbk1lc3NhZ2UgPSBzdWJtaXNzaW9uRWxlbS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWNvbmZpcm1cIik7XG5cbiAgICBpZiAoY29uZmlybWF0aW9uTWVzc2FnZSkge1xuICAgICAgc3VibWlzc2lvbkVsZW0uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG5cbiAgICAgICAgaWYgKGNvbmZpcm0oY29uZmlybWF0aW9uTWVzc2FnZSkpIHtcbiAgICAgICAgICBmb3JtLnN1Ym1pdCgpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9KVxufSlcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9hc3NldHMvamF2YXNjcmlwdHMvbWFpbi5qcyIsImNvbnN0IEVWRU5UUyA9IHtcbiAgam9pbjogJ2pvaW4nLFxuICBsZWF2ZTogJ2xlYXZlJyxcbiAgbWVzc2FnZTogJ21lc3NhZ2UnXG59XG5jb25zdCBTVEFMRV9DT05ORUNUSU9OX1RIUkVTSE9MRF9TRUNPTkRTID0gMTAwXG5jb25zdCBTT0NLRVRfUE9MTElOR19SQVRFID0gMTAwMDBcblxuLyoqXG4gKiBSZXR1cm5zIGEgbnVtZXJpYyB2YWx1ZSBmb3IgdGhlIGN1cnJlbnQgdGltZVxuICovXG5sZXQgbm93ID0gKCkgPT4ge1xuICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKClcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIGN1cnJlbnQgdGltZSBhbmQgcGFzc2VkIGB0aW1lYCBpbiBzZWNvbmRzXG4gKiBAcGFyYW0ge051bWJlcnxEYXRlfSB0aW1lIC0gQSBudW1lcmljIHRpbWUgb3IgZGF0ZSBvYmplY3RcbiAqL1xubGV0IHNlY29uZHNTaW5jZSA9ICh0aW1lKSA9PiB7XG4gIHJldHVybiAobm93KCkgLSB0aW1lKSAvIDEwMDBcbn1cblxuLyoqXG4gKiBDbGFzcyBmb3IgY2hhbm5lbCByZWxhdGVkIGZ1bmN0aW9ucyAoam9pbmluZywgbGVhdmluZywgc3Vic2NyaWJpbmcgYW5kIHNlbmRpbmcgbWVzc2FnZXMpXG4gKi9cbmV4cG9ydCBjbGFzcyBDaGFubmVsIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0b3BpYyAtIHRvcGljIHRvIHN1YnNjcmliZSB0b1xuICAgKiBAcGFyYW0ge1NvY2tldH0gc29ja2V0IC0gQSBTb2NrZXQgaW5zdGFuY2VcbiAgICovXG4gIGNvbnN0cnVjdG9yKHRvcGljLCBzb2NrZXQpIHtcbiAgICB0aGlzLnRvcGljID0gdG9waWNcbiAgICB0aGlzLnNvY2tldCA9IHNvY2tldFxuICAgIHRoaXMub25NZXNzYWdlSGFuZGxlcnMgPSBbXVxuICB9XG5cbiAgLyoqXG4gICAqIEpvaW4gYSBjaGFubmVsLCBzdWJzY3JpYmUgdG8gYWxsIGNoYW5uZWxzIG1lc3NhZ2VzXG4gICAqL1xuICBqb2luKCkge1xuICAgIHRoaXMuc29ja2V0LndzLnNlbmQoSlNPTi5zdHJpbmdpZnkoeyBldmVudDogRVZFTlRTLmpvaW4sIHRvcGljOiB0aGlzLnRvcGljIH0pKVxuICB9XG5cbiAgLyoqXG4gICAqIExlYXZlIGEgY2hhbm5lbCwgc3RvcCBzdWJzY3JpYmluZyB0byBjaGFubmVsIG1lc3NhZ2VzXG4gICAqL1xuICBsZWF2ZSgpIHtcbiAgICB0aGlzLnNvY2tldC53cy5zZW5kKEpTT04uc3RyaW5naWZ5KHsgZXZlbnQ6IEVWRU5UUy5sZWF2ZSwgdG9waWM6IHRoaXMudG9waWMgfSkpXG4gIH1cblxuICAvKipcbiAgICogQ2FsbHMgYWxsIG1lc3NhZ2UgaGFuZGxlcnMgd2l0aCBhIG1hdGNoaW5nIHN1YmplY3RcbiAgICovXG4gIGhhbmRsZU1lc3NhZ2UobXNnKSB7XG4gICAgdGhpcy5vbk1lc3NhZ2VIYW5kbGVycy5mb3JFYWNoKChoYW5kbGVyKSA9PiB7XG4gICAgICBpZiAoaGFuZGxlci5zdWJqZWN0ID09PSBtc2cuc3ViamVjdCkgaGFuZGxlci5jYWxsYmFjayhtc2cucGF5bG9hZClcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFN1YnNjcmliZSB0byBhIGNoYW5uZWwgc3ViamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3ViamVjdCAtIHN1YmplY3QgdG8gbGlzdGVuIGZvcjogYG1zZzpuZXdgXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gY2FsbGJhY2sgZnVuY3Rpb24gd2hlbiBhIG5ldyBtZXNzYWdlIGFycml2ZXNcbiAgICovXG4gIG9uKHN1YmplY3QsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5vbk1lc3NhZ2VIYW5kbGVycy5wdXNoKHsgc3ViamVjdDogc3ViamVjdCwgY2FsbGJhY2s6IGNhbGxiYWNrIH0pXG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIG5ldyBtZXNzYWdlIHRvIHRoZSBjaGFubmVsXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdWJqZWN0IC0gc3ViamVjdCB0byBzZW5kIG1lc3NhZ2UgdG86IGBtc2c6bmV3YFxuICAgKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZCAtIHBheWxvYWQgb2JqZWN0OiBge21lc3NhZ2U6ICdoZWxsbyd9YFxuICAgKi9cbiAgcHVzaChzdWJqZWN0LCBwYXlsb2FkKSB7XG4gICAgdGhpcy5zb2NrZXQud3Muc2VuZChKU09OLnN0cmluZ2lmeSh7IGV2ZW50OiBFVkVOVFMubWVzc2FnZSwgdG9waWM6IHRoaXMudG9waWMsIHN1YmplY3Q6IHN1YmplY3QsIHBheWxvYWQ6IHBheWxvYWQgfSkpXG4gIH1cbn1cblxuLyoqXG4gKiBDbGFzcyBmb3IgbWFpbnRhaW5pbmcgY29ubmVjdGlvbiB3aXRoIHNlcnZlciBhbmQgbWFpbnRhaW5pbmcgY2hhbm5lbHMgbGlzdFxuICovXG5leHBvcnQgY2xhc3MgU29ja2V0IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBlbmRwb2ludCAtIFdlYnNvY2tldCBlbmRwb250IHVzZWQgaW4gcm91dGVzLmNyIGZpbGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKGVuZHBvaW50KSB7XG4gICAgdGhpcy5lbmRwb2ludCA9IGVuZHBvaW50XG4gICAgdGhpcy53cyA9IG51bGxcbiAgICB0aGlzLmNoYW5uZWxzID0gW11cbiAgICB0aGlzLmxhc3RQaW5nID0gbm93KClcbiAgICB0aGlzLnJlY29ubmVjdFRyaWVzID0gMFxuICAgIHRoaXMuYXR0ZW1wdFJlY29ubmVjdCA9IHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBsYXN0IHJlY2VpdmVkIHBpbmcgaGFzIGJlZW4gcGFzdCB0aGUgdGhyZXNob2xkXG4gICAqL1xuICBfY29ubmVjdGlvbklzU3RhbGUoKSB7XG4gICAgcmV0dXJuIHNlY29uZHNTaW5jZSh0aGlzLmxhc3RQaW5nKSA+IFNUQUxFX0NPTk5FQ1RJT05fVEhSRVNIT0xEX1NFQ09ORFNcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmllcyB0byByZWNvbm5lY3QgdG8gdGhlIHdlYnNvY2tldCBzZXJ2ZXIgdXNpbmcgYSByZWN1cnNpdmUgdGltZW91dFxuICAgKi9cbiAgX3JlY29ubmVjdCgpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5yZWNvbm5lY3RUaW1lb3V0KVxuICAgIHRoaXMucmVjb25uZWN0VGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5yZWNvbm5lY3RUcmllcysrXG4gICAgICB0aGlzLmNvbm5lY3QodGhpcy5wYXJhbXMpXG4gICAgICB0aGlzLl9yZWNvbm5lY3QoKVxuICAgIH0sIHRoaXMuX3JlY29ubmVjdEludGVydmFsKCkpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBpbmNyZW1lbnRpbmcgdGltZW91dCBpbnRlcnZhbCBiYXNlZCBhcm91bmQgdGhlIG51bWJlciBvZiByZWNvbm5lY3Rpb24gcmV0cmllc1xuICAgKi9cbiAgX3JlY29ubmVjdEludGVydmFsKCkge1xuICAgIHJldHVybiBbMTAwMCwgMjAwMCwgNTAwMCwgMTAwMDBdW3RoaXMucmVjb25uZWN0VHJpZXNdIHx8IDEwMDAwXG4gIH1cblxuICAvKipcbiAgICogU2V0cyBhIHJlY3Vyc2l2ZSB0aW1lb3V0IHRvIGNoZWNrIGlmIHRoZSBjb25uZWN0aW9uIGlzIHN0YWxlXG4gICAqL1xuICBfcG9sbCgpIHtcbiAgICB0aGlzLnBvbGxpbmdUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5fY29ubmVjdGlvbklzU3RhbGUoKSkge1xuICAgICAgICB0aGlzLl9yZWNvbm5lY3QoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcG9sbCgpXG4gICAgICB9XG4gICAgfSwgU09DS0VUX1BPTExJTkdfUkFURSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhciBwb2xsaW5nIHRpbWVvdXQgYW5kIHN0YXJ0IHBvbGxpbmdcbiAgICovXG4gIF9zdGFydFBvbGxpbmcoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMucG9sbGluZ1RpbWVvdXQpXG4gICAgdGhpcy5fcG9sbCgpXG4gIH1cblxuICAvKipcbiAgICogU2V0cyBgbGFzdFBpbmdgIHRvIHRoZSBjdXJlbnQgdGltZVxuICAgKi9cbiAgX2hhbmRsZVBpbmcoKSB7XG4gICAgdGhpcy5sYXN0UGluZyA9IG5vdygpXG4gIH1cblxuICAvKipcbiAgICogQ2xlYXJzIHJlY29ubmVjdCB0aW1lb3V0LCByZXNldHMgdmFyaWFibGVzIGFuIHN0YXJ0cyBwb2xsaW5nXG4gICAqL1xuICBfcmVzZXQoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMucmVjb25uZWN0VGltZW91dClcbiAgICB0aGlzLnJlY29ubmVjdFRyaWVzID0gMFxuICAgIHRoaXMuYXR0ZW1wdFJlY29ubmVjdCA9IHRydWVcbiAgICB0aGlzLl9zdGFydFBvbGxpbmcoKVxuICB9XG5cbiAgLyoqXG4gICAqIENvbm5lY3QgdGhlIHNvY2tldCB0byB0aGUgc2VydmVyLCBhbmQgYmluZHMgdG8gbmF0aXZlIHdzIGZ1bmN0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gT3B0aW9uYWwgcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLmxvY2F0aW9uIC0gSG9zdG5hbWUgdG8gY29ubmVjdCB0bywgZGVmYXVsdHMgdG8gYHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZWBcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhcm1hcy5wb3J0IC0gUG9ydCB0byBjb25uZWN0IHRvLCBkZWZhdWx0cyB0byBgd2luZG93LmxvY2F0aW9uLnBvcnRgXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMucHJvdG9jb2wgLSBQcm90b2NvbCB0byB1c2UsIGVpdGhlciAnd3NzJyBvciAnd3MnXG4gICAqL1xuICBjb25uZWN0KHBhcmFtcykge1xuICAgIHRoaXMucGFyYW1zID0gcGFyYW1zXG5cbiAgICBsZXQgb3B0cyA9IHtcbiAgICAgIGxvY2F0aW9uOiB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUsXG4gICAgICBwb3J0OiB3aW5kb3cubG9jYXRpb24ucG9ydCxcbiAgICAgIHByb3RvY29sOiB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgPT09ICdodHRwczonID8gJ3dzczonIDogJ3dzOicsXG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcykgT2JqZWN0LmFzc2lnbihvcHRzLCBwYXJhbXMpXG4gICAgaWYgKG9wdHMucG9ydCkgb3B0cy5sb2NhdGlvbiArPSBgOiR7b3B0cy5wb3J0fWBcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLndzID0gbmV3IFdlYlNvY2tldChgJHtvcHRzLnByb3RvY29sfS8vJHtvcHRzLmxvY2F0aW9ufSR7dGhpcy5lbmRwb2ludH1gKVxuICAgICAgdGhpcy53cy5vbm1lc3NhZ2UgPSAobXNnKSA9PiB7IHRoaXMuaGFuZGxlTWVzc2FnZShtc2cpIH1cbiAgICAgIHRoaXMud3Mub25jbG9zZSA9ICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuYXR0ZW1wdFJlY29ubmVjdCkgdGhpcy5fcmVjb25uZWN0KClcbiAgICAgIH1cbiAgICAgIHRoaXMud3Mub25vcGVuID0gKCkgPT4ge1xuICAgICAgICB0aGlzLl9yZXNldCgpXG4gICAgICAgIHJlc29sdmUoKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBzb2NrZXQgY29ubmVjdGlvbiBwZXJtYW5lbnRseVxuICAgKi9cbiAgZGlzY29ubmVjdCgpIHtcbiAgICB0aGlzLmF0dGVtcHRSZWNvbm5lY3QgPSBmYWxzZVxuICAgIGNsZWFyVGltZW91dCh0aGlzLnBvbGxpbmdUaW1lb3V0KVxuICAgIGNsZWFyVGltZW91dCh0aGlzLnJlY29ubmVjdFRpbWVvdXQpXG4gICAgdGhpcy53cy5jbG9zZSgpXG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIG5ldyBjaGFubmVsIHRvIHRoZSBzb2NrZXQgY2hhbm5lbHMgbGlzdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdG9waWMgLSBUb3BpYyBmb3IgdGhlIGNoYW5uZWw6IGBjaGF0X3Jvb206MTIzYFxuICAgKi9cbiAgY2hhbm5lbCh0b3BpYykge1xuICAgIGxldCBjaGFubmVsID0gbmV3IENoYW5uZWwodG9waWMsIHRoaXMpXG4gICAgdGhpcy5jaGFubmVscy5wdXNoKGNoYW5uZWwpXG4gICAgcmV0dXJuIGNoYW5uZWxcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXNzYWdlIGhhbmRsZXIgZm9yIG1lc3NhZ2VzIHJlY2VpdmVkXG4gICAqIEBwYXJhbSB7TWVzc2FnZUV2ZW50fSBtc2cgLSBNZXNzYWdlIHJlY2VpdmVkIGZyb20gd3NcbiAgICovXG4gIGhhbmRsZU1lc3NhZ2UobXNnKSB7XG4gICAgaWYgKG1zZy5kYXRhID09PSBcInBpbmdcIikgcmV0dXJuIHRoaXMuX2hhbmRsZVBpbmcoKVxuXG4gICAgbGV0IHBhcnNlZF9tc2cgPSBKU09OLnBhcnNlKG1zZy5kYXRhKVxuICAgIHRoaXMuY2hhbm5lbHMuZm9yRWFjaCgoY2hhbm5lbCkgPT4ge1xuICAgICAgaWYgKGNoYW5uZWwudG9waWMgPT09IHBhcnNlZF9tc2cudG9waWMpIGNoYW5uZWwuaGFuZGxlTWVzc2FnZShwYXJzZWRfbXNnKVxuICAgIH0pXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFNvY2tldDogU29ja2V0XG59XG5cblxuLyoqXG4gKiBBbGxvd3MgZGVsZXRlIGxpbmtzIHRvIHBvc3QgZm9yIHNlY3VyaXR5IGFuZCBlYXNlIG9mIHVzZSBzaW1pbGFyIHRvIFJhaWxzIGpxdWVyeV91anNcbiAqL1xuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgZnVuY3Rpb24gKCkge1xuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJhW2RhdGEtbWV0aG9kPSdkZWxldGUnXVwiKS5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1jb25maXJtXCIpIHx8IFwiQXJlIHlvdSBzdXJlP1wiO1xuICAgICAgICAgICAgaWYgKGNvbmZpcm0obWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZm9ybSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJmb3JtXCIpO1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgICAgICAgICAgICBmb3JtLnNldEF0dHJpYnV0ZShcImFjdGlvblwiLCBlbGVtZW50LmdldEF0dHJpYnV0ZShcImhyZWZcIikpO1xuICAgICAgICAgICAgICAgIGZvcm0uc2V0QXR0cmlidXRlKFwibWV0aG9kXCIsIFwiUE9TVFwiKTtcbiAgICAgICAgICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwiaGlkZGVuXCIpO1xuICAgICAgICAgICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZShcIm5hbWVcIiwgXCJfbWV0aG9kXCIpO1xuICAgICAgICAgICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZShcInZhbHVlXCIsIFwiREVMRVRFXCIpO1xuICAgICAgICAgICAgICAgIGZvcm0uYXBwZW5kQ2hpbGQoaW5wdXQpO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZm9ybSk7XG4gICAgICAgICAgICAgICAgZm9ybS5zdWJtaXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSlcbiAgICB9KVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9saWIvYW1iZXIvYXNzZXRzL2pzL2FtYmVyLmpzIiwiLy8gcGhvdG9zIGZyb20gZmxpY2tyIHdpdGggY3JlYXRpdmUgY29tbW9ucyBsaWNlbnNlXG5pbXBvcnQgY3l0b3NjYXBlIGZyb20gJ2N5dG9zY2FwZSc7XG5cbmxldCB0b3VybmFtZW50R3JhcGhFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RvdXJuYW1lbnQtZ3JhcGgnKTtcblxuaWYgKHRvdXJuYW1lbnRHcmFwaEVsZW1lbnQpIHtcbiAgbGV0IHRvdXJuYW1lbnREYXRhVXJsID0gdG91cm5hbWVudEdyYXBoRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3RvdXJuYW1lbnQtZGF0YS11cmwnKTtcbiAgZmV0Y2goYCR7dG91cm5hbWVudERhdGFVcmx9Lmpzb25gKVxuICAudGhlbihyZXNwb25zZSA9PiByZXNwb25zZS5qc29uKCkpXG4gIC50aGVuKHRvdXJuYW1lbnREYXRhID0+IHtcbiAgICAvLyBHZXQgcmlkIG9mIGJ5ZSBtYXRjaGVzXG4gICAgbGV0IGZpbHRlcmVkTWF0Y2hEYXRhID0gdG91cm5hbWVudERhdGEubWF0Y2hlcy5maWx0ZXIoKG1hdGNoKSA9PiB7IHJldHVybiBtYXRjaC5sZXZlbCA+IDAgfHwgKG1hdGNoLnBsYXllcl9hX2lkICYmIG1hdGNoLnBsYXllcl9iX2lkKSB9KTtcblxuICAgIC8vIFNvcnQgYnkgbG93ZXN0IGxldmVsLCBhbmQgdGhlbiBieSBpZCBmb3IgY29uc2lzdGVudCByZW5kZXJpbmcgb3JkZXJcbiAgICBmaWx0ZXJlZE1hdGNoRGF0YS5zb3J0KChhLCBiKSA9PiB7XG4gICAgICBpZiAoYS5sZXZlbCAhPSBiLmxldmVsKSB7XG4gICAgICAgIGIubGV2ZWwgLSBhLmxldmVsXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiLmlkIC0gYS5pZFxuICAgICAgfVxuICAgIH0pXG5cbiAgICBsZXQgbWF0Y2hOb2RlcyA9IGZpbHRlcmVkTWF0Y2hEYXRhLm1hcCgobWF0Y2gpID0+IHtcbiAgICAgIGxldCBwbGF5ZXJfYSA9IHRvdXJuYW1lbnREYXRhLnBsYXllcnMuZmluZCgocGxheWVyKSA9PiBwbGF5ZXIuaWQgPT0gbWF0Y2gucGxheWVyX2FfaWQpXG4gICAgICBsZXQgcGxheWVyX2IgPSB0b3VybmFtZW50RGF0YS5wbGF5ZXJzLmZpbmQoKHBsYXllcikgPT4gcGxheWVyLmlkID09IG1hdGNoLnBsYXllcl9iX2lkKVxuICAgICAgbGV0IHdpbm5lciA9IHRvdXJuYW1lbnREYXRhLnBsYXllcnMuZmluZCgocGxheWVyKSA9PiBwbGF5ZXIuaWQgPT0gbWF0Y2gud2lubmVyX2lkKVxuXG4gICAgICBsZXQgb3V0bGluZUNvbG9yXG4gICAgICBpZiAod2lubmVyKVxuICAgICAgICBvdXRsaW5lQ29sb3IgPSAnI2VmNGI2MidcbiAgICAgIGVsc2UgaWYgKHBsYXllcl9hICYmIHBsYXllcl9iKVxuICAgICAgICBvdXRsaW5lQ29sb3IgPSAnI2ZmYTAzOSdcbiAgICAgIGVsc2VcbiAgICAgICAgb3V0bGluZUNvbG9yID0gJyM4MjgyODInXG5cbiAgICAgIGxldCBwbGF5ZXJzTGFiZWwgPSBcIlwiXG4gICAgICBpZiAocGxheWVyX2EgJiYgcGxheWVyX2IpIHtcbiAgICAgICAgcGxheWVyc0xhYmVsID0gYCR7cGxheWVyX2EudGFnfSB2cyAke3BsYXllcl9iLnRhZ31gXG4gICAgICB9IGVsc2UgaWYgKHBsYXllcl9hKSB7XG4gICAgICAgIHBsYXllcnNMYWJlbCA9IGAke3BsYXllcl9hLnRhZ30gdnMgP2BcbiAgICAgIH0gZWxzZSBpZiAocGxheWVyX2IpIHtcbiAgICAgICAgcGxheWVyc0xhYmVsID0gYCR7cGxheWVyX2IudGFnfSB2cyA/YFxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgaWQ6IGBtJHttYXRjaC5pZH1gLFxuICAgICAgICAgIG5hbWU6IGBNYXRjaCAjJHttYXRjaC5pZH1gLFxuICAgICAgICAgIGhyZWY6IG1hdGNoLnVybCxcbiAgICAgICAgICBwbGF5ZXJzX3ZzOiBwbGF5ZXJzTGFiZWwsXG4gICAgICAgICAgYmFja2dyb3VuZDogd2lubmVyID8gd2lubmVyLmltYWdlX3VybCA6ICdub25lJyxcbiAgICAgICAgICBvdXRsaW5lOiBvdXRsaW5lQ29sb3JcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KVxuXG4gICAgbGV0IG1hdGNoRWRnZXMgPSBmaWx0ZXJlZE1hdGNoRGF0YS5maWx0ZXIobWF0Y2ggPT4gbWF0Y2gubmV4dF9tYXRjaF9pZCkubWFwKChtYXRjaCkgPT4ge1xuICAgICAgLy8gc291cmNlIGFuZCB0YXJnZXQgYW5kIHN3YXBwZWQgYXJvdW5kIGFzIHRvIHRyZWF0IHRoZSB3aW5uaW5nIG5vZGUgYXMgdGhlIHRvcCBvZiB0aGUgdHJlZSAoQkZTKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHRhcmdldDogYG0ke21hdGNoLmlkfWAsXG4gICAgICAgICAgc291cmNlOiBgbSR7bWF0Y2gubmV4dF9tYXRjaF9pZH1gLFxuICAgICAgICAgIGNvbG9yOiBtYXRjaC53aW5uZXJfaWQgPyBcIiM0ZWI0ZjlcIiA6IFwiIzgyODI4MlwiXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSlcblxuICAgIGxldCBwbGF5ZXJOb2RlcyA9IFtdO1xuICAgIGZpbHRlcmVkTWF0Y2hEYXRhLmZvckVhY2goKG1hdGNoKSA9PiB7XG4gICAgICBbbWF0Y2gucGxheWVyX2FfaWQsIG1hdGNoLnBsYXllcl9iX2lkXS5mb3JFYWNoKChwbGF5ZXJfaWQpID0+IHtcbiAgICAgICAgbGV0IHBsYXllciA9IHRvdXJuYW1lbnREYXRhLnBsYXllcnMuZmluZCgocGxheWVyKSA9PiBwbGF5ZXIuaWQgPT0gcGxheWVyX2lkKVxuXG4gICAgICAgIGlmIChwbGF5ZXIpXG4gICAgICAgICAgcGxheWVyTm9kZXMgKz0geyBkYXRhOiB7IGlkOiBgcCR7cGxheWVyLmlkfWAsIG5hbWU6IHBsYXllci50YWcgfSB9XG4gICAgICB9KVxuICAgIH0pXG5cbiAgICBsZXQgY3kgPSBjeXRvc2NhcGUoe1xuICAgICAgY29udGFpbmVyOiB0b3VybmFtZW50R3JhcGhFbGVtZW50LFxuXG4gICAgICBib3hTZWxlY3Rpb25FbmFibGVkOiB0cnVlLFxuICAgICAgYXV0b3Vuc2VsZWN0aWZ5OiB0cnVlLFxuXG4gICAgICBtYXhab29tOiAyLFxuICAgICAgbWluWm9vbTogMC4yNSxcblxuICAgICAgc3R5bGU6IGN5dG9zY2FwZS5zdHlsZXNoZWV0KClcbiAgICAgICAgLnNlbGVjdG9yKCdub2RlJylcbiAgICAgICAgICAuY3NzKHtcbiAgICAgICAgICAgICdoZWlnaHQnOiAnODByZW0nLFxuICAgICAgICAgICAgJ3dpZHRoJzogJzgwcmVtJyxcbiAgICAgICAgICAgICdiYWNrZ3JvdW5kLWltYWdlJzogJ2RhdGEoYmFja2dyb3VuZCknLFxuICAgICAgICAgICAgJ2JhY2tncm91bmQtZml0JzogJ2NvdmVyJyxcbiAgICAgICAgICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogJyMzNDNhNDAnLFxuICAgICAgICAgICAgJ2JvcmRlci1jb2xvcic6ICdkYXRhKG91dGxpbmUpJyxcbiAgICAgICAgICAgICdib3JkZXItd2lkdGgnOiAnOHJlbScsXG4gICAgICAgICAgICAnYm9yZGVyLW9wYWNpdHknOiAxLFxuICAgICAgICAgICAgJ2NvbnRlbnQnOiAnZGF0YShwbGF5ZXJzX3ZzKScsXG4gICAgICAgICAgICAnY29sb3InOiAnd2hpdGUnLFxuICAgICAgICAgICAgJ3RleHQtb3V0bGluZS13aWR0aCc6ICcycmVtJyxcbiAgICAgICAgICAgICd0ZXh0LW91dGxpbmUtY29sb3InOiAnIzM0M2E0MCcsXG4gICAgICAgICAgICAndGV4dC12YWxpZ24nOiAnYm90dG9tJyxcbiAgICAgICAgICAgICdmb250LXdlaWdodCc6ICdib2xkJyxcbiAgICAgICAgICAgICdmb250LXNpemUnOiAnMjByZW0nLFxuICAgICAgICAgICAgJ2ZvbnQtZmFtaWx5JzogJ011bGksIEhlbHZldGljYSBOZXVlLCBIZWx2ZXRpY2EsIEFyaWFsLCBzYW5zLXNlcmlmJ1xuICAgICAgICAgIH0pXG4gICAgICAgIC5zZWxlY3RvcignLmVhdGluZycpXG4gICAgICAgICAgLmNzcyh7XG4gICAgICAgICAgICAnYm9yZGVyLWNvbG9yJzogJ3JlZCdcbiAgICAgICAgICB9KVxuICAgICAgICAuc2VsZWN0b3IoJy5lYXRlcicpXG4gICAgICAgICAgLmNzcyh7XG4gICAgICAgICAgICAnYm9yZGVyLXdpZHRoJzogMTBcbiAgICAgICAgICB9KVxuICAgICAgICAuc2VsZWN0b3IoJ2VkZ2UnKVxuICAgICAgICAgIC5jc3Moe1xuICAgICAgICAgICAgJ2N1cnZlLXN0eWxlJzogJ3VuYnVuZGxlZC1iZXppZXInLFxuICAgICAgICAgICAgJ3dpZHRoJzogOCxcbiAgICAgICAgICAgICdzb3VyY2UtYXJyb3ctc2hhcGUnOiAndHJpYW5nbGUnLFxuICAgICAgICAgICAgJ2xpbmUtY29sb3InOiAnZGF0YShjb2xvciknLFxuICAgICAgICAgICAgJ3NvdXJjZS1hcnJvdy1jb2xvcic6ICdkYXRhKGNvbG9yKSdcbiAgICAgICAgICB9KVxuICAgICAgICAuc2VsZWN0b3IoJ2VkZ2UucGxheWVkJylcbiAgICAgICAgICAuY3NzKHtcbiAgICAgICAgICAgICdsaW5lLWNvbG9yJzogXCIjYWVmNzJmXCJcbiAgICAgICAgICB9KSxcblxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgbm9kZXM6IG1hdGNoTm9kZXMsXG4gICAgICAgIGVkZ2VzOiBtYXRjaEVkZ2VzXG4gICAgICB9LFxuXG4gICAgICBsYXlvdXQ6IHtcbiAgICAgICAgbmFtZTogJ2JyZWFkdGhmaXJzdCcsXG4gICAgICAgIGRpcmVjdGVkOiB0cnVlLFxuICAgICAgICBwYWRkaW5nOiAxMFxuICAgICAgfVxuICAgIH0pOyAvLyBjeSBpbml0XG5cbiAgICBjeS5vbigndGFwJywgJ25vZGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBsZXQgbm9kZSA9IHRoaXMuX3ByaXZhdGU7XG4gICAgICBsZXQgaHJlZiA9IG5vZGUuZGF0YS5ocmVmO1xuXG4gICAgICBpZiAoaHJlZilcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBocmVmO1xuICAgIH0pO1xuICB9KS5jYXRjaChmdW5jdGlvbihlcnJvcikge1xuICAgIHRvdXJuYW1lbnRHcmFwaEVsZW1lbnQuaW5uZXJUZXh0ID0gXCJTb21ldGhpbmcgd2VudCB3cm9uZy5cIlxuICB9KTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9hc3NldHMvamF2YXNjcmlwdHMvdG91cm5hbWVudC1ncmFwaC5qcyIsIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcImxvZGFzaC5kZWJvdW5jZVwiKSwgcmVxdWlyZShcImhlYXBcIikpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW1wibG9kYXNoLmRlYm91bmNlXCIsIFwiaGVhcFwiXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJjeXRvc2NhcGVcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJsb2Rhc2guZGVib3VuY2VcIiksIHJlcXVpcmUoXCJoZWFwXCIpKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJjeXRvc2NhcGVcIl0gPSBmYWN0b3J5KHJvb3RbXCJsb2Rhc2guZGVib3VuY2VcIl0sIHJvb3RbXCJoZWFwXCJdKTtcbn0pKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzI2X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMzJfXykge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbi8qKioqKiovIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbi8qKioqKiovIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbi8qKioqKiovIFx0XHRcdH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAyMCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuLypnbG9iYWwgSFRNTEVsZW1lbnQgRG9jdW1lbnRUb3VjaCAqL1xuXG52YXIgd2luZG93ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbnZhciBuYXZpZ2F0b3IgPSB3aW5kb3cgPyB3aW5kb3cubmF2aWdhdG9yIDogbnVsbDtcbnZhciBkb2N1bWVudCA9IHdpbmRvdyA/IHdpbmRvdy5kb2N1bWVudCA6IG51bGw7XG5cbnZhciB0eXBlb2ZzdHIgPSBfdHlwZW9mKCcnKTtcbnZhciB0eXBlb2ZvYmogPSBfdHlwZW9mKHt9KTtcbnZhciB0eXBlb2ZmbiA9IF90eXBlb2YoZnVuY3Rpb24gKCkge30pO1xudmFyIHR5cGVvZmh0bWxlbGUgPSB0eXBlb2YgSFRNTEVsZW1lbnQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKEhUTUxFbGVtZW50KTtcblxudmFyIGluc3RhbmNlU3RyID0gZnVuY3Rpb24gaW5zdGFuY2VTdHIob2JqKSB7XG4gIHJldHVybiBvYmogJiYgb2JqLmluc3RhbmNlU3RyaW5nICYmIGlzLmZuKG9iai5pbnN0YW5jZVN0cmluZykgPyBvYmouaW5zdGFuY2VTdHJpbmcoKSA6IG51bGw7XG59O1xuXG52YXIgaXMgPSB7XG4gIGRlZmluZWQ6IGZ1bmN0aW9uIGRlZmluZWQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsOyAvLyBub3QgdW5kZWZpbmVkIG9yIG51bGxcbiAgfSxcblxuICBzdHJpbmc6IGZ1bmN0aW9uIHN0cmluZyhvYmopIHtcbiAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgKHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG9iaikpID09IHR5cGVvZnN0cjtcbiAgfSxcblxuICBmbjogZnVuY3Rpb24gZm4ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmICh0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihvYmopKSA9PT0gdHlwZW9mZm47XG4gIH0sXG5cbiAgYXJyYXk6IGZ1bmN0aW9uIGFycmF5KG9iaikge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5ID8gQXJyYXkuaXNBcnJheShvYmopIDogb2JqICE9IG51bGwgJiYgb2JqIGluc3RhbmNlb2YgQXJyYXk7XG4gIH0sXG5cbiAgcGxhaW5PYmplY3Q6IGZ1bmN0aW9uIHBsYWluT2JqZWN0KG9iaikge1xuICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiAodHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yob2JqKSkgPT09IHR5cGVvZm9iaiAmJiAhaXMuYXJyYXkob2JqKSAmJiBvYmouY29uc3RydWN0b3IgPT09IE9iamVjdDtcbiAgfSxcblxuICBvYmplY3Q6IGZ1bmN0aW9uIG9iamVjdChvYmopIHtcbiAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgKHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG9iaikpID09PSB0eXBlb2ZvYmo7XG4gIH0sXG5cbiAgbnVtYmVyOiBmdW5jdGlvbiBudW1iZXIob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmICh0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihvYmopKSA9PT0gX3R5cGVvZigxKSAmJiAhaXNOYU4ob2JqKTtcbiAgfSxcblxuICBpbnRlZ2VyOiBmdW5jdGlvbiBpbnRlZ2VyKG9iaikge1xuICAgIHJldHVybiBpcy5udW1iZXIob2JqKSAmJiBNYXRoLmZsb29yKG9iaikgPT09IG9iajtcbiAgfSxcblxuICBib29sOiBmdW5jdGlvbiBib29sKG9iaikge1xuICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiAodHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yob2JqKSkgPT09IF90eXBlb2YodHJ1ZSk7XG4gIH0sXG5cbiAgaHRtbEVsZW1lbnQ6IGZ1bmN0aW9uIGh0bWxFbGVtZW50KG9iaikge1xuICAgIGlmICgndW5kZWZpbmVkJyA9PT0gdHlwZW9maHRtbGVsZSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGwgIT0gb2JqICYmIG9iaiBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xuICAgIH1cbiAgfSxcblxuICBlbGVtZW50T3JDb2xsZWN0aW9uOiBmdW5jdGlvbiBlbGVtZW50T3JDb2xsZWN0aW9uKG9iaikge1xuICAgIHJldHVybiBpcy5lbGVtZW50KG9iaikgfHwgaXMuY29sbGVjdGlvbihvYmopO1xuICB9LFxuXG4gIGVsZW1lbnQ6IGZ1bmN0aW9uIGVsZW1lbnQob2JqKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlU3RyKG9iaikgPT09ICdjb2xsZWN0aW9uJyAmJiBvYmouX3ByaXZhdGUuc2luZ2xlO1xuICB9LFxuXG4gIGNvbGxlY3Rpb246IGZ1bmN0aW9uIGNvbGxlY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlU3RyKG9iaikgPT09ICdjb2xsZWN0aW9uJyAmJiAhb2JqLl9wcml2YXRlLnNpbmdsZTtcbiAgfSxcblxuICBjb3JlOiBmdW5jdGlvbiBjb3JlKG9iaikge1xuICAgIHJldHVybiBpbnN0YW5jZVN0cihvYmopID09PSAnY29yZSc7XG4gIH0sXG5cbiAgc3R5bGU6IGZ1bmN0aW9uIHN0eWxlKG9iaikge1xuICAgIHJldHVybiBpbnN0YW5jZVN0cihvYmopID09PSAnc3R5bGUnO1xuICB9LFxuXG4gIHN0eWxlc2hlZXQ6IGZ1bmN0aW9uIHN0eWxlc2hlZXQob2JqKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlU3RyKG9iaikgPT09ICdzdHlsZXNoZWV0JztcbiAgfSxcblxuICBldmVudDogZnVuY3Rpb24gZXZlbnQob2JqKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlU3RyKG9iaikgPT09ICdldmVudCc7XG4gIH0sXG5cbiAgdGhyZWFkOiBmdW5jdGlvbiB0aHJlYWQob2JqKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlU3RyKG9iaikgPT09ICd0aHJlYWQnO1xuICB9LFxuXG4gIGZhYnJpYzogZnVuY3Rpb24gZmFicmljKG9iaikge1xuICAgIHJldHVybiBpbnN0YW5jZVN0cihvYmopID09PSAnZmFicmljJztcbiAgfSxcblxuICBlbXB0eVN0cmluZzogZnVuY3Rpb24gZW1wdHlTdHJpbmcob2JqKSB7XG4gICAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkIHx8IG9iaiA9PT0gbnVsbCkge1xuICAgICAgLy8gbnVsbCBpcyBlbXB0eVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChvYmogPT09ICcnIHx8IG9iai5tYXRjaCgvXlxccyskLykpIHtcbiAgICAgIHJldHVybiB0cnVlOyAvLyBlbXB0eSBzdHJpbmcgaXMgZW1wdHlcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7IC8vIG90aGVyd2lzZSwgd2UgZG9uJ3Qga25vdyB3aGF0IHdlJ3ZlIGdvdFxuICB9LFxuXG4gIG5vbmVtcHR5U3RyaW5nOiBmdW5jdGlvbiBub25lbXB0eVN0cmluZyhvYmopIHtcbiAgICBpZiAob2JqICYmIGlzLnN0cmluZyhvYmopICYmIG9iaiAhPT0gJycgJiYgIW9iai5tYXRjaCgvXlxccyskLykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICBkb21FbGVtZW50OiBmdW5jdGlvbiBkb21FbGVtZW50KG9iaikge1xuICAgIGlmICh0eXBlb2YgSFRNTEVsZW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7IC8vIHdlJ3JlIG5vdCBpbiBhIGJyb3dzZXIgc28gaXQgZG9lc24ndCBtYXR0ZXJcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xuICAgIH1cbiAgfSxcblxuICBib3VuZGluZ0JveDogZnVuY3Rpb24gYm91bmRpbmdCb3gob2JqKSB7XG4gICAgcmV0dXJuIGlzLnBsYWluT2JqZWN0KG9iaikgJiYgaXMubnVtYmVyKG9iai54MSkgJiYgaXMubnVtYmVyKG9iai54MikgJiYgaXMubnVtYmVyKG9iai55MSkgJiYgaXMubnVtYmVyKG9iai55Mik7XG4gIH0sXG5cbiAgcHJvbWlzZTogZnVuY3Rpb24gcHJvbWlzZShvYmopIHtcbiAgICByZXR1cm4gaXMub2JqZWN0KG9iaikgJiYgaXMuZm4ob2JqLnRoZW4pO1xuICB9LFxuXG4gIHRvdWNoOiBmdW5jdGlvbiB0b3VjaCgpIHtcbiAgICByZXR1cm4gd2luZG93ICYmICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgfHwgd2luZG93LkRvY3VtZW50VG91Y2ggJiYgZG9jdW1lbnQgaW5zdGFuY2VvZiBEb2N1bWVudFRvdWNoKTtcbiAgfSxcblxuICBnZWNrbzogZnVuY3Rpb24gZ2Vja28oKSB7XG4gICAgcmV0dXJuIHdpbmRvdyAmJiAodHlwZW9mIEluc3RhbGxUcmlnZ2VyICE9PSAndW5kZWZpbmVkJyB8fCAnTW96QXBwZWFyYW5jZScgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlKTtcbiAgfSxcblxuICB3ZWJraXQ6IGZ1bmN0aW9uIHdlYmtpdCgpIHtcbiAgICByZXR1cm4gd2luZG93ICYmICh0eXBlb2Ygd2Via2l0VVJMICE9PSAndW5kZWZpbmVkJyB8fCAnV2Via2l0QXBwZWFyYW5jZScgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlKTtcbiAgfSxcblxuICBjaHJvbWl1bTogZnVuY3Rpb24gY2hyb21pdW0oKSB7XG4gICAgcmV0dXJuIHdpbmRvdyAmJiB0eXBlb2YgY2hyb21lICE9PSAndW5kZWZpbmVkJztcbiAgfSxcblxuICBraHRtbDogZnVuY3Rpb24ga2h0bWwoKSB7XG4gICAgcmV0dXJuIG5hdmlnYXRvciAmJiBuYXZpZ2F0b3IudmVuZG9yLm1hdGNoKC9rZGUvaSk7IC8vIHByb2JhYmx5IGEgYmV0dGVyIHdheSB0byBkZXRlY3QgdGhpcy4uLlxuICB9LFxuXG4gIGtodG1sRXRjOiBmdW5jdGlvbiBraHRtbEV0YygpIHtcbiAgICByZXR1cm4gaXMua2h0bWwoKSB8fCBpcy53ZWJraXQoKSB8fCBpcy5jaHJvbWl1bSgpO1xuICB9LFxuXG4gIG1zOiBmdW5jdGlvbiBtcygpIHtcbiAgICByZXR1cm4gbmF2aWdhdG9yICYmIG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL21zaWV8dHJpZGVudHxlZGdlL2kpOyAvLyBwcm9iYWJseSBhIGJldHRlciB3YXkgdG8gZGV0ZWN0IHRoaXMuLi5cbiAgfSxcblxuICB3aW5kb3dzOiBmdW5jdGlvbiB3aW5kb3dzKCkge1xuICAgIHJldHVybiBuYXZpZ2F0b3IgJiYgbmF2aWdhdG9yLmFwcFZlcnNpb24ubWF0Y2goL1dpbi9pKTtcbiAgfSxcblxuICBtYWM6IGZ1bmN0aW9uIG1hYygpIHtcbiAgICByZXR1cm4gbmF2aWdhdG9yICYmIG5hdmlnYXRvci5hcHBWZXJzaW9uLm1hdGNoKC9NYWMvaSk7XG4gIH0sXG5cbiAgbGludXg6IGZ1bmN0aW9uIGxpbnV4KCkge1xuICAgIHJldHVybiBuYXZpZ2F0b3IgJiYgbmF2aWdhdG9yLmFwcFZlcnNpb24ubWF0Y2goL0xpbnV4L2kpO1xuICB9LFxuXG4gIHVuaXg6IGZ1bmN0aW9uIHVuaXgoKSB7XG4gICAgcmV0dXJuIG5hdmlnYXRvciAmJiBuYXZpZ2F0b3IuYXBwVmVyc2lvbi5tYXRjaCgvWDExL2kpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzO1xuXG4vKioqLyB9KSxcbi8qIDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLypnbG9iYWwgY29uc29sZSAqL1xuXG52YXIgaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIG1hdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgdXRpbCA9IHtcblxuICBNQVhfSU5UOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fCA5MDA3MTk5MjU0NzQwOTkxLFxuXG4gIHRydWVpZnk6IGZ1bmN0aW9uIHRydWVpZnkoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgZmFsc2lmeTogZnVuY3Rpb24gZmFsc2lmeSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgemVyb2lmeTogZnVuY3Rpb24gemVyb2lmeSgpIHtcbiAgICByZXR1cm4gMDtcbiAgfSxcblxuICBub29wOiBmdW5jdGlvbiBub29wKCkge30sXG5cbiAgZXJyb3I6IGZ1bmN0aW9uIGVycm9yKG1zZykge1xuICAgIC8qIGVzbGludC1kaXNhYmxlICovXG4gICAgaWYgKGNvbnNvbGUuZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcblxuICAgICAgaWYgKGNvbnNvbGUudHJhY2UpIHtcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xuXG4gICAgICBpZiAoY29uc29sZS50cmFjZSkge1xuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIGVzbGludC1lbmFibGUgKi9cbiAgfSxcblxuICBjbG9uZTogZnVuY3Rpb24gY2xvbmUob2JqKSB7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5kKHt9LCBvYmopO1xuICB9LFxuXG4gIC8vIGdldHMgYSBzaGFsbG93IGNvcHkgb2YgdGhlIGFyZ3VtZW50XG4gIGNvcHk6IGZ1bmN0aW9uIGNvcHkob2JqKSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1pZiAoaXMuYXJyYXkob2JqKSkge1xuICAgICAgcmV0dXJuIG9iai5zbGljZSgpO1xuICAgIH0gZWxzZSBpZiAoaXMucGxhaW5PYmplY3Qob2JqKSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2xvbmUob2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gIH0sXG5cbiAgY29weUFycmF5OiBmdW5jdGlvbiBjb3B5QXJyYXkoYXJyKSB7XG4gICAgcmV0dXJuIGFyci5zbGljZSgpO1xuICB9LFxuXG4gIGNsb25lUG9zaXRpb246IGZ1bmN0aW9uIGNsb25lUG9zaXRpb24ocG9zKSB7XG4gICAgcmV0dXJuIHsgeDogcG9zLngsIHk6IHBvcy55IH07XG4gIH0sXG5cbiAgdXVpZDogZnVuY3Rpb24gdXVpZChhLCBiIC8vIHBsYWNlaG9sZGVyc1xuICApIHtcbiAgICBmb3IgKCAvLyBsb29wIDopXG4gICAgYiA9IGEgPSAnJzsgLy8gYiAtIHJlc3VsdCAsIGEgLSBudW1lcmljIGxldGlhYmxlXG4gICAgYSsrIDwgMzY7IC8vXG4gICAgYiArPSBhICogNTEgJiA1MiAvLyBpZiBcImFcIiBpcyBub3QgOSBvciAxNCBvciAxOSBvciAyNFxuICAgID8gLy8gIHJldHVybiBhIHJhbmRvbSBudW1iZXIgb3IgNFxuICAgIChhIF4gMTUgLy8gaWYgXCJhXCIgaXMgbm90IDE1XG4gICAgPyAvLyBnZW5ldGF0ZSBhIHJhbmRvbSBudW1iZXIgZnJvbSAwIHRvIDE1XG4gICAgOCBeIE1hdGgucmFuZG9tKCkgKiAoYSBeIDIwID8gMTYgOiA0KSAvLyB1bmxlc3MgXCJhXCIgaXMgMjAsIGluIHdoaWNoIGNhc2UgYSByYW5kb20gbnVtYmVyIGZyb20gOCB0byAxMVxuICAgIDogNCAvLyAgb3RoZXJ3aXNlIDRcbiAgICApLnRvU3RyaW5nKDE2KSA6ICctJyAvLyAgaW4gb3RoZXIgY2FzZXMgKGlmIFwiYVwiIGlzIDksMTQsMTksMjQpIGluc2VydCBcIi1cIlxuICAgICkge31cbiAgICByZXR1cm4gYjtcbiAgfVxuXG59O1xuXG51dGlsLm1ha2VCb3VuZGluZ0JveCA9IG1hdGgubWFrZUJvdW5kaW5nQm94LmJpbmQobWF0aCk7XG5cbnV0aWwuX3N0YXRpY0VtcHR5T2JqZWN0ID0ge307XG5cbnV0aWwuc3RhdGljRW1wdHlPYmplY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB1dGlsLl9zdGF0aWNFbXB0eU9iamVjdDtcbn07XG5cbnV0aWwuZXh0ZW5kID0gT2JqZWN0LmFzc2lnbiAhPSBudWxsID8gT2JqZWN0LmFzc2lnbi5iaW5kKE9iamVjdCkgOiBmdW5jdGlvbiAodGd0KSB7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuXG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBvYmogPSBhcmdzW2ldO1xuXG4gICAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGtleXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBrID0ga2V5c1tqXTtcblxuICAgICAgdGd0W2tdID0gb2JqW2tdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0Z3Q7XG59O1xuXG51dGlsLmFzc2lnbiA9IHV0aWwuZXh0ZW5kO1xuXG51dGlsLmRlZmF1bHQgPSBmdW5jdGlvbiAodmFsLCBkZWYpIHtcbiAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGRlZjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG59O1xuXG51dGlsLnJlbW92ZUZyb21BcnJheSA9IGZ1bmN0aW9uIChhcnIsIGVsZSwgbWFueUNvcGllcykge1xuICBmb3IgKHZhciBpID0gYXJyLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoYXJyW2ldID09PSBlbGUpIHtcbiAgICAgIGFyci5zcGxpY2UoaSwgMSk7XG5cbiAgICAgIGlmICghbWFueUNvcGllcykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnV0aWwuY2xlYXJBcnJheSA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLnNwbGljZSgwLCBhcnIubGVuZ3RoKTtcbn07XG5cbnV0aWwucHVzaCA9IGZ1bmN0aW9uIChhcnIsIG90aGVyQXJyKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3RoZXJBcnIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWwgPSBvdGhlckFycltpXTtcblxuICAgIGFyci5wdXNoKGVsKTtcbiAgfVxufTtcblxudXRpbC5nZXRQcmVmaXhlZFByb3BlcnR5ID0gZnVuY3Rpb24gKG9iaiwgcHJvcE5hbWUsIHByZWZpeCkge1xuICBpZiAocHJlZml4KSB7XG4gICAgcHJvcE5hbWUgPSB0aGlzLnByZXBlbmRDYW1lbChwcmVmaXgsIHByb3BOYW1lKTsgLy8gZS5nLiAobGFiZWxXaWR0aCwgc291cmNlKSA9PiBzb3VyY2VMYWJlbFdpZHRoXG4gIH1cblxuICByZXR1cm4gb2JqW3Byb3BOYW1lXTtcbn07XG5cbnV0aWwuc2V0UHJlZml4ZWRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmosIHByb3BOYW1lLCBwcmVmaXgsIHZhbHVlKSB7XG4gIGlmIChwcmVmaXgpIHtcbiAgICBwcm9wTmFtZSA9IHRoaXMucHJlcGVuZENhbWVsKHByZWZpeCwgcHJvcE5hbWUpOyAvLyBlLmcuIChsYWJlbFdpZHRoLCBzb3VyY2UpID0+IHNvdXJjZUxhYmVsV2lkdGhcbiAgfVxuXG4gIG9ialtwcm9wTmFtZV0gPSB2YWx1ZTtcbn07XG5cbltfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKSwgX193ZWJwYWNrX3JlcXVpcmVfXygyMiksIHsgbWVtb2l6ZTogX193ZWJwYWNrX3JlcXVpcmVfXygxMykgfSwgX193ZWJwYWNrX3JlcXVpcmVfXygyMyksIF9fd2VicGFja19yZXF1aXJlX18oMjQpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KSwgX193ZWJwYWNrX3JlcXVpcmVfXygyNyldLmZvckVhY2goZnVuY3Rpb24gKHJlcSkge1xuICB1dGlsLmV4dGVuZCh1dGlsLCByZXEpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gdXRpbDtcblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBtYXRoID0ge307XG5cbm1hdGguYXJlUG9zaXRpb25zU2FtZSA9IGZ1bmN0aW9uIChwMSwgcDIpIHtcbiAgcmV0dXJuIHAxLnggPT09IHAyLnggJiYgcDEueSA9PT0gcDIueTtcbn07XG5cbm1hdGguY29weVBvc2l0aW9uID0gZnVuY3Rpb24gKHApIHtcbiAgcmV0dXJuIHsgeDogcC54LCB5OiBwLnkgfTtcbn07XG5cbm1hdGgubW9kZWxUb1JlbmRlcmVkUG9zaXRpb24gPSBmdW5jdGlvbiAocCwgem9vbSwgcGFuKSB7XG4gIHJldHVybiB7XG4gICAgeDogcC54ICogem9vbSArIHBhbi54LFxuICAgIHk6IHAueSAqIHpvb20gKyBwYW4ueVxuICB9O1xufTtcblxubWF0aC5yZW5kZXJlZFRvTW9kZWxQb3NpdGlvbiA9IGZ1bmN0aW9uIChwLCB6b29tLCBwYW4pIHtcbiAgcmV0dXJuIHtcbiAgICB4OiAocC54IC0gcGFuLngpIC8gem9vbSxcbiAgICB5OiAocC55IC0gcGFuLnkpIC8gem9vbVxuICB9O1xufTtcblxubWF0aC5hcnJheTJwb2ludCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBhcnJbMF0sXG4gICAgeTogYXJyWzFdXG4gIH07XG59O1xuXG5tYXRoLmRlZzJyYWQgPSBmdW5jdGlvbiAoZGVnKSB7XG4gIHJldHVybiBNYXRoLlBJICogZGVnIC8gMTgwO1xufTtcblxubWF0aC5nZXRBbmdsZUZyb21EaXNwID0gZnVuY3Rpb24gKGRpc3BYLCBkaXNwWSkge1xuICByZXR1cm4gTWF0aC5hdGFuMihkaXNwWSwgZGlzcFgpIC0gTWF0aC5QSSAvIDI7XG59O1xuXG5tYXRoLmxvZzIgPSBNYXRoLmxvZzIgfHwgZnVuY3Rpb24gKG4pIHtcbiAgcmV0dXJuIE1hdGgubG9nKG4pIC8gTWF0aC5sb2coMik7XG59O1xuXG5tYXRoLnNpZ251bSA9IGZ1bmN0aW9uICh4KSB7XG4gIGlmICh4ID4gMCkge1xuICAgIHJldHVybiAxO1xuICB9IGVsc2UgaWYgKHggPCAwKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAwO1xuICB9XG59O1xuXG5tYXRoLmRpc3QgPSBmdW5jdGlvbiAocDEsIHAyKSB7XG4gIHJldHVybiBNYXRoLnNxcnQobWF0aC5zcWRpc3QocDEsIHAyKSk7XG59O1xuXG5tYXRoLnNxZGlzdCA9IGZ1bmN0aW9uIChwMSwgcDIpIHtcbiAgdmFyIGR4ID0gcDIueCAtIHAxLng7XG4gIHZhciBkeSA9IHAyLnkgLSBwMS55O1xuXG4gIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn07XG5cbi8vIGZyb20gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Cw6l6aWVyX2N1cnZlI1F1YWRyYXRpY19jdXJ2ZXNcbm1hdGgucWJlemllckF0ID0gZnVuY3Rpb24gKHAwLCBwMSwgcDIsIHQpIHtcbiAgcmV0dXJuICgxIC0gdCkgKiAoMSAtIHQpICogcDAgKyAyICogKDEgLSB0KSAqIHQgKiBwMSArIHQgKiB0ICogcDI7XG59O1xuXG5tYXRoLnFiZXppZXJQdEF0ID0gZnVuY3Rpb24gKHAwLCBwMSwgcDIsIHQpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBtYXRoLnFiZXppZXJBdChwMC54LCBwMS54LCBwMi54LCB0KSxcbiAgICB5OiBtYXRoLnFiZXppZXJBdChwMC55LCBwMS55LCBwMi55LCB0KVxuICB9O1xufTtcblxubWF0aC5saW5lQXQgPSBmdW5jdGlvbiAocDAsIHAxLCB0LCBkKSB7XG4gIHZhciB2ZWMgPSB7XG4gICAgeDogcDEueCAtIHAwLngsXG4gICAgeTogcDEueSAtIHAwLnlcbiAgfTtcblxuICB2YXIgdmVjRGlzdCA9IG1hdGguZGlzdChwMCwgcDEpO1xuXG4gIHZhciBub3JtVmVjID0ge1xuICAgIHg6IHZlYy54IC8gdmVjRGlzdCxcbiAgICB5OiB2ZWMueSAvIHZlY0Rpc3RcbiAgfTtcblxuICB0ID0gdCA9PSBudWxsID8gMCA6IHQ7XG5cbiAgZCA9IGQgIT0gbnVsbCA/IGQgOiB0ICogdmVjRGlzdDtcblxuICByZXR1cm4ge1xuICAgIHg6IHAwLnggKyBub3JtVmVjLnggKiBkLFxuICAgIHk6IHAwLnkgKyBub3JtVmVjLnkgKiBkXG4gIH07XG59O1xuXG5tYXRoLmxpbmVBdERpc3QgPSBmdW5jdGlvbiAocDAsIHAxLCBkKSB7XG4gIHJldHVybiBtYXRoLmxpbmVBdChwMCwgcDEsIHVuZGVmaW5lZCwgZCk7XG59O1xuXG4vLyBnZXQgYW5nbGUgYXQgQSB2aWEgY29zaW5lIGxhd1xubWF0aC50cmlhbmdsZUFuZ2xlID0gZnVuY3Rpb24gKEEsIEIsIEMpIHtcbiAgdmFyIGEgPSBtYXRoLmRpc3QoQiwgQyk7XG4gIHZhciBiID0gbWF0aC5kaXN0KEEsIEMpO1xuICB2YXIgYyA9IG1hdGguZGlzdChBLCBCKTtcblxuICByZXR1cm4gTWF0aC5hY29zKChhICogYSArIGIgKiBiIC0gYyAqIGMpIC8gKDIgKiBhICogYikpO1xufTtcblxubWF0aC5ib3VuZCA9IGZ1bmN0aW9uIChtaW4sIHZhbCwgbWF4KSB7XG4gIHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgdmFsKSk7XG59O1xuXG4vLyBtYWtlcyBhIGZ1bGwgYmIgKHgxLCB5MSwgeDIsIHkyLCB3LCBoKSBmcm9tIGltcGxpY2l0IHBhcmFtc1xubWF0aC5tYWtlQm91bmRpbmdCb3ggPSBmdW5jdGlvbiAoYmIpIHtcbiAgaWYgKGJiID09IG51bGwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDE6IEluZmluaXR5LFxuICAgICAgeTE6IEluZmluaXR5LFxuICAgICAgeDI6IC1JbmZpbml0eSxcbiAgICAgIHkyOiAtSW5maW5pdHksXG4gICAgICB3OiAwLFxuICAgICAgaDogMFxuICAgIH07XG4gIH0gZWxzZSBpZiAoYmIueDEgIT0gbnVsbCAmJiBiYi55MSAhPSBudWxsKSB7XG4gICAgaWYgKGJiLngyICE9IG51bGwgJiYgYmIueTIgIT0gbnVsbCAmJiBiYi54MiA+PSBiYi54MSAmJiBiYi55MiA+PSBiYi55MSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDE6IGJiLngxLFxuICAgICAgICB5MTogYmIueTEsXG4gICAgICAgIHgyOiBiYi54MixcbiAgICAgICAgeTI6IGJiLnkyLFxuICAgICAgICB3OiBiYi54MiAtIGJiLngxLFxuICAgICAgICBoOiBiYi55MiAtIGJiLnkxXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoYmIudyAhPSBudWxsICYmIGJiLmggIT0gbnVsbCAmJiBiYi53ID49IDAgJiYgYmIuaCA+PSAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4MTogYmIueDEsXG4gICAgICAgIHkxOiBiYi55MSxcbiAgICAgICAgeDI6IGJiLngxICsgYmIudyxcbiAgICAgICAgeTI6IGJiLnkxICsgYmIuaCxcbiAgICAgICAgdzogYmIudyxcbiAgICAgICAgaDogYmIuaFxuICAgICAgfTtcbiAgICB9XG4gIH1cbn07XG5cbm1hdGgudXBkYXRlQm91bmRpbmdCb3ggPSBmdW5jdGlvbiAoYmIxLCBiYjIpIHtcbiAgLy8gdXBkYXRlIGJiMSB3aXRoIGJiMiBib3VuZHNcblxuICBiYjEueDEgPSBNYXRoLm1pbihiYjEueDEsIGJiMi54MSk7XG4gIGJiMS54MiA9IE1hdGgubWF4KGJiMS54MiwgYmIyLngyKTtcbiAgYmIxLncgPSBiYjEueDIgLSBiYjEueDE7XG5cbiAgYmIxLnkxID0gTWF0aC5taW4oYmIxLnkxLCBiYjIueTEpO1xuICBiYjEueTIgPSBNYXRoLm1heChiYjEueTIsIGJiMi55Mik7XG4gIGJiMS5oID0gYmIxLnkyIC0gYmIxLnkxO1xufTtcblxubWF0aC5leHBhbmRCb3VuZGluZ0JveEJ5UG9pbnQgPSBmdW5jdGlvbiAoYmIsIHgsIHkpIHtcbiAgYmIueDEgPSBNYXRoLm1pbihiYi54MSwgeCk7XG4gIGJiLngyID0gTWF0aC5tYXgoYmIueDIsIHgpO1xuICBiYi53ID0gYmIueDIgLSBiYi54MTtcblxuICBiYi55MSA9IE1hdGgubWluKGJiLnkxLCB5KTtcbiAgYmIueTIgPSBNYXRoLm1heChiYi55MiwgeSk7XG4gIGJiLmggPSBiYi55MiAtIGJiLnkxO1xufTtcblxubWF0aC5leHBhbmRCb3VuZGluZ0JveCA9IGZ1bmN0aW9uIChiYiwgcGFkZGluZykge1xuICBiYi54MSAtPSBwYWRkaW5nO1xuICBiYi54MiArPSBwYWRkaW5nO1xuICBiYi55MSAtPSBwYWRkaW5nO1xuICBiYi55MiArPSBwYWRkaW5nO1xuICBiYi53ID0gYmIueDIgLSBiYi54MTtcbiAgYmIuaCA9IGJiLnkyIC0gYmIueTE7XG5cbiAgcmV0dXJuIGJiO1xufTtcblxubWF0aC5ib3VuZGluZ0JveGVzSW50ZXJzZWN0ID0gZnVuY3Rpb24gKGJiMSwgYmIyKSB7XG4gIC8vIGNhc2U6IG9uZSBiYiB0byByaWdodCBvZiBvdGhlclxuICBpZiAoYmIxLngxID4gYmIyLngyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChiYjIueDEgPiBiYjEueDIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBjYXNlOiBvbmUgYmIgdG8gbGVmdCBvZiBvdGhlclxuICBpZiAoYmIxLngyIDwgYmIyLngxKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChiYjIueDIgPCBiYjEueDEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBjYXNlOiBvbmUgYmIgYWJvdmUgb3RoZXJcbiAgaWYgKGJiMS55MiA8IGJiMi55MSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoYmIyLnkyIDwgYmIxLnkxKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gY2FzZTogb25lIGJiIGJlbG93IG90aGVyXG4gIGlmIChiYjEueTEgPiBiYjIueTIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGJiMi55MSA+IGJiMS55Mikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIG90aGVyd2lzZSwgbXVzdCBoYXZlIHNvbWUgb3ZlcmxhcFxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbm1hdGguaW5Cb3VuZGluZ0JveCA9IGZ1bmN0aW9uIChiYiwgeCwgeSkge1xuICByZXR1cm4gYmIueDEgPD0geCAmJiB4IDw9IGJiLngyICYmIGJiLnkxIDw9IHkgJiYgeSA8PSBiYi55Mjtcbn07XG5cbm1hdGgucG9pbnRJbkJvdW5kaW5nQm94ID0gZnVuY3Rpb24gKGJiLCBwdCkge1xuICByZXR1cm4gdGhpcy5pbkJvdW5kaW5nQm94KGJiLCBwdC54LCBwdC55KTtcbn07XG5cbm1hdGguYm91bmRpbmdCb3hJbkJvdW5kaW5nQm94ID0gZnVuY3Rpb24gKGJiMSwgYmIyKSB7XG4gIHJldHVybiBtYXRoLmluQm91bmRpbmdCb3goYmIxLCBiYjIueDEsIGJiMi55MSkgJiYgbWF0aC5pbkJvdW5kaW5nQm94KGJiMSwgYmIyLngyLCBiYjIueTIpO1xufTtcblxubWF0aC5yb3VuZFJlY3RhbmdsZUludGVyc2VjdExpbmUgPSBmdW5jdGlvbiAoeCwgeSwgbm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCBwYWRkaW5nKSB7XG5cbiAgdmFyIGNvcm5lclJhZGl1cyA9IHRoaXMuZ2V0Um91bmRSZWN0YW5nbGVSYWRpdXMod2lkdGgsIGhlaWdodCk7XG5cbiAgdmFyIGhhbGZXaWR0aCA9IHdpZHRoIC8gMjtcbiAgdmFyIGhhbGZIZWlnaHQgPSBoZWlnaHQgLyAyO1xuXG4gIC8vIENoZWNrIGludGVyc2VjdGlvbnMgd2l0aCBzdHJhaWdodCBsaW5lIHNlZ21lbnRzXG4gIHZhciBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zID0gdm9pZCAwO1xuXG4gIC8vIFRvcCBzZWdtZW50LCBsZWZ0IHRvIHJpZ2h0XG4gIHtcbiAgICB2YXIgdG9wU3RhcnRYID0gbm9kZVggLSBoYWxmV2lkdGggKyBjb3JuZXJSYWRpdXMgLSBwYWRkaW5nO1xuICAgIHZhciB0b3BTdGFydFkgPSBub2RlWSAtIGhhbGZIZWlnaHQgLSBwYWRkaW5nO1xuICAgIHZhciB0b3BFbmRYID0gbm9kZVggKyBoYWxmV2lkdGggLSBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nO1xuICAgIHZhciB0b3BFbmRZID0gdG9wU3RhcnRZO1xuXG4gICAgc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucyA9IHRoaXMuZmluaXRlTGluZXNJbnRlcnNlY3QoeCwgeSwgbm9kZVgsIG5vZGVZLCB0b3BTdGFydFgsIHRvcFN0YXJ0WSwgdG9wRW5kWCwgdG9wRW5kWSwgZmFsc2UpO1xuXG4gICAgaWYgKHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnM7XG4gICAgfVxuICB9XG5cbiAgLy8gUmlnaHQgc2VnbWVudCwgdG9wIHRvIGJvdHRvbVxuICB7XG4gICAgdmFyIHJpZ2h0U3RhcnRYID0gbm9kZVggKyBoYWxmV2lkdGggKyBwYWRkaW5nO1xuICAgIHZhciByaWdodFN0YXJ0WSA9IG5vZGVZIC0gaGFsZkhlaWdodCArIGNvcm5lclJhZGl1cyAtIHBhZGRpbmc7XG4gICAgdmFyIHJpZ2h0RW5kWCA9IHJpZ2h0U3RhcnRYO1xuICAgIHZhciByaWdodEVuZFkgPSBub2RlWSArIGhhbGZIZWlnaHQgLSBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nO1xuXG4gICAgc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucyA9IHRoaXMuZmluaXRlTGluZXNJbnRlcnNlY3QoeCwgeSwgbm9kZVgsIG5vZGVZLCByaWdodFN0YXJ0WCwgcmlnaHRTdGFydFksIHJpZ2h0RW5kWCwgcmlnaHRFbmRZLCBmYWxzZSk7XG5cbiAgICBpZiAoc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucztcbiAgICB9XG4gIH1cblxuICAvLyBCb3R0b20gc2VnbWVudCwgbGVmdCB0byByaWdodFxuICB7XG4gICAgdmFyIGJvdHRvbVN0YXJ0WCA9IG5vZGVYIC0gaGFsZldpZHRoICsgY29ybmVyUmFkaXVzIC0gcGFkZGluZztcbiAgICB2YXIgYm90dG9tU3RhcnRZID0gbm9kZVkgKyBoYWxmSGVpZ2h0ICsgcGFkZGluZztcbiAgICB2YXIgYm90dG9tRW5kWCA9IG5vZGVYICsgaGFsZldpZHRoIC0gY29ybmVyUmFkaXVzICsgcGFkZGluZztcbiAgICB2YXIgYm90dG9tRW5kWSA9IGJvdHRvbVN0YXJ0WTtcblxuICAgIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMgPSB0aGlzLmZpbml0ZUxpbmVzSW50ZXJzZWN0KHgsIHksIG5vZGVYLCBub2RlWSwgYm90dG9tU3RhcnRYLCBib3R0b21TdGFydFksIGJvdHRvbUVuZFgsIGJvdHRvbUVuZFksIGZhbHNlKTtcblxuICAgIGlmIChzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zO1xuICAgIH1cbiAgfVxuXG4gIC8vIExlZnQgc2VnbWVudCwgdG9wIHRvIGJvdHRvbVxuICB7XG4gICAgdmFyIGxlZnRTdGFydFggPSBub2RlWCAtIGhhbGZXaWR0aCAtIHBhZGRpbmc7XG4gICAgdmFyIGxlZnRTdGFydFkgPSBub2RlWSAtIGhhbGZIZWlnaHQgKyBjb3JuZXJSYWRpdXMgLSBwYWRkaW5nO1xuICAgIHZhciBsZWZ0RW5kWCA9IGxlZnRTdGFydFg7XG4gICAgdmFyIGxlZnRFbmRZID0gbm9kZVkgKyBoYWxmSGVpZ2h0IC0gY29ybmVyUmFkaXVzICsgcGFkZGluZztcblxuICAgIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMgPSB0aGlzLmZpbml0ZUxpbmVzSW50ZXJzZWN0KHgsIHksIG5vZGVYLCBub2RlWSwgbGVmdFN0YXJ0WCwgbGVmdFN0YXJ0WSwgbGVmdEVuZFgsIGxlZnRFbmRZLCBmYWxzZSk7XG5cbiAgICBpZiAoc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucztcbiAgICB9XG4gIH1cblxuICAvLyBDaGVjayBpbnRlcnNlY3Rpb25zIHdpdGggYXJjIHNlZ21lbnRzXG4gIHZhciBhcmNJbnRlcnNlY3Rpb25zID0gdm9pZCAwO1xuXG4gIC8vIFRvcCBMZWZ0XG4gIHtcbiAgICB2YXIgdG9wTGVmdENlbnRlclggPSBub2RlWCAtIGhhbGZXaWR0aCArIGNvcm5lclJhZGl1cztcbiAgICB2YXIgdG9wTGVmdENlbnRlclkgPSBub2RlWSAtIGhhbGZIZWlnaHQgKyBjb3JuZXJSYWRpdXM7XG4gICAgYXJjSW50ZXJzZWN0aW9ucyA9IHRoaXMuaW50ZXJzZWN0TGluZUNpcmNsZSh4LCB5LCBub2RlWCwgbm9kZVksIHRvcExlZnRDZW50ZXJYLCB0b3BMZWZ0Q2VudGVyWSwgY29ybmVyUmFkaXVzICsgcGFkZGluZyk7XG5cbiAgICAvLyBFbnN1cmUgdGhlIGludGVyc2VjdGlvbiBpcyBvbiB0aGUgZGVzaXJlZCBxdWFydGVyIG9mIHRoZSBjaXJjbGVcbiAgICBpZiAoYXJjSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwICYmIGFyY0ludGVyc2VjdGlvbnNbMF0gPD0gdG9wTGVmdENlbnRlclggJiYgYXJjSW50ZXJzZWN0aW9uc1sxXSA8PSB0b3BMZWZ0Q2VudGVyWSkge1xuICAgICAgcmV0dXJuIFthcmNJbnRlcnNlY3Rpb25zWzBdLCBhcmNJbnRlcnNlY3Rpb25zWzFdXTtcbiAgICB9XG4gIH1cblxuICAvLyBUb3AgUmlnaHRcbiAge1xuICAgIHZhciB0b3BSaWdodENlbnRlclggPSBub2RlWCArIGhhbGZXaWR0aCAtIGNvcm5lclJhZGl1cztcbiAgICB2YXIgdG9wUmlnaHRDZW50ZXJZID0gbm9kZVkgLSBoYWxmSGVpZ2h0ICsgY29ybmVyUmFkaXVzO1xuICAgIGFyY0ludGVyc2VjdGlvbnMgPSB0aGlzLmludGVyc2VjdExpbmVDaXJjbGUoeCwgeSwgbm9kZVgsIG5vZGVZLCB0b3BSaWdodENlbnRlclgsIHRvcFJpZ2h0Q2VudGVyWSwgY29ybmVyUmFkaXVzICsgcGFkZGluZyk7XG5cbiAgICAvLyBFbnN1cmUgdGhlIGludGVyc2VjdGlvbiBpcyBvbiB0aGUgZGVzaXJlZCBxdWFydGVyIG9mIHRoZSBjaXJjbGVcbiAgICBpZiAoYXJjSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwICYmIGFyY0ludGVyc2VjdGlvbnNbMF0gPj0gdG9wUmlnaHRDZW50ZXJYICYmIGFyY0ludGVyc2VjdGlvbnNbMV0gPD0gdG9wUmlnaHRDZW50ZXJZKSB7XG4gICAgICByZXR1cm4gW2FyY0ludGVyc2VjdGlvbnNbMF0sIGFyY0ludGVyc2VjdGlvbnNbMV1dO1xuICAgIH1cbiAgfVxuXG4gIC8vIEJvdHRvbSBSaWdodFxuICB7XG4gICAgdmFyIGJvdHRvbVJpZ2h0Q2VudGVyWCA9IG5vZGVYICsgaGFsZldpZHRoIC0gY29ybmVyUmFkaXVzO1xuICAgIHZhciBib3R0b21SaWdodENlbnRlclkgPSBub2RlWSArIGhhbGZIZWlnaHQgLSBjb3JuZXJSYWRpdXM7XG4gICAgYXJjSW50ZXJzZWN0aW9ucyA9IHRoaXMuaW50ZXJzZWN0TGluZUNpcmNsZSh4LCB5LCBub2RlWCwgbm9kZVksIGJvdHRvbVJpZ2h0Q2VudGVyWCwgYm90dG9tUmlnaHRDZW50ZXJZLCBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nKTtcblxuICAgIC8vIEVuc3VyZSB0aGUgaW50ZXJzZWN0aW9uIGlzIG9uIHRoZSBkZXNpcmVkIHF1YXJ0ZXIgb2YgdGhlIGNpcmNsZVxuICAgIGlmIChhcmNJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDAgJiYgYXJjSW50ZXJzZWN0aW9uc1swXSA+PSBib3R0b21SaWdodENlbnRlclggJiYgYXJjSW50ZXJzZWN0aW9uc1sxXSA+PSBib3R0b21SaWdodENlbnRlclkpIHtcbiAgICAgIHJldHVybiBbYXJjSW50ZXJzZWN0aW9uc1swXSwgYXJjSW50ZXJzZWN0aW9uc1sxXV07XG4gICAgfVxuICB9XG5cbiAgLy8gQm90dG9tIExlZnRcbiAge1xuICAgIHZhciBib3R0b21MZWZ0Q2VudGVyWCA9IG5vZGVYIC0gaGFsZldpZHRoICsgY29ybmVyUmFkaXVzO1xuICAgIHZhciBib3R0b21MZWZ0Q2VudGVyWSA9IG5vZGVZICsgaGFsZkhlaWdodCAtIGNvcm5lclJhZGl1cztcbiAgICBhcmNJbnRlcnNlY3Rpb25zID0gdGhpcy5pbnRlcnNlY3RMaW5lQ2lyY2xlKHgsIHksIG5vZGVYLCBub2RlWSwgYm90dG9tTGVmdENlbnRlclgsIGJvdHRvbUxlZnRDZW50ZXJZLCBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nKTtcblxuICAgIC8vIEVuc3VyZSB0aGUgaW50ZXJzZWN0aW9uIGlzIG9uIHRoZSBkZXNpcmVkIHF1YXJ0ZXIgb2YgdGhlIGNpcmNsZVxuICAgIGlmIChhcmNJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDAgJiYgYXJjSW50ZXJzZWN0aW9uc1swXSA8PSBib3R0b21MZWZ0Q2VudGVyWCAmJiBhcmNJbnRlcnNlY3Rpb25zWzFdID49IGJvdHRvbUxlZnRDZW50ZXJZKSB7XG4gICAgICByZXR1cm4gW2FyY0ludGVyc2VjdGlvbnNbMF0sIGFyY0ludGVyc2VjdGlvbnNbMV1dO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBbXTsgLy8gaWYgbm90aGluZ1xufTtcblxubWF0aC5pbkxpbmVWaWNpbml0eSA9IGZ1bmN0aW9uICh4LCB5LCBseDEsIGx5MSwgbHgyLCBseTIsIHRvbGVyYW5jZSkge1xuICB2YXIgdCA9IHRvbGVyYW5jZTtcblxuICB2YXIgeDEgPSBNYXRoLm1pbihseDEsIGx4Mik7XG4gIHZhciB4MiA9IE1hdGgubWF4KGx4MSwgbHgyKTtcbiAgdmFyIHkxID0gTWF0aC5taW4obHkxLCBseTIpO1xuICB2YXIgeTIgPSBNYXRoLm1heChseTEsIGx5Mik7XG5cbiAgcmV0dXJuIHgxIC0gdCA8PSB4ICYmIHggPD0geDIgKyB0ICYmIHkxIC0gdCA8PSB5ICYmIHkgPD0geTIgKyB0O1xufTtcblxubWF0aC5pbkJlemllclZpY2luaXR5ID0gZnVuY3Rpb24gKHgsIHksIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHRvbGVyYW5jZSkge1xuXG4gIHZhciBiYiA9IHtcbiAgICB4MTogTWF0aC5taW4oeDEsIHgzLCB4MikgLSB0b2xlcmFuY2UsXG4gICAgeDI6IE1hdGgubWF4KHgxLCB4MywgeDIpICsgdG9sZXJhbmNlLFxuICAgIHkxOiBNYXRoLm1pbih5MSwgeTMsIHkyKSAtIHRvbGVyYW5jZSxcbiAgICB5MjogTWF0aC5tYXgoeTEsIHkzLCB5MikgKyB0b2xlcmFuY2VcbiAgfTtcblxuICAvLyBpZiBvdXRzaWRlIHRoZSByb3VnaCBib3VuZGluZyBib3ggZm9yIHRoZSBiZXppZXIsIHRoZW4gaXQgY2FuJ3QgYmUgYSBoaXRcbiAgaWYgKHggPCBiYi54MSB8fCB4ID4gYmIueDIgfHwgeSA8IGJiLnkxIHx8IHkgPiBiYi55Mikge1xuICAgIC8vIGNvbnNvbGUubG9nKCdiZXppZXIgb3V0IG9mIHJvdWdoIGJiJylcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgLy8gY29uc29sZS5sb2coJ2RvIG1vcmUgZXhwZW5zaXZlIGNoZWNrJyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5tYXRoLnNvbHZlUXVhZHJhdGljID0gZnVuY3Rpb24gKGEsIGIsIGMsIHZhbCkge1xuICBjIC09IHZhbDtcblxuICB2YXIgciA9IGIgKiBiIC0gNCAqIGEgKiBjO1xuXG4gIGlmIChyIDwgMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhciBzcXJ0UiA9IE1hdGguc3FydChyKTtcbiAgdmFyIGRlbm9tID0gMiAqIGE7XG4gIHZhciByb290MSA9ICgtYiArIHNxcnRSKSAvIGRlbm9tO1xuICB2YXIgcm9vdDIgPSAoLWIgLSBzcXJ0UikgLyBkZW5vbTtcblxuICByZXR1cm4gW3Jvb3QxLCByb290Ml07XG59O1xuXG5tYXRoLnNvbHZlQ3ViaWMgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCwgcmVzdWx0KSB7XG5cbiAgLy8gU29sdmVzIGEgY3ViaWMgZnVuY3Rpb24sIHJldHVybnMgcm9vdCBpbiBmb3JtIFtyMSwgaTEsIHIyLCBpMiwgcjMsIGkzXSwgd2hlcmVcbiAgLy8gciBpcyB0aGUgcmVhbCBjb21wb25lbnQsIGkgaXMgdGhlIGltYWdpbmFyeSBjb21wb25lbnRcblxuICAvLyBBbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgQ2FyZGFubyBtZXRob2QgZnJvbSB0aGUgeWVhciAxNTQ1XG4gIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ3ViaWNfZnVuY3Rpb24jVGhlX25hdHVyZV9vZl90aGVfcm9vdHNcblxuICBiIC89IGE7XG4gIGMgLz0gYTtcbiAgZCAvPSBhO1xuXG4gIHZhciBkaXNjcmltaW5hbnQgPSB2b2lkIDAsXG4gICAgICBxID0gdm9pZCAwLFxuICAgICAgciA9IHZvaWQgMCxcbiAgICAgIGR1bTEgPSB2b2lkIDAsXG4gICAgICBzID0gdm9pZCAwLFxuICAgICAgdCA9IHZvaWQgMCxcbiAgICAgIHRlcm0xID0gdm9pZCAwLFxuICAgICAgcjEzID0gdm9pZCAwO1xuXG4gIHEgPSAoMy4wICogYyAtIGIgKiBiKSAvIDkuMDtcbiAgciA9IC0oMjcuMCAqIGQpICsgYiAqICg5LjAgKiBjIC0gMi4wICogKGIgKiBiKSk7XG4gIHIgLz0gNTQuMDtcblxuICBkaXNjcmltaW5hbnQgPSBxICogcSAqIHEgKyByICogcjtcbiAgcmVzdWx0WzFdID0gMDtcbiAgdGVybTEgPSBiIC8gMy4wO1xuXG4gIGlmIChkaXNjcmltaW5hbnQgPiAwKSB7XG4gICAgcyA9IHIgKyBNYXRoLnNxcnQoZGlzY3JpbWluYW50KTtcbiAgICBzID0gcyA8IDAgPyAtTWF0aC5wb3coLXMsIDEuMCAvIDMuMCkgOiBNYXRoLnBvdyhzLCAxLjAgLyAzLjApO1xuICAgIHQgPSByIC0gTWF0aC5zcXJ0KGRpc2NyaW1pbmFudCk7XG4gICAgdCA9IHQgPCAwID8gLU1hdGgucG93KC10LCAxLjAgLyAzLjApIDogTWF0aC5wb3codCwgMS4wIC8gMy4wKTtcbiAgICByZXN1bHRbMF0gPSAtdGVybTEgKyBzICsgdDtcbiAgICB0ZXJtMSArPSAocyArIHQpIC8gMi4wO1xuICAgIHJlc3VsdFs0XSA9IHJlc3VsdFsyXSA9IC10ZXJtMTtcbiAgICB0ZXJtMSA9IE1hdGguc3FydCgzLjApICogKC10ICsgcykgLyAyO1xuICAgIHJlc3VsdFszXSA9IHRlcm0xO1xuICAgIHJlc3VsdFs1XSA9IC10ZXJtMTtcbiAgICByZXR1cm47XG4gIH1cblxuICByZXN1bHRbNV0gPSByZXN1bHRbM10gPSAwO1xuXG4gIGlmIChkaXNjcmltaW5hbnQgPT09IDApIHtcbiAgICByMTMgPSByIDwgMCA/IC1NYXRoLnBvdygtciwgMS4wIC8gMy4wKSA6IE1hdGgucG93KHIsIDEuMCAvIDMuMCk7XG4gICAgcmVzdWx0WzBdID0gLXRlcm0xICsgMi4wICogcjEzO1xuICAgIHJlc3VsdFs0XSA9IHJlc3VsdFsyXSA9IC0ocjEzICsgdGVybTEpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHEgPSAtcTtcbiAgZHVtMSA9IHEgKiBxICogcTtcbiAgZHVtMSA9IE1hdGguYWNvcyhyIC8gTWF0aC5zcXJ0KGR1bTEpKTtcbiAgcjEzID0gMi4wICogTWF0aC5zcXJ0KHEpO1xuICByZXN1bHRbMF0gPSAtdGVybTEgKyByMTMgKiBNYXRoLmNvcyhkdW0xIC8gMy4wKTtcbiAgcmVzdWx0WzJdID0gLXRlcm0xICsgcjEzICogTWF0aC5jb3MoKGR1bTEgKyAyLjAgKiBNYXRoLlBJKSAvIDMuMCk7XG4gIHJlc3VsdFs0XSA9IC10ZXJtMSArIHIxMyAqIE1hdGguY29zKChkdW0xICsgNC4wICogTWF0aC5QSSkgLyAzLjApO1xuXG4gIHJldHVybjtcbn07XG5cbm1hdGguc3FkaXN0VG9RdWFkcmF0aWNCZXppZXIgPSBmdW5jdGlvbiAoeCwgeSwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuXG4gIC8vIEZpbmQgbWluaW11bSBkaXN0YW5jZSBieSB1c2luZyB0aGUgbWluaW11bSBvZiB0aGUgZGlzdGFuY2VcbiAgLy8gZnVuY3Rpb24gYmV0d2VlbiB0aGUgZ2l2ZW4gcG9pbnQgYW5kIHRoZSBjdXJ2ZVxuXG4gIC8vIFRoaXMgZ2l2ZXMgdGhlIGNvZWZmaWNpZW50cyBvZiB0aGUgcmVzdWx0aW5nIGN1YmljIGVxdWF0aW9uXG4gIC8vIHdob3NlIHJvb3RzIHRlbGwgdXMgd2hlcmUgYSBwb3NzaWJsZSBtaW5pbXVtIGlzXG4gIC8vIChDb2VmZmljaWVudHMgYXJlIGRpdmlkZWQgYnkgNClcblxuICB2YXIgYSA9IDEuMCAqIHgxICogeDEgLSA0ICogeDEgKiB4MiArIDIgKiB4MSAqIHgzICsgNCAqIHgyICogeDIgLSA0ICogeDIgKiB4MyArIHgzICogeDMgKyB5MSAqIHkxIC0gNCAqIHkxICogeTIgKyAyICogeTEgKiB5MyArIDQgKiB5MiAqIHkyIC0gNCAqIHkyICogeTMgKyB5MyAqIHkzO1xuXG4gIHZhciBiID0gMS4wICogOSAqIHgxICogeDIgLSAzICogeDEgKiB4MSAtIDMgKiB4MSAqIHgzIC0gNiAqIHgyICogeDIgKyAzICogeDIgKiB4MyArIDkgKiB5MSAqIHkyIC0gMyAqIHkxICogeTEgLSAzICogeTEgKiB5MyAtIDYgKiB5MiAqIHkyICsgMyAqIHkyICogeTM7XG5cbiAgdmFyIGMgPSAxLjAgKiAzICogeDEgKiB4MSAtIDYgKiB4MSAqIHgyICsgeDEgKiB4MyAtIHgxICogeCArIDIgKiB4MiAqIHgyICsgMiAqIHgyICogeCAtIHgzICogeCArIDMgKiB5MSAqIHkxIC0gNiAqIHkxICogeTIgKyB5MSAqIHkzIC0geTEgKiB5ICsgMiAqIHkyICogeTIgKyAyICogeTIgKiB5IC0geTMgKiB5O1xuXG4gIHZhciBkID0gMS4wICogeDEgKiB4MiAtIHgxICogeDEgKyB4MSAqIHggLSB4MiAqIHggKyB5MSAqIHkyIC0geTEgKiB5MSArIHkxICogeSAtIHkyICogeTtcblxuICAvLyBkZWJ1ZyhcImNvZWZmaWNpZW50czogXCIgKyBhIC8gYSArIFwiLCBcIiArIGIgLyBhICsgXCIsIFwiICsgYyAvIGEgKyBcIiwgXCIgKyBkIC8gYSk7XG5cbiAgdmFyIHJvb3RzID0gW107XG5cbiAgLy8gVXNlIHRoZSBjdWJpYyBzb2x2aW5nIGFsZ29yaXRobVxuICB0aGlzLnNvbHZlQ3ViaWMoYSwgYiwgYywgZCwgcm9vdHMpO1xuXG4gIHZhciB6ZXJvVGhyZXNob2xkID0gMC4wMDAwMDAxO1xuXG4gIHZhciBwYXJhbXMgPSBbXTtcblxuICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgNjsgaW5kZXggKz0gMikge1xuICAgIGlmIChNYXRoLmFicyhyb290c1tpbmRleCArIDFdKSA8IHplcm9UaHJlc2hvbGQgJiYgcm9vdHNbaW5kZXhdID49IDAgJiYgcm9vdHNbaW5kZXhdIDw9IDEuMCkge1xuICAgICAgcGFyYW1zLnB1c2gocm9vdHNbaW5kZXhdKTtcbiAgICB9XG4gIH1cblxuICBwYXJhbXMucHVzaCgxLjApO1xuICBwYXJhbXMucHVzaCgwLjApO1xuXG4gIHZhciBtaW5EaXN0YW5jZVNxdWFyZWQgPSAtMTtcblxuICB2YXIgY3VyWCA9IHZvaWQgMCxcbiAgICAgIGN1clkgPSB2b2lkIDAsXG4gICAgICBkaXN0U3F1YXJlZCA9IHZvaWQgMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyBpKyspIHtcbiAgICBjdXJYID0gTWF0aC5wb3coMS4wIC0gcGFyYW1zW2ldLCAyLjApICogeDEgKyAyLjAgKiAoMSAtIHBhcmFtc1tpXSkgKiBwYXJhbXNbaV0gKiB4MiArIHBhcmFtc1tpXSAqIHBhcmFtc1tpXSAqIHgzO1xuXG4gICAgY3VyWSA9IE1hdGgucG93KDEgLSBwYXJhbXNbaV0sIDIuMCkgKiB5MSArIDIgKiAoMS4wIC0gcGFyYW1zW2ldKSAqIHBhcmFtc1tpXSAqIHkyICsgcGFyYW1zW2ldICogcGFyYW1zW2ldICogeTM7XG5cbiAgICBkaXN0U3F1YXJlZCA9IE1hdGgucG93KGN1clggLSB4LCAyKSArIE1hdGgucG93KGN1clkgLSB5LCAyKTtcbiAgICAvLyBkZWJ1ZygnZGlzdGFuY2UgZm9yIHBhcmFtICcgKyBwYXJhbXNbaV0gKyBcIjogXCIgKyBNYXRoLnNxcnQoZGlzdFNxdWFyZWQpKTtcbiAgICBpZiAobWluRGlzdGFuY2VTcXVhcmVkID49IDApIHtcbiAgICAgIGlmIChkaXN0U3F1YXJlZCA8IG1pbkRpc3RhbmNlU3F1YXJlZCkge1xuICAgICAgICBtaW5EaXN0YW5jZVNxdWFyZWQgPSBkaXN0U3F1YXJlZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWluRGlzdGFuY2VTcXVhcmVkID0gZGlzdFNxdWFyZWQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1pbkRpc3RhbmNlU3F1YXJlZDtcbn07XG5cbm1hdGguc3FkaXN0VG9GaW5pdGVMaW5lID0gZnVuY3Rpb24gKHgsIHksIHgxLCB5MSwgeDIsIHkyKSB7XG4gIHZhciBvZmZzZXQgPSBbeCAtIHgxLCB5IC0geTFdO1xuICB2YXIgbGluZSA9IFt4MiAtIHgxLCB5MiAtIHkxXTtcblxuICB2YXIgbGluZVNxID0gbGluZVswXSAqIGxpbmVbMF0gKyBsaW5lWzFdICogbGluZVsxXTtcbiAgdmFyIGh5cFNxID0gb2Zmc2V0WzBdICogb2Zmc2V0WzBdICsgb2Zmc2V0WzFdICogb2Zmc2V0WzFdO1xuXG4gIHZhciBkb3RQcm9kdWN0ID0gb2Zmc2V0WzBdICogbGluZVswXSArIG9mZnNldFsxXSAqIGxpbmVbMV07XG4gIHZhciBhZGpTcSA9IGRvdFByb2R1Y3QgKiBkb3RQcm9kdWN0IC8gbGluZVNxO1xuXG4gIGlmIChkb3RQcm9kdWN0IDwgMCkge1xuICAgIHJldHVybiBoeXBTcTtcbiAgfVxuXG4gIGlmIChhZGpTcSA+IGxpbmVTcSkge1xuICAgIHJldHVybiAoeCAtIHgyKSAqICh4IC0geDIpICsgKHkgLSB5MikgKiAoeSAtIHkyKTtcbiAgfVxuXG4gIHJldHVybiBoeXBTcSAtIGFkalNxO1xufTtcblxubWF0aC5wb2ludEluc2lkZVBvbHlnb25Qb2ludHMgPSBmdW5jdGlvbiAoeCwgeSwgcG9pbnRzKSB7XG4gIHZhciB4MSA9IHZvaWQgMCxcbiAgICAgIHkxID0gdm9pZCAwLFxuICAgICAgeDIgPSB2b2lkIDAsXG4gICAgICB5MiA9IHZvaWQgMDtcbiAgdmFyIHkzID0gdm9pZCAwO1xuXG4gIC8vIEludGVyc2VjdCB3aXRoIHZlcnRpY2FsIGxpbmUgdGhyb3VnaCAoeCwgeSlcbiAgdmFyIHVwID0gMDtcbiAgLy8gbGV0IGRvd24gPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICB4MSA9IHBvaW50c1tpICogMl07XG4gICAgeTEgPSBwb2ludHNbaSAqIDIgKyAxXTtcblxuICAgIGlmIChpICsgMSA8IHBvaW50cy5sZW5ndGggLyAyKSB7XG4gICAgICB4MiA9IHBvaW50c1soaSArIDEpICogMl07XG4gICAgICB5MiA9IHBvaW50c1soaSArIDEpICogMiArIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICB4MiA9IHBvaW50c1soaSArIDEgLSBwb2ludHMubGVuZ3RoIC8gMikgKiAyXTtcbiAgICAgIHkyID0gcG9pbnRzWyhpICsgMSAtIHBvaW50cy5sZW5ndGggLyAyKSAqIDIgKyAxXTtcbiAgICB9XG5cbiAgICBpZiAoeDEgPT0geCAmJiB4MiA9PSB4KSB7XG4gICAgICAvLyB0aGVuIGlnbm9yZVxuICAgIH0gZWxzZSBpZiAoeDEgPj0geCAmJiB4ID49IHgyIHx8IHgxIDw9IHggJiYgeCA8PSB4Mikge1xuXG4gICAgICB5MyA9ICh4IC0geDEpIC8gKHgyIC0geDEpICogKHkyIC0geTEpICsgeTE7XG5cbiAgICAgIGlmICh5MyA+IHkpIHtcbiAgICAgICAgdXArKztcbiAgICAgIH1cblxuICAgICAgLy8gaWYoIHkzIDwgeSApe1xuICAgICAgLy8gZG93bisrO1xuICAgICAgLy8gfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gIH1cblxuICBpZiAodXAgJSAyID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5tYXRoLnBvaW50SW5zaWRlUG9seWdvbiA9IGZ1bmN0aW9uICh4LCB5LCBiYXNlUG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBkaXJlY3Rpb24sIHBhZGRpbmcpIHtcblxuICAvL2xldCBkaXJlY3Rpb24gPSBhcmd1bWVudHNbNl07XG4gIHZhciB0cmFuc2Zvcm1lZFBvaW50cyA9IG5ldyBBcnJheShiYXNlUG9pbnRzLmxlbmd0aCk7XG5cbiAgLy8gR2l2ZXMgbmVnYXRpdmUgYW5nbGVcbiAgdmFyIGFuZ2xlID0gdm9pZCAwO1xuXG4gIGlmIChkaXJlY3Rpb25bMF0gIT0gbnVsbCkge1xuICAgIGFuZ2xlID0gTWF0aC5hdGFuKGRpcmVjdGlvblsxXSAvIGRpcmVjdGlvblswXSk7XG5cbiAgICBpZiAoZGlyZWN0aW9uWzBdIDwgMCkge1xuICAgICAgYW5nbGUgPSBhbmdsZSArIE1hdGguUEkgLyAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBhbmdsZSA9IC1hbmdsZSAtIE1hdGguUEkgLyAyO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBhbmdsZSA9IGRpcmVjdGlvbjtcbiAgfVxuXG4gIHZhciBjb3MgPSBNYXRoLmNvcygtYW5nbGUpO1xuICB2YXIgc2luID0gTWF0aC5zaW4oLWFuZ2xlKTtcblxuICAvLyAgICBjb25zb2xlLmxvZyhcImJhc2U6IFwiICsgYmFzZVBvaW50cyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhbnNmb3JtZWRQb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgdHJhbnNmb3JtZWRQb2ludHNbaSAqIDJdID0gd2lkdGggLyAyICogKGJhc2VQb2ludHNbaSAqIDJdICogY29zIC0gYmFzZVBvaW50c1tpICogMiArIDFdICogc2luKTtcblxuICAgIHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyICsgMV0gPSBoZWlnaHQgLyAyICogKGJhc2VQb2ludHNbaSAqIDIgKyAxXSAqIGNvcyArIGJhc2VQb2ludHNbaSAqIDJdICogc2luKTtcblxuICAgIHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyXSArPSBjZW50ZXJYO1xuICAgIHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyICsgMV0gKz0gY2VudGVyWTtcbiAgfVxuXG4gIHZhciBwb2ludHMgPSB2b2lkIDA7XG5cbiAgaWYgKHBhZGRpbmcgPiAwKSB7XG4gICAgdmFyIGV4cGFuZGVkTGluZVNldCA9IHRoaXMuZXhwYW5kUG9seWdvbih0cmFuc2Zvcm1lZFBvaW50cywgLXBhZGRpbmcpO1xuXG4gICAgcG9pbnRzID0gdGhpcy5qb2luTGluZXMoZXhwYW5kZWRMaW5lU2V0KTtcbiAgfSBlbHNlIHtcbiAgICBwb2ludHMgPSB0cmFuc2Zvcm1lZFBvaW50cztcbiAgfVxuXG4gIHJldHVybiBtYXRoLnBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCBwb2ludHMpO1xufTtcblxubWF0aC5qb2luTGluZXMgPSBmdW5jdGlvbiAobGluZVNldCkge1xuXG4gIHZhciB2ZXJ0aWNlcyA9IG5ldyBBcnJheShsaW5lU2V0Lmxlbmd0aCAvIDIpO1xuXG4gIHZhciBjdXJyZW50TGluZVN0YXJ0WCA9IHZvaWQgMCxcbiAgICAgIGN1cnJlbnRMaW5lU3RhcnRZID0gdm9pZCAwLFxuICAgICAgY3VycmVudExpbmVFbmRYID0gdm9pZCAwLFxuICAgICAgY3VycmVudExpbmVFbmRZID0gdm9pZCAwO1xuICB2YXIgbmV4dExpbmVTdGFydFggPSB2b2lkIDAsXG4gICAgICBuZXh0TGluZVN0YXJ0WSA9IHZvaWQgMCxcbiAgICAgIG5leHRMaW5lRW5kWCA9IHZvaWQgMCxcbiAgICAgIG5leHRMaW5lRW5kWSA9IHZvaWQgMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVTZXQubGVuZ3RoIC8gNDsgaSsrKSB7XG4gICAgY3VycmVudExpbmVTdGFydFggPSBsaW5lU2V0W2kgKiA0XTtcbiAgICBjdXJyZW50TGluZVN0YXJ0WSA9IGxpbmVTZXRbaSAqIDQgKyAxXTtcbiAgICBjdXJyZW50TGluZUVuZFggPSBsaW5lU2V0W2kgKiA0ICsgMl07XG4gICAgY3VycmVudExpbmVFbmRZID0gbGluZVNldFtpICogNCArIDNdO1xuXG4gICAgaWYgKGkgPCBsaW5lU2V0Lmxlbmd0aCAvIDQgLSAxKSB7XG4gICAgICBuZXh0TGluZVN0YXJ0WCA9IGxpbmVTZXRbKGkgKyAxKSAqIDRdO1xuICAgICAgbmV4dExpbmVTdGFydFkgPSBsaW5lU2V0WyhpICsgMSkgKiA0ICsgMV07XG4gICAgICBuZXh0TGluZUVuZFggPSBsaW5lU2V0WyhpICsgMSkgKiA0ICsgMl07XG4gICAgICBuZXh0TGluZUVuZFkgPSBsaW5lU2V0WyhpICsgMSkgKiA0ICsgM107XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRMaW5lU3RhcnRYID0gbGluZVNldFswXTtcbiAgICAgIG5leHRMaW5lU3RhcnRZID0gbGluZVNldFsxXTtcbiAgICAgIG5leHRMaW5lRW5kWCA9IGxpbmVTZXRbMl07XG4gICAgICBuZXh0TGluZUVuZFkgPSBsaW5lU2V0WzNdO1xuICAgIH1cblxuICAgIHZhciBpbnRlcnNlY3Rpb24gPSB0aGlzLmZpbml0ZUxpbmVzSW50ZXJzZWN0KGN1cnJlbnRMaW5lU3RhcnRYLCBjdXJyZW50TGluZVN0YXJ0WSwgY3VycmVudExpbmVFbmRYLCBjdXJyZW50TGluZUVuZFksIG5leHRMaW5lU3RhcnRYLCBuZXh0TGluZVN0YXJ0WSwgbmV4dExpbmVFbmRYLCBuZXh0TGluZUVuZFksIHRydWUpO1xuXG4gICAgdmVydGljZXNbaSAqIDJdID0gaW50ZXJzZWN0aW9uWzBdO1xuICAgIHZlcnRpY2VzW2kgKiAyICsgMV0gPSBpbnRlcnNlY3Rpb25bMV07XG4gIH1cblxuICByZXR1cm4gdmVydGljZXM7XG59O1xuXG5tYXRoLmV4cGFuZFBvbHlnb24gPSBmdW5jdGlvbiAocG9pbnRzLCBwYWQpIHtcblxuICB2YXIgZXhwYW5kZWRMaW5lU2V0ID0gbmV3IEFycmF5KHBvaW50cy5sZW5ndGggKiAyKTtcblxuICB2YXIgY3VycmVudFBvaW50WCA9IHZvaWQgMCxcbiAgICAgIGN1cnJlbnRQb2ludFkgPSB2b2lkIDAsXG4gICAgICBuZXh0UG9pbnRYID0gdm9pZCAwLFxuICAgICAgbmV4dFBvaW50WSA9IHZvaWQgMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICBjdXJyZW50UG9pbnRYID0gcG9pbnRzW2kgKiAyXTtcbiAgICBjdXJyZW50UG9pbnRZID0gcG9pbnRzW2kgKiAyICsgMV07XG5cbiAgICBpZiAoaSA8IHBvaW50cy5sZW5ndGggLyAyIC0gMSkge1xuICAgICAgbmV4dFBvaW50WCA9IHBvaW50c1soaSArIDEpICogMl07XG4gICAgICBuZXh0UG9pbnRZID0gcG9pbnRzWyhpICsgMSkgKiAyICsgMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRQb2ludFggPSBwb2ludHNbMF07XG4gICAgICBuZXh0UG9pbnRZID0gcG9pbnRzWzFdO1xuICAgIH1cblxuICAgIC8vIEN1cnJlbnQgbGluZTogW2N1cnJlbnRQb2ludFgsIGN1cnJlbnRQb2ludFldIHRvIFtuZXh0UG9pbnRYLCBuZXh0UG9pbnRZXVxuXG4gICAgLy8gQXNzdW1lIENDVyBwb2x5Z29uIHdpbmRpbmdcblxuICAgIHZhciBvZmZzZXRYID0gbmV4dFBvaW50WSAtIGN1cnJlbnRQb2ludFk7XG4gICAgdmFyIG9mZnNldFkgPSAtKG5leHRQb2ludFggLSBjdXJyZW50UG9pbnRYKTtcblxuICAgIC8vIE5vcm1hbGl6ZVxuICAgIHZhciBvZmZzZXRMZW5ndGggPSBNYXRoLnNxcnQob2Zmc2V0WCAqIG9mZnNldFggKyBvZmZzZXRZICogb2Zmc2V0WSk7XG4gICAgdmFyIG5vcm1hbGl6ZWRPZmZzZXRYID0gb2Zmc2V0WCAvIG9mZnNldExlbmd0aDtcbiAgICB2YXIgbm9ybWFsaXplZE9mZnNldFkgPSBvZmZzZXRZIC8gb2Zmc2V0TGVuZ3RoO1xuXG4gICAgZXhwYW5kZWRMaW5lU2V0W2kgKiA0XSA9IGN1cnJlbnRQb2ludFggKyBub3JtYWxpemVkT2Zmc2V0WCAqIHBhZDtcbiAgICBleHBhbmRlZExpbmVTZXRbaSAqIDQgKyAxXSA9IGN1cnJlbnRQb2ludFkgKyBub3JtYWxpemVkT2Zmc2V0WSAqIHBhZDtcbiAgICBleHBhbmRlZExpbmVTZXRbaSAqIDQgKyAyXSA9IG5leHRQb2ludFggKyBub3JtYWxpemVkT2Zmc2V0WCAqIHBhZDtcbiAgICBleHBhbmRlZExpbmVTZXRbaSAqIDQgKyAzXSA9IG5leHRQb2ludFkgKyBub3JtYWxpemVkT2Zmc2V0WSAqIHBhZDtcbiAgfVxuXG4gIHJldHVybiBleHBhbmRlZExpbmVTZXQ7XG59O1xuXG5tYXRoLmludGVyc2VjdExpbmVFbGxpcHNlID0gZnVuY3Rpb24gKHgsIHksIGNlbnRlclgsIGNlbnRlclksIGVsbGlwc2VXcmFkaXVzLCBlbGxpcHNlSHJhZGl1cykge1xuXG4gIHZhciBkaXNwWCA9IGNlbnRlclggLSB4O1xuICB2YXIgZGlzcFkgPSBjZW50ZXJZIC0geTtcblxuICBkaXNwWCAvPSBlbGxpcHNlV3JhZGl1cztcbiAgZGlzcFkgLz0gZWxsaXBzZUhyYWRpdXM7XG5cbiAgdmFyIGxlbiA9IE1hdGguc3FydChkaXNwWCAqIGRpc3BYICsgZGlzcFkgKiBkaXNwWSk7XG5cbiAgdmFyIG5ld0xlbmd0aCA9IGxlbiAtIDE7XG5cbiAgaWYgKG5ld0xlbmd0aCA8IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgbGVuUHJvcG9ydGlvbiA9IG5ld0xlbmd0aCAvIGxlbjtcblxuICByZXR1cm4gWyhjZW50ZXJYIC0geCkgKiBsZW5Qcm9wb3J0aW9uICsgeCwgKGNlbnRlclkgLSB5KSAqIGxlblByb3BvcnRpb24gKyB5XTtcbn07XG5cbm1hdGguY2hlY2tJbkVsbGlwc2UgPSBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSwgcGFkZGluZykge1xuICB4IC09IGNlbnRlclg7XG4gIHkgLT0gY2VudGVyWTtcblxuICB4IC89IHdpZHRoIC8gMiArIHBhZGRpbmc7XG4gIHkgLz0gaGVpZ2h0IC8gMiArIHBhZGRpbmc7XG5cbiAgcmV0dXJuIHggKiB4ICsgeSAqIHkgPD0gMTtcbn07XG5cbi8vIFJldHVybnMgaW50ZXJzZWN0aW9ucyBvZiBpbmNyZWFzaW5nIGRpc3RhbmNlIGZyb20gbGluZSdzIHN0YXJ0IHBvaW50XG5tYXRoLmludGVyc2VjdExpbmVDaXJjbGUgPSBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIsIGNlbnRlclgsIGNlbnRlclksIHJhZGl1cykge1xuXG4gIC8vIENhbGN1bGF0ZSBkLCBkaXJlY3Rpb24gdmVjdG9yIG9mIGxpbmVcbiAgdmFyIGQgPSBbeDIgLSB4MSwgeTIgLSB5MV07IC8vIERpcmVjdGlvbiB2ZWN0b3Igb2YgbGluZVxuICB2YXIgZiA9IFt4MSAtIGNlbnRlclgsIHkxIC0gY2VudGVyWV07XG5cbiAgdmFyIGEgPSBkWzBdICogZFswXSArIGRbMV0gKiBkWzFdO1xuICB2YXIgYiA9IDIgKiAoZlswXSAqIGRbMF0gKyBmWzFdICogZFsxXSk7XG4gIHZhciBjID0gZlswXSAqIGZbMF0gKyBmWzFdICogZlsxXSAtIHJhZGl1cyAqIHJhZGl1cztcblxuICB2YXIgZGlzY3JpbWluYW50ID0gYiAqIGIgLSA0ICogYSAqIGM7XG5cbiAgaWYgKGRpc2NyaW1pbmFudCA8IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgdDEgPSAoLWIgKyBNYXRoLnNxcnQoZGlzY3JpbWluYW50KSkgLyAoMiAqIGEpO1xuICB2YXIgdDIgPSAoLWIgLSBNYXRoLnNxcnQoZGlzY3JpbWluYW50KSkgLyAoMiAqIGEpO1xuXG4gIHZhciB0TWluID0gTWF0aC5taW4odDEsIHQyKTtcbiAgdmFyIHRNYXggPSBNYXRoLm1heCh0MSwgdDIpO1xuICB2YXIgaW5SYW5nZVBhcmFtcyA9IFtdO1xuXG4gIGlmICh0TWluID49IDAgJiYgdE1pbiA8PSAxKSB7XG4gICAgaW5SYW5nZVBhcmFtcy5wdXNoKHRNaW4pO1xuICB9XG5cbiAgaWYgKHRNYXggPj0gMCAmJiB0TWF4IDw9IDEpIHtcbiAgICBpblJhbmdlUGFyYW1zLnB1c2godE1heCk7XG4gIH1cblxuICBpZiAoaW5SYW5nZVBhcmFtcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgbmVhckludGVyc2VjdGlvblggPSBpblJhbmdlUGFyYW1zWzBdICogZFswXSArIHgxO1xuICB2YXIgbmVhckludGVyc2VjdGlvblkgPSBpblJhbmdlUGFyYW1zWzBdICogZFsxXSArIHkxO1xuXG4gIGlmIChpblJhbmdlUGFyYW1zLmxlbmd0aCA+IDEpIHtcblxuICAgIGlmIChpblJhbmdlUGFyYW1zWzBdID09IGluUmFuZ2VQYXJhbXNbMV0pIHtcbiAgICAgIHJldHVybiBbbmVhckludGVyc2VjdGlvblgsIG5lYXJJbnRlcnNlY3Rpb25ZXTtcbiAgICB9IGVsc2Uge1xuXG4gICAgICB2YXIgZmFySW50ZXJzZWN0aW9uWCA9IGluUmFuZ2VQYXJhbXNbMV0gKiBkWzBdICsgeDE7XG4gICAgICB2YXIgZmFySW50ZXJzZWN0aW9uWSA9IGluUmFuZ2VQYXJhbXNbMV0gKiBkWzFdICsgeTE7XG5cbiAgICAgIHJldHVybiBbbmVhckludGVyc2VjdGlvblgsIG5lYXJJbnRlcnNlY3Rpb25ZLCBmYXJJbnRlcnNlY3Rpb25YLCBmYXJJbnRlcnNlY3Rpb25ZXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFtuZWFySW50ZXJzZWN0aW9uWCwgbmVhckludGVyc2VjdGlvblldO1xuICB9XG59O1xuXG5tYXRoLmZpbmRDaXJjbGVOZWFyUG9pbnQgPSBmdW5jdGlvbiAoY2VudGVyWCwgY2VudGVyWSwgcmFkaXVzLCBmYXJYLCBmYXJZKSB7XG5cbiAgdmFyIGRpc3BsYWNlbWVudFggPSBmYXJYIC0gY2VudGVyWDtcbiAgdmFyIGRpc3BsYWNlbWVudFkgPSBmYXJZIC0gY2VudGVyWTtcbiAgdmFyIGRpc3RhbmNlID0gTWF0aC5zcXJ0KGRpc3BsYWNlbWVudFggKiBkaXNwbGFjZW1lbnRYICsgZGlzcGxhY2VtZW50WSAqIGRpc3BsYWNlbWVudFkpO1xuXG4gIHZhciB1bml0RGlzcGxhY2VtZW50WCA9IGRpc3BsYWNlbWVudFggLyBkaXN0YW5jZTtcbiAgdmFyIHVuaXREaXNwbGFjZW1lbnRZID0gZGlzcGxhY2VtZW50WSAvIGRpc3RhbmNlO1xuXG4gIHJldHVybiBbY2VudGVyWCArIHVuaXREaXNwbGFjZW1lbnRYICogcmFkaXVzLCBjZW50ZXJZICsgdW5pdERpc3BsYWNlbWVudFkgKiByYWRpdXNdO1xufTtcblxubWF0aC5maW5kTWF4U3FEaXN0YW5jZVRvT3JpZ2luID0gZnVuY3Rpb24gKHBvaW50cykge1xuICB2YXIgbWF4U3FEaXN0YW5jZSA9IDAuMDAwMDAxO1xuICB2YXIgc3FEaXN0YW5jZSA9IHZvaWQgMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcblxuICAgIHNxRGlzdGFuY2UgPSBwb2ludHNbaSAqIDJdICogcG9pbnRzW2kgKiAyXSArIHBvaW50c1tpICogMiArIDFdICogcG9pbnRzW2kgKiAyICsgMV07XG5cbiAgICBpZiAoc3FEaXN0YW5jZSA+IG1heFNxRGlzdGFuY2UpIHtcbiAgICAgIG1heFNxRGlzdGFuY2UgPSBzcURpc3RhbmNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXhTcURpc3RhbmNlO1xufTtcblxubWF0aC5taWRPZlRocmVlID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgaWYgKGIgPD0gYSAmJiBhIDw9IGMgfHwgYyA8PSBhICYmIGEgPD0gYikge1xuICAgIHJldHVybiBhO1xuICB9IGVsc2UgaWYgKGEgPD0gYiAmJiBiIDw9IGMgfHwgYyA8PSBiICYmIGIgPD0gYSkge1xuICAgIHJldHVybiBiO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjO1xuICB9XG59O1xuXG4vLyAoeDEseTEpPT4oeDIseTIpIGludGVyc2VjdCB3aXRoICh4Myx5Myk9Pih4NCx5NClcbm1hdGguZmluaXRlTGluZXNJbnRlcnNlY3QgPSBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0LCBpbmZpbml0ZUxpbmVzKSB7XG5cbiAgdmFyIGR4MTMgPSB4MSAtIHgzO1xuICB2YXIgZHgyMSA9IHgyIC0geDE7XG4gIHZhciBkeDQzID0geDQgLSB4MztcblxuICB2YXIgZHkxMyA9IHkxIC0geTM7XG4gIHZhciBkeTIxID0geTIgLSB5MTtcbiAgdmFyIGR5NDMgPSB5NCAtIHkzO1xuXG4gIHZhciB1YV90ID0gZHg0MyAqIGR5MTMgLSBkeTQzICogZHgxMztcbiAgdmFyIHViX3QgPSBkeDIxICogZHkxMyAtIGR5MjEgKiBkeDEzO1xuICB2YXIgdV9iID0gZHk0MyAqIGR4MjEgLSBkeDQzICogZHkyMTtcblxuICBpZiAodV9iICE9PSAwKSB7XG4gICAgdmFyIHVhID0gdWFfdCAvIHVfYjtcbiAgICB2YXIgdWIgPSB1Yl90IC8gdV9iO1xuXG4gICAgdmFyIGZscHRUaHJlc2hvbGQgPSAwLjAwMTtcbiAgICB2YXIgbWluID0gMCAtIGZscHRUaHJlc2hvbGQ7XG4gICAgdmFyIG1heCA9IDEgKyBmbHB0VGhyZXNob2xkO1xuXG4gICAgaWYgKG1pbiA8PSB1YSAmJiB1YSA8PSBtYXggJiYgbWluIDw9IHViICYmIHViIDw9IG1heCkge1xuICAgICAgcmV0dXJuIFt4MSArIHVhICogZHgyMSwgeTEgKyB1YSAqIGR5MjFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWluZmluaXRlTGluZXMpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFt4MSArIHVhICogZHgyMSwgeTEgKyB1YSAqIGR5MjFdO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodWFfdCA9PT0gMCB8fCB1Yl90ID09PSAwKSB7XG5cbiAgICAgIC8vIFBhcmFsbGVsLCBjb2luY2lkZW50IGxpbmVzLiBDaGVjayBpZiBvdmVybGFwXG5cbiAgICAgIC8vIENoZWNrIGVuZHBvaW50IG9mIHNlY29uZCBsaW5lXG4gICAgICBpZiAodGhpcy5taWRPZlRocmVlKHgxLCB4MiwgeDQpID09PSB4NCkge1xuICAgICAgICByZXR1cm4gW3g0LCB5NF07XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIHN0YXJ0IHBvaW50IG9mIHNlY29uZCBsaW5lXG4gICAgICBpZiAodGhpcy5taWRPZlRocmVlKHgxLCB4MiwgeDMpID09PSB4Mykge1xuICAgICAgICByZXR1cm4gW3gzLCB5M107XG4gICAgICB9XG5cbiAgICAgIC8vIEVuZHBvaW50IG9mIGZpcnN0IGxpbmVcbiAgICAgIGlmICh0aGlzLm1pZE9mVGhyZWUoeDMsIHg0LCB4MikgPT09IHgyKSB7XG4gICAgICAgIHJldHVybiBbeDIsIHkyXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtdO1xuICAgIH0gZWxzZSB7XG5cbiAgICAgIC8vIFBhcmFsbGVsLCBub24tY29pbmNpZGVudFxuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxufTtcblxuLy8gbWF0aC5wb2x5Z29uSW50ZXJzZWN0TGluZSggeCwgeSwgYmFzZVBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgcGFkZGluZyApXG4vLyBpbnRlcnNlY3QgYSBub2RlIHBvbHlnb24gKHB0cyB0cmFuc2Zvcm1lZClcbi8vXG4vLyBtYXRoLnBvbHlnb25JbnRlcnNlY3RMaW5lKCB4LCB5LCBiYXNlUG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZIClcbi8vIGludGVyc2VjdCB0aGUgcG9pbnRzIChubyB0cmFuc2Zvcm0pXG5tYXRoLnBvbHlnb25JbnRlcnNlY3RMaW5lID0gZnVuY3Rpb24gKHgsIHksIGJhc2VQb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIHBhZGRpbmcpIHtcblxuICB2YXIgaW50ZXJzZWN0aW9ucyA9IFtdO1xuICB2YXIgaW50ZXJzZWN0aW9uID0gdm9pZCAwO1xuXG4gIHZhciB0cmFuc2Zvcm1lZFBvaW50cyA9IG5ldyBBcnJheShiYXNlUG9pbnRzLmxlbmd0aCk7XG5cbiAgdmFyIGRvVHJhbnNmb3JtID0gdHJ1ZTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDUpIHtcbiAgICBkb1RyYW5zZm9ybSA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIHBvaW50cyA9IHZvaWQgMDtcblxuICBpZiAoZG9UcmFuc2Zvcm0pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zZm9ybWVkUG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgdHJhbnNmb3JtZWRQb2ludHNbaSAqIDJdID0gYmFzZVBvaW50c1tpICogMl0gKiB3aWR0aCArIGNlbnRlclg7XG4gICAgICB0cmFuc2Zvcm1lZFBvaW50c1tpICogMiArIDFdID0gYmFzZVBvaW50c1tpICogMiArIDFdICogaGVpZ2h0ICsgY2VudGVyWTtcbiAgICB9XG5cbiAgICBpZiAocGFkZGluZyA+IDApIHtcbiAgICAgIHZhciBleHBhbmRlZExpbmVTZXQgPSBtYXRoLmV4cGFuZFBvbHlnb24odHJhbnNmb3JtZWRQb2ludHMsIC1wYWRkaW5nKTtcblxuICAgICAgcG9pbnRzID0gbWF0aC5qb2luTGluZXMoZXhwYW5kZWRMaW5lU2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9pbnRzID0gdHJhbnNmb3JtZWRQb2ludHM7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBvaW50cyA9IGJhc2VQb2ludHM7XG4gIH1cblxuICB2YXIgY3VycmVudFggPSB2b2lkIDAsXG4gICAgICBjdXJyZW50WSA9IHZvaWQgMCxcbiAgICAgIG5leHRYID0gdm9pZCAwLFxuICAgICAgbmV4dFkgPSB2b2lkIDA7XG5cbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHBvaW50cy5sZW5ndGggLyAyOyBfaSsrKSB7XG5cbiAgICBjdXJyZW50WCA9IHBvaW50c1tfaSAqIDJdO1xuICAgIGN1cnJlbnRZID0gcG9pbnRzW19pICogMiArIDFdO1xuXG4gICAgaWYgKF9pIDwgcG9pbnRzLmxlbmd0aCAvIDIgLSAxKSB7XG4gICAgICBuZXh0WCA9IHBvaW50c1soX2kgKyAxKSAqIDJdO1xuICAgICAgbmV4dFkgPSBwb2ludHNbKF9pICsgMSkgKiAyICsgMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRYID0gcG9pbnRzWzBdO1xuICAgICAgbmV4dFkgPSBwb2ludHNbMV07XG4gICAgfVxuXG4gICAgaW50ZXJzZWN0aW9uID0gdGhpcy5maW5pdGVMaW5lc0ludGVyc2VjdCh4LCB5LCBjZW50ZXJYLCBjZW50ZXJZLCBjdXJyZW50WCwgY3VycmVudFksIG5leHRYLCBuZXh0WSk7XG5cbiAgICBpZiAoaW50ZXJzZWN0aW9uLmxlbmd0aCAhPT0gMCkge1xuICAgICAgaW50ZXJzZWN0aW9ucy5wdXNoKGludGVyc2VjdGlvblswXSwgaW50ZXJzZWN0aW9uWzFdKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW50ZXJzZWN0aW9ucztcbn07XG5cbm1hdGguc2hvcnRlbkludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIChpbnRlcnNlY3Rpb24sIG9mZnNldCwgYW1vdW50KSB7XG5cbiAgdmFyIGRpc3AgPSBbaW50ZXJzZWN0aW9uWzBdIC0gb2Zmc2V0WzBdLCBpbnRlcnNlY3Rpb25bMV0gLSBvZmZzZXRbMV1dO1xuXG4gIHZhciBsZW5ndGggPSBNYXRoLnNxcnQoZGlzcFswXSAqIGRpc3BbMF0gKyBkaXNwWzFdICogZGlzcFsxXSk7XG5cbiAgdmFyIGxlblJhdGlvID0gKGxlbmd0aCAtIGFtb3VudCkgLyBsZW5ndGg7XG5cbiAgaWYgKGxlblJhdGlvIDwgMCkge1xuICAgIGxlblJhdGlvID0gMC4wMDAwMTtcbiAgfVxuXG4gIHJldHVybiBbb2Zmc2V0WzBdICsgbGVuUmF0aW8gKiBkaXNwWzBdLCBvZmZzZXRbMV0gKyBsZW5SYXRpbyAqIGRpc3BbMV1dO1xufTtcblxubWF0aC5nZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUgPSBmdW5jdGlvbiAoc2lkZXMsIHJvdGF0aW9uUmFkaWFucykge1xuICB2YXIgcG9pbnRzID0gbWF0aC5nZW5lcmF0ZVVuaXROZ29uUG9pbnRzKHNpZGVzLCByb3RhdGlvblJhZGlhbnMpO1xuICBwb2ludHMgPSBtYXRoLmZpdFBvbHlnb25Ub1NxdWFyZShwb2ludHMpO1xuXG4gIHJldHVybiBwb2ludHM7XG59O1xuXG5tYXRoLmZpdFBvbHlnb25Ub1NxdWFyZSA9IGZ1bmN0aW9uIChwb2ludHMpIHtcbiAgdmFyIHggPSB2b2lkIDAsXG4gICAgICB5ID0gdm9pZCAwO1xuICB2YXIgc2lkZXMgPSBwb2ludHMubGVuZ3RoIC8gMjtcbiAgdmFyIG1pblggPSBJbmZpbml0eSxcbiAgICAgIG1pblkgPSBJbmZpbml0eSxcbiAgICAgIG1heFggPSAtSW5maW5pdHksXG4gICAgICBtYXhZID0gLUluZmluaXR5O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2lkZXM7IGkrKykge1xuICAgIHggPSBwb2ludHNbMiAqIGldO1xuICAgIHkgPSBwb2ludHNbMiAqIGkgKyAxXTtcblxuICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCB4KTtcbiAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgeCk7XG4gICAgbWluWSA9IE1hdGgubWluKG1pblksIHkpO1xuICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCB5KTtcbiAgfVxuXG4gIC8vIHN0cmV0Y2ggZmFjdG9yc1xuICB2YXIgc3ggPSAyIC8gKG1heFggLSBtaW5YKTtcbiAgdmFyIHN5ID0gMiAvIChtYXhZIC0gbWluWSk7XG5cbiAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgc2lkZXM7IF9pMisrKSB7XG4gICAgeCA9IHBvaW50c1syICogX2kyXSA9IHBvaW50c1syICogX2kyXSAqIHN4O1xuICAgIHkgPSBwb2ludHNbMiAqIF9pMiArIDFdID0gcG9pbnRzWzIgKiBfaTIgKyAxXSAqIHN5O1xuXG4gICAgbWluWCA9IE1hdGgubWluKG1pblgsIHgpO1xuICAgIG1heFggPSBNYXRoLm1heChtYXhYLCB4KTtcbiAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgeSk7XG4gICAgbWF4WSA9IE1hdGgubWF4KG1heFksIHkpO1xuICB9XG5cbiAgaWYgKG1pblkgPCAtMSkge1xuICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IHNpZGVzOyBfaTMrKykge1xuICAgICAgeSA9IHBvaW50c1syICogX2kzICsgMV0gPSBwb2ludHNbMiAqIF9pMyArIDFdICsgKC0xIC0gbWluWSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBvaW50cztcbn07XG5cbm1hdGguZ2VuZXJhdGVVbml0TmdvblBvaW50cyA9IGZ1bmN0aW9uIChzaWRlcywgcm90YXRpb25SYWRpYW5zKSB7XG5cbiAgdmFyIGluY3JlbWVudCA9IDEuMCAvIHNpZGVzICogMiAqIE1hdGguUEk7XG4gIHZhciBzdGFydEFuZ2xlID0gc2lkZXMgJSAyID09PSAwID8gTWF0aC5QSSAvIDIuMCArIGluY3JlbWVudCAvIDIuMCA6IE1hdGguUEkgLyAyLjA7XG5cbiAgc3RhcnRBbmdsZSArPSByb3RhdGlvblJhZGlhbnM7XG5cbiAgdmFyIHBvaW50cyA9IG5ldyBBcnJheShzaWRlcyAqIDIpO1xuXG4gIHZhciBjdXJyZW50QW5nbGUgPSB2b2lkIDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2lkZXM7IGkrKykge1xuICAgIGN1cnJlbnRBbmdsZSA9IGkgKiBpbmNyZW1lbnQgKyBzdGFydEFuZ2xlO1xuXG4gICAgcG9pbnRzWzIgKiBpXSA9IE1hdGguY29zKGN1cnJlbnRBbmdsZSk7IC8vIHhcbiAgICBwb2ludHNbMiAqIGkgKyAxXSA9IE1hdGguc2luKC1jdXJyZW50QW5nbGUpOyAvLyB5XG4gIH1cblxuICByZXR1cm4gcG9pbnRzO1xufTtcblxubWF0aC5nZXRSb3VuZFJlY3RhbmdsZVJhZGl1cyA9IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG5cbiAgLy8gU2V0IHRoZSBkZWZhdWx0IHJhZGl1cywgdW5sZXNzIGhhbGYgb2Ygd2lkdGggb3IgaGVpZ2h0IGlzIHNtYWxsZXIgdGhhbiBkZWZhdWx0XG4gIHJldHVybiBNYXRoLm1pbih3aWR0aCAvIDQsIGhlaWdodCAvIDQsIDgpO1xufTtcblxubWF0aC5nZXRDdXRSZWN0YW5nbGVDb3JuZXJMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiA4O1xufTtcblxubWF0aC5iZXppZXJQdHNUb1F1YWRDb2VmZiA9IGZ1bmN0aW9uIChwMCwgcDEsIHAyKSB7XG4gIHJldHVybiBbcDAgLSAyICogcDEgKyBwMiwgMiAqIChwMSAtIHAwKSwgcDBdO1xufTtcblxubWF0aC5nZXRCYXJyZWxDdXJ2ZUNvbnN0YW50cyA9IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG4gIC8vIGdldCBjdXJ2ZSB3aWR0aCwgaGVpZ2h0LCBhbmQgY29udHJvbCBwb2ludCBwb3NpdGlvbiBvZmZzZXRzIGFzIGEgcGVyY2VudGFnZSBvZiBub2RlIGhlaWdodCAvIHdpZHRoXG4gIHJldHVybiB7XG4gICAgaGVpZ2h0T2Zmc2V0OiBNYXRoLm1pbigxNSwgMC4wNSAqIGhlaWdodCksXG4gICAgd2lkdGhPZmZzZXQ6IE1hdGgubWluKDEwMCwgMC4yNSAqIHdpZHRoKSxcbiAgICBjdHJsUHRPZmZzZXRQY3Q6IDAuMDVcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbWF0aDtcblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogd2luZG93OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbi8qKiovIH0pLFxuLyogNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vLyB1c2UgdGhpcyBtb2R1bGUgdG8gY2hlcnJ5IHBpY2sgZnVuY3Rpb25zIGludG8geW91ciBwcm90b3R5cGVcbi8vICh1c2VmdWwgZm9yIGZ1bmN0aW9ucyBzaGFyZWQgYmV0d2VlbiB0aGUgY29yZSBhbmQgY29sbGVjdGlvbnMsIGZvciBleGFtcGxlKVxuXG4vLyBlLmcuXG4vLyBsZXQgZm9vID0gZGVmaW5lLmZvbyh7IC8qIHBhcmFtcy4uLiAqLyB9KVxuXG52YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBkZWZpbmUgPSB7fTtcblxuW19fd2VicGFja19yZXF1aXJlX18oNDMpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1KSwgX193ZWJwYWNrX3JlcXVpcmVfXyg0NildLmZvckVhY2goZnVuY3Rpb24gKG0pIHtcbiAgdXRpbC5hc3NpZ24oZGVmaW5lLCBtKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmluZTtcblxuLyoqKi8gfSksXG4vKiA1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuLyohXG5FbWJlZGRhYmxlIE1pbmltdW0gU3RyaWN0bHktQ29tcGxpYW50IFByb21pc2VzL0ErIDEuMS4xIFRoZW5hYmxlXG5Db3B5cmlnaHQgKGMpIDIwMTMtMjAxNCBSYWxmIFMuIEVuZ2Vsc2NoYWxsIChodHRwOi8vZW5nZWxzY2hhbGwuY29tKVxuTGljZW5zZWQgdW5kZXIgVGhlIE1JVCBMaWNlbnNlIChodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUKVxuKi9cblxuLyogIHByb21pc2Ugc3RhdGVzIFtQcm9taXNlcy9BKyAyLjFdICAqL1xudmFyIFNUQVRFX1BFTkRJTkcgPSAwOyAvKiAgW1Byb21pc2VzL0ErIDIuMS4xXSAgKi9cbnZhciBTVEFURV9GVUxGSUxMRUQgPSAxOyAvKiAgW1Byb21pc2VzL0ErIDIuMS4yXSAgKi9cbnZhciBTVEFURV9SRUpFQ1RFRCA9IDI7IC8qICBbUHJvbWlzZXMvQSsgMi4xLjNdICAqL1xuXG4vKiAgcHJvbWlzZSBvYmplY3QgY29uc3RydWN0b3IgICovXG52YXIgYXBpID0gZnVuY3Rpb24gYXBpKGV4ZWN1dG9yKSB7XG4gIC8qICBvcHRpb25hbGx5IHN1cHBvcnQgbm9uLWNvbnN0cnVjdG9yL3BsYWluLWZ1bmN0aW9uIGNhbGwgICovXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBhcGkpKSByZXR1cm4gbmV3IGFwaShleGVjdXRvcik7XG5cbiAgLyogIGluaXRpYWxpemUgb2JqZWN0ICAqL1xuICB0aGlzLmlkID0gJ1RoZW5hYmxlLzEuMC43JztcbiAgdGhpcy5zdGF0ZSA9IFNUQVRFX1BFTkRJTkc7IC8qICBpbml0aWFsIHN0YXRlICAqL1xuICB0aGlzLmZ1bGZpbGxWYWx1ZSA9IHVuZGVmaW5lZDsgLyogIGluaXRpYWwgdmFsdWUgICovIC8qICBbUHJvbWlzZXMvQSsgMS4zLCAyLjEuMi4yXSAgKi9cbiAgdGhpcy5yZWplY3RSZWFzb24gPSB1bmRlZmluZWQ7IC8qICBpbml0aWFsIHJlYXNvbiAqLyAvKiAgW1Byb21pc2VzL0ErIDEuNSwgMi4xLjMuMl0gICovXG4gIHRoaXMub25GdWxmaWxsZWQgPSBbXTsgLyogIGluaXRpYWwgaGFuZGxlcnMgICovXG4gIHRoaXMub25SZWplY3RlZCA9IFtdOyAvKiAgaW5pdGlhbCBoYW5kbGVycyAgKi9cblxuICAvKiAgcHJvdmlkZSBvcHRpb25hbCBpbmZvcm1hdGlvbi1oaWRpbmcgcHJveHkgICovXG4gIHRoaXMucHJveHkgPSB7XG4gICAgdGhlbjogdGhpcy50aGVuLmJpbmQodGhpcylcbiAgfTtcblxuICAvKiAgc3VwcG9ydCBvcHRpb25hbCBleGVjdXRvciBmdW5jdGlvbiAgKi9cbiAgaWYgKHR5cGVvZiBleGVjdXRvciA9PT0gJ2Z1bmN0aW9uJykgZXhlY3V0b3IuY2FsbCh0aGlzLCB0aGlzLmZ1bGZpbGwuYmluZCh0aGlzKSwgdGhpcy5yZWplY3QuYmluZCh0aGlzKSk7XG59O1xuXG4vKiAgcHJvbWlzZSBBUEkgbWV0aG9kcyAgKi9cbmFwaS5wcm90b3R5cGUgPSB7XG4gIC8qICBwcm9taXNlIHJlc29sdmluZyBtZXRob2RzICAqL1xuICBmdWxmaWxsOiBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7XG4gICAgcmV0dXJuIGRlbGl2ZXIodGhpcywgU1RBVEVfRlVMRklMTEVELCAnZnVsZmlsbFZhbHVlJywgdmFsdWUpO1xuICB9LFxuICByZWplY3Q6IGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiBkZWxpdmVyKHRoaXMsIFNUQVRFX1JFSkVDVEVELCAncmVqZWN0UmVhc29uJywgdmFsdWUpO1xuICB9LFxuXG4gIC8qICBcIlRoZSB0aGVuIE1ldGhvZFwiIFtQcm9taXNlcy9BKyAxLjEsIDEuMiwgMi4yXSAgKi9cbiAgdGhlbjogZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgIHZhciBjdXJyID0gdGhpcztcbiAgICB2YXIgbmV4dCA9IG5ldyBhcGkoKTsgLyogIFtQcm9taXNlcy9BKyAyLjIuN10gICovXG4gICAgY3Vyci5vbkZ1bGZpbGxlZC5wdXNoKHJlc29sdmVyKG9uRnVsZmlsbGVkLCBuZXh0LCAnZnVsZmlsbCcpKTsgLyogIFtQcm9taXNlcy9BKyAyLjIuMi8yLjIuNl0gICovXG4gICAgY3Vyci5vblJlamVjdGVkLnB1c2gocmVzb2x2ZXIob25SZWplY3RlZCwgbmV4dCwgJ3JlamVjdCcpKTsgLyogIFtQcm9taXNlcy9BKyAyLjIuMy8yLjIuNl0gICovXG4gICAgZXhlY3V0ZShjdXJyKTtcbiAgICByZXR1cm4gbmV4dC5wcm94eTsgLyogIFtQcm9taXNlcy9BKyAyLjIuNywgMy4zXSAgKi9cbiAgfVxufTtcblxuLyogIGRlbGl2ZXIgYW4gYWN0aW9uICAqL1xudmFyIGRlbGl2ZXIgPSBmdW5jdGlvbiBkZWxpdmVyKGN1cnIsIHN0YXRlLCBuYW1lLCB2YWx1ZSkge1xuICBpZiAoY3Vyci5zdGF0ZSA9PT0gU1RBVEVfUEVORElORykge1xuICAgIGN1cnIuc3RhdGUgPSBzdGF0ZTsgLyogIFtQcm9taXNlcy9BKyAyLjEuMi4xLCAyLjEuMy4xXSAgKi9cbiAgICBjdXJyW25hbWVdID0gdmFsdWU7IC8qICBbUHJvbWlzZXMvQSsgMi4xLjIuMiwgMi4xLjMuMl0gICovXG4gICAgZXhlY3V0ZShjdXJyKTtcbiAgfVxuICByZXR1cm4gY3Vycjtcbn07XG5cbi8qICBleGVjdXRlIGFsbCBoYW5kbGVycyAgKi9cbnZhciBleGVjdXRlID0gZnVuY3Rpb24gZXhlY3V0ZShjdXJyKSB7XG4gIGlmIChjdXJyLnN0YXRlID09PSBTVEFURV9GVUxGSUxMRUQpIGV4ZWN1dGVfaGFuZGxlcnMoY3VyciwgJ29uRnVsZmlsbGVkJywgY3Vyci5mdWxmaWxsVmFsdWUpO2Vsc2UgaWYgKGN1cnIuc3RhdGUgPT09IFNUQVRFX1JFSkVDVEVEKSBleGVjdXRlX2hhbmRsZXJzKGN1cnIsICdvblJlamVjdGVkJywgY3Vyci5yZWplY3RSZWFzb24pO1xufTtcblxuLyogIGV4ZWN1dGUgcGFydGljdWxhciBzZXQgb2YgaGFuZGxlcnMgICovXG52YXIgZXhlY3V0ZV9oYW5kbGVycyA9IGZ1bmN0aW9uIGV4ZWN1dGVfaGFuZGxlcnMoY3VyciwgbmFtZSwgdmFsdWUpIHtcbiAgLyogZ2xvYmFsIHNldEltbWVkaWF0ZTogdHJ1ZSAqL1xuICAvKiBnbG9iYWwgc2V0VGltZW91dDogdHJ1ZSAqL1xuXG4gIC8qICBzaG9ydC1jaXJjdWl0IHByb2Nlc3NpbmcgICovXG4gIGlmIChjdXJyW25hbWVdLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXG4gIC8qICBpdGVyYXRlIG92ZXIgYWxsIGhhbmRsZXJzLCBleGFjdGx5IG9uY2UgICovXG4gIHZhciBoYW5kbGVycyA9IGN1cnJbbmFtZV07XG4gIGN1cnJbbmFtZV0gPSBbXTsgLyogIFtQcm9taXNlcy9BKyAyLjIuMi4zLCAyLjIuMy4zXSAgKi9cbiAgdmFyIGZ1bmMgPSBmdW5jdGlvbiBmdW5jKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGhhbmRsZXJzW2ldKHZhbHVlKTtcbiAgICB9IC8qICBbUHJvbWlzZXMvQSsgMi4yLjVdICAqL1xuICB9O1xuXG4gIC8qICBleGVjdXRlIHByb2NlZHVyZSBhc3luY2hyb25vdXNseSAgKi8gLyogIFtQcm9taXNlcy9BKyAyLjIuNCwgMy4xXSAgKi9cbiAgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicpIHNldEltbWVkaWF0ZShmdW5jKTtlbHNlIHNldFRpbWVvdXQoZnVuYywgMCk7XG59O1xuXG4vKiAgZ2VuZXJhdGUgYSByZXNvbHZlciBmdW5jdGlvbiAgKi9cbnZhciByZXNvbHZlciA9IGZ1bmN0aW9uIHJlc29sdmVyKGNiLCBuZXh0LCBtZXRob2QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIC8qICBbUHJvbWlzZXMvQSsgMi4yLjEsIDIuMi43LjMsIDIuMi43LjRdICAqL1xuICAgICAgbmV4dFttZXRob2RdLmNhbGwobmV4dCwgdmFsdWUpOyAvKiAgW1Byb21pc2VzL0ErIDIuMi43LjMsIDIuMi43LjRdICAqL1xuICAgIGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlc3VsdCA9IGNiKHZhbHVlKTtcbiAgICAgICAgfSAvKiAgW1Byb21pc2VzL0ErIDIuMi4yLjEsIDIuMi4zLjEsIDIuMi41LCAzLjJdICAqL1xuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgIG5leHQucmVqZWN0KGUpOyAvKiAgW1Byb21pc2VzL0ErIDIuMi43LjJdICAqL1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKG5leHQsIHJlc3VsdCk7IC8qICBbUHJvbWlzZXMvQSsgMi4yLjcuMV0gICovXG4gICAgICB9XG4gIH07XG59O1xuXG4vKiAgXCJQcm9taXNlIFJlc29sdXRpb24gUHJvY2VkdXJlXCIgICovIC8qICBbUHJvbWlzZXMvQSsgMi4zXSAgKi9cbnZhciByZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZShwcm9taXNlLCB4KSB7XG4gIC8qICBzYW5pdHkgY2hlY2sgYXJndW1lbnRzICAqLyAvKiAgW1Byb21pc2VzL0ErIDIuMy4xXSAgKi9cbiAgaWYgKHByb21pc2UgPT09IHggfHwgcHJvbWlzZS5wcm94eSA9PT0geCkge1xuICAgIHByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoJ2Nhbm5vdCByZXNvbHZlIHByb21pc2Ugd2l0aCBpdHNlbGYnKSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyogIHN1cmdpY2FsbHkgY2hlY2sgZm9yIGEgXCJ0aGVuXCIgbWV0aG9kXG4gICAgKG1haW5seSB0byBqdXN0IGNhbGwgdGhlIFwiZ2V0dGVyXCIgb2YgXCJ0aGVuXCIgb25seSBvbmNlKSAgKi9cbiAgdmFyIHRoZW47XG4gIGlmICgodHlwZW9mIHggPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHgpKSA9PT0gJ29iamVjdCcgJiYgeCAhPT0gbnVsbCB8fCB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICB0aGVuID0geC50aGVuO1xuICAgIH0gLyogIFtQcm9taXNlcy9BKyAyLjMuMy4xLCAzLjVdICAqL1xuICAgIGNhdGNoIChlKSB7XG4gICAgICBwcm9taXNlLnJlamVjdChlKTsgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4yXSAgKi9cbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICAvKiAgaGFuZGxlIG93biBUaGVuYWJsZXMgICAgW1Byb21pc2VzL0ErIDIuMy4yXVxuICAgIGFuZCBzaW1pbGFyIFwidGhlbmFibGVzXCIgW1Byb21pc2VzL0ErIDIuMy4zXSAgKi9cbiAgaWYgKHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHJlc29sdmVkID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIC8qICBjYWxsIHJldHJpZXZlZCBcInRoZW5cIiBtZXRob2QgKi8gLyogIFtQcm9taXNlcy9BKyAyLjMuMy4zXSAgKi9cbiAgICAgIHRoZW4uY2FsbCh4LFxuICAgICAgLyogIHJlc29sdmVQcm9taXNlICAqLyAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjMuMV0gICovXG4gICAgICBmdW5jdGlvbiAoeSkge1xuICAgICAgICBpZiAocmVzb2x2ZWQpIHJldHVybjtyZXNvbHZlZCA9IHRydWU7IC8qICBbUHJvbWlzZXMvQSsgMi4zLjMuMy4zXSAgKi9cbiAgICAgICAgaWYgKHkgPT09IHgpIC8qICBbUHJvbWlzZXMvQSsgMy42XSAgKi9cbiAgICAgICAgICBwcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCdjaXJjdWxhciB0aGVuYWJsZSBjaGFpbicpKTtlbHNlIHJlc29sdmUocHJvbWlzZSwgeSk7XG4gICAgICB9LFxuXG4gICAgICAvKiAgcmVqZWN0UHJvbWlzZSAgKi8gLyogIFtQcm9taXNlcy9BKyAyLjMuMy4zLjJdICAqL1xuICAgICAgZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgaWYgKHJlc29sdmVkKSByZXR1cm47cmVzb2x2ZWQgPSB0cnVlOyAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjMuM10gICovXG4gICAgICAgIHByb21pc2UucmVqZWN0KHIpO1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKCFyZXNvbHZlZCkgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4zLjNdICAqL1xuICAgICAgICBwcm9taXNlLnJlamVjdChlKTsgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4zLjRdICAqL1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICAvKiAgaGFuZGxlIG90aGVyIHZhbHVlcyAgKi9cbiAgcHJvbWlzZS5mdWxmaWxsKHgpOyAvKiAgW1Byb21pc2VzL0ErIDIuMy40LCAyLjMuMy40XSAgKi9cbn07XG5cbi8vIHNvIHdlIGFsd2F5cyBoYXZlIFByb21pc2UuYWxsKClcbmFwaS5hbGwgPSBmdW5jdGlvbiAocHMpIHtcbiAgcmV0dXJuIG5ldyBhcGkoZnVuY3Rpb24gKHJlc29sdmVBbGwsIHJlamVjdEFsbCkge1xuICAgIHZhciB2YWxzID0gbmV3IEFycmF5KHBzLmxlbmd0aCk7XG4gICAgdmFyIGRvbmVDb3VudCA9IDA7XG5cbiAgICB2YXIgZnVsZmlsbCA9IGZ1bmN0aW9uIGZ1bGZpbGwoaSwgdmFsKSB7XG4gICAgICB2YWxzW2ldID0gdmFsO1xuICAgICAgZG9uZUNvdW50Kys7XG5cbiAgICAgIGlmIChkb25lQ291bnQgPT09IHBzLmxlbmd0aCkge1xuICAgICAgICByZXNvbHZlQWxsKHZhbHMpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgdmFyIHAgPSBwc1tpXTtcbiAgICAgICAgdmFyIGlzUHJvbWlzZSA9IHAgIT0gbnVsbCAmJiBwLnRoZW4gIT0gbnVsbDtcblxuICAgICAgICBpZiAoaXNQcm9taXNlKSB7XG4gICAgICAgICAgcC50aGVuKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIGZ1bGZpbGwoaSwgdmFsKTtcbiAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICByZWplY3RBbGwoZXJyKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdmFsID0gcDtcbiAgICAgICAgICBmdWxmaWxsKGksIHZhbCk7XG4gICAgICAgIH1cbiAgICAgIH0pKGkpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5hcGkucmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuIG5ldyBhcGkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHJlc29sdmUodmFsKTtcbiAgfSk7XG59O1xuXG5hcGkucmVqZWN0ID0gZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gbmV3IGFwaShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgcmVqZWN0KHZhbCk7XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgPyBQcm9taXNlIDogYXBpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbi8qKiovIH0pLFxuLyogNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xudmFyIG5ld1F1ZXJ5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5cbnZhciBTZWxlY3RvciA9IGZ1bmN0aW9uIFNlbGVjdG9yKHNlbGVjdG9yKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBzZWxmLl9wcml2YXRlID0ge1xuICAgIHNlbGVjdG9yVGV4dDogc2VsZWN0b3IsXG4gICAgaW52YWxpZDogdHJ1ZVxuICB9O1xuXG4gIGlmIChzZWxlY3RvciA9PSBudWxsIHx8IGlzLnN0cmluZyhzZWxlY3RvcikgJiYgc2VsZWN0b3IubWF0Y2goL15cXHMqJC8pKSB7XG5cbiAgICBzZWxmLmxlbmd0aCA9IDA7XG4gIH0gZWxzZSBpZiAoc2VsZWN0b3IgPT09ICcqJyB8fCBzZWxlY3RvciA9PT0gJ2VkZ2UnIHx8IHNlbGVjdG9yID09PSAnbm9kZScpIHtcblxuICAgIC8vIG1ha2Ugc2luZ2xlLCBncm91cC1vbmx5IHNlbGVjdG9ycyBjaGVhcCB0byBtYWtlIGFuZCBjaGVhcCB0byBmaWx0ZXJcblxuICAgIHNlbGZbMF0gPSBuZXdRdWVyeSgpO1xuICAgIHNlbGZbMF0uZ3JvdXAgPSBzZWxlY3RvciA9PT0gJyonID8gc2VsZWN0b3IgOiBzZWxlY3RvciArICdzJztcbiAgICBzZWxmWzBdLmdyb3VwT25seSA9IHRydWU7XG4gICAgc2VsZlswXS5sZW5ndGggPSAxO1xuICAgIHNlbGYuX3ByaXZhdGUuaW52YWxpZCA9IGZhbHNlO1xuICAgIHNlbGYubGVuZ3RoID0gMTtcbiAgfSBlbHNlIGlmIChpcy5lbGVtZW50T3JDb2xsZWN0aW9uKHNlbGVjdG9yKSkge1xuXG4gICAgdmFyIGNvbGxlY3Rpb24gPSBzZWxlY3Rvci5jb2xsZWN0aW9uKCk7XG5cbiAgICBzZWxmWzBdID0gbmV3UXVlcnkoKTtcbiAgICBzZWxmWzBdLmNvbGxlY3Rpb24gPSBjb2xsZWN0aW9uO1xuICAgIHNlbGZbMF0ubGVuZ3RoID0gMTtcbiAgICBzZWxmLmxlbmd0aCA9IDE7XG4gIH0gZWxzZSBpZiAoaXMuZm4oc2VsZWN0b3IpKSB7XG5cbiAgICBzZWxmWzBdID0gbmV3UXVlcnkoKTtcbiAgICBzZWxmWzBdLmZpbHRlciA9IHNlbGVjdG9yO1xuICAgIHNlbGZbMF0ubGVuZ3RoID0gMTtcbiAgICBzZWxmLmxlbmd0aCA9IDE7XG4gIH0gZWxzZSBpZiAoaXMuc3RyaW5nKHNlbGVjdG9yKSkge1xuICAgIGlmICghc2VsZi5wYXJzZShzZWxlY3RvcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdXRpbC5lcnJvcignQSBzZWxlY3RvciBtdXN0IGJlIGNyZWF0ZWQgZnJvbSBhIHN0cmluZzsgZm91bmQgJywgc2VsZWN0b3IpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHNlbGYuX3ByaXZhdGUuaW52YWxpZCA9IGZhbHNlO1xufTtcblxudmFyIHNlbGZuID0gU2VsZWN0b3IucHJvdG90eXBlO1xuXG5zZWxmbi52YWxpZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICF0aGlzLl9wcml2YXRlLmludmFsaWQ7XG59O1xuXG5zZWxmbi5pbnZhbGlkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5pbnZhbGlkO1xufTtcblxuc2VsZm4udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuc2VsZWN0b3JUZXh0O1xufTtcblxuc2VsZm4uc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubGVuZ3RoO1xufTtcblxuc2VsZm4uZXEgPSBmdW5jdGlvbiAoaSkge1xuICByZXR1cm4gdGhpc1tpXTtcbn07XG5cbnNlbGZuLnNhbWVUZXh0ID0gZnVuY3Rpb24gKG90aGVyU2VsKSB7XG4gIHJldHVybiB0aGlzLnRleHQoKSA9PT0gb3RoZXJTZWwudGV4dCgpO1xufTtcblxuc2VsZm4udG9TdHJpbmcgPSBzZWxmbi5zZWxlY3RvciA9IGZ1bmN0aW9uICgpIHtcblxuICBpZiAodGhpcy5fcHJpdmF0ZS50b1N0cmluZ0NhY2hlICE9IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS50b1N0cmluZ0NhY2hlO1xuICB9XG5cbiAgdmFyIGkgPSB2b2lkIDA7XG4gIHZhciBzdHIgPSAnJztcblxuICB2YXIgY2xlYW4gPSBmdW5jdGlvbiBjbGVhbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGNsZWFuVmFsID0gZnVuY3Rpb24gY2xlYW5WYWwodmFsKSB7XG4gICAgaWYgKGlzLnN0cmluZyh2YWwpKSB7XG4gICAgICByZXR1cm4gJ1wiJyArIHZhbCArICdcIic7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjbGVhbih2YWwpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgc3BhY2UgPSBmdW5jdGlvbiBzcGFjZSh2YWwpIHtcbiAgICByZXR1cm4gJyAnICsgdmFsICsgJyAnO1xuICB9O1xuXG4gIHZhciBxdWVyeVRvU3RyaW5nID0gZnVuY3Rpb24gcXVlcnlUb1N0cmluZyhxdWVyeSkge1xuICAgIHZhciBzdHIgPSAnJztcbiAgICB2YXIgaiA9IHZvaWQgMCxcbiAgICAgICAgc2VsID0gdm9pZCAwO1xuXG4gICAgaWYgKHF1ZXJ5LnN1YmplY3QgPT09IHF1ZXJ5KSB7XG4gICAgICBzdHIgKz0gJyQnO1xuICAgIH1cblxuICAgIHZhciBncm91cCA9IGNsZWFuKHF1ZXJ5Lmdyb3VwKTtcbiAgICBzdHIgKz0gZ3JvdXAuc3Vic3RyaW5nKDAsIGdyb3VwLmxlbmd0aCAtIDEpO1xuXG4gICAgZm9yIChqID0gMDsgaiA8IHF1ZXJ5LmRhdGEubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBkYXRhID0gcXVlcnkuZGF0YVtqXTtcblxuICAgICAgaWYgKGRhdGEudmFsdWUpIHtcbiAgICAgICAgc3RyICs9ICdbJyArIGRhdGEuZmllbGQgKyBzcGFjZShjbGVhbihkYXRhLm9wZXJhdG9yKSkgKyBjbGVhblZhbChkYXRhLnZhbHVlKSArICddJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciArPSAnWycgKyBjbGVhbihkYXRhLm9wZXJhdG9yKSArIGRhdGEuZmllbGQgKyAnXSc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChqID0gMDsgaiA8IHF1ZXJ5Lm1ldGEubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBtZXRhID0gcXVlcnkubWV0YVtqXTtcbiAgICAgIHN0ciArPSAnW1snICsgbWV0YS5maWVsZCArIHNwYWNlKGNsZWFuKG1ldGEub3BlcmF0b3IpKSArIGNsZWFuVmFsKG1ldGEudmFsdWUpICsgJ11dJztcbiAgICB9XG5cbiAgICBmb3IgKGogPSAwOyBqIDwgcXVlcnkuY29sb25TZWxlY3RvcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHNlbCA9IHF1ZXJ5LmNvbG9uU2VsZWN0b3JzW2ldO1xuICAgICAgc3RyICs9IHNlbDtcbiAgICB9XG5cbiAgICBmb3IgKGogPSAwOyBqIDwgcXVlcnkuaWRzLmxlbmd0aDsgaisrKSB7XG4gICAgICBzZWwgPSAnIycgKyBxdWVyeS5pZHNbaV07XG4gICAgICBzdHIgKz0gc2VsO1xuICAgIH1cblxuICAgIGZvciAoaiA9IDA7IGogPCBxdWVyeS5jbGFzc2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICBzZWwgPSAnLicgKyBxdWVyeS5jbGFzc2VzW2pdO1xuICAgICAgc3RyICs9IHNlbDtcbiAgICB9XG5cbiAgICBpZiAocXVlcnkuc291cmNlICE9IG51bGwgJiYgcXVlcnkudGFyZ2V0ICE9IG51bGwpIHtcbiAgICAgIHN0ciA9IHF1ZXJ5VG9TdHJpbmcocXVlcnkuc291cmNlKSArICcgLT4gJyArIHF1ZXJ5VG9TdHJpbmcocXVlcnkudGFyZ2V0KTtcbiAgICB9XG5cbiAgICBpZiAocXVlcnkuY29ubmVjdGVkTm9kZXMgIT0gbnVsbCkge1xuICAgICAgdmFyIG4gPSBxdWVyeS5jb25uZWN0ZWROb2RlcztcblxuICAgICAgc3RyID0gcXVlcnlUb1N0cmluZyhuWzBdKSArICcgPC0+ICcgKyBxdWVyeVRvU3RyaW5nKG5bMV0pO1xuICAgIH1cblxuICAgIGlmIChxdWVyeS5wYXJlbnQgIT0gbnVsbCkge1xuICAgICAgc3RyID0gcXVlcnlUb1N0cmluZyhxdWVyeS5wYXJlbnQpICsgJyA+ICcgKyBzdHI7XG4gICAgfVxuXG4gICAgaWYgKHF1ZXJ5LmFuY2VzdG9yICE9IG51bGwpIHtcbiAgICAgIHN0ciA9IHF1ZXJ5VG9TdHJpbmcocXVlcnkuYW5jZXN0b3IpICsgJyAnICsgc3RyO1xuICAgIH1cblxuICAgIGlmIChxdWVyeS5jaGlsZCAhPSBudWxsKSB7XG4gICAgICBzdHIgKz0gJyA+ICcgKyBxdWVyeVRvU3RyaW5nKHF1ZXJ5LmNoaWxkKTtcbiAgICB9XG5cbiAgICBpZiAocXVlcnkuZGVzY2VuZGFudCAhPSBudWxsKSB7XG4gICAgICBzdHIgKz0gJyAnICsgcXVlcnlUb1N0cmluZyhxdWVyeS5kZXNjZW5kYW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyO1xuICB9O1xuXG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHF1ZXJ5ID0gdGhpc1tpXTtcblxuICAgIHN0ciArPSBxdWVyeVRvU3RyaW5nKHF1ZXJ5KTtcblxuICAgIGlmICh0aGlzLmxlbmd0aCA+IDEgJiYgaSA8IHRoaXMubGVuZ3RoIC0gMSkge1xuICAgICAgc3RyICs9ICcsICc7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5fcHJpdmF0ZS50b1N0cmluZ0NhY2hlID0gc3RyO1xuXG4gIHJldHVybiBzdHI7XG59O1xuXG5bX193ZWJwYWNrX3JlcXVpcmVfXyg0OSksIF9fd2VicGFja19yZXF1aXJlX18oNTIpXS5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gIHJldHVybiB1dGlsLmFzc2lnbihzZWxmbiwgcCk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZWxlY3RvcjtcblxuLyoqKi8gfSksXG4vKiA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbnZhciBpcyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgTWFwID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCk7XG52YXIgU2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblxudmFyIEVsZW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcblxuLy8gZmFjdG9yeSBmb3IgZ2VuZXJhdGluZyBlZGdlIGlkcyB3aGVuIG5vIGlkIGlzIHNwZWNpZmllZCBmb3IgYSBuZXcgZWxlbWVudFxudmFyIGlkRmFjdG9yeSA9IHtcbiAgZ2VuZXJhdGU6IGZ1bmN0aW9uIGdlbmVyYXRlKGN5LCBlbGVtZW50LCB0cnlUaGlzSWQpIHtcbiAgICB2YXIgaWQgPSB0cnlUaGlzSWQgIT0gbnVsbCA/IHRyeVRoaXNJZCA6IHV0aWwudXVpZCgpO1xuXG4gICAgd2hpbGUgKGN5Lmhhc0VsZW1lbnRXaXRoSWQoaWQpKSB7XG4gICAgICBpZCA9IHV0aWwudXVpZCgpO1xuICAgIH1cblxuICAgIHJldHVybiBpZDtcbiAgfVxufTtcblxuLy8gcmVwcmVzZW50cyBhIHNldCBvZiBub2RlcywgZWRnZXMsIG9yIGJvdGggdG9nZXRoZXJcbnZhciBDb2xsZWN0aW9uID0gZnVuY3Rpb24gQ29sbGVjdGlvbihjeSwgZWxlbWVudHMsIG9wdGlvbnMpIHtcbiAgaWYgKGN5ID09PSB1bmRlZmluZWQgfHwgIWlzLmNvcmUoY3kpKSB7XG4gICAgdXRpbC5lcnJvcignQSBjb2xsZWN0aW9uIG11c3QgaGF2ZSBhIHJlZmVyZW5jZSB0byB0aGUgY29yZScpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBtYXAgPSBuZXcgTWFwKCk7XG4gIHZhciBjcmVhdGVkRWxlbWVudHMgPSBmYWxzZTtcblxuICBpZiAoIWVsZW1lbnRzKSB7XG4gICAgZWxlbWVudHMgPSBbXTtcbiAgfSBlbHNlIGlmIChlbGVtZW50cy5sZW5ndGggPiAwICYmIGlzLnBsYWluT2JqZWN0KGVsZW1lbnRzWzBdKSAmJiAhaXMuZWxlbWVudChlbGVtZW50c1swXSkpIHtcbiAgICBjcmVhdGVkRWxlbWVudHMgPSB0cnVlO1xuXG4gICAgLy8gbWFrZSBlbGVtZW50cyBmcm9tIGpzb24gYW5kIHJlc3RvcmUgYWxsIGF0IG9uY2UgbGF0ZXJcbiAgICB2YXIgZWxlcyA9IFtdO1xuICAgIHZhciBlbGVzSWRzID0gbmV3IFNldCgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBlbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBqc29uID0gZWxlbWVudHNbaV07XG5cbiAgICAgIGlmIChqc29uLmRhdGEgPT0gbnVsbCkge1xuICAgICAgICBqc29uLmRhdGEgPSB7fTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRhdGEgPSBqc29uLmRhdGE7XG5cbiAgICAgIC8vIG1ha2Ugc3VyZSBuZXdseSBjcmVhdGVkIGVsZW1lbnRzIGhhdmUgdmFsaWQgaWRzXG4gICAgICBpZiAoZGF0YS5pZCA9PSBudWxsKSB7XG4gICAgICAgIGRhdGEuaWQgPSBpZEZhY3RvcnkuZ2VuZXJhdGUoY3ksIGpzb24pO1xuICAgICAgfSBlbHNlIGlmIChjeS5oYXNFbGVtZW50V2l0aElkKGRhdGEuaWQpIHx8IGVsZXNJZHMuaGFzKGRhdGEuaWQpKSB7XG4gICAgICAgIGNvbnRpbnVlOyAvLyBjYW4ndCBjcmVhdGUgZWxlbWVudCBpZiBwcmlvciBpZCBhbHJlYWR5IGV4aXN0c1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxlID0gbmV3IEVsZW1lbnQoY3ksIGpzb24sIGZhbHNlKTtcbiAgICAgIGVsZXMucHVzaChlbGUpO1xuICAgICAgZWxlc0lkcy5hZGQoZGF0YS5pZCk7XG4gICAgfVxuXG4gICAgZWxlbWVudHMgPSBlbGVzO1xuICB9XG5cbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIGZvciAodmFyIF9pID0gMCwgX2wgPSBlbGVtZW50cy5sZW5ndGg7IF9pIDwgX2w7IF9pKyspIHtcbiAgICB2YXIgZWxlbWVudCA9IGVsZW1lbnRzW19pXTtcbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgaWQgPSBlbGVtZW50Ll9wcml2YXRlLmRhdGEuaWQ7XG5cbiAgICBpZiAob3B0aW9ucyA9PSBudWxsIHx8IG9wdGlvbnMudW5pcXVlICYmICFtYXAuaGFzKGlkKSkge1xuICAgICAgbWFwLnNldChpZCwge1xuICAgICAgICBpbmRleDogdGhpcy5sZW5ndGgsXG4gICAgICAgIGVsZTogZWxlbWVudFxuICAgICAgfSk7XG5cbiAgICAgIHRoaXNbdGhpcy5sZW5ndGhdID0gZWxlbWVudDtcbiAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5fcHJpdmF0ZSA9IHtcbiAgICBjeTogY3ksXG4gICAgbWFwOiBtYXBcbiAgfTtcblxuICAvLyByZXN0b3JlIHRoZSBlbGVtZW50cyBpZiB3ZSBjcmVhdGVkIHRoZW0gZnJvbSBqc29uXG4gIGlmIChjcmVhdGVkRWxlbWVudHMpIHtcbiAgICB0aGlzLnJlc3RvcmUoKTtcbiAgfVxufTtcblxuLy8gRnVuY3Rpb25zXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8vIGtlZXAgdGhlIHByb3RvdHlwZXMgaW4gc3luYyAoYW4gZWxlbWVudCBoYXMgdGhlIHNhbWUgZnVuY3Rpb25zIGFzIGEgY29sbGVjdGlvbilcbi8vIGFuZCB1c2UgZWxlZm4gYW5kIGVsZXNmbiBhcyBzaG9ydGhhbmRzIHRvIHRoZSBwcm90b3R5cGVzXG52YXIgZWxlc2ZuID0gRWxlbWVudC5wcm90b3R5cGUgPSBDb2xsZWN0aW9uLnByb3RvdHlwZTtcblxuZWxlc2ZuLmluc3RhbmNlU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJ2NvbGxlY3Rpb24nO1xufTtcblxuZWxlc2ZuLnNwYXduID0gZnVuY3Rpb24gKGN5LCBlbGVzLCBvcHRzKSB7XG4gIGlmICghaXMuY29yZShjeSkpIHtcbiAgICAvLyBjeSBpcyBvcHRpb25hbFxuICAgIG9wdHMgPSBlbGVzO1xuICAgIGVsZXMgPSBjeTtcbiAgICBjeSA9IHRoaXMuY3koKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgQ29sbGVjdGlvbihjeSwgZWxlcywgb3B0cyk7XG59O1xuXG5lbGVzZm4uc3Bhd25TZWxmID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5zcGF3bih0aGlzKTtcbn07XG5cbmVsZXNmbi5jeSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuY3k7XG59O1xuXG5lbGVzZm4ucmVuZGVyZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9wcml2YXRlLmN5LnJlbmRlcmVyKCk7XG59O1xuXG5lbGVzZm4uZWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXNbMF07XG59O1xuXG5lbGVzZm4uY29sbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKGlzLmNvbGxlY3Rpb24odGhpcykpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSBlbHNlIHtcbiAgICAvLyBhbiBlbGVtZW50XG4gICAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uKHRoaXMuX3ByaXZhdGUuY3ksIFt0aGlzXSk7XG4gIH1cbn07XG5cbmVsZXNmbi51bmlxdWUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXcgQ29sbGVjdGlvbih0aGlzLl9wcml2YXRlLmN5LCB0aGlzLCB7IHVuaXF1ZTogdHJ1ZSB9KTtcbn07XG5cbmVsZXNmbi5oYXNFbGVtZW50V2l0aElkID0gZnVuY3Rpb24gKGlkKSB7XG4gIHJldHVybiB0aGlzLl9wcml2YXRlLm1hcC5oYXMoaWQpO1xufTtcblxuZWxlc2ZuLmdldEVsZW1lbnRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gIHZhciBlbnRyeSA9IHRoaXMuX3ByaXZhdGUubWFwLmdldChpZCk7XG5cbiAgcmV0dXJuIGVudHJ5ID8gZW50cnkuZWxlIDogbmV3IENvbGxlY3Rpb24oY3kpOyAvLyBnZXQgZWxlIG9yIGVtcHR5IGNvbGxlY3Rpb25cbn07XG5cbmVsZXNmbi4kaWQgPSBlbGVzZm4uZ2V0RWxlbWVudEJ5SWQ7XG5cbmVsZXNmbi5wb29sSW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gIHZhciBlbGVzID0gY3kuX3ByaXZhdGUuZWxlbWVudHM7XG4gIHZhciBpZCA9IHRoaXMuX3ByaXZhdGUuZGF0YS5pZDtcblxuICByZXR1cm4gZWxlcy5fcHJpdmF0ZS5tYXAuZ2V0KGlkKS5pbmRleDtcbn07XG5cbmVsZXNmbi5qc29uID0gZnVuY3Rpb24gKG9iaikge1xuICB2YXIgZWxlID0gdGhpcy5lbGVtZW50KCk7XG4gIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICBpZiAoZWxlID09IG51bGwgJiYgb2JqKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gY2FuJ3Qgc2V0IHRvIG5vIGVsZXNcblxuICBpZiAoZWxlID09IG51bGwpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9IC8vIGNhbid0IGdldCBmcm9tIG5vIGVsZXNcblxuICB2YXIgcCA9IGVsZS5fcHJpdmF0ZTtcblxuICBpZiAoaXMucGxhaW5PYmplY3Qob2JqKSkge1xuICAgIC8vIHNldFxuXG4gICAgY3kuc3RhcnRCYXRjaCgpO1xuXG4gICAgaWYgKG9iai5kYXRhKSB7XG4gICAgICBlbGUuZGF0YShvYmouZGF0YSk7XG5cbiAgICAgIHZhciBkYXRhID0gcC5kYXRhO1xuXG4gICAgICBpZiAoZWxlLmlzRWRnZSgpKSB7XG4gICAgICAgIC8vIHNvdXJjZSBhbmQgdGFyZ2V0IGFyZSBpbW11dGFibGUgdmlhIGRhdGEoKVxuICAgICAgICB2YXIgbW92ZSA9IGZhbHNlO1xuICAgICAgICB2YXIgc3BlYyA9IHt9O1xuICAgICAgICB2YXIgc3JjID0gb2JqLmRhdGEuc291cmNlO1xuICAgICAgICB2YXIgdGd0ID0gb2JqLmRhdGEudGFyZ2V0O1xuXG4gICAgICAgIGlmIChzcmMgIT0gbnVsbCAmJiBzcmMgIT09IGRhdGEuc291cmNlKSB7XG4gICAgICAgICAgc3BlYy5zb3VyY2UgPSBzcmM7XG4gICAgICAgICAgbW92ZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGd0ICE9IG51bGwgJiYgdGd0ICE9PSBkYXRhLnRhcmdldCkge1xuICAgICAgICAgIHNwZWMudGFyZ2V0ID0gdGd0O1xuICAgICAgICAgIG1vdmUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1vdmUpIHtcbiAgICAgICAgICBlbGUgPSBlbGUubW92ZShzcGVjKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcGFyZW50IGlzIGltbXV0YWJsZSB2aWEgZGF0YSgpXG4gICAgICAgIHZhciBwYXJlbnQgPSBvYmouZGF0YS5wYXJlbnQ7XG5cbiAgICAgICAgaWYgKHBhcmVudCAhPSBudWxsICYmIHBhcmVudCAhPT0gZGF0YS5wYXJlbnQpIHtcbiAgICAgICAgICBlbGUgPSBlbGUubW92ZSh7IHBhcmVudDogcGFyZW50IH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9iai5wb3NpdGlvbikge1xuICAgICAgZWxlLnBvc2l0aW9uKG9iai5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgLy8gaWdub3JlIGdyb3VwIC0tIGltbXV0YWJsZVxuXG4gICAgdmFyIGNoZWNrU3dpdGNoID0gZnVuY3Rpb24gY2hlY2tTd2l0Y2goaywgdHJ1ZUZuTmFtZSwgZmFsc2VGbk5hbWUpIHtcbiAgICAgIHZhciBvYmpfayA9IG9ialtrXTtcblxuICAgICAgaWYgKG9ial9rICE9IG51bGwgJiYgb2JqX2sgIT09IHBba10pIHtcbiAgICAgICAgaWYgKG9ial9rKSB7XG4gICAgICAgICAgZWxlW3RydWVGbk5hbWVdKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWxlW2ZhbHNlRm5OYW1lXSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNoZWNrU3dpdGNoKCdyZW1vdmVkJywgJ3JlbW92ZScsICdyZXN0b3JlJyk7XG5cbiAgICBjaGVja1N3aXRjaCgnc2VsZWN0ZWQnLCAnc2VsZWN0JywgJ3Vuc2VsZWN0Jyk7XG5cbiAgICBjaGVja1N3aXRjaCgnc2VsZWN0YWJsZScsICdzZWxlY3RpZnknLCAndW5zZWxlY3RpZnknKTtcblxuICAgIGNoZWNrU3dpdGNoKCdsb2NrZWQnLCAnbG9jaycsICd1bmxvY2snKTtcblxuICAgIGNoZWNrU3dpdGNoKCdncmFiYmFibGUnLCAnZ3JhYmlmeScsICd1bmdyYWJpZnknKTtcblxuICAgIGlmIChvYmouY2xhc3NlcyAhPSBudWxsKSB7XG4gICAgICBlbGUuY2xhc3NlcyhvYmouY2xhc3Nlcyk7XG4gICAgfVxuXG4gICAgY3kuZW5kQmF0Y2goKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9IGVsc2UgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gZ2V0XG5cbiAgICB2YXIganNvbiA9IHtcbiAgICAgIGRhdGE6IHV0aWwuY29weShwLmRhdGEpLFxuICAgICAgcG9zaXRpb246IHV0aWwuY29weShwLnBvc2l0aW9uKSxcbiAgICAgIGdyb3VwOiBwLmdyb3VwLFxuICAgICAgcmVtb3ZlZDogcC5yZW1vdmVkLFxuICAgICAgc2VsZWN0ZWQ6IHAuc2VsZWN0ZWQsXG4gICAgICBzZWxlY3RhYmxlOiBwLnNlbGVjdGFibGUsXG4gICAgICBsb2NrZWQ6IHAubG9ja2VkLFxuICAgICAgZ3JhYmJhYmxlOiBwLmdyYWJiYWJsZSxcbiAgICAgIGNsYXNzZXM6IG51bGxcbiAgICB9O1xuXG4gICAganNvbi5jbGFzc2VzID0gJyc7XG5cbiAgICB2YXIgaSA9IDA7XG4gICAgcC5jbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNscykge1xuICAgICAgcmV0dXJuIGpzb24uY2xhc3NlcyArPSBpKysgPT09IDAgPyBjbHMgOiAnICcgKyBjbHM7XG4gICAgfSk7XG5cbiAgICByZXR1cm4ganNvbjtcbiAgfVxufTtcblxuZWxlc2ZuLmpzb25zID0gZnVuY3Rpb24gKCkge1xuICB2YXIganNvbnMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICB2YXIganNvbiA9IGVsZS5qc29uKCk7XG5cbiAgICBqc29ucy5wdXNoKGpzb24pO1xuICB9XG5cbiAgcmV0dXJuIGpzb25zO1xufTtcblxuZWxlc2ZuLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gIHZhciBlbGVzQXJyID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgdmFyIGpzb24gPSBlbGUuanNvbigpO1xuICAgIHZhciBjbG9uZSA9IG5ldyBFbGVtZW50KGN5LCBqc29uLCBmYWxzZSk7IC8vIE5CIG5vIHJlc3RvcmVcblxuICAgIGVsZXNBcnIucHVzaChjbG9uZSk7XG4gIH1cblxuICByZXR1cm4gbmV3IENvbGxlY3Rpb24oY3ksIGVsZXNBcnIpO1xufTtcbmVsZXNmbi5jb3B5ID0gZWxlc2ZuLmNsb25lO1xuXG5lbGVzZm4ucmVzdG9yZSA9IGZ1bmN0aW9uIChub3RpZnlSZW5kZXJlcikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBjeSA9IHNlbGYuY3koKTtcbiAgdmFyIGN5X3AgPSBjeS5fcHJpdmF0ZTtcblxuICBpZiAobm90aWZ5UmVuZGVyZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIG5vdGlmeVJlbmRlcmVyID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGNyZWF0ZSBhcnJheXMgb2Ygbm9kZXMgYW5kIGVkZ2VzLCBzaW5jZSB3ZSBuZWVkIHRvXG4gIC8vIHJlc3RvcmUgdGhlIG5vZGVzIGZpcnN0XG4gIHZhciBub2RlcyA9IFtdO1xuICB2YXIgZWRnZXMgPSBbXTtcbiAgdmFyIGVsZW1lbnRzID0gdm9pZCAwO1xuICBmb3IgKHZhciBfaTIgPSAwLCBsID0gc2VsZi5sZW5ndGg7IF9pMiA8IGw7IF9pMisrKSB7XG4gICAgdmFyIGVsZSA9IHNlbGZbX2kyXTtcblxuICAgIGlmICghZWxlLnJlbW92ZWQoKSkge1xuICAgICAgLy8gZG9uJ3QgbmVlZCB0byBoYW5kbGUgdGhpcyBlbGVcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGtlZXAgbm9kZXMgZmlyc3QgaW4gdGhlIGFycmF5IGFuZCBlZGdlcyBhZnRlclxuICAgIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICAgIC8vIHB1dCB0byBmcm9udCBvZiBhcnJheSBpZiBub2RlXG4gICAgICBub2Rlcy5wdXNoKGVsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHB1dCB0byBlbmQgb2YgYXJyYXkgaWYgZWRnZVxuICAgICAgZWRnZXMucHVzaChlbGUpO1xuICAgIH1cbiAgfVxuXG4gIGVsZW1lbnRzID0gbm9kZXMuY29uY2F0KGVkZ2VzKTtcblxuICB2YXIgaSA9IHZvaWQgMDtcbiAgdmFyIHJlbW92ZUZyb21FbGVtZW50cyA9IGZ1bmN0aW9uIHJlbW92ZUZyb21FbGVtZW50cygpIHtcbiAgICBlbGVtZW50cy5zcGxpY2UoaSwgMSk7XG4gICAgaS0tO1xuICB9O1xuXG4gIC8vIG5vdywgcmVzdG9yZSBlYWNoIGVsZW1lbnRcbiAgZm9yIChpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIF9lbGUgPSBlbGVtZW50c1tpXTtcblxuICAgIHZhciBfcHJpdmF0ZSA9IF9lbGUuX3ByaXZhdGU7XG4gICAgdmFyIGRhdGEgPSBfcHJpdmF0ZS5kYXRhO1xuXG4gICAgLy8gdGhlIHRyYXZlcnNhbCBjYWNoZSBzaG91bGQgc3RhcnQgZnJlc2ggd2hlbiBlbGUgaXMgYWRkZWRcbiAgICBfZWxlLmNsZWFyVHJhdmVyc2FsQ2FjaGUoKTtcblxuICAgIC8vIHNldCBpZCBhbmQgdmFsaWRhdGVcbiAgICBpZiAoZGF0YS5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBkYXRhLmlkID0gaWRGYWN0b3J5LmdlbmVyYXRlKGN5LCBfZWxlKTtcbiAgICB9IGVsc2UgaWYgKGlzLm51bWJlcihkYXRhLmlkKSkge1xuICAgICAgZGF0YS5pZCA9ICcnICsgZGF0YS5pZDsgLy8gbm93IGl0J3MgYSBzdHJpbmdcbiAgICB9IGVsc2UgaWYgKGlzLmVtcHR5U3RyaW5nKGRhdGEuaWQpIHx8ICFpcy5zdHJpbmcoZGF0YS5pZCkpIHtcbiAgICAgIHV0aWwuZXJyb3IoJ0NhbiBub3QgY3JlYXRlIGVsZW1lbnQgd2l0aCBpbnZhbGlkIHN0cmluZyBJRCBgJyArIGRhdGEuaWQgKyAnYCcpO1xuXG4gICAgICAvLyBjYW4ndCBjcmVhdGUgZWxlbWVudCBpZiBpdCBoYXMgZW1wdHkgc3RyaW5nIGFzIGlkIG9yIG5vbi1zdHJpbmcgaWRcbiAgICAgIHJlbW92ZUZyb21FbGVtZW50cygpO1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIGlmIChjeS5oYXNFbGVtZW50V2l0aElkKGRhdGEuaWQpKSB7XG4gICAgICB1dGlsLmVycm9yKCdDYW4gbm90IGNyZWF0ZSBzZWNvbmQgZWxlbWVudCB3aXRoIElEIGAnICsgZGF0YS5pZCArICdgJyk7XG5cbiAgICAgIC8vIGNhbid0IGNyZWF0ZSBlbGVtZW50IGlmIG9uZSBhbHJlYWR5IGhhcyB0aGF0IGlkXG4gICAgICByZW1vdmVGcm9tRWxlbWVudHMoKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBpZCA9IGRhdGEuaWQ7IC8vIGlkIGlzIGZpbmFsaXNlZCwgbm93IGxldCdzIGtlZXAgYSByZWZcblxuICAgIGlmIChfZWxlLmlzTm9kZSgpKSB7XG4gICAgICAvLyBleHRyYSBjaGVja3MgZm9yIG5vZGVzXG4gICAgICB2YXIgcG9zID0gX3ByaXZhdGUucG9zaXRpb247XG5cbiAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgbm9kZXMgaGF2ZSBhIGRlZmluZWQgcG9zaXRpb25cblxuICAgICAgaWYgKHBvcy54ID09IG51bGwpIHtcbiAgICAgICAgcG9zLnggPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAocG9zLnkgPT0gbnVsbCkge1xuICAgICAgICBwb3MueSA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKF9lbGUuaXNFZGdlKCkpIHtcbiAgICAgIC8vIGV4dHJhIGNoZWNrcyBmb3IgZWRnZXNcblxuICAgICAgdmFyIGVkZ2UgPSBfZWxlO1xuICAgICAgdmFyIGZpZWxkcyA9IFsnc291cmNlJywgJ3RhcmdldCddO1xuICAgICAgdmFyIGZpZWxkc0xlbmd0aCA9IGZpZWxkcy5sZW5ndGg7XG4gICAgICB2YXIgYmFkU291cmNlT3JUYXJnZXQgPSBmYWxzZTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZmllbGRzTGVuZ3RoOyBqKyspIHtcblxuICAgICAgICB2YXIgZmllbGQgPSBmaWVsZHNbal07XG4gICAgICAgIHZhciB2YWwgPSBkYXRhW2ZpZWxkXTtcblxuICAgICAgICBpZiAoaXMubnVtYmVyKHZhbCkpIHtcbiAgICAgICAgICB2YWwgPSBkYXRhW2ZpZWxkXSA9ICcnICsgZGF0YVtmaWVsZF07IC8vIG5vdyBzdHJpbmdcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWwgPT0gbnVsbCB8fCB2YWwgPT09ICcnKSB7XG4gICAgICAgICAgLy8gY2FuJ3QgY3JlYXRlIGlmIHNvdXJjZSBvciB0YXJnZXQgaXMgbm90IGRlZmluZWQgcHJvcGVybHlcbiAgICAgICAgICB1dGlsLmVycm9yKCdDYW4gbm90IGNyZWF0ZSBlZGdlIGAnICsgaWQgKyAnYCB3aXRoIHVuc3BlY2lmaWVkICcgKyBmaWVsZCk7XG4gICAgICAgICAgYmFkU291cmNlT3JUYXJnZXQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKCFjeS5oYXNFbGVtZW50V2l0aElkKHZhbCkpIHtcbiAgICAgICAgICAvLyBjYW4ndCBjcmVhdGUgZWRnZSBpZiBvbmUgb2YgaXRzIG5vZGVzIGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgICB1dGlsLmVycm9yKCdDYW4gbm90IGNyZWF0ZSBlZGdlIGAnICsgaWQgKyAnYCB3aXRoIG5vbmV4aXN0YW50ICcgKyBmaWVsZCArICcgYCcgKyB2YWwgKyAnYCcpO1xuICAgICAgICAgIGJhZFNvdXJjZU9yVGFyZ2V0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYmFkU291cmNlT3JUYXJnZXQpIHtcbiAgICAgICAgcmVtb3ZlRnJvbUVsZW1lbnRzKCk7Y29udGludWU7XG4gICAgICB9IC8vIGNhbid0IGNyZWF0ZSB0aGlzXG5cbiAgICAgIHZhciBzcmMgPSBjeS5nZXRFbGVtZW50QnlJZChkYXRhLnNvdXJjZSk7XG4gICAgICB2YXIgdGd0ID0gY3kuZ2V0RWxlbWVudEJ5SWQoZGF0YS50YXJnZXQpO1xuXG4gICAgICBzcmMuX3ByaXZhdGUuZWRnZXMucHVzaChlZGdlKTtcbiAgICAgIHRndC5fcHJpdmF0ZS5lZGdlcy5wdXNoKGVkZ2UpO1xuXG4gICAgICBlZGdlLl9wcml2YXRlLnNvdXJjZSA9IHNyYztcbiAgICAgIGVkZ2UuX3ByaXZhdGUudGFyZ2V0ID0gdGd0O1xuICAgIH0gLy8gaWYgaXMgZWRnZVxuXG4gICAgLy8gY3JlYXRlIG1vY2sgaWRzIC8gaW5kZXhlcyBtYXBzIGZvciBlbGVtZW50IHNvIGl0IGNhbiBiZSB1c2VkIGxpa2UgY29sbGVjdGlvbnNcbiAgICBfcHJpdmF0ZS5tYXAgPSBuZXcgTWFwKCk7XG4gICAgX3ByaXZhdGUubWFwLnNldChpZCwgeyBlbGU6IF9lbGUsIGluZGV4OiAwIH0pO1xuXG4gICAgX3ByaXZhdGUucmVtb3ZlZCA9IGZhbHNlO1xuICAgIGN5LmFkZFRvUG9vbChfZWxlKTtcbiAgfSAvLyBmb3IgZWFjaCBlbGVtZW50XG5cbiAgLy8gZG8gY29tcG91bmQgbm9kZSBzYW5pdHkgY2hlY2tzXG4gIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IG5vZGVzLmxlbmd0aDsgX2kzKyspIHtcbiAgICAvLyBlYWNoIG5vZGVcbiAgICB2YXIgbm9kZSA9IG5vZGVzW19pM107XG4gICAgdmFyIF9kYXRhID0gbm9kZS5fcHJpdmF0ZS5kYXRhO1xuXG4gICAgaWYgKGlzLm51bWJlcihfZGF0YS5wYXJlbnQpKSB7XG4gICAgICAvLyB0aGVuIGF1dG9tYWtlIHN0cmluZ1xuICAgICAgX2RhdGEucGFyZW50ID0gJycgKyBfZGF0YS5wYXJlbnQ7XG4gICAgfVxuXG4gICAgdmFyIHBhcmVudElkID0gX2RhdGEucGFyZW50O1xuXG4gICAgdmFyIHNwZWNpZmllZFBhcmVudCA9IHBhcmVudElkICE9IG51bGw7XG5cbiAgICBpZiAoc3BlY2lmaWVkUGFyZW50KSB7XG4gICAgICB2YXIgcGFyZW50ID0gY3kuZ2V0RWxlbWVudEJ5SWQocGFyZW50SWQpO1xuXG4gICAgICBpZiAocGFyZW50LmVtcHR5KCkpIHtcbiAgICAgICAgLy8gbm9uLWV4aXN0YW50IHBhcmVudDsganVzdCByZW1vdmUgaXRcbiAgICAgICAgX2RhdGEucGFyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNlbGZBc1BhcmVudCA9IGZhbHNlO1xuICAgICAgICB2YXIgYW5jZXN0b3IgPSBwYXJlbnQ7XG4gICAgICAgIHdoaWxlICghYW5jZXN0b3IuZW1wdHkoKSkge1xuICAgICAgICAgIGlmIChub2RlLnNhbWUoYW5jZXN0b3IpKSB7XG4gICAgICAgICAgICAvLyBtYXJrIHNlbGYgYXMgcGFyZW50IGFuZCByZW1vdmUgZnJvbSBkYXRhXG4gICAgICAgICAgICBzZWxmQXNQYXJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgX2RhdGEucGFyZW50ID0gdW5kZWZpbmVkOyAvLyByZW1vdmUgcGFyZW50IHJlZmVyZW5jZVxuXG4gICAgICAgICAgICAvLyBleGl0IG9yIHdlIGxvb3AgZm9yZXZlclxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc2VsZkFzUGFyZW50KSB7XG4gICAgICAgICAgLy8gY29ubmVjdCB3aXRoIGNoaWxkcmVuXG4gICAgICAgICAgcGFyZW50WzBdLl9wcml2YXRlLmNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICAgICAgbm9kZS5fcHJpdmF0ZS5wYXJlbnQgPSBwYXJlbnRbMF07XG5cbiAgICAgICAgICAvLyBsZXQgdGhlIGNvcmUga25vdyB3ZSBoYXZlIGEgY29tcG91bmQgZ3JhcGhcbiAgICAgICAgICBjeV9wLmhhc0NvbXBvdW5kTm9kZXMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IC8vIGVsc2VcbiAgICB9IC8vIGlmIHNwZWNpZmllZCBwYXJlbnRcbiAgfSAvLyBmb3IgZWFjaCBub2RlXG5cbiAgaWYgKGVsZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgcmVzdG9yZWQgPSBuZXcgQ29sbGVjdGlvbihjeSwgZWxlbWVudHMpO1xuXG4gICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgcmVzdG9yZWQubGVuZ3RoOyBfaTQrKykge1xuICAgICAgdmFyIF9lbGUyID0gcmVzdG9yZWRbX2k0XTtcblxuICAgICAgaWYgKF9lbGUyLmlzTm9kZSgpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBhZGRpbmcgYW4gZWRnZSBpbnZhbGlkYXRlcyB0aGUgdHJhdmVyc2FsIGNhY2hlcyBmb3IgdGhlIHBhcmFsbGVsIGVkZ2VzXG4gICAgICBfZWxlMi5wYXJhbGxlbEVkZ2VzKCkuY2xlYXJUcmF2ZXJzYWxDYWNoZSgpO1xuXG4gICAgICAvLyBhZGRpbmcgYW4gZWRnZSBpbnZhbGlkYXRlcyB0aGUgdHJhdmVyc2FsIGNhY2hlIGZvciB0aGUgY29ubmVjdGVkIG5vZGVzXG4gICAgICBfZWxlMi5zb3VyY2UoKS5jbGVhclRyYXZlcnNhbENhY2hlKCk7XG4gICAgICBfZWxlMi50YXJnZXQoKS5jbGVhclRyYXZlcnNhbENhY2hlKCk7XG4gICAgfVxuXG4gICAgdmFyIHRvVXBkYXRlU3R5bGUgPSB2b2lkIDA7XG5cbiAgICBpZiAoY3lfcC5oYXNDb21wb3VuZE5vZGVzKSB7XG4gICAgICB0b1VwZGF0ZVN0eWxlID0gY3kuY29sbGVjdGlvbigpLm1lcmdlKHJlc3RvcmVkKS5tZXJnZShyZXN0b3JlZC5jb25uZWN0ZWROb2RlcygpKS5tZXJnZShyZXN0b3JlZC5wYXJlbnQoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvVXBkYXRlU3R5bGUgPSByZXN0b3JlZDtcbiAgICB9XG5cbiAgICB0b1VwZGF0ZVN0eWxlLmRpcnR5Q29tcG91bmRCb3VuZHNDYWNoZSgpLnVwZGF0ZVN0eWxlKG5vdGlmeVJlbmRlcmVyKTtcblxuICAgIGlmIChub3RpZnlSZW5kZXJlcikge1xuICAgICAgcmVzdG9yZWQuZW1pdEFuZE5vdGlmeSgnYWRkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3RvcmVkLmVtaXQoJ2FkZCcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZWxmOyAvLyBjaGFpbmFiaWxpdHlcbn07XG5cbmVsZXNmbi5yZW1vdmVkID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZWxlID0gdGhpc1swXTtcbiAgcmV0dXJuIGVsZSAmJiBlbGUuX3ByaXZhdGUucmVtb3ZlZDtcbn07XG5cbmVsZXNmbi5pbnNpZGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBlbGUgPSB0aGlzWzBdO1xuICByZXR1cm4gZWxlICYmICFlbGUuX3ByaXZhdGUucmVtb3ZlZDtcbn07XG5cbmVsZXNmbi5yZW1vdmUgPSBmdW5jdGlvbiAobm90aWZ5UmVuZGVyZXIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcmVtb3ZlZCA9IFtdO1xuICB2YXIgZWxlc1RvUmVtb3ZlID0gW107XG4gIHZhciBlbGVzVG9SZW1vdmVJZHMgPSB7fTtcbiAgdmFyIGN5ID0gc2VsZi5fcHJpdmF0ZS5jeTtcblxuICBpZiAobm90aWZ5UmVuZGVyZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIG5vdGlmeVJlbmRlcmVyID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGFkZCBjb25uZWN0ZWQgZWRnZXNcbiAgZnVuY3Rpb24gYWRkQ29ubmVjdGVkRWRnZXMobm9kZSkge1xuICAgIHZhciBlZGdlcyA9IG5vZGUuX3ByaXZhdGUuZWRnZXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgYWRkKGVkZ2VzW2ldKTtcbiAgICB9XG4gIH1cblxuICAvLyBhZGQgZGVzY2VuZGFudCBub2Rlc1xuICBmdW5jdGlvbiBhZGRDaGlsZHJlbihub2RlKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gbm9kZS5fcHJpdmF0ZS5jaGlsZHJlbjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFkZChjaGlsZHJlbltpXSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkKGVsZSkge1xuICAgIHZhciBhbHJlYWR5QWRkZWQgPSBlbGVzVG9SZW1vdmVJZHNbZWxlLmlkKCldO1xuICAgIGlmIChlbGUucmVtb3ZlZCgpIHx8IGFscmVhZHlBZGRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVzVG9SZW1vdmVJZHNbZWxlLmlkKCldID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICBlbGVzVG9SZW1vdmUucHVzaChlbGUpOyAvLyBub2RlcyBhcmUgcmVtb3ZlZCBsYXN0XG5cbiAgICAgIGFkZENvbm5lY3RlZEVkZ2VzKGVsZSk7XG4gICAgICBhZGRDaGlsZHJlbihlbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVzVG9SZW1vdmUudW5zaGlmdChlbGUpOyAvLyBlZGdlcyBhcmUgcmVtb3ZlZCBmaXJzdFxuICAgIH1cbiAgfVxuXG4gIC8vIG1ha2UgdGhlIGxpc3Qgb2YgZWxlbWVudHMgdG8gcmVtb3ZlXG4gIC8vIChtYXkgYmUgcmVtb3ZpbmcgbW9yZSB0aGFuIHNwZWNpZmllZCBkdWUgdG8gY29ubmVjdGVkIGVkZ2VzIGV0YylcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IHNlbGYubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGVsZSA9IHNlbGZbaV07XG5cbiAgICBhZGQoZWxlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUVkZ2VSZWYobm9kZSwgZWRnZSkge1xuICAgIHZhciBjb25uZWN0ZWRFZGdlcyA9IG5vZGUuX3ByaXZhdGUuZWRnZXM7XG5cbiAgICB1dGlsLnJlbW92ZUZyb21BcnJheShjb25uZWN0ZWRFZGdlcywgZWRnZSk7XG5cbiAgICAvLyByZW1vdmluZyBhbiBlZGdlcyBpbnZhbGlkYXRlcyB0aGUgdHJhdmVyc2FsIGNhY2hlIGZvciBpdHMgbm9kZXNcbiAgICBub2RlLmNsZWFyVHJhdmVyc2FsQ2FjaGUoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZVBhcmFsbGVsUmVmcyhlZGdlKSB7XG4gICAgLy8gcmVtb3ZpbmcgYW4gZWRnZSBpbnZhbGlkYXRlcyB0aGUgdHJhdmVyc2FsIGNhY2hlcyBmb3IgdGhlIHBhcmFsbGVsIGVkZ2VzXG4gICAgZWRnZS5wYXJhbGxlbEVkZ2VzKCkuY2xlYXJUcmF2ZXJzYWxDYWNoZSgpO1xuICB9XG5cbiAgdmFyIGFsdGVyZWRQYXJlbnRzID0gW107XG4gIGFsdGVyZWRQYXJlbnRzLmlkcyA9IHt9O1xuXG4gIGZ1bmN0aW9uIHJlbW92ZUNoaWxkUmVmKHBhcmVudCwgZWxlKSB7XG4gICAgZWxlID0gZWxlWzBdO1xuICAgIHBhcmVudCA9IHBhcmVudFswXTtcblxuICAgIHZhciBjaGlsZHJlbiA9IHBhcmVudC5fcHJpdmF0ZS5jaGlsZHJlbjtcbiAgICB2YXIgcGlkID0gcGFyZW50LmlkKCk7XG5cbiAgICB1dGlsLnJlbW92ZUZyb21BcnJheShjaGlsZHJlbiwgZWxlKTtcblxuICAgIGlmICghYWx0ZXJlZFBhcmVudHMuaWRzW3BpZF0pIHtcbiAgICAgIGFsdGVyZWRQYXJlbnRzLmlkc1twaWRdID0gdHJ1ZTtcbiAgICAgIGFsdGVyZWRQYXJlbnRzLnB1c2gocGFyZW50KTtcbiAgICB9XG4gIH1cblxuICBzZWxmLmRpcnR5Q29tcG91bmRCb3VuZHNDYWNoZSgpO1xuXG4gIGN5LnJlbW92ZUZyb21Qb29sKGVsZXNUb1JlbW92ZSk7IC8vIHJlbW92ZSBmcm9tIGNvcmUgcG9vbFxuXG4gIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IGVsZXNUb1JlbW92ZS5sZW5ndGg7IF9pNSsrKSB7XG4gICAgdmFyIF9lbGUzID0gZWxlc1RvUmVtb3ZlW19pNV07XG5cbiAgICAvLyBtYXJrIGFzIHJlbW92ZWRcbiAgICBfZWxlMy5fcHJpdmF0ZS5yZW1vdmVkID0gdHJ1ZTtcblxuICAgIC8vIGFkZCB0byBsaXN0IG9mIHJlbW92ZWQgZWxlbWVudHNcbiAgICByZW1vdmVkLnB1c2goX2VsZTMpO1xuXG4gICAgaWYgKF9lbGUzLmlzRWRnZSgpKSB7XG4gICAgICAvLyByZW1vdmUgcmVmZXJlbmNlcyB0byB0aGlzIGVkZ2UgaW4gaXRzIGNvbm5lY3RlZCBub2Rlc1xuICAgICAgdmFyIHNyYyA9IF9lbGUzLnNvdXJjZSgpWzBdO1xuICAgICAgdmFyIHRndCA9IF9lbGUzLnRhcmdldCgpWzBdO1xuXG4gICAgICByZW1vdmVFZGdlUmVmKHNyYywgX2VsZTMpO1xuICAgICAgcmVtb3ZlRWRnZVJlZih0Z3QsIF9lbGUzKTtcbiAgICAgIHJlbW92ZVBhcmFsbGVsUmVmcyhfZWxlMyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgdG8gcGFyZW50XG4gICAgICB2YXIgcGFyZW50ID0gX2VsZTMucGFyZW50KCk7XG5cbiAgICAgIGlmIChwYXJlbnQubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHJlbW92ZUNoaWxkUmVmKHBhcmVudCwgX2VsZTMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGNoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgY29tcG91bmQgZ3JhcGggb3Igbm90XG4gIHZhciBlbGVzU3RpbGxJbnNpZGUgPSBjeS5fcHJpdmF0ZS5lbGVtZW50cztcbiAgY3kuX3ByaXZhdGUuaGFzQ29tcG91bmROb2RlcyA9IGZhbHNlO1xuICBmb3IgKHZhciBfaTYgPSAwOyBfaTYgPCBlbGVzU3RpbGxJbnNpZGUubGVuZ3RoOyBfaTYrKykge1xuICAgIHZhciBfZWxlNCA9IGVsZXNTdGlsbEluc2lkZVtfaTZdO1xuXG4gICAgaWYgKF9lbGU0LmlzUGFyZW50KCkpIHtcbiAgICAgIGN5Ll9wcml2YXRlLmhhc0NvbXBvdW5kTm9kZXMgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlbW92ZWRFbGVtZW50cyA9IG5ldyBDb2xsZWN0aW9uKHRoaXMuY3koKSwgcmVtb3ZlZCk7XG4gIGlmIChyZW1vdmVkRWxlbWVudHMuc2l6ZSgpID4gMCkge1xuICAgIC8vIG11c3QgbWFudWFsbHkgbm90aWZ5IHNpbmNlIHRyaWdnZXIgd29uJ3QgZG8gdGhpcyBhdXRvbWF0aWNhbGx5IG9uY2UgcmVtb3ZlZFxuXG4gICAgaWYgKG5vdGlmeVJlbmRlcmVyKSB7XG4gICAgICB0aGlzLmN5KCkubm90aWZ5KHtcbiAgICAgICAgdHlwZTogJ3JlbW92ZScsXG4gICAgICAgIGVsZXM6IHJlbW92ZWRFbGVtZW50c1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVtb3ZlZEVsZW1lbnRzLmVtaXQoJ3JlbW92ZScpO1xuICB9XG5cbiAgLy8gdGhlIHBhcmVudHMgd2hvIHdlcmUgbW9kaWZpZWQgYnkgdGhlIHJlbW92YWwgbmVlZCB0aGVpciBzdHlsZSB1cGRhdGVkXG4gIGZvciAodmFyIF9pNyA9IDA7IF9pNyA8IGFsdGVyZWRQYXJlbnRzLmxlbmd0aDsgX2k3KyspIHtcbiAgICB2YXIgX2VsZTUgPSBhbHRlcmVkUGFyZW50c1tfaTddO1xuXG4gICAgaWYgKCFfZWxlNS5yZW1vdmVkKCkpIHtcbiAgICAgIF9lbGU1LnVwZGF0ZVN0eWxlKCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uKGN5LCByZW1vdmVkKTtcbn07XG5cbmVsZXNmbi5tb3ZlID0gZnVuY3Rpb24gKHN0cnVjdCkge1xuICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuXG4gIGlmIChzdHJ1Y3Quc291cmNlICE9PSB1bmRlZmluZWQgfHwgc3RydWN0LnRhcmdldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHNyY0lkID0gc3RydWN0LnNvdXJjZTtcbiAgICB2YXIgdGd0SWQgPSBzdHJ1Y3QudGFyZ2V0O1xuICAgIHZhciBzcmNFeGlzdHMgPSBjeS5oYXNFbGVtZW50V2l0aElkKHNyY0lkKTtcbiAgICB2YXIgdGd0RXhpc3RzID0gY3kuaGFzRWxlbWVudFdpdGhJZCh0Z3RJZCk7XG5cbiAgICBpZiAoc3JjRXhpc3RzIHx8IHRndEV4aXN0cykge1xuICAgICAgdmFyIGpzb25zID0gdGhpcy5qc29ucygpO1xuXG4gICAgICB0aGlzLnJlbW92ZSgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGpzb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBqc29uID0ganNvbnNbaV07XG4gICAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuXG4gICAgICAgIGlmIChqc29uLmdyb3VwID09PSAnZWRnZXMnKSB7XG4gICAgICAgICAgaWYgKHNyY0V4aXN0cykge1xuICAgICAgICAgICAganNvbi5kYXRhLnNvdXJjZSA9IHNyY0lkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0Z3RFeGlzdHMpIHtcbiAgICAgICAgICAgIGpzb24uZGF0YS50YXJnZXQgPSB0Z3RJZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBqc29uLnNjcmF0Y2ggPSBlbGUuX3ByaXZhdGUuc2NyYXRjaDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY3kuYWRkKGpzb25zKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoc3RydWN0LnBhcmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gbW92ZSBub2RlIHRvIG5ldyBwYXJlbnRcbiAgICB2YXIgcGFyZW50SWQgPSBzdHJ1Y3QucGFyZW50O1xuICAgIHZhciBwYXJlbnRFeGlzdHMgPSBwYXJlbnRJZCA9PT0gbnVsbCB8fCBjeS5oYXNFbGVtZW50V2l0aElkKHBhcmVudElkKTtcblxuICAgIGlmIChwYXJlbnRFeGlzdHMpIHtcbiAgICAgIHZhciBfanNvbnMgPSB0aGlzLmpzb25zKCk7XG4gICAgICB2YXIgZGVzY3MgPSB0aGlzLmRlc2NlbmRhbnRzKCk7XG4gICAgICB2YXIgZGVzY3NFdGNKc29ucyA9IGRlc2NzLnVuaW9uKGRlc2NzLnVuaW9uKHRoaXMpLmNvbm5lY3RlZEVkZ2VzKCkpLmpzb25zKCk7XG5cbiAgICAgIHRoaXMucmVtb3ZlKCk7IC8vIE5COiBhbHNvIHJlbW92ZXMgZGVzY2VuZGFudHMgYW5kIHRoZWlyIGNvbm5lY3RlZCBlZGdlc1xuXG4gICAgICBmb3IgKHZhciBfaTggPSAwOyBfaTggPCBfanNvbnMubGVuZ3RoOyBfaTgrKykge1xuICAgICAgICB2YXIgX2pzb24gPSBfanNvbnNbX2k4XTtcbiAgICAgICAgdmFyIF9lbGU2ID0gdGhpc1tfaThdO1xuXG4gICAgICAgIGlmIChfanNvbi5ncm91cCA9PT0gJ25vZGVzJykge1xuICAgICAgICAgIF9qc29uLmRhdGEucGFyZW50ID0gcGFyZW50SWQgPT09IG51bGwgPyB1bmRlZmluZWQgOiBwYXJlbnRJZDtcblxuICAgICAgICAgIF9qc29uLnNjcmF0Y2ggPSBfZWxlNi5fcHJpdmF0ZS5zY3JhdGNoO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjeS5hZGQoX2pzb25zLmNvbmNhdChkZXNjc0V0Y0pzb25zKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7IC8vIGlmIG5vdGhpbmcgZG9uZVxufTtcblxuW19fd2VicGFja19yZXF1aXJlX18oMjkpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyKSwgX193ZWJwYWNrX3JlcXVpcmVfXyg0NyksIF9fd2VicGFja19yZXF1aXJlX18oNDgpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDUzKSwgX193ZWJwYWNrX3JlcXVpcmVfXyg1NCksIF9fd2VicGFja19yZXF1aXJlX18oNTUpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDU2KSwgX193ZWJwYWNrX3JlcXVpcmVfXyg2MSksIF9fd2VicGFja19yZXF1aXJlX18oNjIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDYzKSwgX193ZWJwYWNrX3JlcXVpcmVfXyg3KSwgX193ZWJwYWNrX3JlcXVpcmVfXyg2NCksIF9fd2VicGFja19yZXF1aXJlX18oNjUpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDY2KSwgX193ZWJwYWNrX3JlcXVpcmVfXyg2NyksIF9fd2VicGFja19yZXF1aXJlX18oNjgpXS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wcykge1xuICB1dGlsLmV4dGVuZChlbGVzZm4sIHByb3BzKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbGxlY3Rpb247XG5cbi8qKiovIH0pLFxuLyogOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qIGdsb2JhbCBTZXQgKi9cblxudmFyIHVuZGVmID0gIHRydWUgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodW5kZWZpbmVkKTtcblxudmFyIE9iamVjdFNldCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gT2JqZWN0U2V0KGFycmF5T3JPYmplY3RTZXQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgT2JqZWN0U2V0KTtcblxuICAgIHRoaXMuX29iaiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICBpZiAoYXJyYXlPck9iamVjdFNldCAhPSBudWxsKSB7XG4gICAgICB2YXIgYXJyID0gdm9pZCAwO1xuXG4gICAgICBpZiAoYXJyYXlPck9iamVjdFNldC5pbnN0YW5jZVN0cmluZyAhPSBudWxsICYmIGFycmF5T3JPYmplY3RTZXQuaW5zdGFuY2VTdHJpbmcoKSA9PT0gdGhpcy5pbnN0YW5jZVN0cmluZygpKSB7XG4gICAgICAgIGFyciA9IGFycmF5T3JPYmplY3RTZXQudG9BcnJheSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJyID0gYXJyYXlPck9iamVjdFNldDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5hZGQoYXJyW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoT2JqZWN0U2V0LCBbe1xuICAgIGtleTogJ2luc3RhbmNlU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zdGFuY2VTdHJpbmcoKSB7XG4gICAgICByZXR1cm4gJ3NldCc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWRkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKHZhbCkge1xuICAgICAgdGhpcy5fb2JqW3ZhbF0gPSAxO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2RlbGV0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWxldGUodmFsKSB7XG4gICAgICB0aGlzLl9vYmpbdmFsXSA9IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY2xlYXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIHRoaXMuX29iaiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaGFzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzKHZhbCkge1xuICAgICAgcmV0dXJuIHRoaXMuX29ialt2YWxdID09PSAxO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvQXJyYXknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0FycmF5KCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX29iaikuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmhhcyhrZXkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZm9yRWFjaCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5mb3JFYWNoKGNhbGxiYWNrLCB0aGlzQXJnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzaXplJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5sZW5ndGg7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE9iamVjdFNldDtcbn0oKTtcblxuLy8gVE9ETyB1c2UgdGhlIHN0ZGxpYiBTZXQgaW4gZnV0dXJlLi4uXG4vLyBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBTZXQgIT09IHVuZGVmID8gU2V0IDogT2JqZWN0U2V0O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0U2V0O1xuXG4vKioqLyB9KSxcbi8qIDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcblxuLyoqKi8gfSksXG4vKiAxMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vLyBzdG9yYWdlIGZvciBwYXJzZWQgcXVlcmllc1xudmFyIG5ld1F1ZXJ5ID0gZnVuY3Rpb24gbmV3UXVlcnkoKSB7XG4gIHJldHVybiB7XG4gICAgY2xhc3NlczogW10sXG4gICAgY29sb25TZWxlY3RvcnM6IFtdLFxuICAgIGRhdGE6IFtdLFxuICAgIGdyb3VwOiBudWxsLFxuICAgIGlkczogW10sXG4gICAgbWV0YTogW10sXG5cbiAgICAvLyBmYWtlIHNlbGVjdG9yc1xuICAgIGNvbGxlY3Rpb246IG51bGwsIC8vIGEgY29sbGVjdGlvbiB0byBtYXRjaCBhZ2FpbnN0XG4gICAgZmlsdGVyOiBudWxsLCAvLyBmaWx0ZXIgZnVuY3Rpb25cblxuICAgIC8vIHRoZXNlIGFyZSBkZWZpbmVkIGluIHRoZSB1cHdhcmQgZGlyZWN0aW9uIHJhdGhlciB0aGFuIGRvd24gKGUuZy4gY2hpbGQpXG4gICAgLy8gYmVjYXVzZSB3ZSBuZWVkIHRvIGdvIHVwIGluIFNlbGVjdG9yLmZpbHRlcigpXG4gICAgcGFyZW50OiBudWxsLCAvLyBwYXJlbnQgcXVlcnkgb2JqXG4gICAgYW5jZXN0b3I6IG51bGwsIC8vIGFuY2VzdG9yIHF1ZXJ5IG9ialxuICAgIHN1YmplY3Q6IG51bGwsIC8vIGRlZmluZXMgc3ViamVjdCBpbiBjb21wb3VuZCBxdWVyeSAoc3ViamVjdCBxdWVyeSBvYmo7IHBvaW50cyB0byBzZWxmIGlmIHN1YmplY3QpXG5cbiAgICAvLyB1c2UgdGhlc2Ugb25seSB3aGVuIHN1YmplY3QgaGFzIGJlZW4gZGVmaW5lZFxuICAgIGNoaWxkOiBudWxsLFxuICAgIGRlc2NlbmRhbnQ6IG51bGxcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3UXVlcnk7XG5cbi8qKiovIH0pLFxuLyogMTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xudmFyIGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xuXG52YXIgZXZlbnRSZWdleCA9IC9eKFteLl0rKShcXC4oPzpbXi5dKykpPyQvOyAvLyByZWdleCBmb3IgbWF0Y2hpbmcgZXZlbnQgc3RyaW5ncyAoZS5nLiBcImNsaWNrLm5hbWVzcGFjZVwiKVxudmFyIHVuaXZlcnNhbE5hbWVzcGFjZSA9ICcuKic7IC8vIG1hdGNoZXMgYXMgaWYgbm8gbmFtZXNwYWNlIHNwZWNpZmllZCBhbmQgcHJldmVudHMgdXNlcnMgZnJvbSB1bmJpbmRpbmcgYWNjaWRlbnRhbGx5XG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgcXVhbGlmaWVyQ29tcGFyZTogZnVuY3Rpb24gcXVhbGlmaWVyQ29tcGFyZShxMSwgcTIpIHtcbiAgICByZXR1cm4gcTEgPT09IHEyO1xuICB9LFxuICBldmVudE1hdGNoZXM6IGZ1bmN0aW9uIGV2ZW50TWF0Y2hlcygpIC8qY29udGV4dCwgbGlzdGVuZXIsIGV2ZW50T2JqKi97XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIGV2ZW50RmllbGRzOiBmdW5jdGlvbiBldmVudEZpZWxkcygpIC8qY29udGV4dCove1xuICAgIHJldHVybiB7fTtcbiAgfSxcbiAgY2FsbGJhY2tDb250ZXh0OiBmdW5jdGlvbiBjYWxsYmFja0NvbnRleHQoY29udGV4dCAvKiwgbGlzdGVuZXIsIGV2ZW50T2JqKi8pIHtcbiAgICByZXR1cm4gY29udGV4dDtcbiAgfSxcbiAgYmVmb3JlRW1pdDogZnVuY3Rpb24gYmVmb3JlRW1pdCgpIC8qIGNvbnRleHQsIGxpc3RlbmVyLCBldmVudE9iaiAqL3t9LFxuICBhZnRlckVtaXQ6IGZ1bmN0aW9uIGFmdGVyRW1pdCgpIC8qIGNvbnRleHQsIGxpc3RlbmVyLCBldmVudE9iaiAqL3t9LFxuICBidWJibGU6IGZ1bmN0aW9uIGJ1YmJsZSgpIC8qY29udGV4dCove1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgcGFyZW50OiBmdW5jdGlvbiBwYXJlbnQoKSAvKmNvbnRleHQqL3tcbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcbiAgY29udGV4dDogdW5kZWZpbmVkXG59O1xuXG5mdW5jdGlvbiBFbWl0dGVyKG9wdHMpIHtcbiAgdXRpbC5hc3NpZ24odGhpcywgZGVmYXVsdHMsIG9wdHMpO1xuXG4gIHRoaXMubGlzdGVuZXJzID0gW107XG4gIHRoaXMuZW1pdHRpbmcgPSAwO1xufVxuXG52YXIgcCA9IEVtaXR0ZXIucHJvdG90eXBlO1xuXG52YXIgZm9yRWFjaEV2ZW50ID0gZnVuY3Rpb24gZm9yRWFjaEV2ZW50KHNlbGYsIGhhbmRsZXIsIGV2ZW50cywgcXVhbGlmaWVyLCBjYWxsYmFjaywgY29uZiwgY29uZk92ZXJyaWRlcykge1xuICBpZiAoaXMuZm4ocXVhbGlmaWVyKSkge1xuICAgIGNhbGxiYWNrID0gcXVhbGlmaWVyO1xuICAgIHF1YWxpZmllciA9IG51bGw7XG4gIH1cblxuICBpZiAoY29uZk92ZXJyaWRlcykge1xuICAgIGlmIChjb25mID09IG51bGwpIHtcbiAgICAgIGNvbmYgPSBjb25mT3ZlcnJpZGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25mID0gdXRpbC5hc3NpZ24oe30sIGNvbmYsIGNvbmZPdmVycmlkZXMpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBldmVudExpc3QgPSBldmVudHMuc3BsaXQoL1xccysvKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50TGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBldnQgPSBldmVudExpc3RbaV07XG5cbiAgICBpZiAoaXMuZW1wdHlTdHJpbmcoZXZ0KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIG1hdGNoID0gZXZ0Lm1hdGNoKGV2ZW50UmVnZXgpOyAvLyB0eXBlWy5uYW1lc3BhY2VdXG5cbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHZhciB0eXBlID0gbWF0Y2hbMV07XG4gICAgICB2YXIgbmFtZXNwYWNlID0gbWF0Y2hbMl0gPyBtYXRjaFsyXSA6IG51bGw7XG4gICAgICB2YXIgcmV0ID0gaGFuZGxlcihzZWxmLCBldnQsIHR5cGUsIG5hbWVzcGFjZSwgcXVhbGlmaWVyLCBjYWxsYmFjaywgY29uZik7XG5cbiAgICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSAvLyBhbGxvdyBleGl0aW5nIGVhcmx5XG4gICAgfVxuICB9XG59O1xuXG52YXIgbWFrZUV2ZW50T2JqID0gZnVuY3Rpb24gbWFrZUV2ZW50T2JqKHNlbGYsIG9iaikge1xuICByZXR1cm4gbmV3IEV2ZW50KG9iai50eXBlLCB1dGlsLmFzc2lnbihvYmosIHNlbGYuZXZlbnRGaWVsZHMoc2VsZi5jb250ZXh0KSkpO1xufTtcblxudmFyIGZvckVhY2hFdmVudE9iaiA9IGZ1bmN0aW9uIGZvckVhY2hFdmVudE9iaihzZWxmLCBoYW5kbGVyLCBldmVudHMpIHtcbiAgaWYgKGlzLmV2ZW50KGV2ZW50cykpIHtcbiAgICBoYW5kbGVyKHNlbGYsIGV2ZW50cyk7XG5cbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAoaXMucGxhaW5PYmplY3QoZXZlbnRzKSkge1xuICAgIGhhbmRsZXIoc2VsZiwgbWFrZUV2ZW50T2JqKHNlbGYsIGV2ZW50cykpO1xuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGV2ZW50TGlzdCA9IGV2ZW50cy5zcGxpdCgvXFxzKy8pO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnRMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGV2dCA9IGV2ZW50TGlzdFtpXTtcblxuICAgIGlmIChpcy5lbXB0eVN0cmluZyhldnQpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgbWF0Y2ggPSBldnQubWF0Y2goZXZlbnRSZWdleCk7IC8vIHR5cGVbLm5hbWVzcGFjZV1cblxuICAgIGlmIChtYXRjaCkge1xuICAgICAgdmFyIHR5cGUgPSBtYXRjaFsxXTtcbiAgICAgIHZhciBuYW1lc3BhY2UgPSBtYXRjaFsyXSA/IG1hdGNoWzJdIDogbnVsbDtcbiAgICAgIHZhciBldmVudE9iaiA9IG1ha2VFdmVudE9iaihzZWxmLCB7XG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIG5hbWVzcGFjZTogbmFtZXNwYWNlLFxuICAgICAgICB0YXJnZXQ6IHNlbGYuY29udGV4dFxuICAgICAgfSk7XG5cbiAgICAgIGhhbmRsZXIoc2VsZiwgZXZlbnRPYmopO1xuICAgIH1cbiAgfVxufTtcblxucC5vbiA9IHAuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnRzLCBxdWFsaWZpZXIsIGNhbGxiYWNrLCBjb25mLCBjb25mT3ZlcnJpZGVzKSB7XG4gIGZvckVhY2hFdmVudCh0aGlzLCBmdW5jdGlvbiAoc2VsZiwgZXZlbnQsIHR5cGUsIG5hbWVzcGFjZSwgcXVhbGlmaWVyLCBjYWxsYmFjaywgY29uZikge1xuICAgIGlmIChpcy5mbihjYWxsYmFjaykpIHtcbiAgICAgIHNlbGYubGlzdGVuZXJzLnB1c2goe1xuICAgICAgICBldmVudDogZXZlbnQsIC8vIGZ1bGwgZXZlbnQgc3RyaW5nXG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjaywgLy8gY2FsbGJhY2sgdG8gcnVuXG4gICAgICAgIHR5cGU6IHR5cGUsIC8vIHRoZSBldmVudCB0eXBlIChlLmcuICdjbGljaycpXG4gICAgICAgIG5hbWVzcGFjZTogbmFtZXNwYWNlLCAvLyB0aGUgZXZlbnQgbmFtZXNwYWNlIChlLmcuIFwiLmZvb1wiKVxuICAgICAgICBxdWFsaWZpZXI6IHF1YWxpZmllciwgLy8gYSByZXN0cmljdGlvbiBvbiB3aGV0aGVyIHRvIG1hdGNoIHRoaXMgZW1pdHRlclxuICAgICAgICBjb25mOiBjb25mIC8vIGFkZGl0aW9uYWwgY29uZmlndXJhdGlvblxuICAgICAgfSk7XG4gICAgfVxuICB9LCBldmVudHMsIHF1YWxpZmllciwgY2FsbGJhY2ssIGNvbmYsIGNvbmZPdmVycmlkZXMpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxucC5vbmUgPSBmdW5jdGlvbiAoZXZlbnRzLCBxdWFsaWZpZXIsIGNhbGxiYWNrLCBjb25mKSB7XG4gIHJldHVybiB0aGlzLm9uKGV2ZW50cywgcXVhbGlmaWVyLCBjYWxsYmFjaywgY29uZiwgeyBvbmU6IHRydWUgfSk7XG59O1xuXG5wLnJlbW92ZUxpc3RlbmVyID0gcC5vZmYgPSBmdW5jdGlvbiAoZXZlbnRzLCBxdWFsaWZpZXIsIGNhbGxiYWNrLCBjb25mKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgaWYgKHRoaXMuZW1pdHRpbmcgIT09IDApIHtcbiAgICB0aGlzLmxpc3RlbmVycyA9IHV0aWwuY29weUFycmF5KHRoaXMubGlzdGVuZXJzKTtcbiAgfVxuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVycztcblxuICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChpKSB7XG4gICAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJzW2ldO1xuXG4gICAgZm9yRWFjaEV2ZW50KF90aGlzLCBmdW5jdGlvbiAoc2VsZiwgZXZlbnQsIHR5cGUsIG5hbWVzcGFjZSwgcXVhbGlmaWVyLCBjYWxsYmFjayAvKiwgY29uZiovKSB7XG4gICAgICBpZiAobGlzdGVuZXIudHlwZSA9PT0gdHlwZSAmJiAoIW5hbWVzcGFjZSB8fCBsaXN0ZW5lci5uYW1lc3BhY2UgPT09IG5hbWVzcGFjZSkgJiYgKCFxdWFsaWZpZXIgfHwgc2VsZi5xdWFsaWZpZXJDb21wYXJlKGxpc3RlbmVyLnF1YWxpZmllciwgcXVhbGlmaWVyKSkgJiYgKCFjYWxsYmFjayB8fCBsaXN0ZW5lci5jYWxsYmFjayA9PT0gY2FsbGJhY2spKSB7XG4gICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0sIGV2ZW50cywgcXVhbGlmaWVyLCBjYWxsYmFjaywgY29uZik7XG4gIH07XG5cbiAgZm9yICh2YXIgaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIF9sb29wKGkpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wLmVtaXQgPSBwLnRyaWdnZXIgPSBmdW5jdGlvbiAoZXZlbnRzLCBleHRyYVBhcmFtcywgbWFudWFsQ2FsbGJhY2spIHtcbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzO1xuICB2YXIgbnVtTGlzdGVuZXJzQmVmb3JlRW1pdCA9IGxpc3RlbmVycy5sZW5ndGg7XG5cbiAgdGhpcy5lbWl0dGluZysrO1xuXG4gIGlmICghaXMuYXJyYXkoZXh0cmFQYXJhbXMpKSB7XG4gICAgZXh0cmFQYXJhbXMgPSBbZXh0cmFQYXJhbXNdO1xuICB9XG5cbiAgZm9yRWFjaEV2ZW50T2JqKHRoaXMsIGZ1bmN0aW9uIChzZWxmLCBldmVudE9iaikge1xuICAgIGlmIChtYW51YWxDYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICBsaXN0ZW5lcnMgPSBbe1xuICAgICAgICBldmVudDogZXZlbnRPYmouZXZlbnQsXG4gICAgICAgIHR5cGU6IGV2ZW50T2JqLnR5cGUsXG4gICAgICAgIG5hbWVzcGFjZTogZXZlbnRPYmoubmFtZXNwYWNlLFxuICAgICAgICBjYWxsYmFjazogbWFudWFsQ2FsbGJhY2tcbiAgICAgIH1dO1xuXG4gICAgICBudW1MaXN0ZW5lcnNCZWZvcmVFbWl0ID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICB9XG5cbiAgICB2YXIgX2xvb3AyID0gZnVuY3Rpb24gX2xvb3AyKGkpIHtcbiAgICAgIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyc1tpXTtcblxuICAgICAgaWYgKGxpc3RlbmVyLnR5cGUgPT09IGV2ZW50T2JqLnR5cGUgJiYgKCFsaXN0ZW5lci5uYW1lc3BhY2UgfHwgbGlzdGVuZXIubmFtZXNwYWNlID09PSBldmVudE9iai5uYW1lc3BhY2UgfHwgbGlzdGVuZXIubmFtZXNwYWNlID09PSB1bml2ZXJzYWxOYW1lc3BhY2UpICYmIHNlbGYuZXZlbnRNYXRjaGVzKHNlbGYuY29udGV4dCwgbGlzdGVuZXIsIGV2ZW50T2JqKSkge1xuICAgICAgICB2YXIgYXJncyA9IFtldmVudE9ial07XG5cbiAgICAgICAgaWYgKGV4dHJhUGFyYW1zICE9IG51bGwpIHtcbiAgICAgICAgICB1dGlsLnB1c2goYXJncywgZXh0cmFQYXJhbXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5iZWZvcmVFbWl0KHNlbGYuY29udGV4dCwgbGlzdGVuZXIsIGV2ZW50T2JqKTtcblxuICAgICAgICBpZiAobGlzdGVuZXIuY29uZiAmJiBsaXN0ZW5lci5jb25mLm9uZSkge1xuICAgICAgICAgIHNlbGYubGlzdGVuZXJzID0gc2VsZi5saXN0ZW5lcnMuZmlsdGVyKGZ1bmN0aW9uIChsKSB7XG4gICAgICAgICAgICByZXR1cm4gbCAhPT0gbGlzdGVuZXI7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29udGV4dCA9IHNlbGYuY2FsbGJhY2tDb250ZXh0KHNlbGYuY29udGV4dCwgbGlzdGVuZXIsIGV2ZW50T2JqKTtcbiAgICAgICAgdmFyIHJldCA9IGxpc3RlbmVyLmNhbGxiYWNrLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuXG4gICAgICAgIHNlbGYuYWZ0ZXJFbWl0KHNlbGYuY29udGV4dCwgbGlzdGVuZXIsIGV2ZW50T2JqKTtcblxuICAgICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICAgIGV2ZW50T2JqLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIGV2ZW50T2JqLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gaWYgbGlzdGVuZXIgbWF0Y2hlc1xuICAgIH07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUxpc3RlbmVyc0JlZm9yZUVtaXQ7IGkrKykge1xuICAgICAgX2xvb3AyKGkpO1xuICAgIH0gLy8gZm9yIGxpc3RlbmVyXG5cbiAgICBpZiAoc2VsZi5idWJibGUoc2VsZi5jb250ZXh0KSAmJiAhZXZlbnRPYmouaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgc2VsZi5wYXJlbnQoc2VsZi5jb250ZXh0KS5lbWl0KGV2ZW50T2JqLCBleHRyYVBhcmFtcyk7XG4gICAgfVxuICB9LCBldmVudHMpO1xuXG4gIHRoaXMuZW1pdHRpbmctLTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcblxuLyoqKi8gfSksXG4vKiAxMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgd2luZG93ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbnZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbnZhciBDb2xsZWN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcbnZhciBpcyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgUHJvbWlzZSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgZGVmaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIENvcmUgPSBmdW5jdGlvbiBDb3JlKG9wdHMpIHtcbiAgdmFyIGN5ID0gdGhpcztcblxuICBvcHRzID0gdXRpbC5leHRlbmQoe30sIG9wdHMpO1xuXG4gIHZhciBjb250YWluZXIgPSBvcHRzLmNvbnRhaW5lcjtcblxuICAvLyBhbGxvdyBmb3IgcGFzc2luZyBhIHdyYXBwZWQganF1ZXJ5IG9iamVjdFxuICAvLyBlLmcuIGN5dG9zY2FwZSh7IGNvbnRhaW5lcjogJCgnI2N5JykgfSlcbiAgaWYgKGNvbnRhaW5lciAmJiAhaXMuaHRtbEVsZW1lbnQoY29udGFpbmVyKSAmJiBpcy5odG1sRWxlbWVudChjb250YWluZXJbMF0pKSB7XG4gICAgY29udGFpbmVyID0gY29udGFpbmVyWzBdO1xuICB9XG5cbiAgdmFyIHJlZyA9IGNvbnRhaW5lciA/IGNvbnRhaW5lci5fY3lyZWcgOiBudWxsOyAvLyBlLmcuIGFscmVhZHkgcmVnaXN0ZXJlZCBzb21lIGluZm8gKGUuZy4gcmVhZGllcykgdmlhIGpxdWVyeVxuICByZWcgPSByZWcgfHwge307XG5cbiAgaWYgKHJlZyAmJiByZWcuY3kpIHtcbiAgICByZWcuY3kuZGVzdHJveSgpO1xuXG4gICAgcmVnID0ge307IC8vIG9sZCBpbnN0YW5jZSA9PiByZXBsYWNlIHJlZyBjb21wbGV0ZWx5XG4gIH1cblxuICB2YXIgcmVhZGllcyA9IHJlZy5yZWFkaWVzID0gcmVnLnJlYWRpZXMgfHwgW107XG5cbiAgaWYgKGNvbnRhaW5lcikge1xuICAgIGNvbnRhaW5lci5fY3lyZWcgPSByZWc7XG4gIH0gLy8gbWFrZSBzdXJlIGNvbnRhaW5lciBhc3NvYydkIHJlZyBwb2ludHMgdG8gdGhpcyBjeVxuICByZWcuY3kgPSBjeTtcblxuICB2YXIgaGVhZCA9IHdpbmRvdyAhPT0gdW5kZWZpbmVkICYmIGNvbnRhaW5lciAhPT0gdW5kZWZpbmVkICYmICFvcHRzLmhlYWRsZXNzO1xuICB2YXIgb3B0aW9ucyA9IG9wdHM7XG4gIG9wdGlvbnMubGF5b3V0ID0gdXRpbC5leHRlbmQoeyBuYW1lOiBoZWFkID8gJ2dyaWQnIDogJ251bGwnIH0sIG9wdGlvbnMubGF5b3V0KTtcbiAgb3B0aW9ucy5yZW5kZXJlciA9IHV0aWwuZXh0ZW5kKHsgbmFtZTogaGVhZCA/ICdjYW52YXMnIDogJ251bGwnIH0sIG9wdGlvbnMucmVuZGVyZXIpO1xuXG4gIHZhciBkZWZWYWwgPSBmdW5jdGlvbiBkZWZWYWwoZGVmLCB2YWwsIGFsdFZhbCkge1xuICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9IGVsc2UgaWYgKGFsdFZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gYWx0VmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZGVmO1xuICAgIH1cbiAgfTtcblxuICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlID0ge1xuICAgIGNvbnRhaW5lcjogY29udGFpbmVyLCAvLyBodG1sIGRvbSBlbGUgY29udGFpbmVyXG4gICAgcmVhZHk6IGZhbHNlLCAvLyB3aGV0aGVyIHJlYWR5IGhhcyBiZWVuIHRyaWdnZXJlZFxuICAgIG9wdGlvbnM6IG9wdGlvbnMsIC8vIGNhY2hlZCBvcHRpb25zXG4gICAgZWxlbWVudHM6IG5ldyBDb2xsZWN0aW9uKHRoaXMpLCAvLyBlbGVtZW50cyBpbiB0aGUgZ3JhcGhcbiAgICBsaXN0ZW5lcnM6IFtdLCAvLyBsaXN0IG9mIGxpc3RlbmVyc1xuICAgIGFuaUVsZXM6IG5ldyBDb2xsZWN0aW9uKHRoaXMpLCAvLyBlbGVtZW50cyBiZWluZyBhbmltYXRlZFxuICAgIHNjcmF0Y2g6IHt9LCAvLyBzY3JhdGNoIG9iamVjdCBmb3IgY29yZVxuICAgIGxheW91dDogbnVsbCxcbiAgICByZW5kZXJlcjogbnVsbCxcbiAgICBkZXN0cm95ZWQ6IGZhbHNlLCAvLyB3aGV0aGVyIGRlc3Ryb3kgd2FzIGNhbGxlZFxuICAgIG5vdGlmaWNhdGlvbnNFbmFibGVkOiB0cnVlLCAvLyB3aGV0aGVyIG5vdGlmaWNhdGlvbnMgYXJlIHNlbnQgdG8gdGhlIHJlbmRlcmVyXG4gICAgbWluWm9vbTogMWUtNTAsXG4gICAgbWF4Wm9vbTogMWU1MCxcbiAgICB6b29taW5nRW5hYmxlZDogZGVmVmFsKHRydWUsIG9wdGlvbnMuem9vbWluZ0VuYWJsZWQpLFxuICAgIHVzZXJab29taW5nRW5hYmxlZDogZGVmVmFsKHRydWUsIG9wdGlvbnMudXNlclpvb21pbmdFbmFibGVkKSxcbiAgICBwYW5uaW5nRW5hYmxlZDogZGVmVmFsKHRydWUsIG9wdGlvbnMucGFubmluZ0VuYWJsZWQpLFxuICAgIHVzZXJQYW5uaW5nRW5hYmxlZDogZGVmVmFsKHRydWUsIG9wdGlvbnMudXNlclBhbm5pbmdFbmFibGVkKSxcbiAgICBib3hTZWxlY3Rpb25FbmFibGVkOiBkZWZWYWwodHJ1ZSwgb3B0aW9ucy5ib3hTZWxlY3Rpb25FbmFibGVkKSxcbiAgICBhdXRvbG9jazogZGVmVmFsKGZhbHNlLCBvcHRpb25zLmF1dG9sb2NrLCBvcHRpb25zLmF1dG9sb2NrTm9kZXMpLFxuICAgIGF1dG91bmdyYWJpZnk6IGRlZlZhbChmYWxzZSwgb3B0aW9ucy5hdXRvdW5ncmFiaWZ5LCBvcHRpb25zLmF1dG91bmdyYWJpZnlOb2RlcyksXG4gICAgYXV0b3Vuc2VsZWN0aWZ5OiBkZWZWYWwoZmFsc2UsIG9wdGlvbnMuYXV0b3Vuc2VsZWN0aWZ5KSxcbiAgICBzdHlsZUVuYWJsZWQ6IG9wdGlvbnMuc3R5bGVFbmFibGVkID09PSB1bmRlZmluZWQgPyBoZWFkIDogb3B0aW9ucy5zdHlsZUVuYWJsZWQsXG4gICAgem9vbTogaXMubnVtYmVyKG9wdGlvbnMuem9vbSkgPyBvcHRpb25zLnpvb20gOiAxLFxuICAgIHBhbjoge1xuICAgICAgeDogaXMucGxhaW5PYmplY3Qob3B0aW9ucy5wYW4pICYmIGlzLm51bWJlcihvcHRpb25zLnBhbi54KSA/IG9wdGlvbnMucGFuLnggOiAwLFxuICAgICAgeTogaXMucGxhaW5PYmplY3Qob3B0aW9ucy5wYW4pICYmIGlzLm51bWJlcihvcHRpb25zLnBhbi55KSA/IG9wdGlvbnMucGFuLnkgOiAwXG4gICAgfSxcbiAgICBhbmltYXRpb246IHsgLy8gb2JqZWN0IGZvciBjdXJyZW50bHktcnVubmluZyBhbmltYXRpb25zXG4gICAgICBjdXJyZW50OiBbXSxcbiAgICAgIHF1ZXVlOiBbXVxuICAgIH0sXG4gICAgaGFzQ29tcG91bmROb2RlczogZmFsc2VcbiAgfTtcblxuICB0aGlzLmNyZWF0ZUVtaXR0ZXIoKTtcblxuICAvLyBzZXQgc2VsZWN0aW9uIHR5cGVcbiAgdmFyIHNlbFR5cGUgPSBvcHRpb25zLnNlbGVjdGlvblR5cGU7XG4gIGlmIChzZWxUeXBlID09PSB1bmRlZmluZWQgfHwgc2VsVHlwZSAhPT0gJ2FkZGl0aXZlJyAmJiBzZWxUeXBlICE9PSAnc2luZ2xlJykge1xuICAgIC8vIHRoZW4gc2V0IGRlZmF1bHRcblxuICAgIF9wLnNlbGVjdGlvblR5cGUgPSAnc2luZ2xlJztcbiAgfSBlbHNlIHtcbiAgICBfcC5zZWxlY3Rpb25UeXBlID0gc2VsVHlwZTtcbiAgfVxuXG4gIC8vIGluaXQgem9vbSBib3VuZHNcbiAgaWYgKGlzLm51bWJlcihvcHRpb25zLm1pblpvb20pICYmIGlzLm51bWJlcihvcHRpb25zLm1heFpvb20pICYmIG9wdGlvbnMubWluWm9vbSA8IG9wdGlvbnMubWF4Wm9vbSkge1xuICAgIF9wLm1pblpvb20gPSBvcHRpb25zLm1pblpvb207XG4gICAgX3AubWF4Wm9vbSA9IG9wdGlvbnMubWF4Wm9vbTtcbiAgfSBlbHNlIGlmIChpcy5udW1iZXIob3B0aW9ucy5taW5ab29tKSAmJiBvcHRpb25zLm1heFpvb20gPT09IHVuZGVmaW5lZCkge1xuICAgIF9wLm1pblpvb20gPSBvcHRpb25zLm1pblpvb207XG4gIH0gZWxzZSBpZiAoaXMubnVtYmVyKG9wdGlvbnMubWF4Wm9vbSkgJiYgb3B0aW9ucy5taW5ab29tID09PSB1bmRlZmluZWQpIHtcbiAgICBfcC5tYXhab29tID0gb3B0aW9ucy5tYXhab29tO1xuICB9XG5cbiAgdmFyIGxvYWRFeHREYXRhID0gZnVuY3Rpb24gbG9hZEV4dERhdGEoZXh0RGF0YSwgbmV4dCkge1xuICAgIHZhciBhbnlJc1Byb21pc2UgPSBleHREYXRhLnNvbWUoaXMucHJvbWlzZSk7XG5cbiAgICBpZiAoYW55SXNQcm9taXNlKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoZXh0RGF0YSkudGhlbihuZXh0KTsgLy8gbG9hZCBhbGwgZGF0YSBhc3luY2hyb25vdXNseSwgdGhlbiBleGVjIHJlc3Qgb2YgaW5pdFxuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0KGV4dERhdGEpOyAvLyBleGVjIHN5bmNocm9ub3VzbHkgZm9yIGNvbnZlbmllbmNlXG4gICAgfVxuICB9O1xuXG4gIC8vIHN0YXJ0IHdpdGggdGhlIGRlZmF1bHQgc3R5bGVzaGVldCBzbyB3ZSBoYXZlIHNvbWV0aGluZyBiZWZvcmUgbG9hZGluZyBhbiBleHRlcm5hbCBzdHlsZXNoZWV0XG4gIGlmIChfcC5zdHlsZUVuYWJsZWQpIHtcbiAgICBjeS5zZXRTdHlsZShbXSk7XG4gIH1cblxuICAvLyBjcmVhdGUgdGhlIHJlbmRlcmVyXG4gIGN5LmluaXRSZW5kZXJlcih1dGlsLmV4dGVuZCh7XG4gICAgaGlkZUVkZ2VzT25WaWV3cG9ydDogb3B0aW9ucy5oaWRlRWRnZXNPblZpZXdwb3J0LFxuICAgIHRleHR1cmVPblZpZXdwb3J0OiBvcHRpb25zLnRleHR1cmVPblZpZXdwb3J0LFxuICAgIHdoZWVsU2Vuc2l0aXZpdHk6IGlzLm51bWJlcihvcHRpb25zLndoZWVsU2Vuc2l0aXZpdHkpICYmIG9wdGlvbnMud2hlZWxTZW5zaXRpdml0eSA+IDAgPyBvcHRpb25zLndoZWVsU2Vuc2l0aXZpdHkgOiAxLFxuICAgIG1vdGlvbkJsdXI6IG9wdGlvbnMubW90aW9uQmx1ciA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBvcHRpb25zLm1vdGlvbkJsdXIsIC8vIG9mZiBieSBkZWZhdWx0XG4gICAgbW90aW9uQmx1ck9wYWNpdHk6IG9wdGlvbnMubW90aW9uQmx1ck9wYWNpdHkgPT09IHVuZGVmaW5lZCA/IDAuMDUgOiBvcHRpb25zLm1vdGlvbkJsdXJPcGFjaXR5LFxuICAgIHBpeGVsUmF0aW86IGlzLm51bWJlcihvcHRpb25zLnBpeGVsUmF0aW8pICYmIG9wdGlvbnMucGl4ZWxSYXRpbyA+IDAgPyBvcHRpb25zLnBpeGVsUmF0aW8gOiB1bmRlZmluZWQsXG4gICAgZGVza3RvcFRhcFRocmVzaG9sZDogb3B0aW9ucy5kZXNrdG9wVGFwVGhyZXNob2xkID09PSB1bmRlZmluZWQgPyA0IDogb3B0aW9ucy5kZXNrdG9wVGFwVGhyZXNob2xkLFxuICAgIHRvdWNoVGFwVGhyZXNob2xkOiBvcHRpb25zLnRvdWNoVGFwVGhyZXNob2xkID09PSB1bmRlZmluZWQgPyA4IDogb3B0aW9ucy50b3VjaFRhcFRocmVzaG9sZFxuICB9LCBvcHRpb25zLnJlbmRlcmVyKSk7XG5cbiAgdmFyIHNldEVsZXNBbmRMYXlvdXQgPSBmdW5jdGlvbiBzZXRFbGVzQW5kTGF5b3V0KGVsZW1lbnRzLCBvbmxvYWQsIG9uZG9uZSkge1xuICAgIGN5Lm5vdGlmaWNhdGlvbnMoZmFsc2UpO1xuXG4gICAgLy8gcmVtb3ZlIG9sZCBlbGVtZW50c1xuICAgIHZhciBvbGRFbGVzID0gY3kubXV0YWJsZUVsZW1lbnRzKCk7XG4gICAgaWYgKG9sZEVsZXMubGVuZ3RoID4gMCkge1xuICAgICAgb2xkRWxlcy5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudHMgIT0gbnVsbCkge1xuICAgICAgaWYgKGlzLnBsYWluT2JqZWN0KGVsZW1lbnRzKSB8fCBpcy5hcnJheShlbGVtZW50cykpIHtcbiAgICAgICAgY3kuYWRkKGVsZW1lbnRzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjeS5vbmUoJ2xheW91dHJlYWR5JywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGN5Lm5vdGlmaWNhdGlvbnModHJ1ZSk7XG4gICAgICBjeS5lbWl0KGUpOyAvLyB3ZSBtaXNzZWQgdGhpcyBldmVudCBieSB0dXJuaW5nIG5vdGlmaWNhdGlvbnMgb2ZmLCBzbyBwYXNzIGl0IG9uXG5cbiAgICAgIGN5Lm5vdGlmeSh7XG4gICAgICAgIHR5cGU6ICdsb2FkJyxcbiAgICAgICAgZWxlczogY3kubXV0YWJsZUVsZW1lbnRzKClcbiAgICAgIH0pO1xuXG4gICAgICBjeS5vbmUoJ2xvYWQnLCBvbmxvYWQpO1xuICAgICAgY3kuZW1pdCgnbG9hZCcpO1xuICAgIH0pLm9uZSgnbGF5b3V0c3RvcCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGN5Lm9uZSgnZG9uZScsIG9uZG9uZSk7XG4gICAgICBjeS5lbWl0KCdkb25lJyk7XG4gICAgfSk7XG5cbiAgICB2YXIgbGF5b3V0T3B0cyA9IHV0aWwuZXh0ZW5kKHt9LCBjeS5fcHJpdmF0ZS5vcHRpb25zLmxheW91dCk7XG4gICAgbGF5b3V0T3B0cy5lbGVzID0gY3kuZWxlbWVudHMoKTtcblxuICAgIGN5LmxheW91dChsYXlvdXRPcHRzKS5ydW4oKTtcbiAgfTtcblxuICBsb2FkRXh0RGF0YShbb3B0aW9ucy5zdHlsZSwgb3B0aW9ucy5lbGVtZW50c10sIGZ1bmN0aW9uICh0aGVucykge1xuICAgIHZhciBpbml0U3R5bGUgPSB0aGVuc1swXTtcbiAgICB2YXIgaW5pdEVsZXMgPSB0aGVuc1sxXTtcblxuICAgIC8vIGluaXQgc3R5bGVcbiAgICBpZiAoX3Auc3R5bGVFbmFibGVkKSB7XG4gICAgICBjeS5zdHlsZSgpLmFwcGVuZChpbml0U3R5bGUpO1xuICAgIH1cblxuICAgIC8vIGluaXRpYWwgbG9hZFxuICAgIHNldEVsZXNBbmRMYXlvdXQoaW5pdEVsZXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIG9ucmVhZHlcbiAgICAgIGN5LnN0YXJ0QW5pbWF0aW9uTG9vcCgpO1xuICAgICAgX3AucmVhZHkgPSB0cnVlO1xuXG4gICAgICAvLyBpZiBhIHJlYWR5IGNhbGxiYWNrIGlzIHNwZWNpZmllZCBhcyBhbiBvcHRpb24sIHRoZSBiaW5kIGl0XG4gICAgICBpZiAoaXMuZm4ob3B0aW9ucy5yZWFkeSkpIHtcbiAgICAgICAgY3kub24oJ3JlYWR5Jywgb3B0aW9ucy5yZWFkeSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGJpbmQgYWxsIHRoZSByZWFkeSBoYW5kbGVycyByZWdpc3RlcmVkIGJlZm9yZSBjcmVhdGluZyB0aGlzIGluc3RhbmNlXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlYWRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGZuID0gcmVhZGllc1tpXTtcbiAgICAgICAgY3kub24oJ3JlYWR5JywgZm4pO1xuICAgICAgfVxuICAgICAgaWYgKHJlZykge1xuICAgICAgICByZWcucmVhZGllcyA9IFtdO1xuICAgICAgfSAvLyBjbGVhciBiL2Mgd2UndmUgYm91bmQgdGhlbSBhbGwgYW5kIGRvbid0IHdhbnQgdG8ga2VlcCBpdCBhcm91bmQgaW4gY2FzZSBhIG5ldyBjb3JlIHVzZXMgdGhlIHNhbWUgZGl2IGV0Y1xuXG4gICAgICBjeS5lbWl0KCdyZWFkeScpO1xuICAgIH0sIG9wdGlvbnMuZG9uZSk7XG4gIH0pO1xufTtcblxudmFyIGNvcmVmbiA9IENvcmUucHJvdG90eXBlOyAvLyBzaG9ydCBhbGlhc1xuXG51dGlsLmV4dGVuZChjb3JlZm4sIHtcbiAgaW5zdGFuY2VTdHJpbmc6IGZ1bmN0aW9uIGluc3RhbmNlU3RyaW5nKCkge1xuICAgIHJldHVybiAnY29yZSc7XG4gIH0sXG5cbiAgaXNSZWFkeTogZnVuY3Rpb24gaXNSZWFkeSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5yZWFkeTtcbiAgfSxcblxuICBpc0Rlc3Ryb3llZDogZnVuY3Rpb24gaXNEZXN0cm95ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuZGVzdHJveWVkO1xuICB9LFxuXG4gIHJlYWR5OiBmdW5jdGlvbiByZWFkeShmbikge1xuICAgIGlmICh0aGlzLmlzUmVhZHkoKSkge1xuICAgICAgdGhpcy5lbWl0dGVyKCkuZW1pdCgncmVhZHknLCBbXSwgZm4pOyAvLyBqdXN0IGNhbGxzIGZuIGFzIHRob3VnaCB0cmlnZ2VyZWQgdmlhIHJlYWR5IGV2ZW50XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub24oJ3JlYWR5JywgZm4pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdmFyIGN5ID0gdGhpcztcbiAgICBpZiAoY3kuaXNEZXN0cm95ZWQoKSkgcmV0dXJuO1xuXG4gICAgY3kuc3RvcEFuaW1hdGlvbkxvb3AoKTtcblxuICAgIGN5LmRlc3Ryb3lSZW5kZXJlcigpO1xuXG4gICAgdGhpcy5lbWl0KCdkZXN0cm95Jyk7XG5cbiAgICBjeS5fcHJpdmF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuXG4gICAgcmV0dXJuIGN5O1xuICB9LFxuXG4gIGhhc0VsZW1lbnRXaXRoSWQ6IGZ1bmN0aW9uIGhhc0VsZW1lbnRXaXRoSWQoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5lbGVtZW50cy5oYXNFbGVtZW50V2l0aElkKGlkKTtcbiAgfSxcblxuICBnZXRFbGVtZW50QnlJZDogZnVuY3Rpb24gZ2V0RWxlbWVudEJ5SWQoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5lbGVtZW50cy5nZXRFbGVtZW50QnlJZChpZCk7XG4gIH0sXG5cbiAgc2VsZWN0aW9uVHlwZTogZnVuY3Rpb24gc2VsZWN0aW9uVHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5zZWxlY3Rpb25UeXBlO1xuICB9LFxuXG4gIGhhc0NvbXBvdW5kTm9kZXM6IGZ1bmN0aW9uIGhhc0NvbXBvdW5kTm9kZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuaGFzQ29tcG91bmROb2RlcztcbiAgfSxcblxuICBoZWFkbGVzczogZnVuY3Rpb24gaGVhZGxlc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUub3B0aW9ucy5yZW5kZXJlci5uYW1lID09PSAnbnVsbCc7XG4gIH0sXG5cbiAgc3R5bGVFbmFibGVkOiBmdW5jdGlvbiBzdHlsZUVuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuc3R5bGVFbmFibGVkO1xuICB9LFxuXG4gIGFkZFRvUG9vbDogZnVuY3Rpb24gYWRkVG9Qb29sKGVsZXMpIHtcbiAgICB0aGlzLl9wcml2YXRlLmVsZW1lbnRzLm1lcmdlKGVsZXMpO1xuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgcmVtb3ZlRnJvbVBvb2w6IGZ1bmN0aW9uIHJlbW92ZUZyb21Qb29sKGVsZXMpIHtcbiAgICB0aGlzLl9wcml2YXRlLmVsZW1lbnRzLnVubWVyZ2UoZWxlcyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBjb250YWluZXI6IGZ1bmN0aW9uIGNvbnRhaW5lcigpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5jb250YWluZXI7XG4gIH0sXG5cbiAgb3B0aW9uczogZnVuY3Rpb24gb3B0aW9ucygpIHtcbiAgICByZXR1cm4gdXRpbC5jb3B5KHRoaXMuX3ByaXZhdGUub3B0aW9ucyk7XG4gIH0sXG5cbiAganNvbjogZnVuY3Rpb24ganNvbihvYmopIHtcbiAgICB2YXIgY3kgPSB0aGlzO1xuICAgIHZhciBfcCA9IGN5Ll9wcml2YXRlO1xuICAgIHZhciBlbGVzID0gY3kubXV0YWJsZUVsZW1lbnRzKCk7XG5cbiAgICBpZiAoaXMucGxhaW5PYmplY3Qob2JqKSkge1xuICAgICAgLy8gc2V0XG5cbiAgICAgIGN5LnN0YXJ0QmF0Y2goKTtcblxuICAgICAgaWYgKG9iai5lbGVtZW50cykge1xuICAgICAgICB2YXIgaWRJbkpzb24gPSB7fTtcblxuICAgICAgICB2YXIgdXBkYXRlRWxlcyA9IGZ1bmN0aW9uIHVwZGF0ZUVsZXMoanNvbnMsIGdyKSB7XG4gICAgICAgICAgdmFyIHRvQWRkID0gW107XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGpzb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIganNvbiA9IGpzb25zW2ldO1xuICAgICAgICAgICAgdmFyIGlkID0ganNvbi5kYXRhLmlkO1xuICAgICAgICAgICAgdmFyIGVsZSA9IGN5LmdldEVsZW1lbnRCeUlkKGlkKTtcblxuICAgICAgICAgICAgaWRJbkpzb25baWRdID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKGVsZS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgLy8gZXhpc3RpbmcgZWxlbWVudCBzaG91bGQgYmUgdXBkYXRlZFxuICAgICAgICAgICAgICBlbGUuanNvbihqc29uKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBzaG91bGQgYmUgYWRkZWRcbiAgICAgICAgICAgICAgaWYgKGdyKSB7XG4gICAgICAgICAgICAgICAgdG9BZGQucHVzaCh1dGlsLmV4dGVuZCh7IGdyb3VwOiBnciB9LCBqc29uKSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9BZGQucHVzaChqc29uKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGN5LmFkZCh0b0FkZCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGlzLmFycmF5KG9iai5lbGVtZW50cykpIHtcbiAgICAgICAgICAvLyBlbGVtZW50czogW11cbiAgICAgICAgICB1cGRhdGVFbGVzKG9iai5lbGVtZW50cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZWxlbWVudHM6IHsgbm9kZXM6IFtdLCBlZGdlczogW10gfVxuICAgICAgICAgIHZhciBncnMgPSBbJ25vZGVzJywgJ2VkZ2VzJ107XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBnciA9IGdyc1tpXTtcbiAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IG9iai5lbGVtZW50c1tncl07XG5cbiAgICAgICAgICAgIGlmIChpcy5hcnJheShlbGVtZW50cykpIHtcbiAgICAgICAgICAgICAgdXBkYXRlRWxlcyhlbGVtZW50cywgZ3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVsZW1lbnRzIG5vdCBzcGVjaWZpZWQgaW4ganNvbiBzaG91bGQgYmUgcmVtb3ZlZFxuICAgICAgICBlbGVzLnN0ZEZpbHRlcihmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgICAgcmV0dXJuICFpZEluSnNvbltlbGUuaWQoKV07XG4gICAgICAgIH0pLnJlbW92ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAob2JqLnN0eWxlKSB7XG4gICAgICAgIGN5LnN0eWxlKG9iai5zdHlsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvYmouem9vbSAhPSBudWxsICYmIG9iai56b29tICE9PSBfcC56b29tKSB7XG4gICAgICAgIGN5Lnpvb20ob2JqLnpvb20pO1xuICAgICAgfVxuXG4gICAgICBpZiAob2JqLnBhbikge1xuICAgICAgICBpZiAob2JqLnBhbi54ICE9PSBfcC5wYW4ueCB8fCBvYmoucGFuLnkgIT09IF9wLnBhbi55KSB7XG4gICAgICAgICAgY3kucGFuKG9iai5wYW4pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBmaWVsZHMgPSBbJ21pblpvb20nLCAnbWF4Wm9vbScsICd6b29taW5nRW5hYmxlZCcsICd1c2VyWm9vbWluZ0VuYWJsZWQnLCAncGFubmluZ0VuYWJsZWQnLCAndXNlclBhbm5pbmdFbmFibGVkJywgJ2JveFNlbGVjdGlvbkVuYWJsZWQnLCAnYXV0b2xvY2snLCAnYXV0b3VuZ3JhYmlmeScsICdhdXRvdW5zZWxlY3RpZnknXTtcblxuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGZpZWxkcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGYgPSBmaWVsZHNbX2ldO1xuXG4gICAgICAgIGlmIChvYmpbZl0gIT0gbnVsbCkge1xuICAgICAgICAgIGN5W2ZdKG9ialtmXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY3kuZW5kQmF0Y2goKTtcblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSBlbHNlIGlmIChvYmogPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gZ2V0XG4gICAgICB2YXIganNvbiA9IHt9O1xuXG4gICAgICBqc29uLmVsZW1lbnRzID0ge307XG4gICAgICBlbGVzLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICB2YXIgZ3JvdXAgPSBlbGUuZ3JvdXAoKTtcblxuICAgICAgICBpZiAoIWpzb24uZWxlbWVudHNbZ3JvdXBdKSB7XG4gICAgICAgICAganNvbi5lbGVtZW50c1tncm91cF0gPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGpzb24uZWxlbWVudHNbZ3JvdXBdLnB1c2goZWxlLmpzb24oKSk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMuX3ByaXZhdGUuc3R5bGVFbmFibGVkKSB7XG4gICAgICAgIGpzb24uc3R5bGUgPSBjeS5zdHlsZSgpLmpzb24oKTtcbiAgICAgIH1cblxuICAgICAganNvbi56b29taW5nRW5hYmxlZCA9IGN5Ll9wcml2YXRlLnpvb21pbmdFbmFibGVkO1xuICAgICAganNvbi51c2VyWm9vbWluZ0VuYWJsZWQgPSBjeS5fcHJpdmF0ZS51c2VyWm9vbWluZ0VuYWJsZWQ7XG4gICAgICBqc29uLnpvb20gPSBjeS5fcHJpdmF0ZS56b29tO1xuICAgICAganNvbi5taW5ab29tID0gY3kuX3ByaXZhdGUubWluWm9vbTtcbiAgICAgIGpzb24ubWF4Wm9vbSA9IGN5Ll9wcml2YXRlLm1heFpvb207XG4gICAgICBqc29uLnBhbm5pbmdFbmFibGVkID0gY3kuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQ7XG4gICAgICBqc29uLnVzZXJQYW5uaW5nRW5hYmxlZCA9IGN5Ll9wcml2YXRlLnVzZXJQYW5uaW5nRW5hYmxlZDtcbiAgICAgIGpzb24ucGFuID0gdXRpbC5jb3B5KGN5Ll9wcml2YXRlLnBhbik7XG4gICAgICBqc29uLmJveFNlbGVjdGlvbkVuYWJsZWQgPSBjeS5fcHJpdmF0ZS5ib3hTZWxlY3Rpb25FbmFibGVkO1xuICAgICAganNvbi5yZW5kZXJlciA9IHV0aWwuY29weShjeS5fcHJpdmF0ZS5vcHRpb25zLnJlbmRlcmVyKTtcbiAgICAgIGpzb24uaGlkZUVkZ2VzT25WaWV3cG9ydCA9IGN5Ll9wcml2YXRlLm9wdGlvbnMuaGlkZUVkZ2VzT25WaWV3cG9ydDtcbiAgICAgIGpzb24udGV4dHVyZU9uVmlld3BvcnQgPSBjeS5fcHJpdmF0ZS5vcHRpb25zLnRleHR1cmVPblZpZXdwb3J0O1xuICAgICAganNvbi53aGVlbFNlbnNpdGl2aXR5ID0gY3kuX3ByaXZhdGUub3B0aW9ucy53aGVlbFNlbnNpdGl2aXR5O1xuICAgICAganNvbi5tb3Rpb25CbHVyID0gY3kuX3ByaXZhdGUub3B0aW9ucy5tb3Rpb25CbHVyO1xuXG4gICAgICByZXR1cm4ganNvbjtcbiAgICB9XG4gIH0sXG5cbiAgc2NyYXRjaDogZGVmaW5lLmRhdGEoe1xuICAgIGZpZWxkOiAnc2NyYXRjaCcsXG4gICAgYmluZGluZ0V2ZW50OiAnc2NyYXRjaCcsXG4gICAgYWxsb3dCaW5kaW5nOiB0cnVlLFxuICAgIGFsbG93U2V0dGluZzogdHJ1ZSxcbiAgICBzZXR0aW5nRXZlbnQ6ICdzY3JhdGNoJyxcbiAgICBzZXR0aW5nVHJpZ2dlcnNFdmVudDogdHJ1ZSxcbiAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgYWxsb3dHZXR0aW5nOiB0cnVlXG4gIH0pLFxuXG4gIHJlbW92ZVNjcmF0Y2g6IGRlZmluZS5yZW1vdmVEYXRhKHtcbiAgICBmaWVsZDogJ3NjcmF0Y2gnLFxuICAgIGV2ZW50OiAnc2NyYXRjaCcsXG4gICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgIHRyaWdnZXJFdmVudDogdHJ1ZVxuICB9KVxuXG59KTtcblxuY29yZWZuLiRpZCA9IGNvcmVmbi5nZXRFbGVtZW50QnlJZDtcblxuW19fd2VicGFja19yZXF1aXJlX18oNjkpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDcwKSwgX193ZWJwYWNrX3JlcXVpcmVfXyg3OCksIF9fd2VicGFja19yZXF1aXJlX18oNzkpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDgwKSwgX193ZWJwYWNrX3JlcXVpcmVfXyg4MSksIF9fd2VicGFja19yZXF1aXJlX18oODIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDgzKSwgX193ZWJwYWNrX3JlcXVpcmVfXyg4NCksIF9fd2VicGFja19yZXF1aXJlX18oOTMpXS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wcykge1xuICB1dGlsLmV4dGVuZChjb3JlZm4sIHByb3BzKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvcmU7XG5cbi8qKiovIH0pLFxuLyogMTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtZW1vaXplKGZuLCBrZXlGbikge1xuICBpZiAoIWtleUZuKSB7XG4gICAga2V5Rm4gPSBmdW5jdGlvbiBrZXlGbigpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudHNbMF07XG4gICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuICd1bmRlZmluZWQnO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXJncyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFyZ3Muam9pbignJCcpO1xuICAgIH07XG4gIH1cblxuICB2YXIgbWVtb2l6ZWRGbiA9IGZ1bmN0aW9uIG1lbW9pemVkRm4oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHZhciByZXQgPSB2b2lkIDA7XG4gICAgdmFyIGsgPSBrZXlGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgICB2YXIgY2FjaGUgPSBtZW1vaXplZEZuLmNhY2hlO1xuXG4gICAgaWYgKCEocmV0ID0gY2FjaGVba10pKSB7XG4gICAgICByZXQgPSBjYWNoZVtrXSA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgbWVtb2l6ZWRGbi5jYWNoZSA9IHt9O1xuXG4gIHJldHVybiBtZW1vaXplZEZuO1xufTtcblxuLyoqKi8gfSksXG4vKiAxNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG52YXIgaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIFNldCA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cbi8vIHJlcHJlc2VudHMgYSBub2RlIG9yIGFuIGVkZ2VcbnZhciBFbGVtZW50ID0gZnVuY3Rpb24gRWxlbWVudChjeSwgcGFyYW1zLCByZXN0b3JlKSB7XG4gIHJlc3RvcmUgPSByZXN0b3JlID09PSB1bmRlZmluZWQgfHwgcmVzdG9yZSA/IHRydWUgOiBmYWxzZTtcblxuICBpZiAoY3kgPT09IHVuZGVmaW5lZCB8fCBwYXJhbXMgPT09IHVuZGVmaW5lZCB8fCAhaXMuY29yZShjeSkpIHtcbiAgICB1dGlsLmVycm9yKCdBbiBlbGVtZW50IG11c3QgaGF2ZSBhIGNvcmUgcmVmZXJlbmNlIGFuZCBwYXJhbWV0ZXJzIHNldCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBncm91cCA9IHBhcmFtcy5ncm91cDtcblxuICAvLyB0cnkgdG8gYXV0b21hdGljYWxseSBpbmZlciB0aGUgZ3JvdXAgaWYgdW5zcGVjaWZpZWRcbiAgaWYgKGdyb3VwID09IG51bGwpIHtcbiAgICBpZiAocGFyYW1zLmRhdGEgJiYgcGFyYW1zLmRhdGEuc291cmNlICE9IG51bGwgJiYgcGFyYW1zLmRhdGEudGFyZ2V0ICE9IG51bGwpIHtcbiAgICAgIGdyb3VwID0gJ2VkZ2VzJztcbiAgICB9IGVsc2Uge1xuICAgICAgZ3JvdXAgPSAnbm9kZXMnO1xuICAgIH1cbiAgfVxuXG4gIC8vIHZhbGlkYXRlIGdyb3VwXG4gIGlmIChncm91cCAhPT0gJ25vZGVzJyAmJiBncm91cCAhPT0gJ2VkZ2VzJykge1xuICAgIHV0aWwuZXJyb3IoJ0FuIGVsZW1lbnQgbXVzdCBiZSBvZiB0eXBlIGBub2Rlc2Agb3IgYGVkZ2VzYDsgeW91IHNwZWNpZmllZCBgJyArIGdyb3VwICsgJ2AnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBtYWtlIHRoZSBlbGVtZW50IGFycmF5LWxpa2UsIGp1c3QgbGlrZSBhIGNvbGxlY3Rpb25cbiAgdGhpcy5sZW5ndGggPSAxO1xuICB0aGlzWzBdID0gdGhpcztcblxuICAvLyBOT1RFOiB3aGVuIHNvbWV0aGluZyBpcyBhZGRlZCBoZXJlLCBhZGQgYWxzbyB0byBlbGUuanNvbigpXG4gIHZhciBfcCA9IHRoaXMuX3ByaXZhdGUgPSB7XG4gICAgY3k6IGN5LFxuICAgIHNpbmdsZTogdHJ1ZSwgLy8gaW5kaWNhdGVzIHRoaXMgaXMgYW4gZWxlbWVudFxuICAgIGRhdGE6IHBhcmFtcy5kYXRhIHx8IHt9LCAvLyBkYXRhIG9iamVjdFxuICAgIHBvc2l0aW9uOiBwYXJhbXMucG9zaXRpb24gfHwge30sIC8vICh4LCB5KSBwb3NpdGlvbiBwYWlyXG4gICAgYXV0b1dpZHRoOiB1bmRlZmluZWQsIC8vIHdpZHRoIGFuZCBoZWlnaHQgb2Ygbm9kZXMgY2FsY3VsYXRlZCBieSB0aGUgcmVuZGVyZXIgd2hlbiBzZXQgdG8gc3BlY2lhbCAnYXV0bycgdmFsdWVcbiAgICBhdXRvSGVpZ2h0OiB1bmRlZmluZWQsXG4gICAgYXV0b1BhZGRpbmc6IHVuZGVmaW5lZCxcbiAgICBjb21wb3VuZEJvdW5kc0NsZWFuOiBmYWxzZSwgLy8gd2hldGhlciB0aGUgY29tcG91bmQgZGltZW5zaW9ucyBuZWVkIHRvIGJlIHJlY2FsY3VsYXRlZCB0aGUgbmV4dCB0aW1lIGRpbWVuc2lvbnMgYXJlIHJlYWRcbiAgICBsaXN0ZW5lcnM6IFtdLCAvLyBhcnJheSBvZiBib3VuZCBsaXN0ZW5lcnNcbiAgICBncm91cDogZ3JvdXAsIC8vIHN0cmluZzsgJ25vZGVzJyBvciAnZWRnZXMnXG4gICAgc3R5bGU6IHt9LCAvLyBwcm9wZXJ0aWVzIGFzIHNldCBieSB0aGUgc3R5bGVcbiAgICByc3R5bGU6IHt9LCAvLyBwcm9wZXJ0aWVzIGZvciBzdHlsZSBzZW50IGZyb20gdGhlIHJlbmRlcmVyIHRvIHRoZSBjb3JlXG4gICAgc3R5bGVDeHRzOiBbXSwgLy8gYXBwbGllZCBzdHlsZSBjb250ZXh0cyBmcm9tIHRoZSBzdHlsZXJcbiAgICByZW1vdmVkOiB0cnVlLCAvLyB3aGV0aGVyIGl0J3MgaW5zaWRlIHRoZSB2aXM7IHRydWUgaWYgcmVtb3ZlZCAoc2V0IHRydWUgaGVyZSBzaW5jZSB3ZSBjYWxsIHJlc3RvcmUpXG4gICAgc2VsZWN0ZWQ6IHBhcmFtcy5zZWxlY3RlZCA/IHRydWUgOiBmYWxzZSwgLy8gd2hldGhlciBpdCdzIHNlbGVjdGVkXG4gICAgc2VsZWN0YWJsZTogcGFyYW1zLnNlbGVjdGFibGUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBwYXJhbXMuc2VsZWN0YWJsZSA/IHRydWUgOiBmYWxzZSwgLy8gd2hldGhlciBpdCdzIHNlbGVjdGFibGVcbiAgICBsb2NrZWQ6IHBhcmFtcy5sb2NrZWQgPyB0cnVlIDogZmFsc2UsIC8vIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgbG9ja2VkIChjYW5ub3QgYmUgbW92ZWQpXG4gICAgZ3JhYmJlZDogZmFsc2UsIC8vIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZ3JhYmJlZCBieSB0aGUgbW91c2U7IHJlbmRlcmVyIHNldHMgdGhpcyBwcml2YXRlbHlcbiAgICBncmFiYmFibGU6IHBhcmFtcy5ncmFiYmFibGUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBwYXJhbXMuZ3JhYmJhYmxlID8gdHJ1ZSA6IGZhbHNlLCAvLyB3aGV0aGVyIHRoZSBlbGVtZW50IGNhbiBiZSBncmFiYmVkXG4gICAgYWN0aXZlOiBmYWxzZSwgLy8gd2hldGhlciB0aGUgZWxlbWVudCBpcyBhY3RpdmUgZnJvbSB1c2VyIGludGVyYWN0aW9uXG4gICAgY2xhc3NlczogbmV3IFNldCgpLCAvLyBtYXAgKCBjbGFzc05hbWUgPT4gdHJ1ZSApXG4gICAgYW5pbWF0aW9uOiB7IC8vIG9iamVjdCBmb3IgY3VycmVudGx5LXJ1bm5pbmcgYW5pbWF0aW9uc1xuICAgICAgY3VycmVudDogW10sXG4gICAgICBxdWV1ZTogW11cbiAgICB9LFxuICAgIHJzY3JhdGNoOiB7fSwgLy8gb2JqZWN0IGluIHdoaWNoIHRoZSByZW5kZXJlciBjYW4gc3RvcmUgaW5mb3JtYXRpb25cbiAgICBzY3JhdGNoOiBwYXJhbXMuc2NyYXRjaCB8fCB7fSwgLy8gc2NyYXRjaCBvYmplY3RzXG4gICAgZWRnZXM6IFtdLCAvLyBhcnJheSBvZiBjb25uZWN0ZWQgZWRnZXNcbiAgICBjaGlsZHJlbjogW10sIC8vIGFycmF5IG9mIGNoaWxkcmVuXG4gICAgcGFyZW50OiBudWxsLCAvLyBwYXJlbnQgcmVmXG4gICAgdHJhdmVyc2FsQ2FjaGU6IHt9LCAvLyBjYWNoZSBvZiBvdXRwdXQgb2YgdHJhdmVyc2FsIGZ1bmN0aW9uc1xuICAgIGJhY2tncm91bmRpbmc6IGZhbHNlIC8vIHdoZXRoZXIgYmFja2dyb3VuZCBpbWFnZXMgYXJlIGxvYWRpbmdcbiAgfTtcblxuICAvLyByZW5kZXJlZFBvc2l0aW9uIG92ZXJyaWRlcyBpZiBzcGVjaWZpZWRcbiAgaWYgKHBhcmFtcy5yZW5kZXJlZFBvc2l0aW9uKSB7XG4gICAgdmFyIHJwb3MgPSBwYXJhbXMucmVuZGVyZWRQb3NpdGlvbjtcbiAgICB2YXIgcGFuID0gY3kucGFuKCk7XG4gICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG5cbiAgICBfcC5wb3NpdGlvbiA9IHtcbiAgICAgIHg6IChycG9zLnggLSBwYW4ueCkgLyB6b29tLFxuICAgICAgeTogKHJwb3MueSAtIHBhbi55KSAvIHpvb21cbiAgICB9O1xuICB9XG5cbiAgaWYgKGlzLnN0cmluZyhwYXJhbXMuY2xhc3NlcykpIHtcbiAgICB2YXIgY2xhc3NlcyA9IHBhcmFtcy5jbGFzc2VzLnNwbGl0KC9cXHMrLyk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjbGFzc2VzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGNscyA9IGNsYXNzZXNbaV07XG4gICAgICBpZiAoIWNscyB8fCBjbHMgPT09ICcnKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBfcC5jbGFzc2VzLmFkZChjbHMpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwYXJhbXMuc3R5bGUgfHwgcGFyYW1zLmNzcykge1xuICAgIGN5LnN0eWxlKCkuYXBwbHlCeXBhc3ModGhpcywgcGFyYW1zLnN0eWxlIHx8IHBhcmFtcy5jc3MpO1xuICB9XG5cbiAgdGhpcy5jcmVhdGVFbWl0dGVyKCk7XG5cbiAgaWYgKHJlc3RvcmUgPT09IHVuZGVmaW5lZCB8fCByZXN0b3JlKSB7XG4gICAgdGhpcy5yZXN0b3JlKCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRWxlbWVudDtcblxuLyoqKi8gfSksXG4vKiAxNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBzdGF0ZVNlbGVjdG9ycyA9IFt7XG4gIHNlbGVjdG9yOiAnOnNlbGVjdGVkJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gZWxlLnNlbGVjdGVkKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6dW5zZWxlY3RlZCcsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuICFlbGUuc2VsZWN0ZWQoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzpzZWxlY3RhYmxlJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gZWxlLnNlbGVjdGFibGUoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzp1bnNlbGVjdGFibGUnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiAhZWxlLnNlbGVjdGFibGUoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzpsb2NrZWQnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUubG9ja2VkKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6dW5sb2NrZWQnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiAhZWxlLmxvY2tlZCgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOnZpc2libGUnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUudmlzaWJsZSgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOmhpZGRlbicsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuICFlbGUudmlzaWJsZSgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOnRyYW5zcGFyZW50JyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gZWxlLnRyYW5zcGFyZW50KCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6Z3JhYmJlZCcsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5ncmFiYmVkKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6ZnJlZScsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuICFlbGUuZ3JhYmJlZCgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOnJlbW92ZWQnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUucmVtb3ZlZCgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOmluc2lkZScsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuICFlbGUucmVtb3ZlZCgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOmdyYWJiYWJsZScsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5ncmFiYmFibGUoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzp1bmdyYWJiYWJsZScsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuICFlbGUuZ3JhYmJhYmxlKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6YW5pbWF0ZWQnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUuYW5pbWF0ZWQoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzp1bmFuaW1hdGVkJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gIWVsZS5hbmltYXRlZCgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOnBhcmVudCcsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5pc1BhcmVudCgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOmNoaWxkbGVzcycsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5pc0NoaWxkbGVzcygpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOmNoaWxkJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gZWxlLmlzQ2hpbGQoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzpvcnBoYW4nLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUuaXNPcnBoYW4oKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzpub25vcnBoYW4nLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUuaXNDaGlsZCgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOmxvb3AnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUuaXNMb29wKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6c2ltcGxlJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gZWxlLmlzU2ltcGxlKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6YWN0aXZlJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gZWxlLmFjdGl2ZSgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOmluYWN0aXZlJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gIWVsZS5hY3RpdmUoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzpiYWNrZ3JvdW5kaW5nJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gZWxlLmJhY2tncm91bmRpbmcoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzpub25iYWNrZ3JvdW5kaW5nJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gIWVsZS5iYWNrZ3JvdW5kaW5nKCk7XG4gIH1cbn1dLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgLy8gbi5iLiBzZWxlY3RvcnMgdGhhdCBhcmUgc3RhcnRpbmcgc3Vic3RyaW5ncyBvZiBvdGhlcnMgbXVzdCBoYXZlIHRoZSBsb25nZXIgb25lcyBmaXJzdFxuICByZXR1cm4gdXRpbC5zb3J0LmRlc2NlbmRpbmcoYS5zZWxlY3RvciwgYi5zZWxlY3Rvcik7XG59KTtcblxudmFyIHN0YXRlU2VsZWN0b3JNYXRjaGVzID0gZnVuY3Rpb24gc3RhdGVTZWxlY3Rvck1hdGNoZXMoc2VsLCBlbGUpIHtcbiAgdmFyIGxvb2t1cCA9IHN0YXRlU2VsZWN0b3JNYXRjaGVzLmxvb2t1cCA9IHN0YXRlU2VsZWN0b3JNYXRjaGVzLmxvb2t1cCB8fCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbFRvRm4gPSB7fTtcbiAgICB2YXIgcyA9IHZvaWQgMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGVTZWxlY3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHMgPSBzdGF0ZVNlbGVjdG9yc1tpXTtcblxuICAgICAgc2VsVG9GbltzLnNlbGVjdG9yXSA9IHMubWF0Y2hlcztcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsVG9GbjtcbiAgfSgpO1xuXG4gIHJldHVybiBsb29rdXBbc2VsXShlbGUpO1xufTtcblxudmFyIHN0YXRlU2VsZWN0b3JSZWdleCA9ICcoJyArIHN0YXRlU2VsZWN0b3JzLm1hcChmdW5jdGlvbiAocykge1xuICByZXR1cm4gcy5zZWxlY3Rvcjtcbn0pLmpvaW4oJ3wnKSArICcpJztcblxubW9kdWxlLmV4cG9ydHMgPSB7IHN0YXRlU2VsZWN0b3JzOiBzdGF0ZVNlbGVjdG9ycywgc3RhdGVTZWxlY3Rvck1hdGNoZXM6IHN0YXRlU2VsZWN0b3JNYXRjaGVzLCBzdGF0ZVNlbGVjdG9yUmVnZXg6IHN0YXRlU2VsZWN0b3JSZWdleCB9O1xuXG4vKioqLyB9KSxcbi8qIDE2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qIVxuRXZlbnQgb2JqZWN0IGJhc2VkIG9uIGpRdWVyeSBldmVudHMsIE1JVCBsaWNlbnNlXG5cbmh0dHBzOi8vanF1ZXJ5Lm9yZy9saWNlbnNlL1xuaHR0cHM6Ly90bGRybGVnYWwuY29tL2xpY2Vuc2UvbWl0LWxpY2Vuc2Vcbmh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L2Jsb2IvbWFzdGVyL3NyYy9ldmVudC5qc1xuKi9cblxudmFyIEV2ZW50ID0gZnVuY3Rpb24gRXZlbnQoc3JjLCBwcm9wcykge1xuICB0aGlzLnJlY3ljbGUoc3JjLCBwcm9wcyk7XG59O1xuXG5mdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAwMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwMzAzMzEvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sXG5FdmVudC5wcm90b3R5cGUgPSB7XG4gIGluc3RhbmNlU3RyaW5nOiBmdW5jdGlvbiBpbnN0YW5jZVN0cmluZygpIHtcbiAgICByZXR1cm4gJ2V2ZW50JztcbiAgfSxcblxuICByZWN5Y2xlOiBmdW5jdGlvbiByZWN5Y2xlKHNyYywgcHJvcHMpIHtcbiAgICB0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuRmFsc2U7XG5cbiAgICBpZiAoc3JjICE9IG51bGwgJiYgc3JjLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAvLyBCcm93c2VyIEV2ZW50IG9iamVjdFxuICAgICAgdGhpcy50eXBlID0gc3JjLnR5cGU7XG5cbiAgICAgIC8vIEV2ZW50cyBidWJibGluZyB1cCB0aGUgZG9jdW1lbnQgbWF5IGhhdmUgYmVlbiBtYXJrZWQgYXMgcHJldmVudGVkXG4gICAgICAvLyBieSBhIGhhbmRsZXIgbG93ZXIgZG93biB0aGUgdHJlZTsgcmVmbGVjdCB0aGUgY29ycmVjdCB2YWx1ZS5cbiAgICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gc3JjLmRlZmF1bHRQcmV2ZW50ZWQgPyByZXR1cm5UcnVlIDogcmV0dXJuRmFsc2U7XG4gICAgfSBlbHNlIGlmIChzcmMgIT0gbnVsbCAmJiBzcmMudHlwZSkge1xuICAgICAgLy8gUGxhaW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIGV2ZW50IGRldGFpbHNcbiAgICAgIHByb3BzID0gc3JjO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBFdmVudCBzdHJpbmdcbiAgICAgIHRoaXMudHlwZSA9IHNyYztcbiAgICB9XG5cbiAgICAvLyBQdXQgZXhwbGljaXRseSBwcm92aWRlZCBwcm9wZXJ0aWVzIG9udG8gdGhlIGV2ZW50IG9iamVjdFxuICAgIGlmIChwcm9wcyAhPSBudWxsKSB7XG4gICAgICAvLyBtb3JlIGVmZmljaWVudCB0byBtYW51YWxseSBjb3B5IGZpZWxkcyB3ZSB1c2VcbiAgICAgIHRoaXMub3JpZ2luYWxFdmVudCA9IHByb3BzLm9yaWdpbmFsRXZlbnQ7XG4gICAgICB0aGlzLnR5cGUgPSBwcm9wcy50eXBlICE9IG51bGwgPyBwcm9wcy50eXBlIDogdGhpcy50eXBlO1xuICAgICAgdGhpcy5jeSA9IHByb3BzLmN5O1xuICAgICAgdGhpcy50YXJnZXQgPSBwcm9wcy50YXJnZXQ7XG4gICAgICB0aGlzLnBvc2l0aW9uID0gcHJvcHMucG9zaXRpb247XG4gICAgICB0aGlzLnJlbmRlcmVkUG9zaXRpb24gPSBwcm9wcy5yZW5kZXJlZFBvc2l0aW9uO1xuICAgICAgdGhpcy5uYW1lc3BhY2UgPSBwcm9wcy5uYW1lc3BhY2U7XG4gICAgICB0aGlzLmxheW91dCA9IHByb3BzLmxheW91dDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jeSAhPSBudWxsICYmIHRoaXMucG9zaXRpb24gIT0gbnVsbCAmJiB0aGlzLnJlbmRlcmVkUG9zaXRpb24gPT0gbnVsbCkge1xuICAgICAgLy8gY3JlYXRlIGEgcmVuZGVyZWQgcG9zaXRpb24gYmFzZWQgb24gdGhlIHBhc3NlZCBwb3NpdGlvblxuICAgICAgdmFyIHBvcyA9IHRoaXMucG9zaXRpb247XG4gICAgICB2YXIgem9vbSA9IHRoaXMuY3kuem9vbSgpO1xuICAgICAgdmFyIHBhbiA9IHRoaXMuY3kucGFuKCk7XG5cbiAgICAgIHRoaXMucmVuZGVyZWRQb3NpdGlvbiA9IHtcbiAgICAgICAgeDogcG9zLnggKiB6b29tICsgcGFuLngsXG4gICAgICAgIHk6IHBvcy55ICogem9vbSArIHBhbi55XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBhIHRpbWVzdGFtcCBpZiBpbmNvbWluZyBldmVudCBkb2Vzbid0IGhhdmUgb25lXG4gICAgdGhpcy50aW1lU3RhbXAgPSBzcmMgJiYgc3JjLnRpbWVTdGFtcCB8fCBEYXRlLm5vdygpO1xuICB9LFxuXG4gIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdCgpIHtcbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHJldHVyblRydWU7XG5cbiAgICB2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcbiAgICBpZiAoIWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBpZiBwcmV2ZW50RGVmYXVsdCBleGlzdHMgcnVuIGl0IG9uIHRoZSBvcmlnaW5hbCBldmVudFxuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9LFxuXG4gIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKCkge1xuICAgIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG4gICAgdmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG4gICAgaWYgKCFlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gaWYgc3RvcFByb3BhZ2F0aW9uIGV4aXN0cyBydW4gaXQgb24gdGhlIG9yaWdpbmFsIGV2ZW50XG4gICAgaWYgKGUuc3RvcFByb3BhZ2F0aW9uKSB7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cbiAgfSxcblxuICBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpIHtcbiAgICB0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcbiAgICB0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuICB9LFxuXG4gIGlzRGVmYXVsdFByZXZlbnRlZDogcmV0dXJuRmFsc2UsXG4gIGlzUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcbiAgaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50O1xuXG4vKioqLyB9KSxcbi8qIDE3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qKlxuICogIEVsZW1lbnRzIGFyZSBkcmF3biBpbiBhIHNwZWNpZmljIG9yZGVyIGJhc2VkIG9uIGNvbXBvdW5kIGRlcHRoIChsb3cgdG8gaGlnaCksIHRoZSBlbGVtZW50IHR5cGUgKG5vZGVzIGFib3ZlIGVkZ2VzKSxcbiAqICBhbmQgei1pbmRleCAobG93IHRvIGhpZ2gpLiAgVGhlc2Ugc3R5bGVzIGFmZmVjdCBob3cgdGhpcyBhcHBsaWVzOlxuICpcbiAqICB6LWNvbXBvdW5kLWRlcHRoOiBNYXkgYmUgYGJvdHRvbSB8IG9ycGhhbiB8IGF1dG8gfCB0b3BgLiAgVGhlIGZpcnN0IGRyYXduIGlzIGBib3R0b21gLCB0aGVuIGBvcnBoYW5gIHdoaWNoIGlzIHRoZVxuICogICAgICBzYW1lIGRlcHRoIGFzIHRoZSByb290IG9mIHRoZSBjb21wb3VuZCBncmFwaCwgZm9sbG93ZWQgYnkgdGhlIGRlZmF1bHQgdmFsdWUgYGF1dG9gIHdoaWNoIGRyYXdzIGluIG9yZGVyIGZyb21cbiAqICAgICAgcm9vdCB0byBsZWF2ZXMgb2YgdGhlIGNvbXBvdW5kIGdyYXBoLiAgVGhlIGxhc3QgZHJhd24gaXMgYHRvcGAuXG4gKiAgei1pbmRleC1jb21wYXJlOiBNYXkgYmUgYGF1dG8gfCBtYW51YWxgLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgYGF1dG9gIHdoaWNoIGFsd2F5cyBkcmF3cyBlZGdlcyB1bmRlciBub2Rlcy5cbiAqICAgICAgYG1hbnVhbGAgaWdub3JlcyB0aGlzIGNvbnZlbnRpb24gYW5kIGRyYXdzIGJhc2VkIG9uIHRoZSBgei1pbmRleGAgdmFsdWUgc2V0dGluZy5cbiAqICB6LWluZGV4OiBBbiBpbnRlZ2VyIHZhbHVlIHRoYXQgYWZmZWN0cyB0aGUgcmVsYXRpdmUgZHJhdyBvcmRlciBvZiBlbGVtZW50cy4gIEluIGdlbmVyYWwsIGFuIGVsZW1lbnQgd2l0aCBhIGhpZ2hlclxuICogICAgICBgei1pbmRleGAgd2lsbCBiZSBkcmF3biBvbiB0b3Agb2YgYW4gZWxlbWVudCB3aXRoIGEgbG93ZXIgYHotaW5kZXhgLlxuICovXG52YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciB6SW5kZXhTb3J0ID0gZnVuY3Rpb24gekluZGV4U29ydChhLCBiKSB7XG4gIHZhciBjeSA9IGEuY3koKTtcbiAgdmFyIGhhc0NvbXBvdW5kTm9kZXMgPSBjeS5oYXNDb21wb3VuZE5vZGVzKCk7XG5cbiAgZnVuY3Rpb24gZ2V0RGVwdGgoZWxlKSB7XG4gICAgdmFyIHN0eWxlID0gZWxlLnBzdHlsZSgnei1jb21wb3VuZC1kZXB0aCcpO1xuICAgIGlmIChzdHlsZS52YWx1ZSA9PT0gJ2F1dG8nKSB7XG4gICAgICByZXR1cm4gaGFzQ29tcG91bmROb2RlcyA/IGVsZS56RGVwdGgoKSA6IDA7XG4gICAgfSBlbHNlIGlmIChzdHlsZS52YWx1ZSA9PT0gJ2JvdHRvbScpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9IGVsc2UgaWYgKHN0eWxlLnZhbHVlID09PSAndG9wJykge1xuICAgICAgcmV0dXJuIHV0aWwuTUFYX0lOVDtcbiAgICB9XG4gICAgLy8gJ29ycGhhbidcbiAgICByZXR1cm4gMDtcbiAgfVxuICB2YXIgZGVwdGhEaWZmID0gZ2V0RGVwdGgoYSkgLSBnZXREZXB0aChiKTtcbiAgaWYgKGRlcHRoRGlmZiAhPT0gMCkge1xuICAgIHJldHVybiBkZXB0aERpZmY7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRFbGVEZXB0aChlbGUpIHtcbiAgICB2YXIgc3R5bGUgPSBlbGUucHN0eWxlKCd6LWluZGV4LWNvbXBhcmUnKTtcbiAgICBpZiAoc3R5bGUudmFsdWUgPT09ICdhdXRvJykge1xuICAgICAgcmV0dXJuIGVsZS5pc05vZGUoKSA/IDEgOiAwO1xuICAgIH1cbiAgICAvLyAnbWFudWFsJ1xuICAgIHJldHVybiAwO1xuICB9XG4gIHZhciBlbGVEaWZmID0gZ2V0RWxlRGVwdGgoYSkgLSBnZXRFbGVEZXB0aChiKTtcbiAgaWYgKGVsZURpZmYgIT09IDApIHtcbiAgICByZXR1cm4gZWxlRGlmZjtcbiAgfVxuXG4gIHZhciB6RGlmZiA9IGEucHN0eWxlKCd6LWluZGV4JykudmFsdWUgLSBiLnBzdHlsZSgnei1pbmRleCcpLnZhbHVlO1xuICBpZiAoekRpZmYgIT09IDApIHtcbiAgICByZXR1cm4gekRpZmY7XG4gIH1cbiAgLy8gY29tcGFyZSBpbmRpY2VzIGluIHRoZSBjb3JlIChvcmRlciBhZGRlZCB0byBncmFwaCB3LyBsYXN0IG9uIHRvcClcbiAgcmV0dXJuIGEucG9vbEluZGV4KCkgLSBiLnBvb2xJbmRleCgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB6SW5kZXhTb3J0O1xuXG4vKioqLyB9KSxcbi8qIDE4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBpcyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG52YXIgU2VsZWN0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXG52YXIgU3R5bGUgPSBmdW5jdGlvbiBTdHlsZShjeSkge1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTdHlsZSkpIHtcbiAgICByZXR1cm4gbmV3IFN0eWxlKGN5KTtcbiAgfVxuXG4gIGlmICghaXMuY29yZShjeSkpIHtcbiAgICB1dGlsLmVycm9yKCdBIHN0eWxlIG11c3QgaGF2ZSBhIGNvcmUgcmVmZXJlbmNlJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5fcHJpdmF0ZSA9IHtcbiAgICBjeTogY3ksXG4gICAgY29yZVN0eWxlOiB7fVxuICB9O1xuXG4gIHRoaXMubGVuZ3RoID0gMDtcblxuICB0aGlzLnJlc2V0VG9EZWZhdWx0KCk7XG59O1xuXG52YXIgc3R5Zm4gPSBTdHlsZS5wcm90b3R5cGU7XG5cbnN0eWZuLmluc3RhbmNlU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJ3N0eWxlJztcbn07XG5cbi8vIHJlbW92ZSBhbGwgY29udGV4dHNcbnN0eWZuLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzW2ldID0gdW5kZWZpbmVkO1xuICB9XG4gIHRoaXMubGVuZ3RoID0gMDtcblxuICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gIF9wLm5ld1N0eWxlID0gdHJ1ZTtcblxuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbnN0eWZuLnJlc2V0VG9EZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmNsZWFyKCk7XG4gIHRoaXMuYWRkRGVmYXVsdFN0eWxlc2hlZXQoKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGJ1aWxkcyBhIHN0eWxlIG9iamVjdCBmb3IgdGhlICdjb3JlJyBzZWxlY3Rvclxuc3R5Zm4uY29yZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuY29yZVN0eWxlO1xufTtcblxuLy8gY3JlYXRlIGEgbmV3IGNvbnRleHQgZnJvbSB0aGUgc3BlY2lmaWVkIHNlbGVjdG9yIHN0cmluZyBhbmQgc3dpdGNoIHRvIHRoYXQgY29udGV4dFxuc3R5Zm4uc2VsZWN0b3IgPSBmdW5jdGlvbiAoc2VsZWN0b3JTdHIpIHtcbiAgLy8gJ2NvcmUnIGlzIGEgc3BlY2lhbCBjYXNlIGFuZCBkb2VzIG5vdCBuZWVkIGEgc2VsZWN0b3JcbiAgdmFyIHNlbGVjdG9yID0gc2VsZWN0b3JTdHIgPT09ICdjb3JlJyA/IG51bGwgOiBuZXcgU2VsZWN0b3Ioc2VsZWN0b3JTdHIpO1xuXG4gIHZhciBpID0gdGhpcy5sZW5ndGgrKzsgLy8gbmV3IGNvbnRleHQgbWVhbnMgbmV3IGluZGV4XG4gIHRoaXNbaV0gPSB7XG4gICAgc2VsZWN0b3I6IHNlbGVjdG9yLFxuICAgIHByb3BlcnRpZXM6IFtdLFxuICAgIG1hcHBlZFByb3BlcnRpZXM6IFtdLFxuICAgIGluZGV4OiBpXG4gIH07XG5cbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG4vLyBhZGQgb25lIG9yIG1hbnkgY3NzIHJ1bGVzIHRvIHRoZSBjdXJyZW50IGNvbnRleHRcbnN0eWZuLmNzcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcblxuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAxOlxuICAgICAgdmFyIG1hcCA9IGFyZ3NbMF07XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwcm9wID0gc2VsZi5wcm9wZXJ0aWVzW2ldO1xuICAgICAgICB2YXIgbWFwVmFsID0gbWFwW3Byb3AubmFtZV07XG5cbiAgICAgICAgaWYgKG1hcFZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbWFwVmFsID0gbWFwW3V0aWwuZGFzaDJjYW1lbChwcm9wLm5hbWUpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXBWYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuY3NzUnVsZShwcm9wLm5hbWUsIG1hcFZhbCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIDI6XG4gICAgICB0aGlzLmNzc1J1bGUoYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBicmVhazsgLy8gZG8gbm90aGluZyBpZiBhcmdzIGFyZSBpbnZhbGlkXG4gIH1cblxuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5zdHlmbi5zdHlsZSA9IHN0eWZuLmNzcztcblxuLy8gYWRkIGEgc2luZ2xlIGNzcyBydWxlIHRvIHRoZSBjdXJyZW50IGNvbnRleHRcbnN0eWZuLmNzc1J1bGUgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgLy8gbmFtZS12YWx1ZSBwYWlyXG4gIHZhciBwcm9wZXJ0eSA9IHRoaXMucGFyc2UobmFtZSwgdmFsdWUpO1xuXG4gIC8vIGFkZCBwcm9wZXJ0eSB0byBjdXJyZW50IGNvbnRleHQgaWYgdmFsaWRcbiAgaWYgKHByb3BlcnR5KSB7XG4gICAgdmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7XG4gICAgdGhpc1tpXS5wcm9wZXJ0aWVzLnB1c2gocHJvcGVydHkpO1xuICAgIHRoaXNbaV0ucHJvcGVydGllc1twcm9wZXJ0eS5uYW1lXSA9IHByb3BlcnR5OyAvLyBhbGxvdyBhY2Nlc3MgYnkgbmFtZSBhcyB3ZWxsXG5cbiAgICBpZiAocHJvcGVydHkubmFtZS5tYXRjaCgvcGllLShcXGQrKS1iYWNrZ3JvdW5kLXNpemUvKSAmJiBwcm9wZXJ0eS52YWx1ZSkge1xuICAgICAgdGhpcy5fcHJpdmF0ZS5oYXNQaWUgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChwcm9wZXJ0eS5tYXBwZWQpIHtcbiAgICAgIHRoaXNbaV0ubWFwcGVkUHJvcGVydGllcy5wdXNoKHByb3BlcnR5KTtcbiAgICB9XG5cbiAgICAvLyBhZGQgdG8gY29yZSBzdHlsZSBpZiBuZWNlc3NhcnlcbiAgICB2YXIgY3VycmVudFNlbGVjdG9ySXNDb3JlID0gIXRoaXNbaV0uc2VsZWN0b3I7XG4gICAgaWYgKGN1cnJlbnRTZWxlY3RvcklzQ29yZSkge1xuICAgICAgdGhpcy5fcHJpdmF0ZS5jb3JlU3R5bGVbcHJvcGVydHkubmFtZV0gPSBwcm9wZXJ0eTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbnN0eWZuLmFwcGVuZCA9IGZ1bmN0aW9uIChzdHlsZSkge1xuICBpZiAoaXMuc3R5bGVzaGVldChzdHlsZSkpIHtcbiAgICBzdHlsZS5hcHBlbmRUb1N0eWxlKHRoaXMpO1xuICB9IGVsc2UgaWYgKGlzLmFycmF5KHN0eWxlKSkge1xuICAgIHRoaXMuYXBwZW5kRnJvbUpzb24oc3R5bGUpO1xuICB9IGVsc2UgaWYgKGlzLnN0cmluZyhzdHlsZSkpIHtcbiAgICB0aGlzLmFwcGVuZEZyb21TdHJpbmcoc3R5bGUpO1xuICB9IC8vIHlvdSBwcm9iYWJseSB3b3VsZG4ndCB3YW50IHRvIGFwcGVuZCBhIFN0eWxlLCBzaW5jZSB5b3UnZCBkdXBsaWNhdGUgdGhlIGRlZmF1bHQgcGFydHNcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHN0YXRpYyBmdW5jdGlvblxuU3R5bGUuZnJvbUpzb24gPSBmdW5jdGlvbiAoY3ksIGpzb24pIHtcbiAgdmFyIHN0eWxlID0gbmV3IFN0eWxlKGN5KTtcblxuICBzdHlsZS5mcm9tSnNvbihqc29uKTtcblxuICByZXR1cm4gc3R5bGU7XG59O1xuXG5TdHlsZS5mcm9tU3RyaW5nID0gZnVuY3Rpb24gKGN5LCBzdHJpbmcpIHtcbiAgcmV0dXJuIG5ldyBTdHlsZShjeSkuZnJvbVN0cmluZyhzdHJpbmcpO1xufTtcblxuW19fd2VicGFja19yZXF1aXJlX18oODUpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDg2KSwgX193ZWJwYWNrX3JlcXVpcmVfXyg4NyksIF9fd2VicGFja19yZXF1aXJlX18oODgpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDg5KSwgX193ZWJwYWNrX3JlcXVpcmVfXyg5MCksIF9fd2VicGFja19yZXF1aXJlX18oOTEpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDkyKV0uZm9yRWFjaChmdW5jdGlvbiAocHJvcHMpIHtcbiAgdXRpbC5leHRlbmQoc3R5Zm4sIHByb3BzKTtcbn0pO1xuXG5TdHlsZS50eXBlcyA9IHN0eWZuLnR5cGVzO1xuU3R5bGUucHJvcGVydGllcyA9IHN0eWZuLnByb3BlcnRpZXM7XG5cbm1vZHVsZS5leHBvcnRzID0gU3R5bGU7XG5cbi8qKiovIH0pLFxuLyogMTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgZnVsbEZwc1RpbWUgPSAxMDAwIC8gNjA7IC8vIGFzc3VtZSA2MCBmcmFtZXMgcGVyIHNlY29uZFxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0dXBEZXF1ZXVlaW5nOiBmdW5jdGlvbiBzZXR1cERlcXVldWVpbmcob3B0cykge1xuICAgIHJldHVybiBmdW5jdGlvbiBzZXR1cERlcXVldWVpbmdJbXBsKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHIgPSB0aGlzLnJlbmRlcmVyO1xuXG4gICAgICBpZiAoc2VsZi5kZXF1ZXVlaW5nU2V0dXApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5kZXF1ZXVlaW5nU2V0dXAgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgcXVldWVSZWRyYXcgPSB1dGlsLmRlYm91bmNlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgIHIucmVkcmF3SGludCgnZHJhZycsIHRydWUpO1xuXG4gICAgICAgIHIucmVkcmF3KCk7XG4gICAgICB9LCBvcHRzLmRlcVJlZHJhd1RocmVzaG9sZCk7XG5cbiAgICAgIHZhciBkZXF1ZXVlID0gZnVuY3Rpb24gZGVxdWV1ZSh3aWxsRHJhdywgZnJhbWVTdGFydFRpbWUpIHtcbiAgICAgICAgdmFyIHN0YXJ0VGltZSA9IHV0aWwucGVyZm9ybWFuY2VOb3coKTtcbiAgICAgICAgdmFyIGF2Z1JlbmRlclRpbWUgPSByLmF2ZXJhZ2VSZWRyYXdUaW1lO1xuICAgICAgICB2YXIgcmVuZGVyVGltZSA9IHIubGFzdFJlZHJhd1RpbWU7XG4gICAgICAgIHZhciBkZXFkID0gW107XG4gICAgICAgIHZhciBleHRlbnQgPSByLmN5LmV4dGVudCgpO1xuICAgICAgICB2YXIgcGl4ZWxSYXRpbyA9IHIuZ2V0UGl4ZWxSYXRpbygpO1xuXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgdmFyIG5vdyA9IHV0aWwucGVyZm9ybWFuY2VOb3coKTtcbiAgICAgICAgICB2YXIgZHVyYXRpb24gPSBub3cgLSBzdGFydFRpbWU7XG4gICAgICAgICAgdmFyIGZyYW1lRHVyYXRpb24gPSBub3cgLSBmcmFtZVN0YXJ0VGltZTtcblxuICAgICAgICAgIGlmIChyZW5kZXJUaW1lIDwgZnVsbEZwc1RpbWUpIHtcbiAgICAgICAgICAgIC8vIGlmIHdlJ3JlIHJlbmRlcmluZyBmYXN0ZXIgdGhhbiB0aGUgaWRlYWwgZnBzLCB0aGVuIGRvIGRlcXVldWVpbmdcbiAgICAgICAgICAgIC8vIGR1cmluZyBhbGwgb2YgdGhlIHJlbWFpbmluZyBmcmFtZSB0aW1lXG5cbiAgICAgICAgICAgIHZhciB0aW1lQXZhaWxhYmxlID0gZnVsbEZwc1RpbWUgLSAod2lsbERyYXcgPyBhdmdSZW5kZXJUaW1lIDogMCk7XG5cbiAgICAgICAgICAgIGlmIChmcmFtZUR1cmF0aW9uID49IG9wdHMuZGVxRmFzdENvc3QgKiB0aW1lQXZhaWxhYmxlKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAod2lsbERyYXcpIHtcbiAgICAgICAgICAgICAgaWYgKGR1cmF0aW9uID49IG9wdHMuZGVxQ29zdCAqIHJlbmRlclRpbWUgfHwgZHVyYXRpb24gPj0gb3B0cy5kZXFBdmdDb3N0ICogYXZnUmVuZGVyVGltZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZyYW1lRHVyYXRpb24gPj0gb3B0cy5kZXFOb0RyYXdDb3N0ICogZnVsbEZwc1RpbWUpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHRoaXNEZXFkID0gb3B0cy5kZXEoc2VsZiwgcGl4ZWxSYXRpbywgZXh0ZW50KTtcblxuICAgICAgICAgIGlmICh0aGlzRGVxZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXNEZXFkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGRlcWQucHVzaCh0aGlzRGVxZFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNhbGxiYWNrcyBvbiBkZXF1ZXVlXG4gICAgICAgIGlmIChkZXFkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBvcHRzLm9uRGVxZChzZWxmLCBkZXFkKTtcblxuICAgICAgICAgIGlmICghd2lsbERyYXcgJiYgb3B0cy5zaG91bGRSZWRyYXcoc2VsZiwgZGVxZCwgcGl4ZWxSYXRpbywgZXh0ZW50KSkge1xuICAgICAgICAgICAgcXVldWVSZWRyYXcoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBwcmlvcml0eSA9IG9wdHMucHJpb3JpdHkgfHwgdXRpbC5ub29wO1xuXG4gICAgICByLmJlZm9yZVJlbmRlcihkZXF1ZXVlLCBwcmlvcml0eShzZWxmKSk7XG4gICAgfTtcbiAgfVxufTtcblxuLyoqKi8gfSksXG4vKiAyMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIENvcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcbnZhciBleHRlbnNpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk0KTtcbnZhciBTdHlsZXNoZWV0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMzYpO1xuXG52YXIgY3l0b3NjYXBlID0gZnVuY3Rpb24gY3l0b3NjYXBlKG9wdGlvbnMpIHtcbiAgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gIC8vIGlmIG5vIG9wdGlvbnMgc3BlY2lmaWVkLCB1c2UgZGVmYXVsdFxuICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgLy8gY3JlYXRlIGluc3RhbmNlXG4gIGlmIChpcy5wbGFpbk9iamVjdChvcHRpb25zKSkge1xuICAgIHJldHVybiBuZXcgQ29yZShvcHRpb25zKTtcbiAgfVxuXG4gIC8vIGFsbG93IGZvciByZWdpc3RyYXRpb24gb2YgZXh0ZW5zaW9uc1xuICBlbHNlIGlmIChpcy5zdHJpbmcob3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBleHRlbnNpb24uYXBwbHkoZXh0ZW5zaW9uLCBhcmd1bWVudHMpO1xuICAgIH1cbn07XG5cbi8vIGUuZy4gY3l0b3NjYXBlLnVzZSggcmVxdWlyZSgnY3l0b3NjYXBlLWZvbycpLCBiYXIgKVxuY3l0b3NjYXBlLnVzZSA9IGZ1bmN0aW9uIChleHQpIHtcbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpOyAvLyBhcmdzIHRvIHBhc3MgdG8gZXh0XG5cbiAgYXJncy51bnNoaWZ0KGN5dG9zY2FwZSk7IC8vIGN5dG9zY2FwZSBpcyBmaXJzdCBhcmcgdG8gZXh0XG5cbiAgZXh0LmFwcGx5KG51bGwsIGFyZ3MpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gcmVwbGFjZWQgYnkgYnVpbGQgc3lzdGVtXG5jeXRvc2NhcGUudmVyc2lvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTM3KTtcblxuLy8gZXhwb3NlIHB1YmxpYyBhcGlzIChtb3N0bHkgZm9yIGV4dGVuc2lvbnMpXG5jeXRvc2NhcGUuc3R5bGVzaGVldCA9IGN5dG9zY2FwZS5TdHlsZXNoZWV0ID0gU3R5bGVzaGVldDtcblxubW9kdWxlLmV4cG9ydHMgPSBjeXRvc2NhcGU7XG5cbi8qKiovIH0pLFxuLyogMjEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGdldCBbciwgZywgYl0gZnJvbSAjYWJjIG9yICNhYWJiY2NcbiAgaGV4MnR1cGxlOiBmdW5jdGlvbiBoZXgydHVwbGUoaGV4KSB7XG4gICAgaWYgKCEoaGV4Lmxlbmd0aCA9PT0gNCB8fCBoZXgubGVuZ3RoID09PSA3KSB8fCBoZXhbMF0gIT09ICcjJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzaG9ydEhleCA9IGhleC5sZW5ndGggPT09IDQ7XG4gICAgdmFyIHIgPSB2b2lkIDAsXG4gICAgICAgIGcgPSB2b2lkIDAsXG4gICAgICAgIGIgPSB2b2lkIDA7XG4gICAgdmFyIGJhc2UgPSAxNjtcblxuICAgIGlmIChzaG9ydEhleCkge1xuICAgICAgciA9IHBhcnNlSW50KGhleFsxXSArIGhleFsxXSwgYmFzZSk7XG4gICAgICBnID0gcGFyc2VJbnQoaGV4WzJdICsgaGV4WzJdLCBiYXNlKTtcbiAgICAgIGIgPSBwYXJzZUludChoZXhbM10gKyBoZXhbM10sIGJhc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICByID0gcGFyc2VJbnQoaGV4WzFdICsgaGV4WzJdLCBiYXNlKTtcbiAgICAgIGcgPSBwYXJzZUludChoZXhbM10gKyBoZXhbNF0sIGJhc2UpO1xuICAgICAgYiA9IHBhcnNlSW50KGhleFs1XSArIGhleFs2XSwgYmFzZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtyLCBnLCBiXTtcbiAgfSxcblxuICAvLyBnZXQgW3IsIGcsIGIsIGFdIGZyb20gaHNsKDAsIDAsIDApIG9yIGhzbGEoMCwgMCwgMCwgMClcbiAgaHNsMnR1cGxlOiBmdW5jdGlvbiBoc2wydHVwbGUoaHNsKSB7XG4gICAgdmFyIHJldCA9IHZvaWQgMDtcbiAgICB2YXIgaCA9IHZvaWQgMCxcbiAgICAgICAgcyA9IHZvaWQgMCxcbiAgICAgICAgbCA9IHZvaWQgMCxcbiAgICAgICAgYSA9IHZvaWQgMCxcbiAgICAgICAgciA9IHZvaWQgMCxcbiAgICAgICAgZyA9IHZvaWQgMCxcbiAgICAgICAgYiA9IHZvaWQgMDtcbiAgICBmdW5jdGlvbiBodWUycmdiKHAsIHEsIHQpIHtcbiAgICAgIGlmICh0IDwgMCkgdCArPSAxO1xuICAgICAgaWYgKHQgPiAxKSB0IC09IDE7XG4gICAgICBpZiAodCA8IDEgLyA2KSByZXR1cm4gcCArIChxIC0gcCkgKiA2ICogdDtcbiAgICAgIGlmICh0IDwgMSAvIDIpIHJldHVybiBxO1xuICAgICAgaWYgKHQgPCAyIC8gMykgcmV0dXJuIHAgKyAocSAtIHApICogKDIgLyAzIC0gdCkgKiA2O1xuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuXG4gICAgdmFyIG0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMucmVnZXguaHNsYSArICckJykuZXhlYyhoc2wpO1xuICAgIGlmIChtKSB7XG5cbiAgICAgIC8vIGdldCBodWVcbiAgICAgIGggPSBwYXJzZUludChtWzFdKTtcbiAgICAgIGlmIChoIDwgMCkge1xuICAgICAgICBoID0gKDM2MCAtIC0xICogaCAlIDM2MCkgJSAzNjA7XG4gICAgICB9IGVsc2UgaWYgKGggPiAzNjApIHtcbiAgICAgICAgaCA9IGggJSAzNjA7XG4gICAgICB9XG4gICAgICBoIC89IDM2MDsgLy8gbm9ybWFsaXNlIG9uIFswLCAxXVxuXG4gICAgICBzID0gcGFyc2VGbG9hdChtWzJdKTtcbiAgICAgIGlmIChzIDwgMCB8fCBzID4gMTAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gc2F0dXJhdGlvbiBpcyBbMCwgMTAwXVxuICAgICAgcyA9IHMgLyAxMDA7IC8vIG5vcm1hbGlzZSBvbiBbMCwgMV1cblxuICAgICAgbCA9IHBhcnNlRmxvYXQobVszXSk7XG4gICAgICBpZiAobCA8IDAgfHwgbCA+IDEwMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIGxpZ2h0bmVzcyBpcyBbMCwgMTAwXVxuICAgICAgbCA9IGwgLyAxMDA7IC8vIG5vcm1hbGlzZSBvbiBbMCwgMV1cblxuICAgICAgYSA9IG1bNF07XG4gICAgICBpZiAoYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGEgPSBwYXJzZUZsb2F0KGEpO1xuXG4gICAgICAgIGlmIChhIDwgMCB8fCBhID4gMSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBhbHBoYSBpcyBbMCwgMV1cbiAgICAgIH1cblxuICAgICAgLy8gbm93LCBjb252ZXJ0IHRvIHJnYlxuICAgICAgLy8gY29kZSBmcm9tIGh0dHA6Ly9tamlqYWNrc29uLmNvbS8yMDA4LzAyL3JnYi10by1oc2wtYW5kLXJnYi10by1oc3YtY29sb3ItbW9kZWwtY29udmVyc2lvbi1hbGdvcml0aG1zLWluLWphdmFzY3JpcHRcbiAgICAgIGlmIChzID09PSAwKSB7XG4gICAgICAgIHIgPSBnID0gYiA9IE1hdGgucm91bmQobCAqIDI1NSk7IC8vIGFjaHJvbWF0aWNcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBxID0gbCA8IDAuNSA/IGwgKiAoMSArIHMpIDogbCArIHMgLSBsICogcztcbiAgICAgICAgdmFyIHAgPSAyICogbCAtIHE7XG4gICAgICAgIHIgPSBNYXRoLnJvdW5kKDI1NSAqIGh1ZTJyZ2IocCwgcSwgaCArIDEgLyAzKSk7XG4gICAgICAgIGcgPSBNYXRoLnJvdW5kKDI1NSAqIGh1ZTJyZ2IocCwgcSwgaCkpO1xuICAgICAgICBiID0gTWF0aC5yb3VuZCgyNTUgKiBodWUycmdiKHAsIHEsIGggLSAxIC8gMykpO1xuICAgICAgfVxuXG4gICAgICByZXQgPSBbciwgZywgYiwgYV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfSxcblxuICAvLyBnZXQgW3IsIGcsIGIsIGFdIGZyb20gcmdiKDAsIDAsIDApIG9yIHJnYmEoMCwgMCwgMCwgMClcbiAgcmdiMnR1cGxlOiBmdW5jdGlvbiByZ2IydHVwbGUocmdiKSB7XG4gICAgdmFyIHJldCA9IHZvaWQgMDtcblxuICAgIHZhciBtID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLnJlZ2V4LnJnYmEgKyAnJCcpLmV4ZWMocmdiKTtcbiAgICBpZiAobSkge1xuICAgICAgcmV0ID0gW107XG5cbiAgICAgIHZhciBpc1BjdCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gMzsgaSsrKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbVtpXTtcblxuICAgICAgICBpZiAoY2hhbm5lbFtjaGFubmVsLmxlbmd0aCAtIDFdID09PSAnJScpIHtcbiAgICAgICAgICBpc1BjdFtpXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2hhbm5lbCA9IHBhcnNlRmxvYXQoY2hhbm5lbCk7XG5cbiAgICAgICAgaWYgKGlzUGN0W2ldKSB7XG4gICAgICAgICAgY2hhbm5lbCA9IGNoYW5uZWwgLyAxMDAgKiAyNTU7IC8vIG5vcm1hbGlzZSB0byBbMCwgMjU1XVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoYW5uZWwgPCAwIHx8IGNoYW5uZWwgPiAyNTUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gaW52YWxpZCBjaGFubmVsIHZhbHVlXG5cbiAgICAgICAgcmV0LnB1c2goTWF0aC5mbG9vcihjaGFubmVsKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBhdExlYXN0T25lSXNQY3QgPSBpc1BjdFsxXSB8fCBpc1BjdFsyXSB8fCBpc1BjdFszXTtcbiAgICAgIHZhciBhbGxBcmVQY3QgPSBpc1BjdFsxXSAmJiBpc1BjdFsyXSAmJiBpc1BjdFszXTtcbiAgICAgIGlmIChhdExlYXN0T25lSXNQY3QgJiYgIWFsbEFyZVBjdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIG11c3QgYWxsIGJlIHBlcmNlbnQgdmFsdWVzIGlmIG9uZSBpc1xuXG4gICAgICB2YXIgYWxwaGEgPSBtWzRdO1xuICAgICAgaWYgKGFscGhhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYWxwaGEgPSBwYXJzZUZsb2F0KGFscGhhKTtcblxuICAgICAgICBpZiAoYWxwaGEgPCAwIHx8IGFscGhhID4gMSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBpbnZhbGlkIGFscGhhIHZhbHVlXG5cbiAgICAgICAgcmV0LnB1c2goYWxwaGEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH0sXG5cbiAgY29sb3JuYW1lMnR1cGxlOiBmdW5jdGlvbiBjb2xvcm5hbWUydHVwbGUoY29sb3IpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xvcnNbY29sb3IudG9Mb3dlckNhc2UoKV07XG4gIH0sXG5cbiAgY29sb3IydHVwbGU6IGZ1bmN0aW9uIGNvbG9yMnR1cGxlKGNvbG9yKSB7XG4gICAgcmV0dXJuIChpcy5hcnJheShjb2xvcikgPyBjb2xvciA6IG51bGwpIHx8IHRoaXMuY29sb3JuYW1lMnR1cGxlKGNvbG9yKSB8fCB0aGlzLmhleDJ0dXBsZShjb2xvcikgfHwgdGhpcy5yZ2IydHVwbGUoY29sb3IpIHx8IHRoaXMuaHNsMnR1cGxlKGNvbG9yKTtcbiAgfSxcblxuICBjb2xvcnM6IHtcbiAgICAvLyBzcGVjaWFsIGNvbG91ciBuYW1lc1xuICAgIHRyYW5zcGFyZW50OiBbMCwgMCwgMCwgMF0sIC8vIE5CIGFscGhhID09PSAwXG5cbiAgICAvLyByZWd1bGFyIGNvbG91cnNcbiAgICBhbGljZWJsdWU6IFsyNDAsIDI0OCwgMjU1XSxcbiAgICBhbnRpcXVld2hpdGU6IFsyNTAsIDIzNSwgMjE1XSxcbiAgICBhcXVhOiBbMCwgMjU1LCAyNTVdLFxuICAgIGFxdWFtYXJpbmU6IFsxMjcsIDI1NSwgMjEyXSxcbiAgICBhenVyZTogWzI0MCwgMjU1LCAyNTVdLFxuICAgIGJlaWdlOiBbMjQ1LCAyNDUsIDIyMF0sXG4gICAgYmlzcXVlOiBbMjU1LCAyMjgsIDE5Nl0sXG4gICAgYmxhY2s6IFswLCAwLCAwXSxcbiAgICBibGFuY2hlZGFsbW9uZDogWzI1NSwgMjM1LCAyMDVdLFxuICAgIGJsdWU6IFswLCAwLCAyNTVdLFxuICAgIGJsdWV2aW9sZXQ6IFsxMzgsIDQzLCAyMjZdLFxuICAgIGJyb3duOiBbMTY1LCA0MiwgNDJdLFxuICAgIGJ1cmx5d29vZDogWzIyMiwgMTg0LCAxMzVdLFxuICAgIGNhZGV0Ymx1ZTogWzk1LCAxNTgsIDE2MF0sXG4gICAgY2hhcnRyZXVzZTogWzEyNywgMjU1LCAwXSxcbiAgICBjaG9jb2xhdGU6IFsyMTAsIDEwNSwgMzBdLFxuICAgIGNvcmFsOiBbMjU1LCAxMjcsIDgwXSxcbiAgICBjb3JuZmxvd2VyYmx1ZTogWzEwMCwgMTQ5LCAyMzddLFxuICAgIGNvcm5zaWxrOiBbMjU1LCAyNDgsIDIyMF0sXG4gICAgY3JpbXNvbjogWzIyMCwgMjAsIDYwXSxcbiAgICBjeWFuOiBbMCwgMjU1LCAyNTVdLFxuICAgIGRhcmtibHVlOiBbMCwgMCwgMTM5XSxcbiAgICBkYXJrY3lhbjogWzAsIDEzOSwgMTM5XSxcbiAgICBkYXJrZ29sZGVucm9kOiBbMTg0LCAxMzQsIDExXSxcbiAgICBkYXJrZ3JheTogWzE2OSwgMTY5LCAxNjldLFxuICAgIGRhcmtncmVlbjogWzAsIDEwMCwgMF0sXG4gICAgZGFya2dyZXk6IFsxNjksIDE2OSwgMTY5XSxcbiAgICBkYXJra2hha2k6IFsxODksIDE4MywgMTA3XSxcbiAgICBkYXJrbWFnZW50YTogWzEzOSwgMCwgMTM5XSxcbiAgICBkYXJrb2xpdmVncmVlbjogWzg1LCAxMDcsIDQ3XSxcbiAgICBkYXJrb3JhbmdlOiBbMjU1LCAxNDAsIDBdLFxuICAgIGRhcmtvcmNoaWQ6IFsxNTMsIDUwLCAyMDRdLFxuICAgIGRhcmtyZWQ6IFsxMzksIDAsIDBdLFxuICAgIGRhcmtzYWxtb246IFsyMzMsIDE1MCwgMTIyXSxcbiAgICBkYXJrc2VhZ3JlZW46IFsxNDMsIDE4OCwgMTQzXSxcbiAgICBkYXJrc2xhdGVibHVlOiBbNzIsIDYxLCAxMzldLFxuICAgIGRhcmtzbGF0ZWdyYXk6IFs0NywgNzksIDc5XSxcbiAgICBkYXJrc2xhdGVncmV5OiBbNDcsIDc5LCA3OV0sXG4gICAgZGFya3R1cnF1b2lzZTogWzAsIDIwNiwgMjA5XSxcbiAgICBkYXJrdmlvbGV0OiBbMTQ4LCAwLCAyMTFdLFxuICAgIGRlZXBwaW5rOiBbMjU1LCAyMCwgMTQ3XSxcbiAgICBkZWVwc2t5Ymx1ZTogWzAsIDE5MSwgMjU1XSxcbiAgICBkaW1ncmF5OiBbMTA1LCAxMDUsIDEwNV0sXG4gICAgZGltZ3JleTogWzEwNSwgMTA1LCAxMDVdLFxuICAgIGRvZGdlcmJsdWU6IFszMCwgMTQ0LCAyNTVdLFxuICAgIGZpcmVicmljazogWzE3OCwgMzQsIDM0XSxcbiAgICBmbG9yYWx3aGl0ZTogWzI1NSwgMjUwLCAyNDBdLFxuICAgIGZvcmVzdGdyZWVuOiBbMzQsIDEzOSwgMzRdLFxuICAgIGZ1Y2hzaWE6IFsyNTUsIDAsIDI1NV0sXG4gICAgZ2FpbnNib3JvOiBbMjIwLCAyMjAsIDIyMF0sXG4gICAgZ2hvc3R3aGl0ZTogWzI0OCwgMjQ4LCAyNTVdLFxuICAgIGdvbGQ6IFsyNTUsIDIxNSwgMF0sXG4gICAgZ29sZGVucm9kOiBbMjE4LCAxNjUsIDMyXSxcbiAgICBncmF5OiBbMTI4LCAxMjgsIDEyOF0sXG4gICAgZ3JleTogWzEyOCwgMTI4LCAxMjhdLFxuICAgIGdyZWVuOiBbMCwgMTI4LCAwXSxcbiAgICBncmVlbnllbGxvdzogWzE3MywgMjU1LCA0N10sXG4gICAgaG9uZXlkZXc6IFsyNDAsIDI1NSwgMjQwXSxcbiAgICBob3RwaW5rOiBbMjU1LCAxMDUsIDE4MF0sXG4gICAgaW5kaWFucmVkOiBbMjA1LCA5MiwgOTJdLFxuICAgIGluZGlnbzogWzc1LCAwLCAxMzBdLFxuICAgIGl2b3J5OiBbMjU1LCAyNTUsIDI0MF0sXG4gICAga2hha2k6IFsyNDAsIDIzMCwgMTQwXSxcbiAgICBsYXZlbmRlcjogWzIzMCwgMjMwLCAyNTBdLFxuICAgIGxhdmVuZGVyYmx1c2g6IFsyNTUsIDI0MCwgMjQ1XSxcbiAgICBsYXduZ3JlZW46IFsxMjQsIDI1MiwgMF0sXG4gICAgbGVtb25jaGlmZm9uOiBbMjU1LCAyNTAsIDIwNV0sXG4gICAgbGlnaHRibHVlOiBbMTczLCAyMTYsIDIzMF0sXG4gICAgbGlnaHRjb3JhbDogWzI0MCwgMTI4LCAxMjhdLFxuICAgIGxpZ2h0Y3lhbjogWzIyNCwgMjU1LCAyNTVdLFxuICAgIGxpZ2h0Z29sZGVucm9keWVsbG93OiBbMjUwLCAyNTAsIDIxMF0sXG4gICAgbGlnaHRncmF5OiBbMjExLCAyMTEsIDIxMV0sXG4gICAgbGlnaHRncmVlbjogWzE0NCwgMjM4LCAxNDRdLFxuICAgIGxpZ2h0Z3JleTogWzIxMSwgMjExLCAyMTFdLFxuICAgIGxpZ2h0cGluazogWzI1NSwgMTgyLCAxOTNdLFxuICAgIGxpZ2h0c2FsbW9uOiBbMjU1LCAxNjAsIDEyMl0sXG4gICAgbGlnaHRzZWFncmVlbjogWzMyLCAxNzgsIDE3MF0sXG4gICAgbGlnaHRza3libHVlOiBbMTM1LCAyMDYsIDI1MF0sXG4gICAgbGlnaHRzbGF0ZWdyYXk6IFsxMTksIDEzNiwgMTUzXSxcbiAgICBsaWdodHNsYXRlZ3JleTogWzExOSwgMTM2LCAxNTNdLFxuICAgIGxpZ2h0c3RlZWxibHVlOiBbMTc2LCAxOTYsIDIyMl0sXG4gICAgbGlnaHR5ZWxsb3c6IFsyNTUsIDI1NSwgMjI0XSxcbiAgICBsaW1lOiBbMCwgMjU1LCAwXSxcbiAgICBsaW1lZ3JlZW46IFs1MCwgMjA1LCA1MF0sXG4gICAgbGluZW46IFsyNTAsIDI0MCwgMjMwXSxcbiAgICBtYWdlbnRhOiBbMjU1LCAwLCAyNTVdLFxuICAgIG1hcm9vbjogWzEyOCwgMCwgMF0sXG4gICAgbWVkaXVtYXF1YW1hcmluZTogWzEwMiwgMjA1LCAxNzBdLFxuICAgIG1lZGl1bWJsdWU6IFswLCAwLCAyMDVdLFxuICAgIG1lZGl1bW9yY2hpZDogWzE4NiwgODUsIDIxMV0sXG4gICAgbWVkaXVtcHVycGxlOiBbMTQ3LCAxMTIsIDIxOV0sXG4gICAgbWVkaXVtc2VhZ3JlZW46IFs2MCwgMTc5LCAxMTNdLFxuICAgIG1lZGl1bXNsYXRlYmx1ZTogWzEyMywgMTA0LCAyMzhdLFxuICAgIG1lZGl1bXNwcmluZ2dyZWVuOiBbMCwgMjUwLCAxNTRdLFxuICAgIG1lZGl1bXR1cnF1b2lzZTogWzcyLCAyMDksIDIwNF0sXG4gICAgbWVkaXVtdmlvbGV0cmVkOiBbMTk5LCAyMSwgMTMzXSxcbiAgICBtaWRuaWdodGJsdWU6IFsyNSwgMjUsIDExMl0sXG4gICAgbWludGNyZWFtOiBbMjQ1LCAyNTUsIDI1MF0sXG4gICAgbWlzdHlyb3NlOiBbMjU1LCAyMjgsIDIyNV0sXG4gICAgbW9jY2FzaW46IFsyNTUsIDIyOCwgMTgxXSxcbiAgICBuYXZham93aGl0ZTogWzI1NSwgMjIyLCAxNzNdLFxuICAgIG5hdnk6IFswLCAwLCAxMjhdLFxuICAgIG9sZGxhY2U6IFsyNTMsIDI0NSwgMjMwXSxcbiAgICBvbGl2ZTogWzEyOCwgMTI4LCAwXSxcbiAgICBvbGl2ZWRyYWI6IFsxMDcsIDE0MiwgMzVdLFxuICAgIG9yYW5nZTogWzI1NSwgMTY1LCAwXSxcbiAgICBvcmFuZ2VyZWQ6IFsyNTUsIDY5LCAwXSxcbiAgICBvcmNoaWQ6IFsyMTgsIDExMiwgMjE0XSxcbiAgICBwYWxlZ29sZGVucm9kOiBbMjM4LCAyMzIsIDE3MF0sXG4gICAgcGFsZWdyZWVuOiBbMTUyLCAyNTEsIDE1Ml0sXG4gICAgcGFsZXR1cnF1b2lzZTogWzE3NSwgMjM4LCAyMzhdLFxuICAgIHBhbGV2aW9sZXRyZWQ6IFsyMTksIDExMiwgMTQ3XSxcbiAgICBwYXBheWF3aGlwOiBbMjU1LCAyMzksIDIxM10sXG4gICAgcGVhY2hwdWZmOiBbMjU1LCAyMTgsIDE4NV0sXG4gICAgcGVydTogWzIwNSwgMTMzLCA2M10sXG4gICAgcGluazogWzI1NSwgMTkyLCAyMDNdLFxuICAgIHBsdW06IFsyMjEsIDE2MCwgMjIxXSxcbiAgICBwb3dkZXJibHVlOiBbMTc2LCAyMjQsIDIzMF0sXG4gICAgcHVycGxlOiBbMTI4LCAwLCAxMjhdLFxuICAgIHJlZDogWzI1NSwgMCwgMF0sXG4gICAgcm9zeWJyb3duOiBbMTg4LCAxNDMsIDE0M10sXG4gICAgcm95YWxibHVlOiBbNjUsIDEwNSwgMjI1XSxcbiAgICBzYWRkbGVicm93bjogWzEzOSwgNjksIDE5XSxcbiAgICBzYWxtb246IFsyNTAsIDEyOCwgMTE0XSxcbiAgICBzYW5keWJyb3duOiBbMjQ0LCAxNjQsIDk2XSxcbiAgICBzZWFncmVlbjogWzQ2LCAxMzksIDg3XSxcbiAgICBzZWFzaGVsbDogWzI1NSwgMjQ1LCAyMzhdLFxuICAgIHNpZW5uYTogWzE2MCwgODIsIDQ1XSxcbiAgICBzaWx2ZXI6IFsxOTIsIDE5MiwgMTkyXSxcbiAgICBza3libHVlOiBbMTM1LCAyMDYsIDIzNV0sXG4gICAgc2xhdGVibHVlOiBbMTA2LCA5MCwgMjA1XSxcbiAgICBzbGF0ZWdyYXk6IFsxMTIsIDEyOCwgMTQ0XSxcbiAgICBzbGF0ZWdyZXk6IFsxMTIsIDEyOCwgMTQ0XSxcbiAgICBzbm93OiBbMjU1LCAyNTAsIDI1MF0sXG4gICAgc3ByaW5nZ3JlZW46IFswLCAyNTUsIDEyN10sXG4gICAgc3RlZWxibHVlOiBbNzAsIDEzMCwgMTgwXSxcbiAgICB0YW46IFsyMTAsIDE4MCwgMTQwXSxcbiAgICB0ZWFsOiBbMCwgMTI4LCAxMjhdLFxuICAgIHRoaXN0bGU6IFsyMTYsIDE5MSwgMjE2XSxcbiAgICB0b21hdG86IFsyNTUsIDk5LCA3MV0sXG4gICAgdHVycXVvaXNlOiBbNjQsIDIyNCwgMjA4XSxcbiAgICB2aW9sZXQ6IFsyMzgsIDEzMCwgMjM4XSxcbiAgICB3aGVhdDogWzI0NSwgMjIyLCAxNzldLFxuICAgIHdoaXRlOiBbMjU1LCAyNTUsIDI1NV0sXG4gICAgd2hpdGVzbW9rZTogWzI0NSwgMjQ1LCAyNDVdLFxuICAgIHllbGxvdzogWzI1NSwgMjU1LCAwXSxcbiAgICB5ZWxsb3dncmVlbjogWzE1NCwgMjA1LCA1MF1cbiAgfVxufTtcblxuLyoqKi8gfSksXG4vKiAyMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gaGFzIGFueXRoaW5nIGJlZW4gc2V0IGluIHRoZSBtYXBcbiAgbWFwRW1wdHk6IGZ1bmN0aW9uIG1hcEVtcHR5KG1hcCkge1xuICAgIHZhciBlbXB0eSA9IHRydWU7XG5cbiAgICBpZiAobWFwICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhtYXApLmxlbmd0aCA9PT0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gZW1wdHk7XG4gIH0sXG5cbiAgLy8gcHVzaGVzIHRvIHRoZSBhcnJheSBhdCB0aGUgZW5kIG9mIGEgbWFwIChtYXAgbWF5IG5vdCBiZSBidWlsdClcbiAgcHVzaE1hcDogZnVuY3Rpb24gcHVzaE1hcChvcHRpb25zKSB7XG4gICAgdmFyIGFycmF5ID0gdGhpcy5nZXRNYXAob3B0aW9ucyk7XG5cbiAgICBpZiAoYXJyYXkgPT0gbnVsbCkge1xuICAgICAgLy8gaWYgZW1wdHksIHB1dCBpbml0aWFsIGFycmF5XG4gICAgICB0aGlzLnNldE1hcCh0aGlzLmV4dGVuZCh7fSwgb3B0aW9ucywge1xuICAgICAgICB2YWx1ZTogW29wdGlvbnMudmFsdWVdXG4gICAgICB9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFycmF5LnB1c2gob3B0aW9ucy52YWx1ZSk7XG4gICAgfVxuICB9LFxuXG4gIC8vIHNldHMgdGhlIHZhbHVlIGluIGEgbWFwIChtYXAgbWF5IG5vdCBiZSBidWlsdClcbiAgc2V0TWFwOiBmdW5jdGlvbiBzZXRNYXAob3B0aW9ucykge1xuICAgIHZhciBvYmogPSBvcHRpb25zLm1hcDtcbiAgICB2YXIga2V5ID0gdm9pZCAwO1xuICAgIHZhciBrZXlzID0gb3B0aW9ucy5rZXlzO1xuICAgIHZhciBsID0ga2V5cy5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIF9rZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoaXMucGxhaW5PYmplY3QoX2tleSkpIHtcbiAgICAgICAgdGhpcy5lcnJvcignVHJpZWQgdG8gc2V0IG1hcCB3aXRoIG9iamVjdCBrZXknKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGkgPCBrZXlzLmxlbmd0aCAtIDEpIHtcblxuICAgICAgICAvLyBleHRlbmQgdGhlIG1hcCBpZiBuZWNlc3NhcnlcbiAgICAgICAgaWYgKG9ialtfa2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgb2JqW19rZXldID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBvYmogPSBvYmpbX2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzZXQgdGhlIHZhbHVlXG4gICAgICAgIG9ialtfa2V5XSA9IG9wdGlvbnMudmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8vIGdldHMgdGhlIHZhbHVlIGluIGEgbWFwIGV2ZW4gaWYgaXQncyBub3QgYnVpbHQgaW4gcGxhY2VzXG4gIGdldE1hcDogZnVuY3Rpb24gZ2V0TWFwKG9wdGlvbnMpIHtcbiAgICB2YXIgb2JqID0gb3B0aW9ucy5tYXA7XG4gICAgdmFyIGtleXMgPSBvcHRpb25zLmtleXM7XG4gICAgdmFyIGwgPSBrZXlzLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGlzLnBsYWluT2JqZWN0KGtleSkpIHtcbiAgICAgICAgdGhpcy5lcnJvcignVHJpZWQgdG8gZ2V0IG1hcCB3aXRoIG9iamVjdCBrZXknKTtcbiAgICAgIH1cblxuICAgICAgb2JqID0gb2JqW2tleV07XG5cbiAgICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG4gIH0sXG5cbiAgLy8gZGVsZXRlcyB0aGUgZW50cnkgaW4gdGhlIG1hcFxuICBkZWxldGVNYXA6IGZ1bmN0aW9uIGRlbGV0ZU1hcChvcHRpb25zKSB7XG4gICAgdmFyIG9iaiA9IG9wdGlvbnMubWFwO1xuICAgIHZhciBrZXlzID0gb3B0aW9ucy5rZXlzO1xuICAgIHZhciBsID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIGtlZXBDaGlsZHJlbiA9IG9wdGlvbnMua2VlcENoaWxkcmVuO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoaXMucGxhaW5PYmplY3Qoa2V5KSkge1xuICAgICAgICB0aGlzLmVycm9yKCdUcmllZCB0byBkZWxldGUgbWFwIHdpdGggb2JqZWN0IGtleScpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGFzdEtleSA9IGkgPT09IG9wdGlvbnMua2V5cy5sZW5ndGggLSAxO1xuICAgICAgaWYgKGxhc3RLZXkpIHtcblxuICAgICAgICBpZiAoa2VlcENoaWxkcmVuKSB7XG4gICAgICAgICAgLy8gdGhlbiBvbmx5IGRlbGV0ZSBjaGlsZCBmaWVsZHMgbm90IGluIGtlZXBDaGlsZHJlblxuICAgICAgICAgIHZhciBjaGlsZHJlbiA9IE9iamVjdC5rZXlzKG9iaik7XG5cbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltqXTtcblxuICAgICAgICAgICAgaWYgKCFrZWVwQ2hpbGRyZW5bY2hpbGRdKSB7XG4gICAgICAgICAgICAgIG9ialtjaGlsZF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9ialtrZXldID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmogPSBvYmpba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKiovIH0pLFxuLyogMjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIG51bWJlciA9ICcoPzpbLStdPyg/Oig/OlxcXFxkK3xcXFxcZCpcXFxcLlxcXFxkKykoPzpbRWVdWystXT9cXFxcZCspPykpJztcblxudmFyIHJnYmEgPSAncmdiW2FdP1xcXFwoKCcgKyBudW1iZXIgKyAnWyVdPylcXFxccyosXFxcXHMqKCcgKyBudW1iZXIgKyAnWyVdPylcXFxccyosXFxcXHMqKCcgKyBudW1iZXIgKyAnWyVdPykoPzpcXFxccyosXFxcXHMqKCcgKyBudW1iZXIgKyAnKSk/XFxcXCknO1xudmFyIHJnYmFOb0JhY2tSZWZzID0gJ3JnYlthXT9cXFxcKCg/OicgKyBudW1iZXIgKyAnWyVdPylcXFxccyosXFxcXHMqKD86JyArIG51bWJlciArICdbJV0/KVxcXFxzKixcXFxccyooPzonICsgbnVtYmVyICsgJ1slXT8pKD86XFxcXHMqLFxcXFxzKig/OicgKyBudW1iZXIgKyAnKSk/XFxcXCknO1xuXG52YXIgaHNsYSA9ICdoc2xbYV0/XFxcXCgoJyArIG51bWJlciArICcpXFxcXHMqLFxcXFxzKignICsgbnVtYmVyICsgJ1slXSlcXFxccyosXFxcXHMqKCcgKyBudW1iZXIgKyAnWyVdKSg/OlxcXFxzKixcXFxccyooJyArIG51bWJlciArICcpKT9cXFxcKSc7XG52YXIgaHNsYU5vQmFja1JlZnMgPSAnaHNsW2FdP1xcXFwoKD86JyArIG51bWJlciArICcpXFxcXHMqLFxcXFxzKig/OicgKyBudW1iZXIgKyAnWyVdKVxcXFxzKixcXFxccyooPzonICsgbnVtYmVyICsgJ1slXSkoPzpcXFxccyosXFxcXHMqKD86JyArIG51bWJlciArICcpKT9cXFxcKSc7XG5cbnZhciBoZXgzID0gJ1xcXFwjWzAtOWEtZkEtRl17M30nO1xudmFyIGhleDYgPSAnXFxcXCNbMC05YS1mQS1GXXs2fSc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICByZWdleDoge1xuICAgIG51bWJlcjogbnVtYmVyLFxuICAgIHJnYmE6IHJnYmEsXG4gICAgcmdiYU5vQmFja1JlZnM6IHJnYmFOb0JhY2tSZWZzLFxuICAgIGhzbGE6IGhzbGEsXG4gICAgaHNsYU5vQmFja1JlZnM6IGhzbGFOb0JhY2tSZWZzLFxuICAgIGhleDM6IGhleDMsXG4gICAgaGV4NjogaGV4NlxuICB9XG59O1xuXG4vKioqLyB9KSxcbi8qIDI0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBtZW1vaXplID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG52YXIgaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICBjYW1lbDJkYXNoOiBtZW1vaXplKGZ1bmN0aW9uIChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbQS1aXSkvZywgZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJldHVybiAnLScgKyB2LnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG4gIH0pLFxuXG4gIGRhc2gyY2FtZWw6IG1lbW9pemUoZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvKC1cXHcpL2csIGZ1bmN0aW9uICh2KSB7XG4gICAgICByZXR1cm4gdlsxXS50b1VwcGVyQ2FzZSgpO1xuICAgIH0pO1xuICB9KSxcblxuICBwcmVwZW5kQ2FtZWw6IG1lbW9pemUoZnVuY3Rpb24gKHByZWZpeCwgc3RyKSB7XG4gICAgcmV0dXJuIHByZWZpeCArIHN0clswXS50b1VwcGVyQ2FzZSgpICsgc3RyLnN1YnN0cmluZygxKTtcbiAgfSwgZnVuY3Rpb24gKHByZWZpeCwgc3RyKSB7XG4gICAgcmV0dXJuIHByZWZpeCArICckJyArIHN0cjtcbiAgfSksXG5cbiAgY2FwaXRhbGl6ZTogZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHIpIHtcbiAgICBpZiAoaXMuZW1wdHlTdHJpbmcoc3RyKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnN1YnN0cmluZygxKTtcbiAgfVxuXG59O1xuXG4vKioqLyB9KSxcbi8qIDI1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciB3aW5kb3cgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xudmFyIHBlcmZvcm1hbmNlID0gd2luZG93ID8gd2luZG93LnBlcmZvcm1hbmNlIDogbnVsbDtcblxudmFyIHV0aWwgPSB7fTtcblxudmFyIHBub3cgPSBwZXJmb3JtYW5jZSAmJiBwZXJmb3JtYW5jZS5ub3cgPyBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcbn0gOiBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBEYXRlLm5vdygpO1xufTtcblxudmFyIHJhZiA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHdpbmRvdykge1xuICAgIGlmICh3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZm4pO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZShmbik7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAod2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgICAgICB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZuKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZuKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgIGlmIChmbikge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZuKHBub3coKSk7XG4gICAgICB9LCAxMDAwIC8gNjApO1xuICAgIH1cbiAgfTtcbn0oKTtcblxudXRpbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgcmFmKGZuKTtcbn07XG5cbnV0aWwucGVyZm9ybWFuY2VOb3cgPSBwbm93O1xuXG51dGlsLmRlYm91bmNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNik7XG5cbnV0aWwubm93ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gRGF0ZS5ub3coKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gdXRpbDtcblxuLyoqKi8gfSksXG4vKiAyNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMjZfXztcblxuLyoqKi8gfSksXG4vKiAyNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBhc2NlbmRpbmcoYSwgYikge1xuICBpZiAoYSA8IGIpIHtcbiAgICByZXR1cm4gLTE7XG4gIH0gZWxzZSBpZiAoYSA+IGIpIHtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMDtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZXNjZW5kaW5nKGEsIGIpIHtcbiAgcmV0dXJuIC0xICogYXNjZW5kaW5nKGEsIGIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc29ydDoge1xuICAgIGFzY2VuZGluZzogYXNjZW5kaW5nLFxuICAgIGRlc2NlbmRpbmc6IGRlc2NlbmRpbmdcbiAgfVxufTtcblxuLyoqKi8gfSksXG4vKiAyOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBPYmplY3RNYXAoKSB7XG4gIHRoaXMuX29iaiA9IHt9O1xufVxuXG52YXIgcCA9IE9iamVjdE1hcC5wcm90b3R5cGU7XG5cbnAuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsKSB7XG4gIHRoaXMuX29ialtrZXldID0gdmFsO1xufTtcblxucC5kZWxldGUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHRoaXMuX29ialtrZXldID0gbnVsbDtcbn07XG5cbnAuaGFzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gdGhpcy5fb2JqW2tleV0gIT0gbnVsbDtcbn07XG5cbnAuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gdGhpcy5fb2JqW2tleV07XG59O1xuXG4vLyBUT0RPIHVzZSB0aGUgc3RkbGliIE1hcCBpbiBmdXR1cmUuLi5cbi8vIG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIE1hcCAhPT0gJ3VuZGVmaW5lZCcgPyBNYXAgOiBPYmplY3RNYXA7XG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdE1hcDtcblxuLyoqKi8gfSksXG4vKiAyOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBlbGVzZm4gPSB7fTtcblxuW19fd2VicGFja19yZXF1aXJlX18oMzApLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKSwgX193ZWJwYWNrX3JlcXVpcmVfXygzMyksIF9fd2VicGFja19yZXF1aXJlX18oMzQpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1KSwgX193ZWJwYWNrX3JlcXVpcmVfXygzNiksIF9fd2VicGFja19yZXF1aXJlX18oMzcpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4KSwgX193ZWJwYWNrX3JlcXVpcmVfXygzOSksIF9fd2VicGFja19yZXF1aXJlX18oNDApLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxKV0uZm9yRWFjaChmdW5jdGlvbiAocHJvcHMpIHtcbiAgdXRpbC5leHRlbmQoZWxlc2ZuLCBwcm9wcyk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbGVzZm47XG5cbi8qKiovIH0pLFxuLyogMzAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIGRlZmluZVNlYXJjaCA9IGZ1bmN0aW9uIGRlZmluZVNlYXJjaChwYXJhbXMpIHtcbiAgcGFyYW1zID0ge1xuICAgIGJmczogcGFyYW1zLmJmcyB8fCAhcGFyYW1zLmRmcyxcbiAgICBkZnM6IHBhcmFtcy5kZnMgfHwgIXBhcmFtcy5iZnNcbiAgfTtcblxuICAvLyBmcm9tIHBzZXVkb2NvZGUgb24gd2lraXBlZGlhXG4gIHJldHVybiBmdW5jdGlvbiBzZWFyY2hGbihyb290cywgZm4sIGRpcmVjdGVkKSB7XG4gICAgdmFyIG9wdGlvbnM7XG4gICAgaWYgKGlzLnBsYWluT2JqZWN0KHJvb3RzKSAmJiAhaXMuZWxlbWVudE9yQ29sbGVjdGlvbihyb290cykpIHtcbiAgICAgIG9wdGlvbnMgPSByb290cztcbiAgICAgIHJvb3RzID0gb3B0aW9ucy5yb290cyB8fCBvcHRpb25zLnJvb3Q7XG4gICAgICBmbiA9IG9wdGlvbnMudmlzaXQ7XG4gICAgICBkaXJlY3RlZCA9IG9wdGlvbnMuZGlyZWN0ZWQ7XG4gICAgfVxuXG4gICAgZGlyZWN0ZWQgPSBhcmd1bWVudHMubGVuZ3RoID09PSAyICYmICFpcy5mbihmbikgPyBmbiA6IGRpcmVjdGVkO1xuICAgIGZuID0gaXMuZm4oZm4pID8gZm4gOiBmdW5jdGlvbiAoKSB7fTtcblxuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgdmFyIHYgPSByb290cyA9IGlzLnN0cmluZyhyb290cykgPyB0aGlzLmZpbHRlcihyb290cykgOiByb290cztcbiAgICB2YXIgUSA9IFtdO1xuICAgIHZhciBjb25uZWN0ZWROb2RlcyA9IFtdO1xuICAgIHZhciBjb25uZWN0ZWRCeSA9IHt9O1xuICAgIHZhciBpZDJkZXB0aCA9IHt9O1xuICAgIHZhciBWID0ge307XG4gICAgdmFyIGogPSAwO1xuICAgIHZhciBmb3VuZDtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgdmFyIGVkZ2VzID0gdGhpcy5lZGdlcygpO1xuXG4gICAgLy8gZW5xdWV1ZSB2XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodltpXS5pc05vZGUoKSkge1xuICAgICAgICBRLnVuc2hpZnQodltpXSk7XG5cbiAgICAgICAgaWYgKHBhcmFtcy5iZnMpIHtcbiAgICAgICAgICBWW3ZbaV0uaWQoKV0gPSB0cnVlO1xuXG4gICAgICAgICAgY29ubmVjdGVkTm9kZXMucHVzaCh2W2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlkMmRlcHRoW3ZbaV0uaWQoKV0gPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHdoaWxlIChRLmxlbmd0aCAhPT0gMCkge1xuICAgICAgdmFyIHYgPSBwYXJhbXMuYmZzID8gUS5zaGlmdCgpIDogUS5wb3AoKTtcblxuICAgICAgaWYgKHBhcmFtcy5kZnMpIHtcbiAgICAgICAgaWYgKFZbdi5pZCgpXSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgVlt2LmlkKCldID0gdHJ1ZTtcblxuICAgICAgICBjb25uZWN0ZWROb2Rlcy5wdXNoKHYpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGVwdGggPSBpZDJkZXB0aFt2LmlkKCldO1xuICAgICAgdmFyIHByZXZFZGdlID0gY29ubmVjdGVkQnlbdi5pZCgpXTtcbiAgICAgIHZhciBwcmV2Tm9kZSA9IHByZXZFZGdlID09IG51bGwgPyB1bmRlZmluZWQgOiBwcmV2RWRnZS5jb25uZWN0ZWROb2RlcygpLm5vdCh2KVswXTtcbiAgICAgIHZhciByZXQ7XG5cbiAgICAgIHJldCA9IGZuKHYsIHByZXZFZGdlLCBwcmV2Tm9kZSwgaisrLCBkZXB0aCk7XG5cbiAgICAgIGlmIChyZXQgPT09IHRydWUpIHtcbiAgICAgICAgZm91bmQgPSB2O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHZhciB2d0VkZ2VzID0gdi5jb25uZWN0ZWRFZGdlcyhkaXJlY3RlZCA/IGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgcmV0dXJuIGVsZS5kYXRhKCdzb3VyY2UnKSA9PT0gdi5pZCgpO1xuICAgICAgfSA6IHVuZGVmaW5lZCkuaW50ZXJzZWN0KGVkZ2VzKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdndFZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZSA9IHZ3RWRnZXNbaV07XG4gICAgICAgIHZhciB3ID0gZS5jb25uZWN0ZWROb2RlcyhmdW5jdGlvbiAobikge1xuICAgICAgICAgIHJldHVybiBuLmlkKCkgIT09IHYuaWQoKTtcbiAgICAgICAgfSkuaW50ZXJzZWN0KG5vZGVzKTtcblxuICAgICAgICBpZiAody5sZW5ndGggIT09IDAgJiYgIVZbdy5pZCgpXSkge1xuICAgICAgICAgIHcgPSB3WzBdO1xuXG4gICAgICAgICAgUS5wdXNoKHcpO1xuXG4gICAgICAgICAgaWYgKHBhcmFtcy5iZnMpIHtcbiAgICAgICAgICAgIFZbdy5pZCgpXSA9IHRydWU7XG5cbiAgICAgICAgICAgIGNvbm5lY3RlZE5vZGVzLnB1c2godyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29ubmVjdGVkQnlbdy5pZCgpXSA9IGU7XG5cbiAgICAgICAgICBpZDJkZXB0aFt3LmlkKCldID0gaWQyZGVwdGhbdi5pZCgpXSArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY29ubmVjdGVkRWxlcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb25uZWN0ZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5vZGUgPSBjb25uZWN0ZWROb2Rlc1tpXTtcbiAgICAgIHZhciBlZGdlID0gY29ubmVjdGVkQnlbbm9kZS5pZCgpXTtcblxuICAgICAgaWYgKGVkZ2UpIHtcbiAgICAgICAgY29ubmVjdGVkRWxlcy5wdXNoKGVkZ2UpO1xuICAgICAgfVxuXG4gICAgICBjb25uZWN0ZWRFbGVzLnB1c2gobm9kZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6IGN5LmNvbGxlY3Rpb24oY29ubmVjdGVkRWxlcywgeyB1bmlxdWU6IHRydWUgfSksXG4gICAgICBmb3VuZDogY3kuY29sbGVjdGlvbihmb3VuZClcbiAgICB9O1xuICB9O1xufTtcblxuLy8gc2VhcmNoLCBzcGFubmluZyB0cmVlcywgZXRjXG52YXIgZWxlc2ZuID0ge1xuICBicmVhZHRoRmlyc3RTZWFyY2g6IGRlZmluZVNlYXJjaCh7IGJmczogdHJ1ZSB9KSxcbiAgZGVwdGhGaXJzdFNlYXJjaDogZGVmaW5lU2VhcmNoKHsgZGZzOiB0cnVlIH0pXG59O1xuXG4vLyBuaWNlLCBzaG9ydCBtYXRoZW1hdGhpY2FsIGFsaWFzXG5lbGVzZm4uYmZzID0gZWxlc2ZuLmJyZWFkdGhGaXJzdFNlYXJjaDtcbmVsZXNmbi5kZnMgPSBlbGVzZm4uZGVwdGhGaXJzdFNlYXJjaDtcblxubW9kdWxlLmV4cG9ydHMgPSBlbGVzZm47XG5cbi8qKiovIH0pLFxuLyogMzEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBIZWFwID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblxudmFyIGVsZXNmbiA9IHtcblxuICBkaWprc3RyYTogZnVuY3Rpb24gZGlqa3N0cmEocm9vdCwgd2VpZ2h0Rm4sIGRpcmVjdGVkKSB7XG4gICAgdmFyIG9wdGlvbnM7XG4gICAgaWYgKGlzLnBsYWluT2JqZWN0KHJvb3QpICYmICFpcy5lbGVtZW50T3JDb2xsZWN0aW9uKHJvb3QpKSB7XG4gICAgICBvcHRpb25zID0gcm9vdDtcbiAgICAgIHJvb3QgPSBvcHRpb25zLnJvb3Q7XG4gICAgICB3ZWlnaHRGbiA9IG9wdGlvbnMud2VpZ2h0O1xuICAgICAgZGlyZWN0ZWQgPSBvcHRpb25zLmRpcmVjdGVkO1xuICAgIH1cblxuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgd2VpZ2h0Rm4gPSBpcy5mbih3ZWlnaHRGbikgPyB3ZWlnaHRGbiA6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH07IC8vIGlmIG5vdCBzcGVjaWZpZWQsIGFzc3VtZSBlYWNoIGVkZ2UgaGFzIGVxdWFsIHdlaWdodCAoMSlcblxuICAgIHZhciBzb3VyY2UgPSBpcy5zdHJpbmcocm9vdCkgPyB0aGlzLmZpbHRlcihyb290KVswXSA6IHJvb3RbMF07XG4gICAgdmFyIGRpc3QgPSB7fTtcbiAgICB2YXIgcHJldiA9IHt9O1xuICAgIHZhciBrbm93bkRpc3QgPSB7fTtcblxuICAgIHZhciBlZGdlcyA9IHRoaXMuZWRnZXMoKS5maWx0ZXIoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgcmV0dXJuICFlbGUuaXNMb29wKCk7XG4gICAgfSk7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuXG4gICAgdmFyIGdldERpc3QgPSBmdW5jdGlvbiBnZXREaXN0KG5vZGUpIHtcbiAgICAgIHJldHVybiBkaXN0W25vZGUuaWQoKV07XG4gICAgfTtcblxuICAgIHZhciBzZXREaXN0ID0gZnVuY3Rpb24gc2V0RGlzdChub2RlLCBkKSB7XG4gICAgICBkaXN0W25vZGUuaWQoKV0gPSBkO1xuXG4gICAgICBRLnVwZGF0ZUl0ZW0obm9kZSk7XG4gICAgfTtcblxuICAgIHZhciBRID0gbmV3IEhlYXAoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBnZXREaXN0KGEpIC0gZ2V0RGlzdChiKTtcbiAgICB9KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG5cbiAgICAgIGRpc3Rbbm9kZS5pZCgpXSA9IG5vZGUuc2FtZShzb3VyY2UpID8gMCA6IEluZmluaXR5O1xuICAgICAgUS5wdXNoKG5vZGUpO1xuICAgIH1cblxuICAgIHZhciBkaXN0QmV0d2VlbiA9IGZ1bmN0aW9uIGRpc3RCZXR3ZWVuKHUsIHYpIHtcbiAgICAgIHZhciB1dnMgPSAoZGlyZWN0ZWQgPyB1LmVkZ2VzVG8odikgOiB1LmVkZ2VzV2l0aCh2KSkuaW50ZXJzZWN0KGVkZ2VzKTtcbiAgICAgIHZhciBzbWFsbGVzdERpc3RhbmNlID0gSW5maW5pdHk7XG4gICAgICB2YXIgc21hbGxlc3RFZGdlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHV2cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWRnZSA9IHV2c1tpXTtcbiAgICAgICAgdmFyIHdlaWdodCA9IHdlaWdodEZuKGVkZ2UpO1xuXG4gICAgICAgIGlmICh3ZWlnaHQgPCBzbWFsbGVzdERpc3RhbmNlIHx8ICFzbWFsbGVzdEVkZ2UpIHtcbiAgICAgICAgICBzbWFsbGVzdERpc3RhbmNlID0gd2VpZ2h0O1xuICAgICAgICAgIHNtYWxsZXN0RWRnZSA9IGVkZ2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZWRnZTogc21hbGxlc3RFZGdlLFxuICAgICAgICBkaXN0OiBzbWFsbGVzdERpc3RhbmNlXG4gICAgICB9O1xuICAgIH07XG5cbiAgICB3aGlsZSAoUS5zaXplKCkgPiAwKSB7XG4gICAgICB2YXIgdSA9IFEucG9wKCk7XG4gICAgICB2YXIgc21hbGxldHNEaXN0ID0gZ2V0RGlzdCh1KTtcbiAgICAgIHZhciB1aWQgPSB1LmlkKCk7XG5cbiAgICAgIGtub3duRGlzdFt1aWRdID0gc21hbGxldHNEaXN0O1xuXG4gICAgICBpZiAoc21hbGxldHNEaXN0ID09PSBJbmZpbml0eSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5laWdoYm9ycyA9IHUubmVpZ2hib3Job29kKCkuaW50ZXJzZWN0KG5vZGVzKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmVpZ2hib3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB2ID0gbmVpZ2hib3JzW2ldO1xuICAgICAgICB2YXIgdmlkID0gdi5pZCgpO1xuICAgICAgICB2YXIgdkRpc3QgPSBkaXN0QmV0d2Vlbih1LCB2KTtcblxuICAgICAgICB2YXIgYWx0ID0gc21hbGxldHNEaXN0ICsgdkRpc3QuZGlzdDtcblxuICAgICAgICBpZiAoYWx0IDwgZ2V0RGlzdCh2KSkge1xuICAgICAgICAgIHNldERpc3QodiwgYWx0KTtcblxuICAgICAgICAgIHByZXZbdmlkXSA9IHtcbiAgICAgICAgICAgIG5vZGU6IHUsXG4gICAgICAgICAgICBlZGdlOiB2RGlzdC5lZGdlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBmb3JcbiAgICB9IC8vIHdoaWxlXG5cbiAgICByZXR1cm4ge1xuICAgICAgZGlzdGFuY2VUbzogZnVuY3Rpb24gZGlzdGFuY2VUbyhub2RlKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBpcy5zdHJpbmcobm9kZSkgPyBub2Rlcy5maWx0ZXIobm9kZSlbMF0gOiBub2RlWzBdO1xuXG4gICAgICAgIHJldHVybiBrbm93bkRpc3RbdGFyZ2V0LmlkKCldO1xuICAgICAgfSxcblxuICAgICAgcGF0aFRvOiBmdW5jdGlvbiBwYXRoVG8obm9kZSkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gaXMuc3RyaW5nKG5vZGUpID8gbm9kZXMuZmlsdGVyKG5vZGUpWzBdIDogbm9kZVswXTtcbiAgICAgICAgdmFyIFMgPSBbXTtcbiAgICAgICAgdmFyIHUgPSB0YXJnZXQ7XG5cbiAgICAgICAgaWYgKHRhcmdldC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgUy51bnNoaWZ0KHRhcmdldCk7XG5cbiAgICAgICAgICB3aGlsZSAocHJldlt1LmlkKCldKSB7XG4gICAgICAgICAgICB2YXIgcCA9IHByZXZbdS5pZCgpXTtcblxuICAgICAgICAgICAgUy51bnNoaWZ0KHAuZWRnZSk7XG4gICAgICAgICAgICBTLnVuc2hpZnQocC5ub2RlKTtcblxuICAgICAgICAgICAgdSA9IHAubm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY3kuY29sbGVjdGlvbihTKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVsZXNmbjtcblxuLyoqKi8gfSksXG4vKiAzMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMzJfXztcblxuLyoqKi8gfSksXG4vKiAzMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG4vLyBzZWFyY2gsIHNwYW5uaW5nIHRyZWVzLCBldGNcbnZhciBlbGVzZm4gPSB7XG5cbiAgLy8ga3J1c2thbCdzIGFsZ29yaXRobSAoZmluZHMgbWluIHNwYW5uaW5nIHRyZWUsIGFzc3VtaW5nIHVuZGlyZWN0ZWQgZ3JhcGgpXG4gIC8vIGltcGxlbWVudGVkIGZyb20gcHNldWRvY29kZSBmcm9tIHdpa2lwZWRpYVxuICBrcnVza2FsOiBmdW5jdGlvbiBrcnVza2FsKHdlaWdodEZuKSB7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuXG4gICAgd2VpZ2h0Rm4gPSBpcy5mbih3ZWlnaHRGbikgPyB3ZWlnaHRGbiA6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH07IC8vIGlmIG5vdCBzcGVjaWZpZWQsIGFzc3VtZSBlYWNoIGVkZ2UgaGFzIGVxdWFsIHdlaWdodCAoMSlcblxuICAgIGZ1bmN0aW9uIGZpbmRTZXQoZWxlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZvcmVzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlcyA9IGZvcmVzdFtpXTtcblxuICAgICAgICBpZiAoZWxlcy5hbnlTYW1lKGVsZSkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZWxlczogZWxlcyxcbiAgICAgICAgICAgIGluZGV4OiBpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBBID0gY3kuY29sbGVjdGlvbihjeSwgW10pO1xuICAgIHZhciBmb3Jlc3QgPSBbXTtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmb3Jlc3QucHVzaChub2Rlc1tpXS5jb2xsZWN0aW9uKCkpO1xuICAgIH1cblxuICAgIHZhciBlZGdlcyA9IHRoaXMuZWRnZXMoKTtcbiAgICB2YXIgUyA9IGVkZ2VzLnRvQXJyYXkoKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICB2YXIgd2VpZ2h0QSA9IHdlaWdodEZuKGEpO1xuICAgICAgdmFyIHdlaWdodEIgPSB3ZWlnaHRGbihiKTtcblxuICAgICAgcmV0dXJuIHdlaWdodEEgLSB3ZWlnaHRCO1xuICAgIH0pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBTLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWRnZSA9IFNbaV07XG4gICAgICB2YXIgdSA9IGVkZ2Uuc291cmNlKClbMF07XG4gICAgICB2YXIgdiA9IGVkZ2UudGFyZ2V0KClbMF07XG4gICAgICB2YXIgc2V0VSA9IGZpbmRTZXQodSk7XG4gICAgICB2YXIgc2V0ViA9IGZpbmRTZXQodik7XG5cbiAgICAgIGlmIChzZXRVLmluZGV4ICE9PSBzZXRWLmluZGV4KSB7XG4gICAgICAgIEEgPSBBLmFkZChlZGdlKTtcblxuICAgICAgICAvLyBjb21iaW5lIGZvcmVzdHMgZm9yIHUgYW5kIHZcbiAgICAgICAgZm9yZXN0W3NldFUuaW5kZXhdID0gc2V0VS5lbGVzLmFkZChzZXRWLmVsZXMpO1xuICAgICAgICBmb3Jlc3Quc3BsaWNlKHNldFYuaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBub2Rlcy5hZGQoQSk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuXG4vKioqLyB9KSxcbi8qIDM0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBpcyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBlbGVzZm4gPSB7XG5cbiAgLy8gSW1wbGVtZW50ZWQgZnJvbSBwc2V1ZG9jb2RlIGZyb20gd2lraXBlZGlhXG4gIGFTdGFyOiBmdW5jdGlvbiBhU3RhcihvcHRpb25zKSB7XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvLyBSZWNvbnN0cnVjdHMgdGhlIHBhdGggZnJvbSBTdGFydCB0byBFbmQsIGFjdW11bGF0aW5nIHRoZSByZXN1bHQgaW4gcGF0aEFjdW1cbiAgICB2YXIgcmVjb25zdHJ1Y3RQYXRoID0gZnVuY3Rpb24gcmVjb25zdHJ1Y3RQYXRoKHN0YXJ0LCBlbmQsIGNhbWVGcm9tTWFwLCBwYXRoQWN1bSkge1xuICAgICAgLy8gQmFzZSBjYXNlXG4gICAgICBpZiAoc3RhcnQgPT0gZW5kKSB7XG4gICAgICAgIHBhdGhBY3VtLnVuc2hpZnQoY3kuZ2V0RWxlbWVudEJ5SWQoZW5kKSk7XG4gICAgICAgIHJldHVybiBwYXRoQWN1bTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVuZCBpbiBjYW1lRnJvbU1hcCkge1xuICAgICAgICAvLyBXZSBrbm93IHdoaWNoIG5vZGUgaXMgYmVmb3JlIHRoZSBsYXN0IG9uZVxuICAgICAgICB2YXIgcHJldmlvdXMgPSBjYW1lRnJvbU1hcFtlbmRdO1xuICAgICAgICB2YXIgcHJldmlvdXNFZGdlID0gY2FtZUZyb21FZGdlW2VuZF07XG5cbiAgICAgICAgcGF0aEFjdW0udW5zaGlmdChjeS5nZXRFbGVtZW50QnlJZChwcmV2aW91c0VkZ2UpKTtcbiAgICAgICAgcGF0aEFjdW0udW5zaGlmdChjeS5nZXRFbGVtZW50QnlJZChlbmQpKTtcblxuICAgICAgICByZXR1cm4gcmVjb25zdHJ1Y3RQYXRoKHN0YXJ0LCBwcmV2aW91cywgY2FtZUZyb21NYXAsIHBhdGhBY3VtKTtcbiAgICAgIH1cblxuICAgICAgLy8gV2Ugc2hvdWxkIG5vdCByZWFjaCBoZXJlIVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuXG4gICAgLy8gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgaW4gb3BlblNldCB3aGljaCBoYXMgbWluaW11bSBmU2NvcmVcbiAgICB2YXIgZmluZE1pbiA9IGZ1bmN0aW9uIGZpbmRNaW4ob3BlblNldCwgZlNjb3JlKSB7XG4gICAgICBpZiAob3BlblNldC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gU2hvdWxkIG5ldmVyIGJlIHRoZSBjYXNlXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB2YXIgbWluUG9zID0gMDtcbiAgICAgIHZhciB0ZW1wU2NvcmUgPSBmU2NvcmVbb3BlblNldFswXV07XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IG9wZW5TZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHMgPSBmU2NvcmVbb3BlblNldFtpXV07XG4gICAgICAgIGlmIChzIDwgdGVtcFNjb3JlKSB7XG4gICAgICAgICAgdGVtcFNjb3JlID0gcztcbiAgICAgICAgICBtaW5Qb3MgPSBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbWluUG9zO1xuICAgIH07XG5cbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuXG4gICAgLy8gcm9vdCAtIG1hbmRhdG9yeSFcbiAgICBpZiAob3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMucm9vdCAhPSBudWxsKSB7XG4gICAgICB2YXIgc291cmNlID0gaXMuc3RyaW5nKG9wdGlvbnMucm9vdCkgP1xuICAgICAgLy8gdXNlIGl0IGFzIGEgc2VsZWN0b3IsIGUuZy4gXCIjcm9vdElEXG4gICAgICB0aGlzLmZpbHRlcihvcHRpb25zLnJvb3QpWzBdIDogb3B0aW9ucy5yb290WzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIGdvYWwgLSBtYW5kYXRvcnkhXG4gICAgaWYgKG9wdGlvbnMuZ29hbCAhPSBudWxsKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gaXMuc3RyaW5nKG9wdGlvbnMuZ29hbCkgP1xuICAgICAgLy8gdXNlIGl0IGFzIGEgc2VsZWN0b3IsIGUuZy4gXCIjZ29hbElEXG4gICAgICB0aGlzLmZpbHRlcihvcHRpb25zLmdvYWwpWzBdIDogb3B0aW9ucy5nb2FsWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIEhldXJpc3RpYyBmdW5jdGlvbiAtIG9wdGlvbmFsXG4gICAgaWYgKG9wdGlvbnMuaGV1cmlzdGljICE9IG51bGwgJiYgaXMuZm4ob3B0aW9ucy5oZXVyaXN0aWMpKSB7XG4gICAgICB2YXIgaGV1cmlzdGljID0gb3B0aW9ucy5oZXVyaXN0aWM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBoZXVyaXN0aWMgPSBmdW5jdGlvbiBoZXVyaXN0aWMoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfTsgLy8gdXNlIGNvbnN0YW50IGlmIHVuc3BlY2lmaWVkXG4gICAgfVxuXG4gICAgLy8gV2VpZ2h0IGZ1bmN0aW9uIC0gb3B0aW9uYWxcbiAgICBpZiAob3B0aW9ucy53ZWlnaHQgIT0gbnVsbCAmJiBpcy5mbihvcHRpb25zLndlaWdodCkpIHtcbiAgICAgIHZhciB3ZWlnaHRGbiA9IG9wdGlvbnMud2VpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBub3Qgc3BlY2lmaWVkLCBhc3N1bWUgZWFjaCBlZGdlIGhhcyBlcXVhbCB3ZWlnaHQgKDEpXG4gICAgICB2YXIgd2VpZ2h0Rm4gPSBmdW5jdGlvbiB3ZWlnaHRGbihlKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBkaXJlY3RlZCAtIG9wdGlvbmFsXG4gICAgaWYgKG9wdGlvbnMuZGlyZWN0ZWQgIT0gbnVsbCkge1xuICAgICAgdmFyIGRpcmVjdGVkID0gb3B0aW9ucy5kaXJlY3RlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRpcmVjdGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHNpZCA9IHNvdXJjZS5pZCgpO1xuICAgIHZhciB0aWQgPSB0YXJnZXQuaWQoKTtcblxuICAgIHZhciBjbG9zZWRTZXQgPSBbXTtcbiAgICB2YXIgb3BlblNldCA9IFtzaWRdO1xuICAgIHZhciBjYW1lRnJvbSA9IHt9O1xuICAgIHZhciBjYW1lRnJvbUVkZ2UgPSB7fTtcbiAgICB2YXIgZ1Njb3JlID0ge307XG4gICAgdmFyIGZTY29yZSA9IHt9O1xuXG4gICAgZ1Njb3JlW3NpZF0gPSAwO1xuICAgIGZTY29yZVtzaWRdID0gaGV1cmlzdGljKHNvdXJjZSk7XG5cbiAgICAvLyBDb3VudGVyXG4gICAgdmFyIHN0ZXBzID0gMDtcblxuICAgIC8vIE1haW4gbG9vcFxuICAgIHdoaWxlIChvcGVuU2V0Lmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBtaW5Qb3MgPSBmaW5kTWluKG9wZW5TZXQsIGZTY29yZSk7XG4gICAgICB2YXIgY01pbiA9IGN5LmdldEVsZW1lbnRCeUlkKG9wZW5TZXRbbWluUG9zXSk7XG4gICAgICB2YXIgY01pbklkID0gY01pbi5pZCgpO1xuICAgICAgc3RlcHMrKztcblxuICAgICAgLy8gSWYgd2UndmUgZm91bmQgb3VyIGdvYWwsIHRoZW4gd2UgYXJlIGRvbmVcbiAgICAgIGlmIChjTWluSWQgPT0gdGlkKSB7XG4gICAgICAgIHZhciByUGF0aCA9IHJlY29uc3RydWN0UGF0aChzaWQsIHRpZCwgY2FtZUZyb20sIFtdKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGZvdW5kOiB0cnVlLFxuICAgICAgICAgIGRpc3RhbmNlOiBnU2NvcmVbY01pbklkXSxcbiAgICAgICAgICBwYXRoOiBlbGVzLnNwYXduKHJQYXRoKSxcbiAgICAgICAgICBzdGVwczogc3RlcHNcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gQWRkIGNNaW4gdG8gcHJvY2Vzc2VkIG5vZGVzXG4gICAgICBjbG9zZWRTZXQucHVzaChjTWluSWQpO1xuICAgICAgLy8gUmVtb3ZlIGNNaW4gZnJvbSBib3VuZGFyeSBub2Rlc1xuICAgICAgb3BlblNldC5zcGxpY2UobWluUG9zLCAxKTtcblxuICAgICAgLy8gVXBkYXRlIHNjb3JlcyBmb3IgbmVpZ2hib3JzIG9mIGNNaW5cbiAgICAgIC8vIFRha2UgaW50byBhY2NvdW50IGlmIGdyYXBoIGlzIGRpcmVjdGVkIG9yIG5vdFxuICAgICAgdmFyIHZ3RWRnZXMgPSBjTWluLl9wcml2YXRlLmVkZ2VzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZ3RWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGUgPSB2d0VkZ2VzW2ldO1xuXG4gICAgICAgIC8vIGVkZ2UgbXVzdCBiZSBpbiBzZXQgb2YgY2FsbGluZyBlbGVzXG4gICAgICAgIGlmICghdGhpcy5oYXNFbGVtZW50V2l0aElkKGUuaWQoKSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNNaW4gbXVzdCBiZSB0aGUgc291cmNlIG9mIGVkZ2UgaWYgZGlyZWN0ZWRcbiAgICAgICAgaWYgKGRpcmVjdGVkICYmIGUuZGF0YSgnc291cmNlJykgIT09IGNNaW5JZCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHdTcmMgPSBlLnNvdXJjZSgpO1xuICAgICAgICB2YXIgd1RndCA9IGUudGFyZ2V0KCk7XG5cbiAgICAgICAgdmFyIHcgPSB3U3JjLmlkKCkgIT09IGNNaW5JZCA/IHdTcmMgOiB3VGd0O1xuICAgICAgICB2YXIgd2lkID0gdy5pZCgpO1xuXG4gICAgICAgIC8vIG5vZGUgbXVzdCBiZSBpbiBzZXQgb2YgY2FsbGluZyBlbGVzXG4gICAgICAgIGlmICghdGhpcy5oYXNFbGVtZW50V2l0aElkKHdpZCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIG5vZGUgaXMgaW4gY2xvc2VkU2V0LCBpZ25vcmUgaXRcbiAgICAgICAgaWYgKGNsb3NlZFNldC5pbmRleE9mKHdpZCkgIT0gLTEpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5ldyB0ZW50YXRpdmUgc2NvcmUgZm9yIG5vZGUgd1xuICAgICAgICB2YXIgdGVtcFNjb3JlID0gZ1Njb3JlW2NNaW5JZF0gKyB3ZWlnaHRGbihlKTtcblxuICAgICAgICAvLyBVcGRhdGUgZ1Njb3JlIGZvciBub2RlIHcgaWY6XG4gICAgICAgIC8vICAgdyBub3QgcHJlc2VudCBpbiBvcGVuU2V0XG4gICAgICAgIC8vIE9SXG4gICAgICAgIC8vICAgdGVudGF0aXZlIGdTY29yZSBpcyBsZXNzIHRoYW4gcHJldmlvdXMgdmFsdWVcblxuICAgICAgICAvLyB3IG5vdCBpbiBvcGVuU2V0XG4gICAgICAgIGlmIChvcGVuU2V0LmluZGV4T2Yod2lkKSA9PSAtMSkge1xuICAgICAgICAgIGdTY29yZVt3aWRdID0gdGVtcFNjb3JlO1xuICAgICAgICAgIGZTY29yZVt3aWRdID0gdGVtcFNjb3JlICsgaGV1cmlzdGljKHcpO1xuICAgICAgICAgIG9wZW5TZXQucHVzaCh3aWQpOyAvLyBBZGQgbm9kZSB0byBvcGVuU2V0XG4gICAgICAgICAgY2FtZUZyb21bd2lkXSA9IGNNaW5JZDtcbiAgICAgICAgICBjYW1lRnJvbUVkZ2Vbd2lkXSA9IGUuaWQoKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyB3IGFscmVhZHkgaW4gb3BlblNldCwgYnV0IHdpdGggZ3JlYXRlciBnU2NvcmVcbiAgICAgICAgaWYgKHRlbXBTY29yZSA8IGdTY29yZVt3aWRdKSB7XG4gICAgICAgICAgZ1Njb3JlW3dpZF0gPSB0ZW1wU2NvcmU7XG4gICAgICAgICAgZlNjb3JlW3dpZF0gPSB0ZW1wU2NvcmUgKyBoZXVyaXN0aWModyk7XG4gICAgICAgICAgY2FtZUZyb21bd2lkXSA9IGNNaW5JZDtcbiAgICAgICAgfVxuICAgICAgfSAvLyBFbmQgb2YgbmVpZ2hib3JzIHVwZGF0ZVxuICAgIH0gLy8gRW5kIG9mIG1haW4gbG9vcFxuXG4gICAgLy8gSWYgd2UndmUgcmVhY2hlZCBoZXJlLCB0aGVuIHdlJ3ZlIG5vdCByZWFjaGVkIG91ciBnb2FsXG4gICAgcmV0dXJuIHtcbiAgICAgIGZvdW5kOiBmYWxzZSxcbiAgICAgIGRpc3RhbmNlOiB1bmRlZmluZWQsXG4gICAgICBwYXRoOiB1bmRlZmluZWQsXG4gICAgICBzdGVwczogc3RlcHNcbiAgICB9O1xuICB9XG5cbn07IC8vIGVsZXNmblxuXG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuXG4vKioqLyB9KSxcbi8qIDM1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBpcyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBlbGVzZm4gPSB7XG5cbiAgLy8gSW1wbGVtZW50ZWQgZnJvbSBwc2V1ZG9jb2RlIGZyb20gd2lraXBlZGlhXG4gIGZsb3lkV2Fyc2hhbGw6IGZ1bmN0aW9uIGZsb3lkV2Fyc2hhbGwob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuXG4gICAgLy8gV2VpZ2h0IGZ1bmN0aW9uIC0gb3B0aW9uYWxcbiAgICBpZiAob3B0aW9ucy53ZWlnaHQgIT0gbnVsbCAmJiBpcy5mbihvcHRpb25zLndlaWdodCkpIHtcbiAgICAgIHZhciB3ZWlnaHRGbiA9IG9wdGlvbnMud2VpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBub3Qgc3BlY2lmaWVkLCBhc3N1bWUgZWFjaCBlZGdlIGhhcyBlcXVhbCB3ZWlnaHQgKDEpXG4gICAgICB2YXIgd2VpZ2h0Rm4gPSBmdW5jdGlvbiB3ZWlnaHRGbihlKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBkaXJlY3RlZCAtIG9wdGlvbmFsXG4gICAgaWYgKG9wdGlvbnMuZGlyZWN0ZWQgIT0gbnVsbCkge1xuICAgICAgdmFyIGRpcmVjdGVkID0gb3B0aW9ucy5kaXJlY3RlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRpcmVjdGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGVkZ2VzID0gdGhpcy5lZGdlcygpLnN0ZEZpbHRlcihmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuICFlLmlzTG9vcCgpO1xuICAgIH0pO1xuICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgICB2YXIgbnVtTm9kZXMgPSBub2Rlcy5sZW5ndGg7XG5cbiAgICAvLyBtYXBwaW5nOiBub2RlIGlkIC0+IHBvc2l0aW9uIGluIG5vZGVzIGFycmF5XG4gICAgdmFyIGlkMnBvc2l0aW9uID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICBpZDJwb3NpdGlvbltub2Rlc1tpXS5pZCgpXSA9IGk7XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6ZSBkaXN0YW5jZSBtYXRyaXhcbiAgICB2YXIgZGlzdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgdmFyIG5ld1JvdyA9IG5ldyBBcnJheShudW1Ob2Rlcyk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bU5vZGVzOyBqKyspIHtcbiAgICAgICAgaWYgKGkgPT0gaikge1xuICAgICAgICAgIG5ld1Jvd1tqXSA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3Um93W2pdID0gSW5maW5pdHk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRpc3QucHVzaChuZXdSb3cpO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgbWF0cml4IHVzZWQgZm9yIHBhdGggcmVjb25zdHJ1Y3Rpb25cbiAgICAvLyBJbml0aWFsaXplIGRpc3RhbmNlIG1hdHJpeFxuICAgIHZhciBuZXh0ID0gW107XG4gICAgdmFyIGVkZ2VOZXh0ID0gW107XG5cbiAgICB2YXIgaW5pdE1hdHJpeCA9IGZ1bmN0aW9uIGluaXRNYXRyaXgobmV4dCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICAgIHZhciBuZXdSb3cgPSBuZXcgQXJyYXkobnVtTm9kZXMpO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bU5vZGVzOyBqKyspIHtcbiAgICAgICAgICBuZXdSb3dbal0gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dC5wdXNoKG5ld1Jvdyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGluaXRNYXRyaXgobmV4dCk7XG4gICAgaW5pdE1hdHJpeChlZGdlTmV4dCk7XG5cbiAgICAvLyBQcm9jZXNzIGVkZ2VzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZUluZGV4ID0gaWQycG9zaXRpb25bZWRnZXNbaV0uc291cmNlKCkuaWQoKV07XG4gICAgICB2YXIgdGFyZ2V0SW5kZXggPSBpZDJwb3NpdGlvbltlZGdlc1tpXS50YXJnZXQoKS5pZCgpXTtcbiAgICAgIHZhciB3ZWlnaHQgPSB3ZWlnaHRGbihlZGdlc1tpXSk7XG5cbiAgICAgIC8vIENoZWNrIGlmIGFscmVhZHkgcHJvY2VzcyBhbm90aGVyIGVkZ2UgYmV0d2VlbiBzYW1lIDIgbm9kZXNcbiAgICAgIGlmIChkaXN0W3NvdXJjZUluZGV4XVt0YXJnZXRJbmRleF0gPiB3ZWlnaHQpIHtcbiAgICAgICAgZGlzdFtzb3VyY2VJbmRleF1bdGFyZ2V0SW5kZXhdID0gd2VpZ2h0O1xuICAgICAgICBuZXh0W3NvdXJjZUluZGV4XVt0YXJnZXRJbmRleF0gPSB0YXJnZXRJbmRleDtcbiAgICAgICAgZWRnZU5leHRbc291cmNlSW5kZXhdW3RhcmdldEluZGV4XSA9IGVkZ2VzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHVuZGlyZWN0ZWQgZ3JhcGgsIHByb2Nlc3MgJ3JldmVyc2VkJyBlZGdlc1xuICAgIGlmICghZGlyZWN0ZWQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNvdXJjZUluZGV4ID0gaWQycG9zaXRpb25bZWRnZXNbaV0udGFyZ2V0KCkuaWQoKV07XG4gICAgICAgIHZhciB0YXJnZXRJbmRleCA9IGlkMnBvc2l0aW9uW2VkZ2VzW2ldLnNvdXJjZSgpLmlkKCldO1xuICAgICAgICB2YXIgd2VpZ2h0ID0gd2VpZ2h0Rm4oZWRnZXNbaV0pO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIGFscmVhZHkgcHJvY2VzcyBhbm90aGVyIGVkZ2UgYmV0d2VlbiBzYW1lIDIgbm9kZXNcbiAgICAgICAgaWYgKGRpc3Rbc291cmNlSW5kZXhdW3RhcmdldEluZGV4XSA+IHdlaWdodCkge1xuICAgICAgICAgIGRpc3Rbc291cmNlSW5kZXhdW3RhcmdldEluZGV4XSA9IHdlaWdodDtcbiAgICAgICAgICBuZXh0W3NvdXJjZUluZGV4XVt0YXJnZXRJbmRleF0gPSB0YXJnZXRJbmRleDtcbiAgICAgICAgICBlZGdlTmV4dFtzb3VyY2VJbmRleF1bdGFyZ2V0SW5kZXhdID0gZWRnZXNbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNYWluIGxvb3BcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IG51bU5vZGVzOyBrKyspIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bU5vZGVzOyBqKyspIHtcbiAgICAgICAgICBpZiAoZGlzdFtpXVtrXSArIGRpc3Rba11bal0gPCBkaXN0W2ldW2pdKSB7XG4gICAgICAgICAgICBkaXN0W2ldW2pdID0gZGlzdFtpXVtrXSArIGRpc3Rba11bal07XG4gICAgICAgICAgICBuZXh0W2ldW2pdID0gbmV4dFtpXVtrXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBCdWlsZCByZXN1bHQgb2JqZWN0XG4gICAgdmFyIHBvc2l0aW9uMmlkID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICBwb3NpdGlvbjJpZC5wdXNoKG5vZGVzW2ldLmlkKCkpO1xuICAgIH1cblxuICAgIHZhciByZXMgPSB7XG4gICAgICBkaXN0YW5jZTogZnVuY3Rpb24gZGlzdGFuY2UoZnJvbSwgdG8pIHtcbiAgICAgICAgaWYgKGlzLnN0cmluZyhmcm9tKSkge1xuICAgICAgICAgIC8vIGZyb20gaXMgYSBzZWxlY3RvciBzdHJpbmdcbiAgICAgICAgICB2YXIgZnJvbUlkID0gY3kuZmlsdGVyKGZyb20pWzBdLmlkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZnJvbSBpcyBhIG5vZGVcbiAgICAgICAgICB2YXIgZnJvbUlkID0gZnJvbS5pZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzLnN0cmluZyh0bykpIHtcbiAgICAgICAgICAvLyB0byBpcyBhIHNlbGVjdG9yIHN0cmluZ1xuICAgICAgICAgIHZhciB0b0lkID0gY3kuZmlsdGVyKHRvKVswXS5pZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHRvIGlzIGEgbm9kZVxuICAgICAgICAgIHZhciB0b0lkID0gdG8uaWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkaXN0W2lkMnBvc2l0aW9uW2Zyb21JZF1dW2lkMnBvc2l0aW9uW3RvSWRdXTtcbiAgICAgIH0sXG5cbiAgICAgIHBhdGg6IGZ1bmN0aW9uIHBhdGgoZnJvbSwgdG8pIHtcbiAgICAgICAgdmFyIHJlY29uc3RydWN0UGF0aEF1eCA9IGZ1bmN0aW9uIHJlY29uc3RydWN0UGF0aEF1eChmcm9tLCB0bywgbmV4dCwgcG9zaXRpb24yaWQsIGVkZ2VOZXh0KSB7XG4gICAgICAgICAgaWYgKGZyb20gPT09IHRvKSB7XG4gICAgICAgICAgICByZXR1cm4gY3kuZ2V0RWxlbWVudEJ5SWQocG9zaXRpb24yaWRbZnJvbV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobmV4dFtmcm9tXVt0b10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcGF0aCA9IFtjeS5nZXRFbGVtZW50QnlJZChwb3NpdGlvbjJpZFtmcm9tXSldO1xuICAgICAgICAgIHZhciBwcmV2ID0gZnJvbTtcbiAgICAgICAgICB3aGlsZSAoZnJvbSAhPT0gdG8pIHtcbiAgICAgICAgICAgIHByZXYgPSBmcm9tO1xuICAgICAgICAgICAgZnJvbSA9IG5leHRbZnJvbV1bdG9dO1xuXG4gICAgICAgICAgICB2YXIgZWRnZSA9IGVkZ2VOZXh0W3ByZXZdW2Zyb21dO1xuICAgICAgICAgICAgcGF0aC5wdXNoKGVkZ2UpO1xuXG4gICAgICAgICAgICBwYXRoLnB1c2goY3kuZ2V0RWxlbWVudEJ5SWQocG9zaXRpb24yaWRbZnJvbV0pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGlzLnN0cmluZyhmcm9tKSkge1xuICAgICAgICAgIC8vIGZyb20gaXMgYSBzZWxlY3RvciBzdHJpbmdcbiAgICAgICAgICB2YXIgZnJvbUlkID0gY3kuZmlsdGVyKGZyb20pWzBdLmlkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZnJvbSBpcyBhIG5vZGVcbiAgICAgICAgICB2YXIgZnJvbUlkID0gZnJvbS5pZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzLnN0cmluZyh0bykpIHtcbiAgICAgICAgICAvLyB0byBpcyBhIHNlbGVjdG9yIHN0cmluZ1xuICAgICAgICAgIHZhciB0b0lkID0gY3kuZmlsdGVyKHRvKVswXS5pZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHRvIGlzIGEgbm9kZVxuICAgICAgICAgIHZhciB0b0lkID0gdG8uaWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXRoQXJyID0gcmVjb25zdHJ1Y3RQYXRoQXV4KGlkMnBvc2l0aW9uW2Zyb21JZF0sIGlkMnBvc2l0aW9uW3RvSWRdLCBuZXh0LCBwb3NpdGlvbjJpZCwgZWRnZU5leHQpO1xuXG4gICAgICAgIHJldHVybiBjeS5jb2xsZWN0aW9uKHBhdGhBcnIpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gcmVzO1xuICB9IC8vIGZsb3lkV2Fyc2hhbGxcblxufTsgLy8gZWxlc2ZuXG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuXG4vKioqLyB9KSxcbi8qIDM2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBpcyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBlbGVzZm4gPSB7XG5cbiAgLy8gSW1wbGVtZW50ZWQgZnJvbSBwc2V1ZG9jb2RlIGZyb20gd2lraXBlZGlhXG4gIGJlbGxtYW5Gb3JkOiBmdW5jdGlvbiBiZWxsbWFuRm9yZChvcHRpb25zKSB7XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvLyBXZWlnaHQgZnVuY3Rpb24gLSBvcHRpb25hbFxuICAgIGlmIChvcHRpb25zLndlaWdodCAhPSBudWxsICYmIGlzLmZuKG9wdGlvbnMud2VpZ2h0KSkge1xuICAgICAgdmFyIHdlaWdodEZuID0gb3B0aW9ucy53ZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIG5vdCBzcGVjaWZpZWQsIGFzc3VtZSBlYWNoIGVkZ2UgaGFzIGVxdWFsIHdlaWdodCAoMSlcbiAgICAgIHZhciB3ZWlnaHRGbiA9IGZ1bmN0aW9uIHdlaWdodEZuKGUpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIGRpcmVjdGVkIC0gb3B0aW9uYWxcbiAgICBpZiAob3B0aW9ucy5kaXJlY3RlZCAhPSBudWxsKSB7XG4gICAgICB2YXIgZGlyZWN0ZWQgPSBvcHRpb25zLmRpcmVjdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGlyZWN0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyByb290IC0gbWFuZGF0b3J5IVxuICAgIGlmIChvcHRpb25zLnJvb3QgIT0gbnVsbCkge1xuICAgICAgaWYgKGlzLnN0cmluZyhvcHRpb25zLnJvb3QpKSB7XG4gICAgICAgIC8vIHVzZSBpdCBhcyBhIHNlbGVjdG9yLCBlLmcuIFwiI3Jvb3RJRFxuICAgICAgICB2YXIgc291cmNlID0gdGhpcy5maWx0ZXIob3B0aW9ucy5yb290KVswXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBvcHRpb25zLnJvb3RbMF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICB2YXIgZWRnZXMgPSB0aGlzLmVkZ2VzKCkuc3RkRmlsdGVyKGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gIWUuaXNMb29wKCk7XG4gICAgfSk7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICAgIHZhciBudW1Ob2RlcyA9IG5vZGVzLmxlbmd0aDtcblxuICAgIC8vIG1hcHBpbmc6IG5vZGUgaWQgLT4gcG9zaXRpb24gaW4gbm9kZXMgYXJyYXlcbiAgICB2YXIgaWQycG9zaXRpb24gPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgIGlkMnBvc2l0aW9uW25vZGVzW2ldLmlkKCldID0gaTtcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXphdGlvbnNcbiAgICB2YXIgY29zdCA9IFtdO1xuICAgIHZhciBwcmVkZWNlc3NvciA9IFtdO1xuICAgIHZhciBwcmVkRWRnZSA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICBpZiAobm9kZXNbaV0uaWQoKSA9PT0gc291cmNlLmlkKCkpIHtcbiAgICAgICAgY29zdFtpXSA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb3N0W2ldID0gSW5maW5pdHk7XG4gICAgICB9XG4gICAgICBwcmVkZWNlc3NvcltpXSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBFZGdlcyByZWxheGF0aW9uXG4gICAgdmFyIGZsYWcgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgIGZsYWcgPSBmYWxzZTtcbiAgICAgIGZvciAodmFyIGUgPSAwOyBlIDwgZWRnZXMubGVuZ3RoOyBlKyspIHtcbiAgICAgICAgdmFyIHNvdXJjZUluZGV4ID0gaWQycG9zaXRpb25bZWRnZXNbZV0uc291cmNlKCkuaWQoKV07XG4gICAgICAgIHZhciB0YXJnZXRJbmRleCA9IGlkMnBvc2l0aW9uW2VkZ2VzW2VdLnRhcmdldCgpLmlkKCldO1xuICAgICAgICB2YXIgd2VpZ2h0ID0gd2VpZ2h0Rm4oZWRnZXNbZV0pO1xuXG4gICAgICAgIHZhciB0ZW1wID0gY29zdFtzb3VyY2VJbmRleF0gKyB3ZWlnaHQ7XG4gICAgICAgIGlmICh0ZW1wIDwgY29zdFt0YXJnZXRJbmRleF0pIHtcbiAgICAgICAgICBjb3N0W3RhcmdldEluZGV4XSA9IHRlbXA7XG4gICAgICAgICAgcHJlZGVjZXNzb3JbdGFyZ2V0SW5kZXhdID0gc291cmNlSW5kZXg7XG4gICAgICAgICAgcHJlZEVkZ2VbdGFyZ2V0SW5kZXhdID0gZWRnZXNbZV07XG4gICAgICAgICAgZmxhZyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB1bmRpcmVjdGVkIGdyYXBoLCB3ZSBuZWVkIHRvIHRha2UgaW50byBhY2NvdW50IHRoZSAncmV2ZXJzZScgZWRnZVxuICAgICAgICBpZiAoIWRpcmVjdGVkKSB7XG4gICAgICAgICAgdmFyIHRlbXAgPSBjb3N0W3RhcmdldEluZGV4XSArIHdlaWdodDtcbiAgICAgICAgICBpZiAodGVtcCA8IGNvc3Rbc291cmNlSW5kZXhdKSB7XG4gICAgICAgICAgICBjb3N0W3NvdXJjZUluZGV4XSA9IHRlbXA7XG4gICAgICAgICAgICBwcmVkZWNlc3Nvcltzb3VyY2VJbmRleF0gPSB0YXJnZXRJbmRleDtcbiAgICAgICAgICAgIHByZWRFZGdlW3NvdXJjZUluZGV4XSA9IGVkZ2VzW2VdO1xuICAgICAgICAgICAgZmxhZyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghZmxhZykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZmxhZykge1xuICAgICAgLy8gQ2hlY2sgZm9yIG5lZ2F0aXZlIHdlaWdodCBjeWNsZXNcbiAgICAgIGZvciAodmFyIGUgPSAwOyBlIDwgZWRnZXMubGVuZ3RoOyBlKyspIHtcbiAgICAgICAgdmFyIHNvdXJjZUluZGV4ID0gaWQycG9zaXRpb25bZWRnZXNbZV0uc291cmNlKCkuaWQoKV07XG4gICAgICAgIHZhciB0YXJnZXRJbmRleCA9IGlkMnBvc2l0aW9uW2VkZ2VzW2VdLnRhcmdldCgpLmlkKCldO1xuICAgICAgICB2YXIgd2VpZ2h0ID0gd2VpZ2h0Rm4oZWRnZXNbZV0pO1xuXG4gICAgICAgIGlmIChjb3N0W3NvdXJjZUluZGV4XSArIHdlaWdodCA8IGNvc3RbdGFyZ2V0SW5kZXhdKSB7XG4gICAgICAgICAgdXRpbC5lcnJvcignR3JhcGggY29udGFpbnMgYSBuZWdhdGl2ZSB3ZWlnaHQgY3ljbGUgZm9yIEJlbGxtYW4tRm9yZCcpO1xuICAgICAgICAgIHJldHVybiB7IHBhdGhUbzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZGlzdGFuY2VUbzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaGFzTmVnYXRpdmVXZWlnaHRDeWNsZTogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQnVpbGQgcmVzdWx0IG9iamVjdFxuICAgIHZhciBwb3NpdGlvbjJpZCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgcG9zaXRpb24yaWQucHVzaChub2Rlc1tpXS5pZCgpKTtcbiAgICB9XG5cbiAgICB2YXIgcmVzID0ge1xuICAgICAgZGlzdGFuY2VUbzogZnVuY3Rpb24gZGlzdGFuY2VUbyh0bykge1xuICAgICAgICBpZiAoaXMuc3RyaW5nKHRvKSkge1xuICAgICAgICAgIC8vIHRvIGlzIGEgc2VsZWN0b3Igc3RyaW5nXG4gICAgICAgICAgdmFyIHRvSWQgPSBjeS5maWx0ZXIodG8pWzBdLmlkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdG8gaXMgYSBub2RlXG4gICAgICAgICAgdmFyIHRvSWQgPSB0by5pZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvc3RbaWQycG9zaXRpb25bdG9JZF1dO1xuICAgICAgfSxcblxuICAgICAgcGF0aFRvOiBmdW5jdGlvbiBwYXRoVG8odG8pIHtcblxuICAgICAgICB2YXIgcmVjb25zdHJ1Y3RQYXRoQXV4ID0gZnVuY3Rpb24gcmVjb25zdHJ1Y3RQYXRoQXV4KHByZWRlY2Vzc29yLCBmcm9tUG9zLCB0b1BvcywgcG9zaXRpb24yaWQsIGFjdW1QYXRoLCBwcmVkRWRnZSkge1xuICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIC8vIEFkZCB0b0lkIHRvIHBhdGhcbiAgICAgICAgICAgIGFjdW1QYXRoLnB1c2goY3kuZ2V0RWxlbWVudEJ5SWQocG9zaXRpb24yaWRbdG9Qb3NdKSk7XG4gICAgICAgICAgICBhY3VtUGF0aC5wdXNoKHByZWRFZGdlW3RvUG9zXSk7XG5cbiAgICAgICAgICAgIGlmIChmcm9tUG9zID09PSB0b1Bvcykge1xuICAgICAgICAgICAgICAvLyByZWFjaGVkIHN0YXJ0aW5nIG5vZGVcbiAgICAgICAgICAgICAgcmV0dXJuIGFjdW1QYXRoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBubyBwYXRoIGV4aXN0cywgZGlzY2FydCBhY3VtdWxhdGVkIHBhdGggYW5kIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgICAgIHZhciBwcmVkUG9zID0gcHJlZGVjZXNzb3JbdG9Qb3NdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcmVkUG9zID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0b1BvcyA9IHByZWRQb3M7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChpcy5zdHJpbmcodG8pKSB7XG4gICAgICAgICAgLy8gdG8gaXMgYSBzZWxlY3RvciBzdHJpbmdcbiAgICAgICAgICB2YXIgdG9JZCA9IGN5LmZpbHRlcih0bylbMF0uaWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB0byBpcyBhIG5vZGVcbiAgICAgICAgICB2YXIgdG9JZCA9IHRvLmlkKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhdGggPSBbXTtcblxuICAgICAgICAvLyBUaGlzIHJldHVybnMgYSByZXZlcnNlZCBwYXRoXG4gICAgICAgIHZhciByZXMgPSByZWNvbnN0cnVjdFBhdGhBdXgocHJlZGVjZXNzb3IsIGlkMnBvc2l0aW9uW3NvdXJjZS5pZCgpXSwgaWQycG9zaXRpb25bdG9JZF0sIHBvc2l0aW9uMmlkLCBwYXRoLCBwcmVkRWRnZSk7XG5cbiAgICAgICAgLy8gR2V0IGl0IGluIHRoZSBjb3JyZWN0IG9yZGVyIGFuZCByZXR1cm4gaXRcbiAgICAgICAgaWYgKHJlcyAhPSBudWxsKSB7XG4gICAgICAgICAgcmVzLnJldmVyc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlbGVzLnNwYXduKHJlcyk7XG4gICAgICB9LFxuXG4gICAgICBoYXNOZWdhdGl2ZVdlaWdodEN5Y2xlOiBmYWxzZVxuICAgIH07XG5cbiAgICByZXR1cm4gcmVzO1xuICB9IC8vIGJlbGxtYW5Gb3JkXG5cbn07IC8vIGVsZXNmblxuXG5tb2R1bGUuZXhwb3J0cyA9IGVsZXNmbjtcblxuLyoqKi8gfSksXG4vKiAzNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBlbGVzZm4gPSB7XG5cbiAgLy8gQ29tcHV0ZXMgdGhlIG1pbmltdW0gY3V0IG9mIGFuIHVuZGlyZWN0ZWQgZ3JhcGhcbiAgLy8gUmV0dXJucyB0aGUgY29ycmVjdCBhbnN3ZXIgd2l0aCBoaWdoIHByb2JhYmlsaXR5XG4gIGthcmdlclN0ZWluOiBmdW5jdGlvbiBrYXJnZXJTdGVpbihvcHRpb25zKSB7XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvLyBGdW5jdGlvbiB3aGljaCBjb2xhcHNlcyAyIChtZXRhKSBub2RlcyBpbnRvIG9uZVxuICAgIC8vIFVwZGF0ZXMgdGhlIHJlbWFpbmluZyBlZGdlIGxpc3RzXG4gICAgLy8gUmVjZWl2ZXMgYXMgYSBwYXJhbWF0ZXIgdGhlIGVkZ2Ugd2hpY2ggY2F1c2VzIHRoZSBjb2xsYXBzZVxuICAgIHZhciBjb2xhcHNlID0gZnVuY3Rpb24gY29sYXBzZShlZGdlSW5kZXgsIG5vZGVNYXAsIHJlbWFpbmluZ0VkZ2VzKSB7XG4gICAgICB2YXIgZWRnZUluZm8gPSByZW1haW5pbmdFZGdlc1tlZGdlSW5kZXhdO1xuICAgICAgdmFyIHNvdXJjZUluID0gZWRnZUluZm9bMV07XG4gICAgICB2YXIgdGFyZ2V0SW4gPSBlZGdlSW5mb1syXTtcbiAgICAgIHZhciBwYXJ0aXRpb24xID0gbm9kZU1hcFtzb3VyY2VJbl07XG4gICAgICB2YXIgcGFydGl0aW9uMiA9IG5vZGVNYXBbdGFyZ2V0SW5dO1xuXG4gICAgICAvLyBEZWxldGUgYWxsIGVkZ2VzIGJldHdlZW4gcGFydGl0aW9uMSBhbmQgcGFydGl0aW9uMlxuICAgICAgdmFyIG5ld0VkZ2VzID0gcmVtYWluaW5nRWRnZXMuZmlsdGVyKGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgIGlmIChub2RlTWFwW2VkZ2VbMV1dID09PSBwYXJ0aXRpb24xICYmIG5vZGVNYXBbZWRnZVsyXV0gPT09IHBhcnRpdGlvbjIpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGVNYXBbZWRnZVsxXV0gPT09IHBhcnRpdGlvbjIgJiYgbm9kZU1hcFtlZGdlWzJdXSA9PT0gcGFydGl0aW9uMSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBBbGwgZWRnZXMgcG9pbnRpbmcgdG8gcGFydGl0aW9uMiBzaG91bGQgbm93IHBvaW50IHRvIHBhcnRpdGlvbjFcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3RWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBuZXdFZGdlc1tpXTtcbiAgICAgICAgaWYgKGVkZ2VbMV0gPT09IHBhcnRpdGlvbjIpIHtcbiAgICAgICAgICAvLyBDaGVjayBzb3VyY2VcbiAgICAgICAgICBuZXdFZGdlc1tpXSA9IGVkZ2Uuc2xpY2UoMCk7XG4gICAgICAgICAgbmV3RWRnZXNbaV1bMV0gPSBwYXJ0aXRpb24xO1xuICAgICAgICB9IGVsc2UgaWYgKGVkZ2VbMl0gPT09IHBhcnRpdGlvbjIpIHtcbiAgICAgICAgICAvLyBDaGVjayB0YXJnZXRcbiAgICAgICAgICBuZXdFZGdlc1tpXSA9IGVkZ2Uuc2xpY2UoMCk7XG4gICAgICAgICAgbmV3RWRnZXNbaV1bMl0gPSBwYXJ0aXRpb24xO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE1vdmUgYWxsIG5vZGVzIGZyb20gcGFydGl0aW9uMiB0byBwYXJ0aXRpb24xXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVNYXAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKG5vZGVNYXBbaV0gPT09IHBhcnRpdGlvbjIpIHtcbiAgICAgICAgICBub2RlTWFwW2ldID0gcGFydGl0aW9uMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3RWRnZXM7XG4gICAgfTtcblxuICAgIC8vIENvbnRyYWN0cyBhIGdyYXBoIHVudGlsIHdlIHJlYWNoIGEgY2VydGFpbiBudW1iZXIgb2YgbWV0YSBub2Rlc1xuICAgIHZhciBjb250cmFjdFVudGlsID0gZnVuY3Rpb24gY29udHJhY3RVbnRpbChtZXRhTm9kZU1hcCwgcmVtYWluaW5nRWRnZXMsIHNpemUsIHNpemVMaW1pdCkge1xuICAgICAgLy8gU3RvcCBjb25kaXRpb25cbiAgICAgIGlmIChzaXplIDw9IHNpemVMaW1pdCkge1xuICAgICAgICByZXR1cm4gcmVtYWluaW5nRWRnZXM7XG4gICAgICB9XG5cbiAgICAgIC8vIENob29zZSBhbiBlZGdlIHJhbmRvbWx5XG4gICAgICB2YXIgZWRnZUluZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogcmVtYWluaW5nRWRnZXMubGVuZ3RoKTtcblxuICAgICAgLy8gQ29sYXBzZSBncmFwaCBiYXNlZCBvbiBlZGdlXG4gICAgICB2YXIgbmV3RWRnZXMgPSBjb2xhcHNlKGVkZ2VJbmRleCwgbWV0YU5vZGVNYXAsIHJlbWFpbmluZ0VkZ2VzKTtcblxuICAgICAgcmV0dXJuIGNvbnRyYWN0VW50aWwobWV0YU5vZGVNYXAsIG5ld0VkZ2VzLCBzaXplIC0gMSwgc2l6ZUxpbWl0KTtcbiAgICB9O1xuXG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICB2YXIgZWRnZXMgPSB0aGlzLmVkZ2VzKCkuc3RkRmlsdGVyKGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gIWUuaXNMb29wKCk7XG4gICAgfSk7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICAgIHZhciBudW1Ob2RlcyA9IG5vZGVzLmxlbmd0aDtcbiAgICB2YXIgbnVtRWRnZXMgPSBlZGdlcy5sZW5ndGg7XG4gICAgdmFyIG51bUl0ZXIgPSBNYXRoLmNlaWwoTWF0aC5wb3coTWF0aC5sb2cobnVtTm9kZXMpIC8gTWF0aC5MTjIsIDIpKTtcbiAgICB2YXIgc3RvcFNpemUgPSBNYXRoLmZsb29yKG51bU5vZGVzIC8gTWF0aC5zcXJ0KDIpKTtcblxuICAgIGlmIChudW1Ob2RlcyA8IDIpIHtcbiAgICAgIHV0aWwuZXJyb3IoJ0F0IGxlYXN0IDIgbm9kZXMgYXJlIHJlcXVpcmVkIGZvciBLYXJnZXItU3RlaW4gYWxnb3JpdGhtJyk7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBudW1lcmljYWwgaWRlbnRpZmllcnMgZm9yIGVhY2ggbm9kZVxuICAgIC8vIG1hcHBpbmc6IG5vZGUgaWQgLT4gcG9zaXRpb24gaW4gbm9kZXMgYXJyYXlcbiAgICAvLyBmb3IgcmV2ZXJzZSBtYXBwaW5nLCBzaW1wbHkgdXNlIG5vZGVzIGFycmF5XG4gICAgdmFyIGlkMnBvc2l0aW9uID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICBpZDJwb3NpdGlvbltub2Rlc1tpXS5pZCgpXSA9IGk7XG4gICAgfVxuXG4gICAgLy8gTm93IHN0b3JlIGVkZ2UgZGVzdGluYXRpb24gYXMgaW5kZXhlc1xuICAgIC8vIEZvcm1hdCBmb3IgZWFjaCBlZGdlIChlZGdlIGluZGV4LCBzb3VyY2Ugbm9kZSBpbmRleCwgdGFyZ2V0IG5vZGUgaW5kZXgpXG4gICAgdmFyIGVkZ2VJbmRleGVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1FZGdlczsgaSsrKSB7XG4gICAgICB2YXIgZSA9IGVkZ2VzW2ldO1xuICAgICAgZWRnZUluZGV4ZXMucHVzaChbaSwgaWQycG9zaXRpb25bZS5zb3VyY2UoKS5pZCgpXSwgaWQycG9zaXRpb25bZS50YXJnZXQoKS5pZCgpXV0pO1xuICAgIH1cblxuICAgIC8vIFdlIHdpbGwgc3RvcmUgdGhlIGJlc3QgY3V0IGZvdW5kIGhlcmVcbiAgICB2YXIgbWluQ3V0U2l6ZSA9IEluZmluaXR5O1xuICAgIHZhciBtaW5DdXQ7XG5cbiAgICAvLyBJbml0aWFsIG1ldGEgbm9kZSBwYXJ0aXRpb25cbiAgICB2YXIgb3JpZ2luYWxNZXRhTm9kZSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgb3JpZ2luYWxNZXRhTm9kZS5wdXNoKGkpO1xuICAgIH1cblxuICAgIC8vIE1haW4gbG9vcFxuICAgIGZvciAodmFyIGl0ZXIgPSAwOyBpdGVyIDw9IG51bUl0ZXI7IGl0ZXIrKykge1xuICAgICAgLy8gQ3JlYXRlIG5ldyBtZXRhIG5vZGUgcGFydGl0aW9uXG4gICAgICB2YXIgbWV0YU5vZGVNYXAgPSBvcmlnaW5hbE1ldGFOb2RlLnNsaWNlKDApO1xuXG4gICAgICAvLyBDb250cmFjdCB1bnRpbCBzdG9wIHBvaW50IChzdG9wU2l6ZSBub2RlcylcbiAgICAgIHZhciBlZGdlc1N0YXRlID0gY29udHJhY3RVbnRpbChtZXRhTm9kZU1hcCwgZWRnZUluZGV4ZXMsIG51bU5vZGVzLCBzdG9wU2l6ZSk7XG5cbiAgICAgIC8vIENyZWF0ZSBhIGNvcHkgb2YgdGhlIGNvbGFwc2VkIG5vZGVzIHN0YXRlXG4gICAgICB2YXIgbWV0YU5vZGVNYXAyID0gbWV0YU5vZGVNYXAuc2xpY2UoMCk7XG5cbiAgICAgIC8vIFJ1biAyIGl0ZXJhdGlvbnMgc3RhcnRpbmcgaW4gdGhlIHN0b3Agc3RhdGVcbiAgICAgIHZhciByZXMxID0gY29udHJhY3RVbnRpbChtZXRhTm9kZU1hcCwgZWRnZXNTdGF0ZSwgc3RvcFNpemUsIDIpO1xuICAgICAgdmFyIHJlczIgPSBjb250cmFjdFVudGlsKG1ldGFOb2RlTWFwMiwgZWRnZXNTdGF0ZSwgc3RvcFNpemUsIDIpO1xuXG4gICAgICAvLyBJcyBhbnkgb2YgdGhlIDIgcmVzdWx0cyB0aGUgYmVzdCBjdXQgc28gZmFyP1xuICAgICAgaWYgKHJlczEubGVuZ3RoIDw9IHJlczIubGVuZ3RoICYmIHJlczEubGVuZ3RoIDwgbWluQ3V0U2l6ZSkge1xuICAgICAgICBtaW5DdXRTaXplID0gcmVzMS5sZW5ndGg7XG4gICAgICAgIG1pbkN1dCA9IFtyZXMxLCBtZXRhTm9kZU1hcF07XG4gICAgICB9IGVsc2UgaWYgKHJlczIubGVuZ3RoIDw9IHJlczEubGVuZ3RoICYmIHJlczIubGVuZ3RoIDwgbWluQ3V0U2l6ZSkge1xuICAgICAgICBtaW5DdXRTaXplID0gcmVzMi5sZW5ndGg7XG4gICAgICAgIG1pbkN1dCA9IFtyZXMyLCBtZXRhTm9kZU1hcDJdO1xuICAgICAgfVxuICAgIH0gLy8gZW5kIG9mIG1haW4gbG9vcFxuXG5cbiAgICAvLyBDb25zdHJ1Y3QgcmVzdWx0XG4gICAgdmFyIHJlc0VkZ2VzID0gbWluQ3V0WzBdLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIGVkZ2VzW2VbMF1dO1xuICAgIH0pO1xuICAgIHZhciBwYXJ0aXRpb24xID0gW107XG4gICAgdmFyIHBhcnRpdGlvbjIgPSBbXTtcblxuICAgIC8vIHRyYXZlcnNlIG1ldGFOb2RlTWFwIGZvciBiZXN0IGN1dFxuICAgIHZhciB3aXRuZXNzTm9kZVBhcnRpdGlvbiA9IG1pbkN1dFsxXVswXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1pbkN1dFsxXS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHBhcnRpdGlvbklkID0gbWluQ3V0WzFdW2ldO1xuICAgICAgaWYgKHBhcnRpdGlvbklkID09PSB3aXRuZXNzTm9kZVBhcnRpdGlvbikge1xuICAgICAgICBwYXJ0aXRpb24xLnB1c2gobm9kZXNbaV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydGl0aW9uMi5wdXNoKG5vZGVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmV0ID0ge1xuICAgICAgY3V0OiBlbGVzLnNwYXduKGN5LCByZXNFZGdlcyksXG4gICAgICBwYXJ0aXRpb24xOiBlbGVzLnNwYXduKHBhcnRpdGlvbjEpLFxuICAgICAgcGFydGl0aW9uMjogZWxlcy5zcGF3bihwYXJ0aXRpb24yKVxuICAgIH07XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG59OyAvLyBlbGVzZm5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGVsZXNmbjtcblxuLyoqKi8gfSksXG4vKiAzOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgZWxlc2ZuID0ge1xuXG4gIHBhZ2VSYW5rOiBmdW5jdGlvbiBwYWdlUmFuayhvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB2YXIgbm9ybWFsaXplVmVjdG9yID0gZnVuY3Rpb24gbm9ybWFsaXplVmVjdG9yKHZlY3Rvcikge1xuICAgICAgdmFyIGxlbmd0aCA9IHZlY3Rvci5sZW5ndGg7XG5cbiAgICAgIC8vIEZpcnN0LCBnZXQgc3VtIG9mIGFsbCBlbGVtZW50c1xuICAgICAgdmFyIHRvdGFsID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdG90YWwgKz0gdmVjdG9yW2ldO1xuICAgICAgfVxuXG4gICAgICAvLyBOb3csIGRpdmlkZSBlYWNoIGJ5IHRoZSBzdW0gb2YgYWxsIGVsZW1lbnRzXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZlY3RvcltpXSA9IHZlY3RvcltpXSAvIHRvdGFsO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBkYW1waW5nRmFjdG9yIC0gb3B0aW9uYWxcbiAgICBpZiAob3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMuZGFtcGluZ0ZhY3RvciAhPSBudWxsKSB7XG4gICAgICB2YXIgZGFtcGluZ0ZhY3RvciA9IG9wdGlvbnMuZGFtcGluZ0ZhY3RvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRhbXBpbmdGYWN0b3IgPSAwLjg7IC8vIERlZmF1bHQgZGFtcGluZyBmYWN0b3JcbiAgICB9XG5cbiAgICAvLyBkZXNpcmVkIHByZWNpc2lvbiAtIG9wdGlvbmFsXG4gICAgaWYgKG9wdGlvbnMgIT0gbnVsbCAmJiBvcHRpb25zLnByZWNpc2lvbiAhPSBudWxsKSB7XG4gICAgICB2YXIgZXBzaWxvbiA9IG9wdGlvbnMucHJlY2lzaW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZXBzaWxvbiA9IDAuMDAwMDAxOyAvLyBEZWZhdWx0IHByZWNpc2lvblxuICAgIH1cblxuICAgIC8vIE1heCBudW1iZXIgb2YgaXRlcmF0aW9ucyAtIG9wdGlvbmFsXG4gICAgaWYgKG9wdGlvbnMgIT0gbnVsbCAmJiBvcHRpb25zLml0ZXJhdGlvbnMgIT0gbnVsbCkge1xuICAgICAgdmFyIG51bUl0ZXIgPSBvcHRpb25zLml0ZXJhdGlvbnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBudW1JdGVyID0gMjAwOyAvLyBEZWZhdWx0IG51bWJlciBvZiBpdGVyYXRpb25zXG4gICAgfVxuXG4gICAgLy8gV2VpZ2h0IGZ1bmN0aW9uIC0gb3B0aW9uYWxcbiAgICBpZiAob3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMud2VpZ2h0ICE9IG51bGwgJiYgaXMuZm4ob3B0aW9ucy53ZWlnaHQpKSB7XG4gICAgICB2YXIgd2VpZ2h0Rm4gPSBvcHRpb25zLndlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgbm90IHNwZWNpZmllZCwgYXNzdW1lIGVhY2ggZWRnZSBoYXMgZXF1YWwgd2VpZ2h0ICgxKVxuICAgICAgdmFyIHdlaWdodEZuID0gZnVuY3Rpb24gd2VpZ2h0Rm4oZSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICB2YXIgZWRnZXMgPSB0aGlzLmVkZ2VzKCkuc3RkRmlsdGVyKGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gIWUuaXNMb29wKCk7XG4gICAgfSk7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICAgIHZhciBudW1Ob2RlcyA9IG5vZGVzLmxlbmd0aDtcbiAgICB2YXIgbnVtRWRnZXMgPSBlZGdlcy5sZW5ndGg7XG5cbiAgICAvLyBDcmVhdGUgbnVtZXJpY2FsIGlkZW50aWZpZXJzIGZvciBlYWNoIG5vZGVcbiAgICAvLyBtYXBwaW5nOiBub2RlIGlkIC0+IHBvc2l0aW9uIGluIG5vZGVzIGFycmF5XG4gICAgLy8gZm9yIHJldmVyc2UgbWFwcGluZywgc2ltcGx5IHVzZSBub2RlcyBhcnJheVxuICAgIHZhciBpZDJwb3NpdGlvbiA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgaWQycG9zaXRpb25bbm9kZXNbaV0uaWQoKV0gPSBpO1xuICAgIH1cblxuICAgIC8vIENvbnN0cnVjdCB0cmFuc3Bvc2VkIGFkamFjZW5jeSBtYXRyaXhcbiAgICAvLyBGaXJzdCBsZXRzIGhhdmUgYSB6ZXJvZWQgbWF0cml4IG9mIHRoZSByaWdodCBzaXplXG4gICAgLy8gV2UnbGwgYWxzbyBrZWVwIHRyYWNrIG9mIHRoZSBzdW0gb2YgZWFjaCBjb2x1bW5cbiAgICB2YXIgbWF0cml4ID0gW107XG4gICAgdmFyIGNvbHVtblN1bSA9IFtdO1xuICAgIHZhciBhZGRpdGlvbmFsUHJvYiA9ICgxIC0gZGFtcGluZ0ZhY3RvcikgLyBudW1Ob2RlcztcblxuICAgIC8vIENyZWF0ZSBudWxsIG1hdHJpY1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgdmFyIG5ld1JvdyA9IFtdO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1Ob2RlczsgaisrKSB7XG4gICAgICAgIG5ld1Jvdy5wdXNoKDAuMCk7XG4gICAgICB9XG4gICAgICBtYXRyaXgucHVzaChuZXdSb3cpO1xuICAgICAgY29sdW1uU3VtLnB1c2goMC4wKTtcbiAgICB9XG5cbiAgICAvLyBOb3csIHByb2Nlc3MgZWRnZXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUVkZ2VzOyBpKyspIHtcbiAgICAgIHZhciBlZGdlID0gZWRnZXNbaV07XG4gICAgICB2YXIgcyA9IGlkMnBvc2l0aW9uW2VkZ2Uuc291cmNlKCkuaWQoKV07XG4gICAgICB2YXIgdCA9IGlkMnBvc2l0aW9uW2VkZ2UudGFyZ2V0KCkuaWQoKV07XG4gICAgICB2YXIgdyA9IHdlaWdodEZuKGVkZ2UpO1xuXG4gICAgICAvLyBVcGRhdGUgbWF0cml4XG4gICAgICBtYXRyaXhbdF1bc10gKz0gdztcblxuICAgICAgLy8gVXBkYXRlIGNvbHVtbiBzdW1cbiAgICAgIGNvbHVtblN1bVtzXSArPSB3O1xuICAgIH1cblxuICAgIC8vIEFkZCBhZGRpdGlvbmFsIHByb2JhYmlsaXR5IGJhc2VkIG9uIGRhbXBpbmcgZmFjdG9yXG4gICAgLy8gQWxzbywgdGFrZSBpbnRvIGFjY291bnQgY29sdW1ucyB0aGF0IGhhdmUgc3VtID0gMFxuICAgIHZhciBwID0gMS4wIC8gbnVtTm9kZXMgKyBhZGRpdGlvbmFsUHJvYjsgLy8gU2hvcnRoYW5kXG4gICAgLy8gVHJhdmVyc2UgbWF0cml4LCBjb2x1bW4gYnkgY29sdW1uXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1Ob2RlczsgaisrKSB7XG4gICAgICBpZiAoY29sdW1uU3VtW2pdID09PSAwKSB7XG4gICAgICAgIC8vIE5vICdsaW5rcycgb3V0IGZyb20gbm9kZSBqdGgsIGFzc3VtZSBlcXVhbCBwcm9iYWJpbGl0eSBmb3IgZWFjaCBwb3NzaWJsZSBub2RlXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgICAgIG1hdHJpeFtpXVtqXSA9IHA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vZGUganRoIGhhcyBvdXRnb2luZyBsaW5rLCBjb21wdXRlIG5vcm1hbGl6ZWQgcHJvYmFiaWxpdGllc1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgICAgICBtYXRyaXhbaV1bal0gPSBtYXRyaXhbaV1bal0gLyBjb2x1bW5TdW1bal0gKyBhZGRpdGlvbmFsUHJvYjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENvbXB1dGUgZG9taW5hbnQgZWlnZW52ZWN0b3IgdXNpbmcgcG93ZXIgbWV0aG9kXG4gICAgdmFyIGVpZ2VudmVjdG9yID0gW107XG4gICAgdmFyIG51bGxWZWN0b3IgPSBbXTtcbiAgICB2YXIgcHJldmlvdXM7XG5cbiAgICAvLyBTdGFydCB3aXRoIGEgdmVjdG9yIG9mIGFsbCAxJ3NcbiAgICAvLyBBbHNvLCBpbml0aWFsaXplIGEgbnVsbCB2ZWN0b3Igd2hpY2ggd2lsbCBiZSB1c2VkIGFzIHNob3J0aGFuZFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgZWlnZW52ZWN0b3IucHVzaCgxLjApO1xuICAgICAgbnVsbFZlY3Rvci5wdXNoKDAuMCk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaXRlciA9IDA7IGl0ZXIgPCBudW1JdGVyOyBpdGVyKyspIHtcbiAgICAgIC8vIE5ldyBhcnJheSB3aXRoIGFsbCAwJ3NcbiAgICAgIHZhciB0ZW1wID0gbnVsbFZlY3Rvci5zbGljZSgwKTtcblxuICAgICAgLy8gTXVsdGlwbHkgbWF0cml4IHdpdGggcHJldmlvdXMgcmVzdWx0XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1Ob2RlczsgaisrKSB7XG4gICAgICAgICAgdGVtcFtpXSArPSBtYXRyaXhbaV1bal0gKiBlaWdlbnZlY3RvcltqXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBub3JtYWxpemVWZWN0b3IodGVtcCk7XG4gICAgICBwcmV2aW91cyA9IGVpZ2VudmVjdG9yO1xuICAgICAgZWlnZW52ZWN0b3IgPSB0ZW1wO1xuXG4gICAgICB2YXIgZGlmZiA9IDA7XG4gICAgICAvLyBDb21wdXRlIGRpZmZlcmVuY2UgKHNxdWFyZWQgbW9kdWxlKSBvZiBib3RoIHZlY3RvcnNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgICBkaWZmICs9IE1hdGgucG93KHByZXZpb3VzW2ldIC0gZWlnZW52ZWN0b3JbaV0sIDIpO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBkaWZmZXJlbmNlIGlzIGxlc3MgdGhhbiB0aGUgZGVzaXJlZCB0aHJlc2hvbGQsIHN0b3AgaXRlcmF0aW5nXG4gICAgICBpZiAoZGlmZiA8IGVwc2lsb24pIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ29uc3RydWN0IHJlc3VsdFxuICAgIHZhciByZXMgPSB7XG4gICAgICByYW5rOiBmdW5jdGlvbiByYW5rKG5vZGUpIHtcbiAgICAgICAgaWYgKGlzLnN0cmluZyhub2RlKSkge1xuICAgICAgICAgIC8vIGlzIGEgc2VsZWN0b3Igc3RyaW5nXG4gICAgICAgICAgdmFyIG5vZGVJZCA9IGN5LmZpbHRlcihub2RlKVswXS5pZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGlzIGEgbm9kZSBvYmplY3RcbiAgICAgICAgICB2YXIgbm9kZUlkID0gbm9kZS5pZCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlaWdlbnZlY3RvcltpZDJwb3NpdGlvbltub2RlSWRdXTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIHJlcztcbiAgfSAvLyBwYWdlUmFua1xuXG59OyAvLyBlbGVzZm5cblxubW9kdWxlLmV4cG9ydHMgPSBlbGVzZm47XG5cbi8qKiovIH0pLFxuLyogMzkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIGVsZXNmbiA9IHtcblxuICBkZWdyZWVDZW50cmFsaXR5Tm9ybWFsaXplZDogZnVuY3Rpb24gZGVncmVlQ2VudHJhbGl0eU5vcm1hbGl6ZWQob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuXG4gICAgLy8gZGlyZWN0ZWQgLSBvcHRpb25hbFxuICAgIGlmIChvcHRpb25zLmRpcmVjdGVkICE9IG51bGwpIHtcbiAgICAgIHZhciBkaXJlY3RlZCA9IG9wdGlvbnMuZGlyZWN0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkaXJlY3RlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgICB2YXIgbnVtTm9kZXMgPSBub2Rlcy5sZW5ndGg7XG5cbiAgICBpZiAoIWRpcmVjdGVkKSB7XG4gICAgICB2YXIgZGVncmVlcyA9IHt9O1xuICAgICAgdmFyIG1heERlZ3JlZSA9IDA7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAvLyBhZGQgY3VycmVudCBub2RlIHRvIHRoZSBjdXJyZW50IG9wdGlvbnMgb2JqZWN0IGFuZCBjYWxsIGRlZ3JlZUNlbnRyYWxpdHlcbiAgICAgICAgdmFyIGN1cnJEZWdyZWUgPSB0aGlzLmRlZ3JlZUNlbnRyYWxpdHkodXRpbC5leHRlbmQoe30sIG9wdGlvbnMsIHsgcm9vdDogbm9kZSB9KSk7XG4gICAgICAgIGlmIChtYXhEZWdyZWUgPCBjdXJyRGVncmVlLmRlZ3JlZSkgbWF4RGVncmVlID0gY3VyckRlZ3JlZS5kZWdyZWU7XG5cbiAgICAgICAgZGVncmVlc1tub2RlLmlkKCldID0gY3VyckRlZ3JlZS5kZWdyZWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRlZ3JlZTogZnVuY3Rpb24gZGVncmVlKG5vZGUpIHtcbiAgICAgICAgICBpZiAobWF4RGVncmVlID09IDApIHJldHVybiAwO1xuXG4gICAgICAgICAgaWYgKGlzLnN0cmluZyhub2RlKSkge1xuICAgICAgICAgICAgLy8gZnJvbSBpcyBhIHNlbGVjdG9yIHN0cmluZ1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBjeS5maWx0ZXIobm9kZSlbMF0uaWQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZnJvbSBpcyBhIG5vZGVcbiAgICAgICAgICAgIHZhciBub2RlID0gbm9kZS5pZCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBkZWdyZWVzW25vZGVdIC8gbWF4RGVncmVlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaW5kZWdyZWVzID0ge307XG4gICAgICB2YXIgb3V0ZGVncmVlcyA9IHt9O1xuICAgICAgdmFyIG1heEluZGVncmVlID0gMDtcbiAgICAgIHZhciBtYXhPdXRkZWdyZWUgPSAwO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgLy8gYWRkIGN1cnJlbnQgbm9kZSB0byB0aGUgY3VycmVudCBvcHRpb25zIG9iamVjdCBhbmQgY2FsbCBkZWdyZWVDZW50cmFsaXR5XG4gICAgICAgIHZhciBjdXJyRGVncmVlID0gdGhpcy5kZWdyZWVDZW50cmFsaXR5KHV0aWwuZXh0ZW5kKHt9LCBvcHRpb25zLCB7IHJvb3Q6IG5vZGUgfSkpO1xuXG4gICAgICAgIGlmIChtYXhJbmRlZ3JlZSA8IGN1cnJEZWdyZWUuaW5kZWdyZWUpIG1heEluZGVncmVlID0gY3VyckRlZ3JlZS5pbmRlZ3JlZTtcblxuICAgICAgICBpZiAobWF4T3V0ZGVncmVlIDwgY3VyckRlZ3JlZS5vdXRkZWdyZWUpIG1heE91dGRlZ3JlZSA9IGN1cnJEZWdyZWUub3V0ZGVncmVlO1xuXG4gICAgICAgIGluZGVncmVlc1tub2RlLmlkKCldID0gY3VyckRlZ3JlZS5pbmRlZ3JlZTtcbiAgICAgICAgb3V0ZGVncmVlc1tub2RlLmlkKCldID0gY3VyckRlZ3JlZS5vdXRkZWdyZWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluZGVncmVlOiBmdW5jdGlvbiBpbmRlZ3JlZShub2RlKSB7XG4gICAgICAgICAgaWYgKG1heEluZGVncmVlID09IDApIHJldHVybiAwO1xuXG4gICAgICAgICAgaWYgKGlzLnN0cmluZyhub2RlKSkge1xuICAgICAgICAgICAgLy8gZnJvbSBpcyBhIHNlbGVjdG9yIHN0cmluZ1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBjeS5maWx0ZXIobm9kZSlbMF0uaWQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZnJvbSBpcyBhIG5vZGVcbiAgICAgICAgICAgIHZhciBub2RlID0gbm9kZS5pZCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBpbmRlZ3JlZXNbbm9kZV0gLyBtYXhJbmRlZ3JlZTtcbiAgICAgICAgfSxcbiAgICAgICAgb3V0ZGVncmVlOiBmdW5jdGlvbiBvdXRkZWdyZWUobm9kZSkge1xuICAgICAgICAgIGlmIChtYXhPdXRkZWdyZWUgPT0gMCkgcmV0dXJuIDA7XG5cbiAgICAgICAgICBpZiAoaXMuc3RyaW5nKG5vZGUpKSB7XG4gICAgICAgICAgICAvLyBmcm9tIGlzIGEgc2VsZWN0b3Igc3RyaW5nXG4gICAgICAgICAgICB2YXIgbm9kZSA9IGN5LmZpbHRlcihub2RlKVswXS5pZCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBmcm9tIGlzIGEgbm9kZVxuICAgICAgICAgICAgdmFyIG5vZGUgPSBub2RlLmlkKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG91dGRlZ3JlZXNbbm9kZV0gLyBtYXhPdXRkZWdyZWU7XG4gICAgICAgIH1cblxuICAgICAgfTtcbiAgICB9XG4gIH0sIC8vIGRlZ3JlZUNlbnRyYWxpdHlOb3JtYWxpemVkXG5cbiAgLy8gSW1wbGVtZW50ZWQgZnJvbSB0aGUgYWxnb3JpdGhtIGluIE9wc2FobCdzIHBhcGVyXG4gIC8vIFwiTm9kZSBjZW50cmFsaXR5IGluIHdlaWdodGVkIG5ldHdvcmtzOiBHZW5lcmFsaXppbmcgZGVncmVlIGFuZCBzaG9ydGVzdCBwYXRoc1wiXG4gIC8vIGNoZWNrIHRoZSBoZWFkaW5nIDIgXCJEZWdyZWVcIlxuICBkZWdyZWVDZW50cmFsaXR5OiBmdW5jdGlvbiBkZWdyZWVDZW50cmFsaXR5KG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHZhciBjYWxsaW5nRWxlcyA9IHRoaXM7XG5cbiAgICAvLyByb290IC0gbWFuZGF0b3J5IVxuICAgIGlmIChvcHRpb25zICE9IG51bGwgJiYgb3B0aW9ucy5yb290ICE9IG51bGwpIHtcbiAgICAgIHZhciByb290ID0gaXMuc3RyaW5nKG9wdGlvbnMucm9vdCkgPyB0aGlzLmZpbHRlcihvcHRpb25zLnJvb3QpWzBdIDogb3B0aW9ucy5yb290WzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIHdlaWdodCAtIG9wdGlvbmFsXG4gICAgaWYgKG9wdGlvbnMud2VpZ2h0ICE9IG51bGwgJiYgaXMuZm4ob3B0aW9ucy53ZWlnaHQpKSB7XG4gICAgICB2YXIgd2VpZ2h0Rm4gPSBvcHRpb25zLndlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgbm90IHNwZWNpZmllZCwgYXNzdW1lIGVhY2ggZWRnZSBoYXMgZXF1YWwgd2VpZ2h0ICgxKVxuICAgICAgdmFyIHdlaWdodEZuID0gZnVuY3Rpb24gd2VpZ2h0Rm4oZSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gZGlyZWN0ZWQgLSBvcHRpb25hbFxuICAgIGlmIChvcHRpb25zLmRpcmVjdGVkICE9IG51bGwpIHtcbiAgICAgIHZhciBkaXJlY3RlZCA9IG9wdGlvbnMuZGlyZWN0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkaXJlY3RlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGFscGhhIC0gb3B0aW9uYWxcbiAgICBpZiAob3B0aW9ucy5hbHBoYSAhPSBudWxsICYmIGlzLm51bWJlcihvcHRpb25zLmFscGhhKSkge1xuICAgICAgdmFyIGFscGhhID0gb3B0aW9ucy5hbHBoYTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWxwaGEgPSAwO1xuICAgIH1cblxuICAgIGlmICghZGlyZWN0ZWQpIHtcbiAgICAgIHZhciBjb25uRWRnZXMgPSByb290LmNvbm5lY3RlZEVkZ2VzKCkuaW50ZXJzZWN0aW9uKGNhbGxpbmdFbGVzKTtcbiAgICAgIHZhciBrID0gY29ubkVkZ2VzLmxlbmd0aDtcbiAgICAgIHZhciBzID0gMDtcblxuICAgICAgLy8gTm93LCBzdW0gZWRnZSB3ZWlnaHRzXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbm5FZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWRnZSA9IGNvbm5FZGdlc1tpXTtcbiAgICAgICAgcyArPSB3ZWlnaHRGbihlZGdlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGVncmVlOiBNYXRoLnBvdyhrLCAxIC0gYWxwaGEpICogTWF0aC5wb3cocywgYWxwaGEpXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaW5jb21pbmcgPSByb290LmNvbm5lY3RlZEVkZ2VzKCdlZGdlW3RhcmdldCA9IFwiJyArIHJvb3QuaWQoKSArICdcIl0nKS5pbnRlcnNlY3Rpb24oY2FsbGluZ0VsZXMpO1xuICAgICAgdmFyIG91dGdvaW5nID0gcm9vdC5jb25uZWN0ZWRFZGdlcygnZWRnZVtzb3VyY2UgPSBcIicgKyByb290LmlkKCkgKyAnXCJdJykuaW50ZXJzZWN0aW9uKGNhbGxpbmdFbGVzKTtcbiAgICAgIHZhciBrX2luID0gaW5jb21pbmcubGVuZ3RoO1xuICAgICAgdmFyIGtfb3V0ID0gb3V0Z29pbmcubGVuZ3RoO1xuICAgICAgdmFyIHNfaW4gPSAwO1xuICAgICAgdmFyIHNfb3V0ID0gMDtcblxuICAgICAgLy8gTm93LCBzdW0gaW5jb21pbmcgZWRnZSB3ZWlnaHRzXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluY29taW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlZGdlID0gaW5jb21pbmdbaV07XG4gICAgICAgIHNfaW4gKz0gd2VpZ2h0Rm4oZWRnZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIE5vdywgc3VtIG91dGdvaW5nIGVkZ2Ugd2VpZ2h0c1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRnb2luZy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWRnZSA9IG91dGdvaW5nW2ldO1xuICAgICAgICBzX291dCArPSB3ZWlnaHRGbihlZGdlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5kZWdyZWU6IE1hdGgucG93KGtfaW4sIDEgLSBhbHBoYSkgKiBNYXRoLnBvdyhzX2luLCBhbHBoYSksXG4gICAgICAgIG91dGRlZ3JlZTogTWF0aC5wb3coa19vdXQsIDEgLSBhbHBoYSkgKiBNYXRoLnBvdyhzX291dCwgYWxwaGEpXG4gICAgICB9O1xuICAgIH1cbiAgfSAvLyBkZWdyZWVDZW50cmFsaXR5XG5cbn07IC8vIGVsZXNmblxuXG4vLyBuaWNlLCBzaG9ydCBtYXRoZW1hdGhpY2FsIGFsaWFzXG5lbGVzZm4uZGMgPSBlbGVzZm4uZGVncmVlQ2VudHJhbGl0eTtcbmVsZXNmbi5kY24gPSBlbGVzZm4uZGVncmVlQ2VudHJhbGl0eU5vcm1hbGlzZWQgPSBlbGVzZm4uZGVncmVlQ2VudHJhbGl0eU5vcm1hbGl6ZWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuXG4vKioqLyB9KSxcbi8qIDQwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBpcyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBlbGVzZm4gPSB7XG5cbiAgY2xvc2VuZXNzQ2VudHJhbGl0eU5vcm1hbGl6ZWQ6IGZ1bmN0aW9uIGNsb3NlbmVzc0NlbnRyYWxpdHlOb3JtYWxpemVkKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICAgIHZhciBoYXJtb25pYyA9IG9wdGlvbnMuaGFybW9uaWM7XG4gICAgaWYgKGhhcm1vbmljID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGhhcm1vbmljID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgY2xvc2VuZXNzZXMgPSB7fTtcbiAgICB2YXIgbWF4Q2xvc2VuZXNzID0gMDtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgdmFyIGZ3ID0gdGhpcy5mbG95ZFdhcnNoYWxsKHsgd2VpZ2h0OiBvcHRpb25zLndlaWdodCwgZGlyZWN0ZWQ6IG9wdGlvbnMuZGlyZWN0ZWQgfSk7XG5cbiAgICAvLyBDb21wdXRlIGNsb3NlbmVzcyBmb3IgZXZlcnkgbm9kZSBhbmQgZmluZCB0aGUgbWF4aW11bSBjbG9zZW5lc3NcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY3VyckNsb3NlbmVzcyA9IDA7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5vZGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChpICE9IGopIHtcbiAgICAgICAgICB2YXIgZCA9IGZ3LmRpc3RhbmNlKG5vZGVzW2ldLCBub2Rlc1tqXSk7XG5cbiAgICAgICAgICBpZiAoaGFybW9uaWMpIHtcbiAgICAgICAgICAgIGN1cnJDbG9zZW5lc3MgKz0gMSAvIGQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN1cnJDbG9zZW5lc3MgKz0gZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFoYXJtb25pYykge1xuICAgICAgICBjdXJyQ2xvc2VuZXNzID0gMSAvIGN1cnJDbG9zZW5lc3M7XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXhDbG9zZW5lc3MgPCBjdXJyQ2xvc2VuZXNzKSB7XG4gICAgICAgIG1heENsb3NlbmVzcyA9IGN1cnJDbG9zZW5lc3M7XG4gICAgICB9XG5cbiAgICAgIGNsb3NlbmVzc2VzW25vZGVzW2ldLmlkKCldID0gY3VyckNsb3NlbmVzcztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY2xvc2VuZXNzOiBmdW5jdGlvbiBjbG9zZW5lc3Mobm9kZSkge1xuICAgICAgICBpZiAobWF4Q2xvc2VuZXNzID09IDApIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpcy5zdHJpbmcobm9kZSkpIHtcbiAgICAgICAgICAvLyBmcm9tIGlzIGEgc2VsZWN0b3Igc3RyaW5nXG4gICAgICAgICAgdmFyIG5vZGUgPSBjeS5maWx0ZXIobm9kZSlbMF0uaWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBmcm9tIGlzIGEgbm9kZVxuICAgICAgICAgIHZhciBub2RlID0gbm9kZS5pZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNsb3NlbmVzc2VzW25vZGVdIC8gbWF4Q2xvc2VuZXNzO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG5cbiAgLy8gSW1wbGVtZW50ZWQgZnJvbSBwc2V1ZG9jb2RlIGZyb20gd2lraXBlZGlhXG4gIGNsb3NlbmVzc0NlbnRyYWxpdHk6IGZ1bmN0aW9uIGNsb3NlbmVzc0NlbnRyYWxpdHkob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLy8gcm9vdCAtIG1hbmRhdG9yeSFcbiAgICBpZiAob3B0aW9ucy5yb290ICE9IG51bGwpIHtcbiAgICAgIGlmIChpcy5zdHJpbmcob3B0aW9ucy5yb290KSkge1xuICAgICAgICAvLyB1c2UgaXQgYXMgYSBzZWxlY3RvciwgZS5nLiBcIiNyb290SURcbiAgICAgICAgdmFyIHJvb3QgPSB0aGlzLmZpbHRlcihvcHRpb25zLnJvb3QpWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJvb3QgPSBvcHRpb25zLnJvb3RbMF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gd2VpZ2h0IC0gb3B0aW9uYWxcbiAgICBpZiAob3B0aW9ucy53ZWlnaHQgIT0gbnVsbCAmJiBpcy5mbihvcHRpb25zLndlaWdodCkpIHtcbiAgICAgIHZhciB3ZWlnaHQgPSBvcHRpb25zLndlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHdlaWdodCA9IGZ1bmN0aW9uIHdlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIGRpcmVjdGVkIC0gb3B0aW9uYWxcbiAgICBpZiAob3B0aW9ucy5kaXJlY3RlZCAhPSBudWxsICYmIGlzLmJvb2wob3B0aW9ucy5kaXJlY3RlZCkpIHtcbiAgICAgIHZhciBkaXJlY3RlZCA9IG9wdGlvbnMuZGlyZWN0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkaXJlY3RlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBoYXJtb25pYyA9IG9wdGlvbnMuaGFybW9uaWM7XG4gICAgaWYgKGhhcm1vbmljID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGhhcm1vbmljID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyB3ZSBuZWVkIGRpc3RhbmNlIGZyb20gdGhpcyBub2RlIHRvIGV2ZXJ5IG90aGVyIG5vZGVcbiAgICB2YXIgZGlqa3N0cmEgPSB0aGlzLmRpamtzdHJhKHtcbiAgICAgIHJvb3Q6IHJvb3QsXG4gICAgICB3ZWlnaHQ6IHdlaWdodCxcbiAgICAgIGRpcmVjdGVkOiBkaXJlY3RlZFxuICAgIH0pO1xuICAgIHZhciB0b3RhbERpc3RhbmNlID0gMDtcblxuICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobm9kZXNbaV0uaWQoKSAhPSByb290LmlkKCkpIHtcbiAgICAgICAgdmFyIGQgPSBkaWprc3RyYS5kaXN0YW5jZVRvKG5vZGVzW2ldKTtcblxuICAgICAgICBpZiAoaGFybW9uaWMpIHtcbiAgICAgICAgICB0b3RhbERpc3RhbmNlICs9IDEgLyBkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRvdGFsRGlzdGFuY2UgKz0gZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBoYXJtb25pYyA/IHRvdGFsRGlzdGFuY2UgOiAxIC8gdG90YWxEaXN0YW5jZTtcbiAgfSAvLyBjbG9zZW5lc3NDZW50cmFsaXR5XG5cbn07IC8vIGVsZXNmblxuXG4vLyBuaWNlLCBzaG9ydCBtYXRoZW1hdGhpY2FsIGFsaWFzXG5lbGVzZm4uY2MgPSBlbGVzZm4uY2xvc2VuZXNzQ2VudHJhbGl0eTtcbmVsZXNmbi5jY24gPSBlbGVzZm4uY2xvc2VuZXNzQ2VudHJhbGl0eU5vcm1hbGlzZWQgPSBlbGVzZm4uY2xvc2VuZXNzQ2VudHJhbGl0eU5vcm1hbGl6ZWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuXG4vKioqLyB9KSxcbi8qIDQxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBpcyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgSGVhcCA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbnZhciBlbGVzZm4gPSB7XG5cbiAgLy8gSW1wbGVtZW50ZWQgZnJvbSB0aGUgYWxnb3JpdGhtIGluIHRoZSBwYXBlciBcIk9uIFZhcmlhbnRzIG9mIFNob3J0ZXN0LVBhdGggQmV0d2Vlbm5lc3MgQ2VudHJhbGl0eSBhbmQgdGhlaXIgR2VuZXJpYyBDb21wdXRhdGlvblwiIGJ5IFVscmlrIEJyYW5kZXNcbiAgYmV0d2Vlbm5lc3NDZW50cmFsaXR5OiBmdW5jdGlvbiBiZXR3ZWVubmVzc0NlbnRyYWxpdHkob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLy8gV2VpZ2h0IC0gb3B0aW9uYWxcbiAgICB2YXIgd2VpZ2h0ZWQsIHdlaWdodEZuO1xuICAgIGlmIChpcy5mbihvcHRpb25zLndlaWdodCkpIHtcbiAgICAgIHdlaWdodEZuID0gb3B0aW9ucy53ZWlnaHQ7XG4gICAgICB3ZWlnaHRlZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdlaWdodGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gRGlyZWN0ZWQgLSBkZWZhdWx0IGZhbHNlXG4gICAgdmFyIGRpcmVjdGVkID0gb3B0aW9ucy5kaXJlY3RlZCAhPSBudWxsID8gb3B0aW9ucy5kaXJlY3RlZCA6IGZhbHNlO1xuXG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcblxuICAgIC8vIHN0YXJ0aW5nXG4gICAgdmFyIFYgPSB0aGlzLm5vZGVzKCk7XG4gICAgdmFyIEEgPSB7fTtcbiAgICB2YXIgX0MgPSB7fTtcbiAgICB2YXIgbWF4ID0gMDtcbiAgICB2YXIgQyA9IHtcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsKSB7XG4gICAgICAgIF9DW2tleV0gPSB2YWw7XG5cbiAgICAgICAgaWYgKHZhbCA+IG1heCkge1xuICAgICAgICAgIG1heCA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgICAgIHJldHVybiBfQ1trZXldO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBBIGNvbnRhaW5zIHRoZSBuZWlnaGJvcmhvb2RzIG9mIGV2ZXJ5IG5vZGVcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IFYubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB2ID0gVltpXTtcbiAgICAgIHZhciB2aWQgPSB2LmlkKCk7XG5cbiAgICAgIGlmIChkaXJlY3RlZCkge1xuICAgICAgICBBW3ZpZF0gPSB2Lm91dGdvZXJzKCkubm9kZXMoKTsgLy8gZ2V0IG91dGdvZXJzIG9mIGV2ZXJ5IG5vZGVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIEFbdmlkXSA9IHYub3Blbk5laWdoYm9yaG9vZCgpLm5vZGVzKCk7IC8vIGdldCBuZWlnaGJvcnMgb2YgZXZlcnkgbm9kZVxuICAgICAgfVxuXG4gICAgICBDLnNldCh2aWQsIDApO1xuICAgIH1cblxuICAgIGZvciAodmFyIHMgPSAwOyBzIDwgVi5sZW5ndGg7IHMrKykge1xuICAgICAgdmFyIHNpZCA9IFZbc10uaWQoKTtcbiAgICAgIHZhciBTID0gW107IC8vIHN0YWNrXG4gICAgICB2YXIgUCA9IHt9O1xuICAgICAgdmFyIGcgPSB7fTtcbiAgICAgIHZhciBkID0ge307XG4gICAgICB2YXIgUSA9IG5ldyBIZWFwKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBkW2FdIC0gZFtiXTtcbiAgICAgIH0pOyAvLyBxdWV1ZVxuXG4gICAgICAvLyBpbml0IGRpY3Rpb25hcmllc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBWLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB2aWQgPSBWW2ldLmlkKCk7XG5cbiAgICAgICAgUFt2aWRdID0gW107XG4gICAgICAgIGdbdmlkXSA9IDA7XG4gICAgICAgIGRbdmlkXSA9IEluZmluaXR5O1xuICAgICAgfVxuXG4gICAgICBnW3NpZF0gPSAxOyAvLyBzaWdtYVxuICAgICAgZFtzaWRdID0gMDsgLy8gZGlzdGFuY2UgdG8gc1xuXG4gICAgICBRLnB1c2goc2lkKTtcblxuICAgICAgd2hpbGUgKCFRLmVtcHR5KCkpIHtcbiAgICAgICAgdmFyIHYgPSBRLnBvcCgpO1xuXG4gICAgICAgIFMucHVzaCh2KTtcblxuICAgICAgICBpZiAod2VpZ2h0ZWQpIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IEFbdl0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciB3ID0gQVt2XVtqXTtcbiAgICAgICAgICAgIHZhciB2RWxlID0gY3kuZ2V0RWxlbWVudEJ5SWQodik7XG5cbiAgICAgICAgICAgIHZhciBlZGdlO1xuICAgICAgICAgICAgaWYgKHZFbGUuZWRnZXNUbyh3KS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGVkZ2UgPSB2RWxlLmVkZ2VzVG8odylbMF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlZGdlID0gdy5lZGdlc1RvKHZFbGUpWzBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZWRnZVdlaWdodCA9IHdlaWdodEZuKGVkZ2UpO1xuXG4gICAgICAgICAgICB3ID0gdy5pZCgpO1xuXG4gICAgICAgICAgICBpZiAoZFt3XSA+IGRbdl0gKyBlZGdlV2VpZ2h0KSB7XG4gICAgICAgICAgICAgIGRbd10gPSBkW3ZdICsgZWRnZVdlaWdodDtcblxuICAgICAgICAgICAgICBpZiAoUS5ub2Rlcy5pbmRleE9mKHcpIDwgMCkge1xuICAgICAgICAgICAgICAgIC8vaWYgdyBpcyBub3QgaW4gUVxuICAgICAgICAgICAgICAgIFEucHVzaCh3KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgcG9zaXRpb24gaWYgdyBpcyBpbiBRXG4gICAgICAgICAgICAgICAgUS51cGRhdGVJdGVtKHcpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZ1t3XSA9IDA7XG4gICAgICAgICAgICAgIFBbd10gPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRbd10gPT0gZFt2XSArIGVkZ2VXZWlnaHQpIHtcbiAgICAgICAgICAgICAgZ1t3XSA9IGdbd10gKyBnW3ZdO1xuICAgICAgICAgICAgICBQW3ddLnB1c2godik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgQVt2XS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIHcgPSBBW3ZdW2pdLmlkKCk7XG5cbiAgICAgICAgICAgIGlmIChkW3ddID09IEluZmluaXR5KSB7XG4gICAgICAgICAgICAgIFEucHVzaCh3KTtcblxuICAgICAgICAgICAgICBkW3ddID0gZFt2XSArIDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkW3ddID09IGRbdl0gKyAxKSB7XG4gICAgICAgICAgICAgIGdbd10gPSBnW3ddICsgZ1t2XTtcbiAgICAgICAgICAgICAgUFt3XS5wdXNoKHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZSA9IHt9O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBWLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVbVltpXS5pZCgpXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChTLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHcgPSBTLnBvcCgpO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgUFt3XS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHZhciB2ID0gUFt3XVtqXTtcblxuICAgICAgICAgIGVbdl0gPSBlW3ZdICsgZ1t2XSAvIGdbd10gKiAoMSArIGVbd10pO1xuXG4gICAgICAgICAgaWYgKHcgIT0gVltzXS5pZCgpKSB7XG4gICAgICAgICAgICBDLnNldCh3LCBDLmdldCh3KSArIGVbd10pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZXQgPSB7XG4gICAgICBiZXR3ZWVubmVzczogZnVuY3Rpb24gYmV0d2Vlbm5lc3Mobm9kZSkge1xuICAgICAgICBpZiAoaXMuc3RyaW5nKG5vZGUpKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSBjeS5maWx0ZXIobm9kZSkuaWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IG5vZGUuaWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBDLmdldChub2RlKTtcbiAgICAgIH0sXG5cbiAgICAgIGJldHdlZW5uZXNzTm9ybWFsaXplZDogZnVuY3Rpb24gYmV0d2Vlbm5lc3NOb3JtYWxpemVkKG5vZGUpIHtcbiAgICAgICAgaWYgKG1heCA9PSAwKSByZXR1cm4gMDtcblxuICAgICAgICBpZiAoaXMuc3RyaW5nKG5vZGUpKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSBjeS5maWx0ZXIobm9kZSkuaWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IG5vZGUuaWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBDLmdldChub2RlKSAvIG1heDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gYWxpYXNcbiAgICByZXQuYmV0d2Vlbm5lc3NOb3JtYWxpc2VkID0gcmV0LmJldHdlZW5uZXNzTm9ybWFsaXplZDtcblxuICAgIHJldHVybiByZXQ7XG4gIH0gLy8gYmV0d2Vlbm5lc3NDZW50cmFsaXR5XG5cbn07IC8vIGVsZXNmblxuXG4vLyBuaWNlLCBzaG9ydCBtYXRoZW1hdGhpY2FsIGFsaWFzXG5lbGVzZm4uYmMgPSBlbGVzZm4uYmV0d2Vlbm5lc3NDZW50cmFsaXR5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVsZXNmbjtcblxuLyoqKi8gfSksXG4vKiA0MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgZGVmaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIGVsZXNmbiA9IHtcbiAgYW5pbWF0ZTogZGVmaW5lLmFuaW1hdGUoKSxcbiAgYW5pbWF0aW9uOiBkZWZpbmUuYW5pbWF0aW9uKCksXG4gIGFuaW1hdGVkOiBkZWZpbmUuYW5pbWF0ZWQoKSxcbiAgY2xlYXJRdWV1ZTogZGVmaW5lLmNsZWFyUXVldWUoKSxcbiAgZGVsYXk6IGRlZmluZS5kZWxheSgpLFxuICBkZWxheUFuaW1hdGlvbjogZGVmaW5lLmRlbGF5QW5pbWF0aW9uKCksXG4gIHN0b3A6IGRlZmluZS5zdG9wKClcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuXG4vKioqLyB9KSxcbi8qIDQzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbnZhciBBbmltYXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0KTtcbnZhciBtYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbnZhciBpcyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBkZWZpbmUgPSB7XG5cbiAgYW5pbWF0ZWQ6IGZ1bmN0aW9uIGFuaW1hdGVkKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBhbmltYXRlZEltcGwoKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3kgfHwgdGhpcztcblxuICAgICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbGUgPSBhbGxbMF07XG5cbiAgICAgIGlmIChlbGUpIHtcbiAgICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5hbmltYXRpb24uY3VycmVudC5sZW5ndGggPiAwO1xuICAgICAgfVxuICAgIH07XG4gIH0sIC8vIGFuaW1hdGVkXG5cbiAgY2xlYXJRdWV1ZTogZnVuY3Rpb24gY2xlYXJRdWV1ZSgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gY2xlYXJRdWV1ZUltcGwoKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3kgfHwgdGhpcztcblxuICAgICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IGFsbFtpXTtcbiAgICAgICAgZWxlLl9wcml2YXRlLmFuaW1hdGlvbi5xdWV1ZSA9IFtdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICB9LCAvLyBjbGVhclF1ZXVlXG5cbiAgZGVsYXk6IGZ1bmN0aW9uIGRlbGF5KCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBkZWxheUltcGwodGltZSwgY29tcGxldGUpIHtcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3kgfHwgdGhpcztcblxuICAgICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0ZSh7XG4gICAgICAgIGRlbGF5OiB0aW1lLFxuICAgICAgICBkdXJhdGlvbjogdGltZSxcbiAgICAgICAgY29tcGxldGU6IGNvbXBsZXRlXG4gICAgICB9KTtcbiAgICB9O1xuICB9LCAvLyBkZWxheVxuXG4gIGRlbGF5QW5pbWF0aW9uOiBmdW5jdGlvbiBkZWxheUFuaW1hdGlvbigpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gZGVsYXlBbmltYXRpb25JbXBsKHRpbWUsIGNvbXBsZXRlKSB7XG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5IHx8IHRoaXM7XG5cbiAgICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmFuaW1hdGlvbih7XG4gICAgICAgIGRlbGF5OiB0aW1lLFxuICAgICAgICBkdXJhdGlvbjogdGltZSxcbiAgICAgICAgY29tcGxldGU6IGNvbXBsZXRlXG4gICAgICB9KTtcbiAgICB9O1xuICB9LCAvLyBkZWxheVxuXG4gIGFuaW1hdGlvbjogZnVuY3Rpb24gYW5pbWF0aW9uKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBhbmltYXRpb25JbXBsKHByb3BlcnRpZXMsIHBhcmFtcykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHNlbGZJc0FycmF5TGlrZSA9IHNlbGYubGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgICB2YXIgYWxsID0gc2VsZklzQXJyYXlMaWtlID8gc2VsZiA6IFtzZWxmXTsgLy8gcHV0IGluIGFycmF5IGlmIG5vdCBhcnJheS1saWtlXG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5IHx8IHRoaXM7XG4gICAgICB2YXIgaXNDb3JlID0gIXNlbGZJc0FycmF5TGlrZTtcbiAgICAgIHZhciBpc0VsZXMgPSAhaXNDb3JlO1xuXG4gICAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3R5bGUgPSBjeS5zdHlsZSgpO1xuXG4gICAgICBwcm9wZXJ0aWVzID0gdXRpbC5hc3NpZ24oe30sIHByb3BlcnRpZXMsIHBhcmFtcyk7XG5cbiAgICAgIHZhciBwcm9wZXJ0aWVzRW1wdHkgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKS5sZW5ndGggPT09IDA7XG5cbiAgICAgIGlmIChwcm9wZXJ0aWVzRW1wdHkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb24oYWxsWzBdLCBwcm9wZXJ0aWVzKTsgLy8gbm90aGluZyB0byBhbmltYXRlXG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9wZXJ0aWVzLmR1cmF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvcGVydGllcy5kdXJhdGlvbiA9IDQwMDtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChwcm9wZXJ0aWVzLmR1cmF0aW9uKSB7XG4gICAgICAgIGNhc2UgJ3Nsb3cnOlxuICAgICAgICAgIHByb3BlcnRpZXMuZHVyYXRpb24gPSA2MDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2Zhc3QnOlxuICAgICAgICAgIHByb3BlcnRpZXMuZHVyYXRpb24gPSAyMDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0VsZXMpIHtcbiAgICAgICAgcHJvcGVydGllcy5zdHlsZSA9IHN0eWxlLmdldFByb3BzTGlzdChwcm9wZXJ0aWVzLnN0eWxlIHx8IHByb3BlcnRpZXMuY3NzKTtcblxuICAgICAgICBwcm9wZXJ0aWVzLmNzcyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRWxlcyAmJiBwcm9wZXJ0aWVzLnJlbmRlcmVkUG9zaXRpb24gIT0gbnVsbCkge1xuICAgICAgICB2YXIgcnBvcyA9IHByb3BlcnRpZXMucmVuZGVyZWRQb3NpdGlvbjtcbiAgICAgICAgdmFyIHBhbiA9IGN5LnBhbigpO1xuICAgICAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcblxuICAgICAgICBwcm9wZXJ0aWVzLnBvc2l0aW9uID0gbWF0aC5yZW5kZXJlZFRvTW9kZWxQb3NpdGlvbihycG9zLCB6b29tLCBwYW4pO1xuICAgICAgfVxuXG4gICAgICAvLyBvdmVycmlkZSBwYW4gdy8gcGFuQnkgaWYgc2V0XG4gICAgICBpZiAoaXNDb3JlICYmIHByb3BlcnRpZXMucGFuQnkgIT0gbnVsbCkge1xuICAgICAgICB2YXIgcGFuQnkgPSBwcm9wZXJ0aWVzLnBhbkJ5O1xuICAgICAgICB2YXIgY3lQYW4gPSBjeS5wYW4oKTtcblxuICAgICAgICBwcm9wZXJ0aWVzLnBhbiA9IHtcbiAgICAgICAgICB4OiBjeVBhbi54ICsgcGFuQnkueCxcbiAgICAgICAgICB5OiBjeVBhbi55ICsgcGFuQnkueVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBvdmVycmlkZSBwYW4gdy8gY2VudGVyIGlmIHNldFxuICAgICAgdmFyIGNlbnRlciA9IHByb3BlcnRpZXMuY2VudGVyIHx8IHByb3BlcnRpZXMuY2VudHJlO1xuICAgICAgaWYgKGlzQ29yZSAmJiBjZW50ZXIgIT0gbnVsbCkge1xuICAgICAgICB2YXIgY2VudGVyUGFuID0gY3kuZ2V0Q2VudGVyUGFuKGNlbnRlci5lbGVzLCBwcm9wZXJ0aWVzLnpvb20pO1xuXG4gICAgICAgIGlmIChjZW50ZXJQYW4gIT0gbnVsbCkge1xuICAgICAgICAgIHByb3BlcnRpZXMucGFuID0gY2VudGVyUGFuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIG92ZXJyaWRlIHBhbiAmIHpvb20gdy8gZml0IGlmIHNldFxuICAgICAgaWYgKGlzQ29yZSAmJiBwcm9wZXJ0aWVzLmZpdCAhPSBudWxsKSB7XG4gICAgICAgIHZhciBmaXQgPSBwcm9wZXJ0aWVzLmZpdDtcbiAgICAgICAgdmFyIGZpdFZwID0gY3kuZ2V0Rml0Vmlld3BvcnQoZml0LmVsZXMgfHwgZml0LmJvdW5kaW5nQm94LCBmaXQucGFkZGluZyk7XG5cbiAgICAgICAgaWYgKGZpdFZwICE9IG51bGwpIHtcbiAgICAgICAgICBwcm9wZXJ0aWVzLnBhbiA9IGZpdFZwLnBhbjtcbiAgICAgICAgICBwcm9wZXJ0aWVzLnpvb20gPSBmaXRWcC56b29tO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIG92ZXJyaWRlIHpvb20gKCYgcG90ZW50aWFsbHkgcGFuKSB3LyB6b29tIG9iaiBpZiBzZXRcbiAgICAgIGlmIChpc0NvcmUgJiYgaXMucGxhaW5PYmplY3QocHJvcGVydGllcy56b29tKSkge1xuICAgICAgICB2YXIgdnAgPSBjeS5nZXRab29tZWRWaWV3cG9ydChwcm9wZXJ0aWVzLnpvb20pO1xuXG4gICAgICAgIGlmICh2cCAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKHZwLnpvb21lZCkge1xuICAgICAgICAgICAgcHJvcGVydGllcy56b29tID0gdnAuem9vbTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodnAucGFubmVkKSB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLnBhbiA9IHZwLnBhbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb24oYWxsWzBdLCBwcm9wZXJ0aWVzKTtcbiAgICB9O1xuICB9LCAvLyBhbmltYXRlXG5cbiAgYW5pbWF0ZTogZnVuY3Rpb24gYW5pbWF0ZSgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gYW5pbWF0ZUltcGwocHJvcGVydGllcywgcGFyYW1zKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3kgfHwgdGhpcztcblxuICAgICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtcykge1xuICAgICAgICBwcm9wZXJ0aWVzID0gdXRpbC5leHRlbmQoe30sIHByb3BlcnRpZXMsIHBhcmFtcyk7XG4gICAgICB9XG5cbiAgICAgIC8vIG1hbnVhbGx5IGhvb2sgYW5kIHJ1biB0aGUgYW5pbWF0aW9uXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gYWxsW2ldO1xuICAgICAgICB2YXIgcXVldWUgPSBlbGUuYW5pbWF0ZWQoKSAmJiAocHJvcGVydGllcy5xdWV1ZSA9PT0gdW5kZWZpbmVkIHx8IHByb3BlcnRpZXMucXVldWUpO1xuXG4gICAgICAgIHZhciBhbmkgPSBlbGUuYW5pbWF0aW9uKHByb3BlcnRpZXMsIHF1ZXVlID8geyBxdWV1ZTogdHJ1ZSB9IDogdW5kZWZpbmVkKTtcblxuICAgICAgICBhbmkucGxheSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9O1xuICB9LCAvLyBhbmltYXRlXG5cbiAgc3RvcDogZnVuY3Rpb24gc3RvcCgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gc3RvcEltcGwoY2xlYXJRdWV1ZSwganVtcFRvRW5kKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3kgfHwgdGhpcztcblxuICAgICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IGFsbFtpXTtcbiAgICAgICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgICAgICB2YXIgYW5pcyA9IF9wLmFuaW1hdGlvbi5jdXJyZW50O1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYW5pcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHZhciBhbmkgPSBhbmlzW2pdO1xuICAgICAgICAgIHZhciBhbmlfcCA9IGFuaS5fcHJpdmF0ZTtcblxuICAgICAgICAgIGlmIChqdW1wVG9FbmQpIHtcbiAgICAgICAgICAgIC8vIG5leHQgaXRlcmF0aW9uIG9mIHRoZSBhbmltYXRpb24gbG9vcCwgdGhlIGFuaW1hdGlvblxuICAgICAgICAgICAgLy8gd2lsbCBnbyBzdHJhaWdodCB0byB0aGUgZW5kIGFuZCBiZSByZW1vdmVkXG4gICAgICAgICAgICBhbmlfcC5kdXJhdGlvbiA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2xlYXIgdGhlIHF1ZXVlIG9mIGZ1dHVyZSBhbmltYXRpb25zXG4gICAgICAgIGlmIChjbGVhclF1ZXVlKSB7XG4gICAgICAgICAgX3AuYW5pbWF0aW9uLnF1ZXVlID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWp1bXBUb0VuZCkge1xuICAgICAgICAgIF9wLmFuaW1hdGlvbi5jdXJyZW50ID0gW107XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gd2UgaGF2ZSB0byBub3RpZnkgKHRoZSBhbmltYXRpb24gbG9vcCBkb2Vzbid0IGRvIGl0IGZvciB1cyBvbiBgc3RvcGApXG4gICAgICBjeS5ub3RpZnkoe1xuICAgICAgICBlbGVzOiB0aGlzLFxuICAgICAgICB0eXBlOiAnZHJhdydcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICB9IC8vIHN0b3BcblxufTsgLy8gZGVmaW5lXG5cbm1vZHVsZS5leHBvcnRzID0gZGVmaW5lO1xuXG4vKioqLyB9KSxcbi8qIDQ0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbnZhciBpcyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgUHJvbWlzZSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbnZhciBBbmltYXRpb24gPSBmdW5jdGlvbiBBbmltYXRpb24odGFyZ2V0LCBvcHRzLCBvcHRzMikge1xuICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlID0gdXRpbC5leHRlbmQoe1xuICAgIGR1cmF0aW9uOiAxMDAwXG4gIH0sIG9wdHMsIG9wdHMyKTtcblxuICBfcC50YXJnZXQgPSB0YXJnZXQ7XG4gIF9wLnN0eWxlID0gX3Auc3R5bGUgfHwgX3AuY3NzO1xuICBfcC5zdGFydGVkID0gZmFsc2U7XG4gIF9wLnBsYXlpbmcgPSBmYWxzZTtcbiAgX3AuaG9va2VkID0gZmFsc2U7XG4gIF9wLmFwcGx5aW5nID0gZmFsc2U7XG4gIF9wLnByb2dyZXNzID0gMDtcbiAgX3AuY29tcGxldGVzID0gW107XG4gIF9wLmZyYW1lcyA9IFtdO1xuXG4gIGlmIChfcC5jb21wbGV0ZSAmJiBpcy5mbihfcC5jb21wbGV0ZSkpIHtcbiAgICBfcC5jb21wbGV0ZXMucHVzaChfcC5jb21wbGV0ZSk7XG4gIH1cblxuICAvLyBmb3IgZnV0dXJlIHRpbWVsaW5lL2FuaW1hdGlvbnMgaW1wbFxuICB0aGlzLmxlbmd0aCA9IDE7XG4gIHRoaXNbMF0gPSB0aGlzO1xufTtcblxudmFyIGFuaWZuID0gQW5pbWF0aW9uLnByb3RvdHlwZTtcblxudXRpbC5leHRlbmQoYW5pZm4sIHtcblxuICBpbnN0YW5jZVN0cmluZzogZnVuY3Rpb24gaW5zdGFuY2VTdHJpbmcoKSB7XG4gICAgcmV0dXJuICdhbmltYXRpb24nO1xuICB9LFxuXG4gIGhvb2s6IGZ1bmN0aW9uIGhvb2soKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcblxuICAgIGlmICghX3AuaG9va2VkKSB7XG4gICAgICAvLyBhZGQgdG8gdGFyZ2V0J3MgYW5pbWF0aW9uIHF1ZXVlXG4gICAgICB2YXIgcSA9IHZvaWQgMDtcbiAgICAgIHZhciB0QW5pID0gX3AudGFyZ2V0Ll9wcml2YXRlLmFuaW1hdGlvbjtcbiAgICAgIGlmIChfcC5xdWV1ZSkge1xuICAgICAgICBxID0gdEFuaS5xdWV1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHEgPSB0QW5pLmN1cnJlbnQ7XG4gICAgICB9XG4gICAgICBxLnB1c2godGhpcyk7XG5cbiAgICAgIC8vIGFkZCB0byB0aGUgYW5pbWF0aW9uIGxvb3AgcG9vbFxuICAgICAgaWYgKGlzLmVsZW1lbnRPckNvbGxlY3Rpb24oX3AudGFyZ2V0KSkge1xuICAgICAgICBfcC50YXJnZXQuY3koKS5hZGRUb0FuaW1hdGlvblBvb2woX3AudGFyZ2V0KTtcbiAgICAgIH1cblxuICAgICAgX3AuaG9va2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBwbGF5OiBmdW5jdGlvbiBwbGF5KCkge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICAvLyBhdXRvcmV3aW5kXG4gICAgaWYgKF9wLnByb2dyZXNzID09PSAxKSB7XG4gICAgICBfcC5wcm9ncmVzcyA9IDA7XG4gICAgfVxuXG4gICAgX3AucGxheWluZyA9IHRydWU7XG4gICAgX3Auc3RhcnRlZCA9IGZhbHNlOyAvLyBuZWVkcyB0byBiZSBzdGFydGVkIGJ5IGFuaW1hdGlvbiBsb29wXG4gICAgX3Auc3RvcHBlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5ob29rKCk7XG5cbiAgICAvLyB0aGUgYW5pbWF0aW9uIGxvb3Agd2lsbCBzdGFydCB0aGUgYW5pbWF0aW9uLi4uXG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBwbGF5aW5nOiBmdW5jdGlvbiBwbGF5aW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnBsYXlpbmc7XG4gIH0sXG5cbiAgYXBwbHk6IGZ1bmN0aW9uIGFwcGx5KCkge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICBfcC5hcHBseWluZyA9IHRydWU7XG4gICAgX3Auc3RhcnRlZCA9IGZhbHNlOyAvLyBuZWVkcyB0byBiZSBzdGFydGVkIGJ5IGFuaW1hdGlvbiBsb29wXG4gICAgX3Auc3RvcHBlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5ob29rKCk7XG5cbiAgICAvLyB0aGUgYW5pbWF0aW9uIGxvb3Agd2lsbCBhcHBseSB0aGUgYW5pbWF0aW9uIGF0IHRoaXMgcHJvZ3Jlc3NcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGFwcGx5aW5nOiBmdW5jdGlvbiBhcHBseWluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5hcHBseWluZztcbiAgfSxcblxuICBwYXVzZTogZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcblxuICAgIF9wLnBsYXlpbmcgPSBmYWxzZTtcbiAgICBfcC5zdGFydGVkID0gZmFsc2U7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBzdG9wOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICBfcC5wbGF5aW5nID0gZmFsc2U7XG4gICAgX3Auc3RhcnRlZCA9IGZhbHNlO1xuICAgIF9wLnN0b3BwZWQgPSB0cnVlOyAvLyB0byBiZSByZW1vdmVkIGZyb20gYW5pbWF0aW9uIHF1ZXVlc1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgcmV3aW5kOiBmdW5jdGlvbiByZXdpbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvZ3Jlc3MoMCk7XG4gIH0sXG5cbiAgZmFzdGZvcndhcmQ6IGZ1bmN0aW9uIGZhc3Rmb3J3YXJkKCkge1xuICAgIHJldHVybiB0aGlzLnByb2dyZXNzKDEpO1xuICB9LFxuXG4gIHRpbWU6IGZ1bmN0aW9uIHRpbWUodCkge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICBpZiAodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gX3AucHJvZ3Jlc3MgKiBfcC5kdXJhdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMucHJvZ3Jlc3ModCAvIF9wLmR1cmF0aW9uKTtcbiAgICB9XG4gIH0sXG5cbiAgcHJvZ3Jlc3M6IGZ1bmN0aW9uIHByb2dyZXNzKHApIHtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIHZhciB3YXNQbGF5aW5nID0gX3AucGxheWluZztcblxuICAgIGlmIChwID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBfcC5wcm9ncmVzcztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHdhc1BsYXlpbmcpIHtcbiAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgfVxuXG4gICAgICBfcC5wcm9ncmVzcyA9IHA7XG4gICAgICBfcC5zdGFydGVkID0gZmFsc2U7XG5cbiAgICAgIGlmICh3YXNQbGF5aW5nKSB7XG4gICAgICAgIHRoaXMucGxheSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGNvbXBsZXRlZDogZnVuY3Rpb24gY29tcGxldGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnByb2dyZXNzID09PSAxO1xuICB9LFxuXG4gIHJldmVyc2U6IGZ1bmN0aW9uIHJldmVyc2UoKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICB2YXIgd2FzUGxheWluZyA9IF9wLnBsYXlpbmc7XG5cbiAgICBpZiAod2FzUGxheWluZykge1xuICAgICAgdGhpcy5wYXVzZSgpO1xuICAgIH1cblxuICAgIF9wLnByb2dyZXNzID0gMSAtIF9wLnByb2dyZXNzO1xuICAgIF9wLnN0YXJ0ZWQgPSBmYWxzZTtcblxuICAgIHZhciBzd2FwID0gZnVuY3Rpb24gc3dhcChhLCBiKSB7XG4gICAgICB2YXIgX3BhID0gX3BbYV07XG5cbiAgICAgIGlmIChfcGEgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIF9wW2FdID0gX3BbYl07XG4gICAgICBfcFtiXSA9IF9wYTtcbiAgICB9O1xuXG4gICAgc3dhcCgnem9vbScsICdzdGFydFpvb20nKTtcbiAgICBzd2FwKCdwYW4nLCAnc3RhcnRQYW4nKTtcbiAgICBzd2FwKCdwb3NpdGlvbicsICdzdGFydFBvc2l0aW9uJyk7XG5cbiAgICAvLyBzd2FwIHN0eWxlc1xuICAgIGlmIChfcC5zdHlsZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfcC5zdHlsZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcHJvcCA9IF9wLnN0eWxlW2ldO1xuICAgICAgICB2YXIgbmFtZSA9IHByb3AubmFtZTtcbiAgICAgICAgdmFyIHN0YXJ0U3R5bGVQcm9wID0gX3Auc3RhcnRTdHlsZVtuYW1lXTtcblxuICAgICAgICBfcC5zdGFydFN0eWxlW25hbWVdID0gcHJvcDtcbiAgICAgICAgX3Auc3R5bGVbaV0gPSBzdGFydFN0eWxlUHJvcDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAod2FzUGxheWluZykge1xuICAgICAgdGhpcy5wbGF5KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgcHJvbWlzZTogZnVuY3Rpb24gcHJvbWlzZSh0eXBlKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcblxuICAgIHZhciBhcnIgPSB2b2lkIDA7XG5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2ZyYW1lJzpcbiAgICAgICAgYXJyID0gX3AuZnJhbWVzO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICBjYXNlICdjb21wbGV0ZSc6XG4gICAgICBjYXNlICdjb21wbGV0ZWQnOlxuICAgICAgICBhcnIgPSBfcC5jb21wbGV0ZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGFyci5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxufSk7XG5cbmFuaWZuLmNvbXBsZXRlID0gYW5pZm4uY29tcGxldGVkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFuaW1hdGlvbjtcblxuLyoqKi8gfSksXG4vKiA0NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG52YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG52YXIgaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgZGVmaW5lID0ge1xuXG4gIC8vIGFjY2VzcyBkYXRhIGZpZWxkXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEocGFyYW1zKSB7XG4gICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgZmllbGQ6ICdkYXRhJyxcbiAgICAgIGJpbmRpbmdFdmVudDogJ2RhdGEnLFxuICAgICAgYWxsb3dCaW5kaW5nOiBmYWxzZSxcbiAgICAgIGFsbG93U2V0dGluZzogZmFsc2UsXG4gICAgICBhbGxvd0dldHRpbmc6IGZhbHNlLFxuICAgICAgc2V0dGluZ0V2ZW50OiAnZGF0YScsXG4gICAgICBzZXR0aW5nVHJpZ2dlcnNFdmVudDogZmFsc2UsXG4gICAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgICBpbW11dGFibGVLZXlzOiB7fSwgLy8ga2V5ID0+IHRydWUgaWYgaW1tdXRhYmxlXG4gICAgICB1cGRhdGVTdHlsZTogZmFsc2UsXG4gICAgICBiZWZvcmVHZXQ6IGZ1bmN0aW9uIGJlZm9yZUdldChzZWxmKSB7fSxcbiAgICAgIGJlZm9yZVNldDogZnVuY3Rpb24gYmVmb3JlU2V0KHNlbGYsIG9iaikge30sXG4gICAgICBvblNldDogZnVuY3Rpb24gb25TZXQoc2VsZikge30sXG4gICAgICBjYW5TZXQ6IGZ1bmN0aW9uIGNhblNldChzZWxmKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gICAgcGFyYW1zID0gdXRpbC5leHRlbmQoe30sIGRlZmF1bHRzLCBwYXJhbXMpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGRhdGFJbXBsKG5hbWUsIHZhbHVlKSB7XG4gICAgICB2YXIgcCA9IHBhcmFtcztcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbc2VsZl07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuICAgICAgdmFyIHNpbmdsZSA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGZbMF0gOiBzZWxmO1xuXG4gICAgICAvLyAuZGF0YSgnZm9vJywgLi4uKVxuICAgICAgaWYgKGlzLnN0cmluZyhuYW1lKSkge1xuICAgICAgICAvLyBzZXQgb3IgZ2V0IHByb3BlcnR5XG5cbiAgICAgICAgLy8gLmRhdGEoJ2ZvbycpXG4gICAgICAgIGlmIChwLmFsbG93R2V0dGluZyAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gZ2V0XG5cbiAgICAgICAgICB2YXIgcmV0ID0gdm9pZCAwO1xuICAgICAgICAgIGlmIChzaW5nbGUpIHtcbiAgICAgICAgICAgIHAuYmVmb3JlR2V0KHNpbmdsZSk7XG5cbiAgICAgICAgICAgIHJldCA9IHNpbmdsZS5fcHJpdmF0ZVtwLmZpZWxkXVtuYW1lXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJldDtcblxuICAgICAgICAgIC8vIC5kYXRhKCdmb28nLCAnYmFyJylcbiAgICAgICAgfSBlbHNlIGlmIChwLmFsbG93U2V0dGluZyAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gc2V0XG4gICAgICAgICAgdmFyIHZhbGlkID0gIXAuaW1tdXRhYmxlS2V5c1tuYW1lXTtcbiAgICAgICAgICBpZiAodmFsaWQpIHtcbiAgICAgICAgICAgIHZhciBjaGFuZ2UgPSBfZGVmaW5lUHJvcGVydHkoe30sIG5hbWUsIHZhbHVlKTtcblxuICAgICAgICAgICAgcC5iZWZvcmVTZXQoc2VsZiwgY2hhbmdlKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhbGwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBlbGUgPSBhbGxbaV07XG5cbiAgICAgICAgICAgICAgaWYgKHAuY2FuU2V0KGVsZSkpIHtcbiAgICAgICAgICAgICAgICBlbGUuX3ByaXZhdGVbcC5maWVsZF1bbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB1cGRhdGUgbWFwcGVycyBpZiBhc2tlZFxuICAgICAgICAgICAgaWYgKHAudXBkYXRlU3R5bGUpIHtcbiAgICAgICAgICAgICAgc2VsZi51cGRhdGVTdHlsZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjYWxsIG9uU2V0IGNhbGxiYWNrXG4gICAgICAgICAgICBwLm9uU2V0KHNlbGYpO1xuXG4gICAgICAgICAgICBpZiAocC5zZXR0aW5nVHJpZ2dlcnNFdmVudCkge1xuICAgICAgICAgICAgICBzZWxmW3AudHJpZ2dlckZuTmFtZV0ocC5zZXR0aW5nRXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC5kYXRhKHsgJ2Zvbyc6ICdiYXInIH0pXG4gICAgICB9IGVsc2UgaWYgKHAuYWxsb3dTZXR0aW5nICYmIGlzLnBsYWluT2JqZWN0KG5hbWUpKSB7XG4gICAgICAgIC8vIGV4dGVuZFxuICAgICAgICB2YXIgb2JqID0gbmFtZTtcbiAgICAgICAgdmFyIGsgPSB2b2lkIDAsXG4gICAgICAgICAgICB2ID0gdm9pZCAwO1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG5cbiAgICAgICAgcC5iZWZvcmVTZXQoc2VsZiwgb2JqKTtcblxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwga2V5cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICBrID0ga2V5c1tfaV07XG4gICAgICAgICAgdiA9IG9ialtrXTtcblxuICAgICAgICAgIHZhciBfdmFsaWQgPSAhcC5pbW11dGFibGVLZXlzW2tdO1xuICAgICAgICAgIGlmIChfdmFsaWQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYWxsLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIHZhciBfZWxlID0gYWxsW2pdO1xuXG4gICAgICAgICAgICAgIGlmIChwLmNhblNldChfZWxlKSkge1xuICAgICAgICAgICAgICAgIF9lbGUuX3ByaXZhdGVbcC5maWVsZF1ba10gPSB2O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXBkYXRlIG1hcHBlcnMgaWYgYXNrZWRcbiAgICAgICAgaWYgKHAudXBkYXRlU3R5bGUpIHtcbiAgICAgICAgICBzZWxmLnVwZGF0ZVN0eWxlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjYWxsIG9uU2V0IGNhbGxiYWNrXG4gICAgICAgIHAub25TZXQoc2VsZik7XG5cbiAgICAgICAgaWYgKHAuc2V0dGluZ1RyaWdnZXJzRXZlbnQpIHtcbiAgICAgICAgICBzZWxmW3AudHJpZ2dlckZuTmFtZV0ocC5zZXR0aW5nRXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gLmRhdGEoZnVuY3Rpb24oKXsgLi4uIH0pXG4gICAgICB9IGVsc2UgaWYgKHAuYWxsb3dCaW5kaW5nICYmIGlzLmZuKG5hbWUpKSB7XG4gICAgICAgIC8vIGJpbmQgdG8gZXZlbnRcbiAgICAgICAgdmFyIGZuID0gbmFtZTtcbiAgICAgICAgc2VsZi5vbihwLmJpbmRpbmdFdmVudCwgZm4pO1xuXG4gICAgICAgIC8vIC5kYXRhKClcbiAgICAgIH0gZWxzZSBpZiAocC5hbGxvd0dldHRpbmcgJiYgbmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIGdldCB3aG9sZSBvYmplY3RcbiAgICAgICAgdmFyIF9yZXQgPSB2b2lkIDA7XG4gICAgICAgIGlmIChzaW5nbGUpIHtcbiAgICAgICAgICBwLmJlZm9yZUdldChzaW5nbGUpO1xuXG4gICAgICAgICAgX3JldCA9IHNpbmdsZS5fcHJpdmF0ZVtwLmZpZWxkXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3JldDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7IC8vIG1haW50YWluIGNoYWluYWJpbGl0eVxuICAgIH07IC8vIGZ1bmN0aW9uXG4gIH0sIC8vIGRhdGFcblxuICAvLyByZW1vdmUgZGF0YSBmaWVsZFxuICByZW1vdmVEYXRhOiBmdW5jdGlvbiByZW1vdmVEYXRhKHBhcmFtcykge1xuICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgIGZpZWxkOiAnZGF0YScsXG4gICAgICBldmVudDogJ2RhdGEnLFxuICAgICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgICAgdHJpZ2dlckV2ZW50OiBmYWxzZSxcbiAgICAgIGltbXV0YWJsZUtleXM6IHt9IC8vIGtleSA9PiB0cnVlIGlmIGltbXV0YWJsZVxuICAgIH07XG4gICAgcGFyYW1zID0gdXRpbC5leHRlbmQoe30sIGRlZmF1bHRzLCBwYXJhbXMpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlbW92ZURhdGFJbXBsKG5hbWVzKSB7XG4gICAgICB2YXIgcCA9IHBhcmFtcztcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbc2VsZl07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuXG4gICAgICAvLyAucmVtb3ZlRGF0YSgnZm9vIGJhcicpXG4gICAgICBpZiAoaXMuc3RyaW5nKG5hbWVzKSkge1xuICAgICAgICAvLyB0aGVuIGdldCB0aGUgbGlzdCBvZiBrZXlzLCBhbmQgZGVsZXRlIHRoZW1cbiAgICAgICAgdmFyIGtleXMgPSBuYW1lcy5zcGxpdCgvXFxzKy8pO1xuICAgICAgICB2YXIgbCA9IGtleXMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgLy8gZGVsZXRlIGVhY2ggbm9uLWVtcHR5IGtleVxuICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChpcy5lbXB0eVN0cmluZyhrZXkpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgdmFsaWQgPSAhcC5pbW11dGFibGVLZXlzW2tleV07IC8vIG5vdCB2YWxpZCBpZiBpbW11dGFibGVcbiAgICAgICAgICBpZiAodmFsaWQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGlfYSA9IDAsIGxfYSA9IGFsbC5sZW5ndGg7IGlfYSA8IGxfYTsgaV9hKyspIHtcbiAgICAgICAgICAgICAgYWxsW2lfYV0uX3ByaXZhdGVbcC5maWVsZF1ba2V5XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocC50cmlnZ2VyRXZlbnQpIHtcbiAgICAgICAgICBzZWxmW3AudHJpZ2dlckZuTmFtZV0ocC5ldmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAucmVtb3ZlRGF0YSgpXG4gICAgICB9IGVsc2UgaWYgKG5hbWVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gdGhlbiBkZWxldGUgYWxsIGtleXNcblxuICAgICAgICBmb3IgKHZhciBfaV9hID0gMCwgX2xfYSA9IGFsbC5sZW5ndGg7IF9pX2EgPCBfbF9hOyBfaV9hKyspIHtcbiAgICAgICAgICB2YXIgX3ByaXZhdGVGaWVsZHMgPSBhbGxbX2lfYV0uX3ByaXZhdGVbcC5maWVsZF07XG4gICAgICAgICAgdmFyIF9rZXlzID0gT2JqZWN0LmtleXMoX3ByaXZhdGVGaWVsZHMpO1xuXG4gICAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgX2tleXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAgICAgdmFyIF9rZXkgPSBfa2V5c1tfaTJdO1xuICAgICAgICAgICAgdmFyIHZhbGlkS2V5VG9EZWxldGUgPSAhcC5pbW11dGFibGVLZXlzW19rZXldO1xuXG4gICAgICAgICAgICBpZiAodmFsaWRLZXlUb0RlbGV0ZSkge1xuICAgICAgICAgICAgICBfcHJpdmF0ZUZpZWxkc1tfa2V5XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocC50cmlnZ2VyRXZlbnQpIHtcbiAgICAgICAgICBzZWxmW3AudHJpZ2dlckZuTmFtZV0ocC5ldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7IC8vIG1haW50YWluIGNoYWluaW5nXG4gICAgfTsgLy8gZnVuY3Rpb25cbiAgfSAvLyByZW1vdmVEYXRhXG59OyAvLyBkZWZpbmVcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZpbmU7XG5cbi8qKiovIH0pLFxuLyogNDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIFByb21pc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG52YXIgZGVmaW5lID0ge1xuXG4gIGV2ZW50QWxpYXNlc09uOiBmdW5jdGlvbiBldmVudEFsaWFzZXNPbihwcm90bykge1xuICAgIHZhciBwID0gcHJvdG87XG5cbiAgICBwLmFkZExpc3RlbmVyID0gcC5saXN0ZW4gPSBwLmJpbmQgPSBwLm9uO1xuICAgIHAudW5saXN0ZW4gPSBwLnVuYmluZCA9IHAub2ZmID0gcC5yZW1vdmVMaXN0ZW5lcjtcbiAgICBwLnRyaWdnZXIgPSBwLmVtaXQ7XG5cbiAgICAvLyB0aGlzIGlzIGp1c3QgYSB3cmFwcGVyIGFsaWFzIG9mIC5vbigpXG4gICAgcC5wb24gPSBwLnByb21pc2VPbiA9IGZ1bmN0aW9uIChldmVudHMsIHNlbGVjdG9yKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uIGNhbGxiYWNrKGUpIHtcbiAgICAgICAgICBzZWxmLm9mZi5hcHBseShzZWxmLCBvZmZBcmdzKTtcblxuICAgICAgICAgIHJlc29sdmUoZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIG9uQXJncyA9IGFyZ3MuY29uY2F0KFtjYWxsYmFja10pO1xuICAgICAgICB2YXIgb2ZmQXJncyA9IG9uQXJncy5jb25jYXQoW10pO1xuXG4gICAgICAgIHNlbGYub24uYXBwbHkoc2VsZiwgb25BcmdzKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cblxufTsgLy8gZGVmaW5lXG5cbm1vZHVsZS5leHBvcnRzID0gZGVmaW5lO1xuXG4vKioqLyB9KSxcbi8qIDQ3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBTZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXG52YXIgZWxlc2ZuID0ge1xuICBjbGFzc2VzOiBmdW5jdGlvbiBjbGFzc2VzKF9jbGFzc2VzKSB7XG4gICAgX2NsYXNzZXMgPSAoX2NsYXNzZXMgfHwgJycpLm1hdGNoKC9cXFMrL2cpIHx8IFtdO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY2hhbmdlZCA9IFtdO1xuICAgIHZhciBjbGFzc2VzTWFwID0gbmV3IFNldChfY2xhc3Nlcyk7XG5cbiAgICAvLyBjaGVjayBhbmQgdXBkYXRlIGVhY2ggZWxlXG5cbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChqKSB7XG4gICAgICB2YXIgZWxlID0gc2VsZltqXTtcbiAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICAgIHZhciBlbGVDbGFzc2VzID0gX3AuY2xhc3NlcztcbiAgICAgIHZhciBjaGFuZ2VkRWxlID0gZmFsc2U7XG5cbiAgICAgIC8vIGNoZWNrIGlmIGVsZSBoYXMgYWxsIG9mIHRoZSBwYXNzZWQgY2xhc3Nlc1xuICAgICAgY2xhc3Nlc01hcC5mb3JFYWNoKGZ1bmN0aW9uIChjbHMpIHtcbiAgICAgICAgdmFyIGVsZUhhc0NsYXNzID0gZWxlQ2xhc3Nlcy5oYXMoY2xzKTtcblxuICAgICAgICBpZiAoIWVsZUhhc0NsYXNzKSB7XG4gICAgICAgICAgY2hhbmdlZEVsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBjaGVjayBpZiBlbGUgaGFzIGNsYXNzZXMgb3V0c2lkZSBvZiB0aG9zZSBwYXNzZWRcbiAgICAgIGlmICghY2hhbmdlZEVsZSkge1xuICAgICAgICBlbGVDbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGVsZUNscykge1xuICAgICAgICAgIHZhciBzcGVjZENsYXNzID0gY2xhc3Nlc01hcC5oYXMoZWxlQ2xzKTtcblxuICAgICAgICAgIGlmICghc3BlY2RDbGFzcykge1xuICAgICAgICAgICAgY2hhbmdlZEVsZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoYW5nZWRFbGUpIHtcbiAgICAgICAgX3AuY2xhc3NlcyA9IG5ldyBTZXQoY2xhc3Nlc01hcCk7XG5cbiAgICAgICAgY2hhbmdlZC5wdXNoKGVsZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2VsZi5sZW5ndGg7IGorKykge1xuICAgICAgX2xvb3Aoaik7XG4gICAgfVxuXG4gICAgLy8gdHJpZ2dlciB1cGRhdGUgc3R5bGUgb24gdGhvc2UgZWxlcyB0aGF0IGhhZCBjbGFzcyBjaGFuZ2VzXG4gICAgaWYgKGNoYW5nZWQubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5zcGF3bihjaGFuZ2VkKS51cGRhdGVTdHlsZSgpLmVtaXQoJ2NsYXNzJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGY7XG4gIH0sXG5cbiAgYWRkQ2xhc3M6IGZ1bmN0aW9uIGFkZENsYXNzKGNsYXNzZXMpIHtcbiAgICByZXR1cm4gdGhpcy50b2dnbGVDbGFzcyhjbGFzc2VzLCB0cnVlKTtcbiAgfSxcblxuICBoYXNDbGFzczogZnVuY3Rpb24gaGFzQ2xhc3MoY2xhc3NOYW1lKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgcmV0dXJuIGVsZSAhPSBudWxsICYmIGVsZS5fcHJpdmF0ZS5jbGFzc2VzLmhhcyhjbGFzc05hbWUpO1xuICB9LFxuXG4gIHRvZ2dsZUNsYXNzOiBmdW5jdGlvbiB0b2dnbGVDbGFzcyhjbGFzc2VzU3RyLCB0b2dnbGUpIHtcbiAgICB2YXIgY2xhc3NlcyA9IGNsYXNzZXNTdHIubWF0Y2goL1xcUysvZykgfHwgW107XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjaGFuZ2VkID0gW107IC8vIGVsZXMgd2hvIGhhZCBjbGFzc2VzIGNoYW5nZWRcblxuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IHNlbGYubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgdmFyIF9lbGUgPSBzZWxmW2ldO1xuICAgICAgdmFyIF9jaGFuZ2VkRWxlID0gZmFsc2U7XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2xhc3Nlcy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgY2xzID0gY2xhc3Nlc1tqXTtcbiAgICAgICAgdmFyIF9lbGVDbGFzc2VzID0gX2VsZS5fcHJpdmF0ZS5jbGFzc2VzO1xuICAgICAgICB2YXIgaGFzQ2xhc3MgPSBfZWxlQ2xhc3Nlcy5oYXMoY2xzKTtcbiAgICAgICAgdmFyIHNob3VsZEFkZCA9IHRvZ2dsZSB8fCB0b2dnbGUgPT09IHVuZGVmaW5lZCAmJiAhaGFzQ2xhc3M7XG5cbiAgICAgICAgaWYgKHNob3VsZEFkZCkge1xuICAgICAgICAgIF9lbGVDbGFzc2VzLmFkZChjbHMpO1xuXG4gICAgICAgICAgaWYgKCFoYXNDbGFzcyAmJiAhX2NoYW5nZWRFbGUpIHtcbiAgICAgICAgICAgIGNoYW5nZWQucHVzaChfZWxlKTtcbiAgICAgICAgICAgIF9jaGFuZ2VkRWxlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdGhlbiByZW1vdmVcbiAgICAgICAgICBfZWxlQ2xhc3Nlcy5kZWxldGUoY2xzKTtcblxuICAgICAgICAgIGlmIChoYXNDbGFzcyAmJiAhX2NoYW5nZWRFbGUpIHtcbiAgICAgICAgICAgIGNoYW5nZWQucHVzaChfZWxlKTtcbiAgICAgICAgICAgIF9jaGFuZ2VkRWxlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gZm9yIGogY2xhc3Nlc1xuICAgIH0gLy8gZm9yIGkgZWxlc1xuXG4gICAgLy8gdHJpZ2dlciB1cGRhdGUgc3R5bGUgb24gdGhvc2UgZWxlcyB0aGF0IGhhZCBjbGFzcyBjaGFuZ2VzXG4gICAgaWYgKGNoYW5nZWQubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5zcGF3bihjaGFuZ2VkKS51cGRhdGVTdHlsZSgpLmVtaXQoJ2NsYXNzJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGY7XG4gIH0sXG5cbiAgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGNsYXNzZXMpIHtcbiAgICByZXR1cm4gdGhpcy50b2dnbGVDbGFzcyhjbGFzc2VzLCBmYWxzZSk7XG4gIH0sXG5cbiAgZmxhc2hDbGFzczogZnVuY3Rpb24gZmxhc2hDbGFzcyhjbGFzc2VzLCBkdXJhdGlvbikge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmIChkdXJhdGlvbiA9PSBudWxsKSB7XG4gICAgICBkdXJhdGlvbiA9IDI1MDtcbiAgICB9IGVsc2UgaWYgKGR1cmF0aW9uID09PSAwKSB7XG4gICAgICByZXR1cm4gc2VsZjsgLy8gbm90aGluZyB0byBkbyByZWFsbHlcbiAgICB9XG5cbiAgICBzZWxmLmFkZENsYXNzKGNsYXNzZXMpO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5yZW1vdmVDbGFzcyhjbGFzc2VzKTtcbiAgICB9LCBkdXJhdGlvbik7XG5cbiAgICByZXR1cm4gc2VsZjtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbGVzZm47XG5cbi8qKiovIH0pLFxuLyogNDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBTZWxlY3RvciA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cbnZhciBlbGVzZm4gPSB7XG4gIGFsbEFyZTogZnVuY3Rpb24gYWxsQXJlKHNlbGVjdG9yKSB7XG4gICAgdmFyIHNlbE9iaiA9IG5ldyBTZWxlY3RvcihzZWxlY3Rvcik7XG5cbiAgICByZXR1cm4gdGhpcy5ldmVyeShmdW5jdGlvbiAoZWxlKSB7XG4gICAgICByZXR1cm4gc2VsT2JqLm1hdGNoZXMoZWxlKTtcbiAgICB9KTtcbiAgfSxcblxuICBpczogZnVuY3Rpb24gaXMoc2VsZWN0b3IpIHtcbiAgICB2YXIgc2VsT2JqID0gbmV3IFNlbGVjdG9yKHNlbGVjdG9yKTtcblxuICAgIHJldHVybiB0aGlzLnNvbWUoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgcmV0dXJuIHNlbE9iai5tYXRjaGVzKGVsZSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgc29tZTogZnVuY3Rpb24gc29tZShmbiwgdGhpc0FyZykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHJldCA9ICF0aGlzQXJnID8gZm4odGhpc1tpXSwgaSwgdGhpcykgOiBmbi5hcHBseSh0aGlzQXJnLCBbdGhpc1tpXSwgaSwgdGhpc10pO1xuXG4gICAgICBpZiAocmV0KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICBldmVyeTogZnVuY3Rpb24gZXZlcnkoZm4sIHRoaXNBcmcpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciByZXQgPSAhdGhpc0FyZyA/IGZuKHRoaXNbaV0sIGksIHRoaXMpIDogZm4uYXBwbHkodGhpc0FyZywgW3RoaXNbaV0sIGksIHRoaXNdKTtcblxuICAgICAgaWYgKCFyZXQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIHNhbWU6IGZ1bmN0aW9uIHNhbWUoY29sbGVjdGlvbikge1xuICAgIGNvbGxlY3Rpb24gPSB0aGlzLmN5KCkuY29sbGVjdGlvbihjb2xsZWN0aW9uKTtcblxuICAgIC8vIGNoZWFwIGV4dHJhIGNoZWNrXG4gICAgaWYgKHRoaXMubGVuZ3RoICE9PSBjb2xsZWN0aW9uLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmV2ZXJ5KGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uLmhhc0VsZW1lbnRXaXRoSWQoZWxlLmlkKCkpO1xuICAgIH0pO1xuICB9LFxuXG4gIGFueVNhbWU6IGZ1bmN0aW9uIGFueVNhbWUoY29sbGVjdGlvbikge1xuICAgIGNvbGxlY3Rpb24gPSB0aGlzLmN5KCkuY29sbGVjdGlvbihjb2xsZWN0aW9uKTtcblxuICAgIHJldHVybiB0aGlzLnNvbWUoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uaGFzRWxlbWVudFdpdGhJZChlbGUuaWQoKSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgYWxsQXJlTmVpZ2hib3JzOiBmdW5jdGlvbiBhbGxBcmVOZWlnaGJvcnMoY29sbGVjdGlvbikge1xuICAgIGNvbGxlY3Rpb24gPSB0aGlzLmN5KCkuY29sbGVjdGlvbihjb2xsZWN0aW9uKTtcblxuICAgIHZhciBuaG9vZCA9IHRoaXMubmVpZ2hib3Job29kKCk7XG5cbiAgICByZXR1cm4gY29sbGVjdGlvbi5ldmVyeShmdW5jdGlvbiAoZWxlKSB7XG4gICAgICByZXR1cm4gbmhvb2QuaGFzRWxlbWVudFdpdGhJZChlbGUuaWQoKSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgY29udGFpbnM6IGZ1bmN0aW9uIGNvbnRhaW5zKGNvbGxlY3Rpb24pIHtcbiAgICBjb2xsZWN0aW9uID0gdGhpcy5jeSgpLmNvbGxlY3Rpb24oY29sbGVjdGlvbik7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICByZXR1cm4gY29sbGVjdGlvbi5ldmVyeShmdW5jdGlvbiAoZWxlKSB7XG4gICAgICByZXR1cm4gc2VsZi5oYXNFbGVtZW50V2l0aElkKGVsZS5pZCgpKTtcbiAgICB9KTtcbiAgfVxufTtcblxuZWxlc2ZuLmFsbEFyZU5laWdoYm91cnMgPSBlbGVzZm4uYWxsQXJlTmVpZ2hib3JzO1xuZWxlc2ZuLmhhcyA9IGVsZXNmbi5jb250YWlucztcblxubW9kdWxlLmV4cG9ydHMgPSBlbGVzZm47XG5cbi8qKiovIH0pLFxuLyogNDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xudmFyIGV4cHJzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MCk7XG52YXIgbmV3UXVlcnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcblxuLy8gb2YgYWxsIHRoZSBleHByZXNzaW9ucywgZmluZCB0aGUgZmlyc3QgbWF0Y2ggaW4gdGhlIHJlbWFpbmluZyB0ZXh0XG52YXIgY29uc3VtZUV4cHIgPSBmdW5jdGlvbiBjb25zdW1lRXhwcihyZW1haW5pbmcpIHtcbiAgdmFyIGV4cHIgPSB2b2lkIDA7XG4gIHZhciBtYXRjaCA9IHZvaWQgMDtcbiAgdmFyIG5hbWUgPSB2b2lkIDA7XG5cbiAgZm9yICh2YXIgaiA9IDA7IGogPCBleHBycy5sZW5ndGg7IGorKykge1xuICAgIHZhciBlID0gZXhwcnNbal07XG4gICAgdmFyIG4gPSBlLm5hbWU7XG5cbiAgICB2YXIgbSA9IHJlbWFpbmluZy5tYXRjaChlLnJlZ2V4T2JqKTtcblxuICAgIGlmIChtICE9IG51bGwpIHtcbiAgICAgIG1hdGNoID0gbTtcbiAgICAgIGV4cHIgPSBlO1xuICAgICAgbmFtZSA9IG47XG5cbiAgICAgIHZhciBjb25zdW1lZCA9IG1bMF07XG4gICAgICByZW1haW5pbmcgPSByZW1haW5pbmcuc3Vic3RyaW5nKGNvbnN1bWVkLmxlbmd0aCk7XG5cbiAgICAgIGJyZWFrOyAvLyB3ZSd2ZSBjb25zdW1lZCBvbmUgZXhwciwgc28gd2UgY2FuIHJldHVybiBub3dcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGV4cHI6IGV4cHIsXG4gICAgbWF0Y2g6IG1hdGNoLFxuICAgIG5hbWU6IG5hbWUsXG4gICAgcmVtYWluaW5nOiByZW1haW5pbmdcbiAgfTtcbn07XG5cbi8vIGNvbnN1bWUgYWxsIGxlYWRpbmcgd2hpdGVzcGFjZVxudmFyIGNvbnN1bWVXaGl0ZXNwYWNlID0gZnVuY3Rpb24gY29uc3VtZVdoaXRlc3BhY2UocmVtYWluaW5nKSB7XG4gIHZhciBtYXRjaCA9IHJlbWFpbmluZy5tYXRjaCgvXlxccysvKTtcblxuICBpZiAobWF0Y2gpIHtcbiAgICB2YXIgY29uc3VtZWQgPSBtYXRjaFswXTtcbiAgICByZW1haW5pbmcgPSByZW1haW5pbmcuc3Vic3RyaW5nKGNvbnN1bWVkLmxlbmd0aCk7XG4gIH1cblxuICByZXR1cm4gcmVtYWluaW5nO1xufTtcblxudmFyIHBhcnNlID0gZnVuY3Rpb24gcGFyc2Uoc2VsZWN0b3IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHZhciByZW1haW5pbmcgPSBzZWxmLl9wcml2YXRlLnNlbGVjdG9yVGV4dCA9IHNlbGVjdG9yO1xuXG4gIHZhciBjdXJyZW50UXVlcnkgPSBzZWxmWzBdID0gbmV3UXVlcnkoKTtcbiAgc2VsZi5sZW5ndGggPSAxO1xuXG4gIHJlbWFpbmluZyA9IGNvbnN1bWVXaGl0ZXNwYWNlKHJlbWFpbmluZyk7IC8vIGdldCByaWQgb2YgbGVhZGluZyB3aGl0ZXNwYWNlXG5cbiAgZm9yICg7Oykge1xuICAgIHZhciBjaGVjayA9IGNvbnN1bWVFeHByKHJlbWFpbmluZyk7XG5cbiAgICBpZiAoY2hlY2suZXhwciA9PSBudWxsKSB7XG4gICAgICB1dGlsLmVycm9yKCdUaGUgc2VsZWN0b3IgYCcgKyBzZWxlY3RvciArICdgaXMgaW52YWxpZCcpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IGNoZWNrLm1hdGNoLnNsaWNlKDEpO1xuXG4gICAgICAvLyBsZXQgdGhlIHRva2VuIHBvcHVsYXRlIHRoZSBzZWxlY3RvciBvYmplY3QgaW4gY3VycmVudFF1ZXJ5XG4gICAgICB2YXIgcmV0ID0gY2hlY2suZXhwci5wb3B1bGF0ZShzZWxmLCBjdXJyZW50UXVlcnksIGFyZ3MpO1xuXG4gICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIGV4aXQgaWYgcG9wdWxhdGlvbiBmYWlsZWRcbiAgICAgIH0gZWxzZSBpZiAocmV0ICE9IG51bGwpIHtcbiAgICAgICAgY3VycmVudFF1ZXJ5ID0gcmV0OyAvLyBjaGFuZ2UgdGhlIGN1cnJlbnQgcXVlcnkgdG8gYmUgZmlsbGVkIGlmIHRoZSBleHByIHNwZWNpZmllc1xuICAgICAgfVxuICAgIH1cblxuICAgIHJlbWFpbmluZyA9IGNoZWNrLnJlbWFpbmluZztcblxuICAgIC8vIHdlJ3JlIGRvbmUgd2hlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBwYXJzZVxuICAgIGlmIChyZW1haW5pbmcubWF0Y2goL15cXHMqJC8pKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvLyBhZGp1c3QgcmVmZXJlbmNlcyBmb3Igc3ViamVjdFxuICBmb3IgKHZhciBqID0gMDsgaiA8IHNlbGYubGVuZ3RoOyBqKyspIHtcbiAgICB2YXIgcXVlcnkgPSBzZWxmW2pdO1xuXG4gICAgaWYgKHF1ZXJ5LnN1YmplY3QgIT0gbnVsbCkge1xuICAgICAgLy8gZ28gdXAgdGhlIHRyZWUgdW50aWwgd2UgcmVhY2ggdGhlIHN1YmplY3RcbiAgICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKHF1ZXJ5LnN1YmplY3QgPT09IHF1ZXJ5KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gLy8gZG9uZSBpZiBzdWJqZWN0IGlzIHNlbGZcblxuICAgICAgICBpZiAocXVlcnkucGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAvLyBzd2FwIHBhcmVudC9jaGlsZCByZWZlcmVuY2VcbiAgICAgICAgICB2YXIgcGFyZW50ID0gcXVlcnkucGFyZW50O1xuICAgICAgICAgIHZhciBjaGlsZCA9IHF1ZXJ5O1xuXG4gICAgICAgICAgY2hpbGQucGFyZW50ID0gbnVsbDtcbiAgICAgICAgICBwYXJlbnQuY2hpbGQgPSBjaGlsZDtcblxuICAgICAgICAgIHF1ZXJ5ID0gcGFyZW50OyAvLyBnbyB1cCB0aGUgdHJlZVxuICAgICAgICB9IGVsc2UgaWYgKHF1ZXJ5LmFuY2VzdG9yICE9IG51bGwpIHtcbiAgICAgICAgICAvLyBzd2FwIGFuY2VzdG9yL2Rlc2NlbmRhbnRcbiAgICAgICAgICB2YXIgYW5jZXN0b3IgPSBxdWVyeS5hbmNlc3RvcjtcbiAgICAgICAgICB2YXIgZGVzY2VuZGFudCA9IHF1ZXJ5O1xuXG4gICAgICAgICAgZGVzY2VuZGFudC5hbmNlc3RvciA9IG51bGw7XG4gICAgICAgICAgYW5jZXN0b3IuZGVzY2VuZGFudCA9IGRlc2NlbmRhbnQ7XG5cbiAgICAgICAgICBxdWVyeSA9IGFuY2VzdG9yOyAvLyBnbyB1cCB0aGUgdHJlZVxuICAgICAgICB9IGVsc2UgaWYgKHF1ZXJ5LnNvdXJjZSB8fCBxdWVyeS50YXJnZXQgfHwgcXVlcnkuY29ubmVjdGVkTm9kZXMpIHtcbiAgICAgICAgICB1dGlsLmVycm9yKCdUaGUgc2VsZWN0b3IgYCcgKyBzZWxmLnRleHQoKSArICdgIGNhbiBub3QgY29udGFpbiBhIHN1YmplY3Qgc2VsZWN0b3IgdGhhdCBhcHBsaWVzIHRvIHRoZSBzb3VyY2Ugb3IgdGFyZ2V0IG9mIGFuIGVkZ2Ugc2VsZWN0b3InKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXRpbC5lcnJvcignV2hlbiBhZGp1c3RpbmcgcmVmZXJlbmNlcyBmb3IgdGhlIHNlbGVjdG9yIGAnICsgc2VsZi50ZXh0KCkgKyAnYCwgbmVpdGhlciBwYXJlbnQgbm9yIGFuY2VzdG9yIHdhcyBmb3VuZCcpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBmb3JcblxuICAgICAgc2VsZltqXSA9IHF1ZXJ5LnN1YmplY3Q7IC8vIHN1YmplY3Qgc2hvdWxkIGJlIHRoZSByb290IHF1ZXJ5XG4gICAgfSAvLyBpZlxuICB9IC8vIGZvclxuXG4gIHJldHVybiB0cnVlOyAvLyBzdWNjZXNzXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHsgcGFyc2U6IHBhcnNlIH07XG5cbi8qKiovIH0pLFxuLyogNTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF9zbGljZWRUb0FycmF5ID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9IHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgcmV0dXJuIGFycjsgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHsgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTsgfSBlbHNlIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH0gfTsgfSgpO1xuXG52YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KSxcbiAgICBzdGF0ZVNlbGVjdG9yUmVnZXggPSBfcmVxdWlyZS5zdGF0ZVNlbGVjdG9yUmVnZXg7XG5cbnZhciB0b2tlbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUxKTtcbnZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbnZhciBuZXdRdWVyeSA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuXG4vLyB3aGVuIGEgdG9rZW4gbGlrZSBhIHZhcmlhYmxlIGhhcyBlc2NhcGVkIG1ldGEgY2hhcmFjdGVycywgd2UgbmVlZCB0byBjbGVhbiB0aGUgYmFja3NsYXNoZXMgb3V0XG4vLyBzbyB0aGF0IHZhbHVlcyBnZXQgY29tcGFyZWQgcHJvcGVybHkgaW4gU2VsZWN0b3IuZmlsdGVyKClcbnZhciBjbGVhbk1ldGFDaGFycyA9IGZ1bmN0aW9uIGNsZWFuTWV0YUNoYXJzKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UobmV3IFJlZ0V4cCgnXFxcXFxcXFwoJyArIHRva2Vucy5tZXRhQ2hhciArICcpJywgJ2cnKSwgZnVuY3Rpb24gKG1hdGNoLCAkMSkge1xuICAgIHJldHVybiAkMTtcbiAgfSk7XG59O1xuXG52YXIgcmVwbGFjZUxhc3RRdWVyeSA9IGZ1bmN0aW9uIHJlcGxhY2VMYXN0UXVlcnkoc2VsZWN0b3IsIGV4YW1pbmluZ1F1ZXJ5LCByZXBsYWNlbWVudFF1ZXJ5KSB7XG4gIGlmIChleGFtaW5pbmdRdWVyeSA9PT0gc2VsZWN0b3Jbc2VsZWN0b3IubGVuZ3RoIC0gMV0pIHtcbiAgICBzZWxlY3RvcltzZWxlY3Rvci5sZW5ndGggLSAxXSA9IHJlcGxhY2VtZW50UXVlcnk7XG4gIH1cbn07XG5cbi8vIE5PVEU6IGFkZCBuZXcgZXhwcmVzc2lvbiBzeW50YXggaGVyZSB0byBoYXZlIGl0IHJlY29nbmlzZWQgYnkgdGhlIHBhcnNlcjtcbi8vIC0gYSBxdWVyeSBjb250YWlucyBhbGwgYWRqYWNlbnQgKGkuZS4gbm8gc2VwYXJhdG9yIGluIGJldHdlZW4pIGV4cHJlc3Npb25zO1xuLy8gLSB0aGUgY3VycmVudCBxdWVyeSBpcyBzdG9yZWQgaW4gc2VsZWN0b3JbaV0gLS0tIHlvdSBjYW4gdXNlIHRoZSByZWZlcmVuY2UgdG8gYHRoaXNgIGluIHRoZSBwb3B1bGF0ZSBmdW5jdGlvbjtcbi8vIC0geW91IG5lZWQgdG8gY2hlY2sgdGhlIHF1ZXJ5IG9iamVjdHMgaW4gU2VsZWN0b3IuZmlsdGVyKCkgZm9yIGl0IGFjdHVhbGx5IGZpbHRlciBwcm9wZXJseSwgYnV0IHRoYXQncyBwcmV0dHkgc3RyYWlnaHQgZm9yd2FyZFxuLy8gLSB3aGVuIHlvdSBhZGQgc29tZXRoaW5nIGhlcmUsIGFsc28gYWRkIHRvIFNlbGVjdG9yLnRvU3RyaW5nKClcbnZhciBleHBycyA9IFt7XG4gIG5hbWU6ICdncm91cCcsXG4gIHF1ZXJ5OiB0cnVlLFxuICByZWdleDogJygnICsgdG9rZW5zLmdyb3VwICsgJyknLFxuICBwb3B1bGF0ZTogZnVuY3Rpb24gcG9wdWxhdGUoc2VsZWN0b3IsIHF1ZXJ5LCBfcmVmKSB7XG4gICAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMSksXG4gICAgICAgIGdyb3VwID0gX3JlZjJbMF07XG5cbiAgICBxdWVyeS5ncm91cCA9IGdyb3VwID09PSAnKicgPyBncm91cCA6IGdyb3VwICsgJ3MnO1xuICB9XG59LCB7XG4gIG5hbWU6ICdzdGF0ZScsXG4gIHF1ZXJ5OiB0cnVlLFxuICByZWdleDogc3RhdGVTZWxlY3RvclJlZ2V4LFxuICBwb3B1bGF0ZTogZnVuY3Rpb24gcG9wdWxhdGUoc2VsZWN0b3IsIHF1ZXJ5LCBfcmVmMykge1xuICAgIHZhciBfcmVmNCA9IF9zbGljZWRUb0FycmF5KF9yZWYzLCAxKSxcbiAgICAgICAgc3RhdGUgPSBfcmVmNFswXTtcblxuICAgIHF1ZXJ5LmNvbG9uU2VsZWN0b3JzLnB1c2goc3RhdGUpO1xuICB9XG59LCB7XG4gIG5hbWU6ICdpZCcsXG4gIHF1ZXJ5OiB0cnVlLFxuICByZWdleDogJ1xcXFwjKCcgKyB0b2tlbnMuaWQgKyAnKScsXG4gIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnksIF9yZWY1KSB7XG4gICAgdmFyIF9yZWY2ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjUsIDEpLFxuICAgICAgICBpZCA9IF9yZWY2WzBdO1xuXG4gICAgcXVlcnkuaWRzLnB1c2goY2xlYW5NZXRhQ2hhcnMoaWQpKTtcbiAgfVxufSwge1xuICBuYW1lOiAnY2xhc3NOYW1lJyxcbiAgcXVlcnk6IHRydWUsXG4gIHJlZ2V4OiAnXFxcXC4oJyArIHRva2Vucy5jbGFzc05hbWUgKyAnKScsXG4gIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnksIF9yZWY3KSB7XG4gICAgdmFyIF9yZWY4ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjcsIDEpLFxuICAgICAgICBjbGFzc05hbWUgPSBfcmVmOFswXTtcblxuICAgIHF1ZXJ5LmNsYXNzZXMucHVzaChjbGVhbk1ldGFDaGFycyhjbGFzc05hbWUpKTtcbiAgfVxufSwge1xuICBuYW1lOiAnZGF0YUV4aXN0cycsXG4gIHF1ZXJ5OiB0cnVlLFxuICByZWdleDogJ1xcXFxbXFxcXHMqKCcgKyB0b2tlbnMudmFyaWFibGUgKyAnKVxcXFxzKlxcXFxdJyxcbiAgcG9wdWxhdGU6IGZ1bmN0aW9uIHBvcHVsYXRlKHNlbGVjdG9yLCBxdWVyeSwgX3JlZjkpIHtcbiAgICB2YXIgX3JlZjEwID0gX3NsaWNlZFRvQXJyYXkoX3JlZjksIDEpLFxuICAgICAgICB2YXJpYWJsZSA9IF9yZWYxMFswXTtcblxuICAgIHF1ZXJ5LmRhdGEucHVzaCh7XG4gICAgICBmaWVsZDogY2xlYW5NZXRhQ2hhcnModmFyaWFibGUpXG4gICAgfSk7XG4gIH1cbn0sIHtcbiAgbmFtZTogJ2RhdGFDb21wYXJlJyxcbiAgcXVlcnk6IHRydWUsXG4gIHJlZ2V4OiAnXFxcXFtcXFxccyooJyArIHRva2Vucy52YXJpYWJsZSArICcpXFxcXHMqKCcgKyB0b2tlbnMuY29tcGFyYXRvck9wICsgJylcXFxccyooJyArIHRva2Vucy52YWx1ZSArICcpXFxcXHMqXFxcXF0nLFxuICBwb3B1bGF0ZTogZnVuY3Rpb24gcG9wdWxhdGUoc2VsZWN0b3IsIHF1ZXJ5LCBfcmVmMTEpIHtcbiAgICB2YXIgX3JlZjEyID0gX3NsaWNlZFRvQXJyYXkoX3JlZjExLCAzKSxcbiAgICAgICAgdmFyaWFibGUgPSBfcmVmMTJbMF0sXG4gICAgICAgIGNvbXBhcmF0b3JPcCA9IF9yZWYxMlsxXSxcbiAgICAgICAgdmFsdWUgPSBfcmVmMTJbMl07XG5cbiAgICB2YXIgdmFsdWVJc1N0cmluZyA9IG5ldyBSZWdFeHAoJ14nICsgdG9rZW5zLnN0cmluZyArICckJykuZXhlYyh2YWx1ZSkgIT0gbnVsbDtcblxuICAgIGlmICh2YWx1ZUlzU3RyaW5nKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZygxLCB2YWx1ZS5sZW5ndGggLSAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICB9XG5cbiAgICBxdWVyeS5kYXRhLnB1c2goe1xuICAgICAgZmllbGQ6IGNsZWFuTWV0YUNoYXJzKHZhcmlhYmxlKSxcbiAgICAgIG9wZXJhdG9yOiBjb21wYXJhdG9yT3AsXG4gICAgICB2YWx1ZTogdmFsdWVcbiAgICB9KTtcbiAgfVxufSwge1xuICBuYW1lOiAnZGF0YUJvb2wnLFxuICBxdWVyeTogdHJ1ZSxcbiAgcmVnZXg6ICdcXFxcW1xcXFxzKignICsgdG9rZW5zLmJvb2xPcCArICcpXFxcXHMqKCcgKyB0b2tlbnMudmFyaWFibGUgKyAnKVxcXFxzKlxcXFxdJyxcbiAgcG9wdWxhdGU6IGZ1bmN0aW9uIHBvcHVsYXRlKHNlbGVjdG9yLCBxdWVyeSwgX3JlZjEzKSB7XG4gICAgdmFyIF9yZWYxNCA9IF9zbGljZWRUb0FycmF5KF9yZWYxMywgMiksXG4gICAgICAgIGJvb2xPcCA9IF9yZWYxNFswXSxcbiAgICAgICAgdmFyaWFibGUgPSBfcmVmMTRbMV07XG5cbiAgICBxdWVyeS5kYXRhLnB1c2goe1xuICAgICAgZmllbGQ6IGNsZWFuTWV0YUNoYXJzKHZhcmlhYmxlKSxcbiAgICAgIG9wZXJhdG9yOiBib29sT3BcbiAgICB9KTtcbiAgfVxufSwge1xuICBuYW1lOiAnbWV0YUNvbXBhcmUnLFxuICBxdWVyeTogdHJ1ZSxcbiAgcmVnZXg6ICdcXFxcW1xcXFxbXFxcXHMqKCcgKyB0b2tlbnMubWV0YSArICcpXFxcXHMqKCcgKyB0b2tlbnMuY29tcGFyYXRvck9wICsgJylcXFxccyooJyArIHRva2Vucy5udW1iZXIgKyAnKVxcXFxzKlxcXFxdXFxcXF0nLFxuICBwb3B1bGF0ZTogZnVuY3Rpb24gcG9wdWxhdGUoc2VsZWN0b3IsIHF1ZXJ5LCBfcmVmMTUpIHtcbiAgICB2YXIgX3JlZjE2ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjE1LCAzKSxcbiAgICAgICAgbWV0YSA9IF9yZWYxNlswXSxcbiAgICAgICAgY29tcGFyYXRvck9wID0gX3JlZjE2WzFdLFxuICAgICAgICBudW1iZXIgPSBfcmVmMTZbMl07XG5cbiAgICBxdWVyeS5tZXRhLnB1c2goe1xuICAgICAgZmllbGQ6IGNsZWFuTWV0YUNoYXJzKG1ldGEpLFxuICAgICAgb3BlcmF0b3I6IGNvbXBhcmF0b3JPcCxcbiAgICAgIHZhbHVlOiBwYXJzZUZsb2F0KG51bWJlcilcbiAgICB9KTtcbiAgfVxufSwge1xuICBuYW1lOiAnbmV4dFF1ZXJ5JyxcbiAgc2VwYXJhdG9yOiB0cnVlLFxuICByZWdleDogdG9rZW5zLnNlcGFyYXRvcixcbiAgcG9wdWxhdGU6IGZ1bmN0aW9uIHBvcHVsYXRlKHNlbGVjdG9yKSB7XG4gICAgLy8gZ28gb24gdG8gbmV4dCBxdWVyeVxuICAgIHZhciBuZXh0UXVlcnkgPSBzZWxlY3RvcltzZWxlY3Rvci5sZW5ndGgrK10gPSBuZXdRdWVyeSgpO1xuICAgIHNlbGVjdG9yLmN1cnJlbnRTdWJqZWN0ID0gbnVsbDtcblxuICAgIHJldHVybiBuZXh0UXVlcnk7XG4gIH1cbn0sIHtcbiAgbmFtZTogJ2RpcmVjdGVkRWRnZScsXG4gIHNlcGFyYXRvcjogdHJ1ZSxcbiAgcmVnZXg6IHRva2Vucy5kaXJlY3RlZEVkZ2UsXG4gIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnkpIHtcbiAgICB2YXIgZWRnZVF1ZXJ5ID0gbmV3UXVlcnkoKTtcbiAgICB2YXIgc291cmNlID0gcXVlcnk7XG4gICAgdmFyIHRhcmdldCA9IG5ld1F1ZXJ5KCk7XG5cbiAgICBlZGdlUXVlcnkuZ3JvdXAgPSAnZWRnZXMnO1xuICAgIGVkZ2VRdWVyeS50YXJnZXQgPSB0YXJnZXQ7XG4gICAgZWRnZVF1ZXJ5LnNvdXJjZSA9IHNvdXJjZTtcbiAgICBlZGdlUXVlcnkuc3ViamVjdCA9IHNlbGVjdG9yLmN1cnJlbnRTdWJqZWN0O1xuXG4gICAgLy8gdGhlIHF1ZXJ5IGluIHRoZSBzZWxlY3RvciBzaG91bGQgYmUgdGhlIGVkZ2UgcmF0aGVyIHRoYW4gdGhlIHNvdXJjZVxuICAgIHJlcGxhY2VMYXN0UXVlcnkoc2VsZWN0b3IsIHF1ZXJ5LCBlZGdlUXVlcnkpO1xuXG4gICAgLy8gd2UncmUgbm93IHBvcHVsYXRpbmcgdGhlIHRhcmdldCBxdWVyeSB3aXRoIGV4cHJlc3Npb25zIHRoYXQgZm9sbG93XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxufSwge1xuICBuYW1lOiAndW5kaXJlY3RlZEVkZ2UnLFxuICBzZXBhcmF0b3I6IHRydWUsXG4gIHJlZ2V4OiB0b2tlbnMudW5kaXJlY3RlZEVkZ2UsXG4gIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnkpIHtcbiAgICB2YXIgZWRnZVF1ZXJ5ID0gbmV3UXVlcnkoKTtcbiAgICB2YXIgc291cmNlID0gcXVlcnk7XG4gICAgdmFyIHRhcmdldCA9IG5ld1F1ZXJ5KCk7XG5cbiAgICBlZGdlUXVlcnkuZ3JvdXAgPSAnZWRnZXMnO1xuICAgIGVkZ2VRdWVyeS5jb25uZWN0ZWROb2RlcyA9IFtzb3VyY2UsIHRhcmdldF07XG4gICAgZWRnZVF1ZXJ5LnN1YmplY3QgPSBzZWxlY3Rvci5jdXJyZW50U3ViamVjdDtcblxuICAgIC8vIHRoZSBxdWVyeSBpbiB0aGUgc2VsZWN0b3Igc2hvdWxkIGJlIHRoZSBlZGdlIHJhdGhlciB0aGFuIHRoZSBzb3VyY2VcbiAgICByZXBsYWNlTGFzdFF1ZXJ5KHNlbGVjdG9yLCBxdWVyeSwgZWRnZVF1ZXJ5KTtcblxuICAgIC8vIHdlJ3JlIG5vdyBwb3B1bGF0aW5nIHRoZSB0YXJnZXQgcXVlcnkgd2l0aCBleHByZXNzaW9ucyB0aGF0IGZvbGxvd1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbn0sIHtcbiAgbmFtZTogJ2NoaWxkJyxcbiAgc2VwYXJhdG9yOiB0cnVlLFxuICByZWdleDogdG9rZW5zLmNoaWxkLFxuICBwb3B1bGF0ZTogZnVuY3Rpb24gcG9wdWxhdGUoc2VsZWN0b3IsIHF1ZXJ5KSB7XG4gICAgLy8gdGhpcyBxdWVyeSBpcyB0aGUgcGFyZW50IG9mIHRoZSBmb2xsb3dpbmcgcXVlcnlcbiAgICB2YXIgY2hpbGRRdWVyeSA9IG5ld1F1ZXJ5KCk7XG4gICAgY2hpbGRRdWVyeS5wYXJlbnQgPSBxdWVyeTtcbiAgICBjaGlsZFF1ZXJ5LnN1YmplY3QgPSBzZWxlY3Rvci5jdXJyZW50U3ViamVjdDtcblxuICAgIC8vIGl0J3MgY2hlYXBlciB0byBjb21wYXJlIGNoaWxkcmVuIGZpcnN0IGFuZCBnbyB1cCBzbyByZXBsYWNlIHRoZSBwYXJlbnRcbiAgICByZXBsYWNlTGFzdFF1ZXJ5KHNlbGVjdG9yLCBxdWVyeSwgY2hpbGRRdWVyeSk7XG5cbiAgICAvLyB3ZSdyZSBub3cgcG9wdWxhdGluZyB0aGUgY2hpbGQgcXVlcnkgd2l0aCBleHByZXNzaW9ucyB0aGF0IGZvbGxvd1xuICAgIHJldHVybiBjaGlsZFF1ZXJ5O1xuICB9XG59LCB7XG4gIG5hbWU6ICdkZXNjZW5kYW50JyxcbiAgc2VwYXJhdG9yOiB0cnVlLFxuICByZWdleDogdG9rZW5zLmRlc2NlbmRhbnQsXG4gIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnkpIHtcbiAgICAvLyB0aGlzIHF1ZXJ5IGlzIHRoZSBhbmNlc3RvciBvZiB0aGUgZm9sbG93aW5nIHF1ZXJ5XG4gICAgdmFyIGRlc2NlbmRhbnRRdWVyeSA9IG5ld1F1ZXJ5KCk7XG4gICAgZGVzY2VuZGFudFF1ZXJ5LmFuY2VzdG9yID0gcXVlcnk7XG4gICAgZGVzY2VuZGFudFF1ZXJ5LnN1YmplY3QgPSBzZWxlY3Rvci5jdXJyZW50U3ViamVjdDtcblxuICAgIC8vIGl0J3MgY2hlYXBlciB0byBjb21wYXJlIGRlc2NlbmRhbnRzIGZpcnN0IGFuZCBnbyB1cCBzbyByZXBsYWNlIHRoZSBhbmNlc3RvclxuICAgIHJlcGxhY2VMYXN0UXVlcnkoc2VsZWN0b3IsIHF1ZXJ5LCBkZXNjZW5kYW50UXVlcnkpO1xuXG4gICAgLy8gd2UncmUgbm93IHBvcHVsYXRpbmcgdGhlIGRlc2NlbmRhbnQgcXVlcnkgd2l0aCBleHByZXNzaW9ucyB0aGF0IGZvbGxvd1xuICAgIHJldHVybiBkZXNjZW5kYW50UXVlcnk7XG4gIH1cbn0sIHtcbiAgbmFtZTogJ3N1YmplY3QnLFxuICBtb2RpZmllcjogdHJ1ZSxcbiAgcmVnZXg6IHRva2Vucy5zdWJqZWN0LFxuICBwb3B1bGF0ZTogZnVuY3Rpb24gcG9wdWxhdGUoc2VsZWN0b3IsIHF1ZXJ5KSB7XG4gICAgaWYgKHNlbGVjdG9yLmN1cnJlbnRTdWJqZWN0ICE9IG51bGwgJiYgcXVlcnkuc3ViamVjdCAhPSBxdWVyeSkge1xuICAgICAgdXRpbC5lcnJvcignUmVkZWZpbml0aW9uIG9mIHN1YmplY3QgaW4gc2VsZWN0b3IgYCcgKyBzZWxlY3Rvci50b1N0cmluZygpICsgJ2AnKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzZWxlY3Rvci5jdXJyZW50U3ViamVjdCA9IHF1ZXJ5O1xuICAgIHF1ZXJ5LnN1YmplY3QgPSBxdWVyeTtcbiAgICBzZWxlY3RvcltzZWxlY3Rvci5sZW5ndGggLSAxXS5zdWJqZWN0ID0gcXVlcnk7XG4gIH1cbn1dO1xuXG5leHBycy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gIHJldHVybiBlLnJlZ2V4T2JqID0gbmV3IFJlZ0V4cCgnXicgKyBlLnJlZ2V4KTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cHJzO1xuXG4vKioqLyB9KSxcbi8qIDUxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuLy8gdG9rZW5zIGluIHRoZSBxdWVyeSBsYW5ndWFnZVxudmFyIHRva2VucyA9IHtcbiAgbWV0YUNoYXI6ICdbXFxcXCFcXFxcXCJcXFxcI1xcXFwkXFxcXCVcXFxcJlxcXFxcXCdcXFxcKFxcXFwpXFxcXCpcXFxcK1xcXFwsXFxcXC5cXFxcL1xcXFw6XFxcXDtcXFxcPFxcXFw9XFxcXD5cXFxcP1xcXFxAXFxcXFtcXFxcXVxcXFxeXFxcXGBcXFxce1xcXFx8XFxcXH1cXFxcfl0nLCAvLyBjaGFycyB3ZSBuZWVkIHRvIGVzY2FwZSBpbiBsZXQgbmFtZXMsIGV0Y1xuICBjb21wYXJhdG9yT3A6ICc9fFxcXFwhPXw+fD49fDx8PD18XFxcXCQ9fFxcXFxePXxcXFxcKj0nLCAvLyBiaW5hcnkgY29tcGFyaXNvbiBvcCAodXNlZCBpbiBkYXRhIHNlbGVjdG9ycylcbiAgYm9vbE9wOiAnXFxcXD98XFxcXCF8XFxcXF4nLCAvLyBib29sZWFuICh1bmFyeSkgb3BlcmF0b3JzICh1c2VkIGluIGRhdGEgc2VsZWN0b3JzKVxuICBzdHJpbmc6ICdcIig/OlxcXFxcXFxcXCJ8W15cIl0pKlwiJyArICd8JyArIFwiJyg/OlxcXFxcXFxcJ3xbXiddKSonXCIsIC8vIHN0cmluZyBsaXRlcmFscyAodXNlZCBpbiBkYXRhIHNlbGVjdG9ycykgLS0gZG91YmxlcXVvdGVzIHwgc2luZ2xlcXVvdGVzXG4gIG51bWJlcjogdXRpbC5yZWdleC5udW1iZXIsIC8vIG51bWJlciBsaXRlcmFsICh1c2VkIGluIGRhdGEgc2VsZWN0b3JzKSAtLS0gZS5nLiAwLjEyMzQsIDEyMzQsIDEyZTEyM1xuICBtZXRhOiAnZGVncmVlfGluZGVncmVlfG91dGRlZ3JlZScsIC8vIGFsbG93ZWQgbWV0YWRhdGEgZmllbGRzIChpLmUuIGFsbG93ZWQgZnVuY3Rpb25zIHRvIHVzZSBmcm9tIENvbGxlY3Rpb24pXG4gIHNlcGFyYXRvcjogJ1xcXFxzKixcXFxccyonLCAvLyBxdWVyaWVzIGFyZSBzZXBhcmF0ZWQgYnkgY29tbWFzLCBlLmcuIGVkZ2VbZm9vID0gJ2JhciddLCBub2RlLnNvbWVDbGFzc1xuICBkZXNjZW5kYW50OiAnXFxcXHMrJyxcbiAgY2hpbGQ6ICdcXFxccys+XFxcXHMrJyxcbiAgc3ViamVjdDogJ1xcXFwkJyxcbiAgZ3JvdXA6ICdub2RlfGVkZ2V8XFxcXConLFxuICBkaXJlY3RlZEVkZ2U6ICdcXFxccystPlxcXFxzKycsXG4gIHVuZGlyZWN0ZWRFZGdlOiAnXFxcXHMrPC0+XFxcXHMrJ1xufTtcbnRva2Vucy52YXJpYWJsZSA9ICcoPzpbXFxcXHctXXwoPzpcXFxcXFxcXCcgKyB0b2tlbnMubWV0YUNoYXIgKyAnKSkrJzsgLy8gYSB2YXJpYWJsZSBuYW1lXG50b2tlbnMudmFsdWUgPSB0b2tlbnMuc3RyaW5nICsgJ3wnICsgdG9rZW5zLm51bWJlcjsgLy8gYSB2YWx1ZSBsaXRlcmFsLCBlaXRoZXIgYSBzdHJpbmcgb3IgbnVtYmVyXG50b2tlbnMuY2xhc3NOYW1lID0gdG9rZW5zLnZhcmlhYmxlOyAvLyBhIGNsYXNzIG5hbWUgKGZvbGxvd3MgdmFyaWFibGUgY29udmVudGlvbnMpXG50b2tlbnMuaWQgPSB0b2tlbnMudmFyaWFibGU7IC8vIGFuIGVsZW1lbnQgaWQgKGZvbGxvd3MgdmFyaWFibGUgY29udmVudGlvbnMpXG5cbihmdW5jdGlvbiAoKSB7XG4gIHZhciBvcHMgPSB2b2lkIDAsXG4gICAgICBvcCA9IHZvaWQgMCxcbiAgICAgIGkgPSB2b2lkIDA7XG5cbiAgLy8gYWRkIEAgdmFyaWFudHMgdG8gY29tcGFyYXRvck9wXG4gIG9wcyA9IHRva2Vucy5jb21wYXJhdG9yT3Auc3BsaXQoJ3wnKTtcbiAgZm9yIChpID0gMDsgaSA8IG9wcy5sZW5ndGg7IGkrKykge1xuICAgIG9wID0gb3BzW2ldO1xuICAgIHRva2Vucy5jb21wYXJhdG9yT3AgKz0gJ3xAJyArIG9wO1xuICB9XG5cbiAgLy8gYWRkICEgdmFyaWFudHMgdG8gY29tcGFyYXRvck9wXG4gIG9wcyA9IHRva2Vucy5jb21wYXJhdG9yT3Auc3BsaXQoJ3wnKTtcbiAgZm9yIChpID0gMDsgaSA8IG9wcy5sZW5ndGg7IGkrKykge1xuICAgIG9wID0gb3BzW2ldO1xuXG4gICAgaWYgKG9wLmluZGV4T2YoJyEnKSA+PSAwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9IC8vIHNraXAgb3BzIHRoYXQgZXhwbGljaXRseSBjb250YWluICFcbiAgICBpZiAob3AgPT09ICc9Jykge1xuICAgICAgY29udGludWU7XG4gICAgfSAvLyBza2lwID0gYi9jICE9IGlzIGV4cGxpY2l0bHkgZGVmaW5lZFxuXG4gICAgdG9rZW5zLmNvbXBhcmF0b3JPcCArPSAnfFxcXFwhJyArIG9wO1xuICB9XG59KSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHRva2VucztcblxuLyoqKi8gfSksXG4vKiA1MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KSxcbiAgICBzdGF0ZVNlbGVjdG9yTWF0Y2hlcyA9IF9yZXF1aXJlLnN0YXRlU2VsZWN0b3JNYXRjaGVzO1xuXG52YXIgaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG4vLyBnZW5lcmljIGNoZWNraW5nIGZvciBkYXRhL21ldGFkYXRhXG52YXIgb3BlcmFuZHNNYXRjaCA9IGZ1bmN0aW9uIG9wZXJhbmRzTWF0Y2gocXVlcnksIHBhcmFtcykge1xuICB2YXIgYWxsRGF0YU1hdGNoZXMgPSB0cnVlO1xuICBmb3IgKHZhciBrID0gMDsgayA8IHF1ZXJ5W3BhcmFtcy5uYW1lXS5sZW5ndGg7IGsrKykge1xuICAgIHZhciBkYXRhID0gcXVlcnlbcGFyYW1zLm5hbWVdW2tdO1xuICAgIHZhciBvcGVyYXRvciA9IGRhdGEub3BlcmF0b3I7XG4gICAgdmFyIHZhbHVlID0gZGF0YS52YWx1ZTtcbiAgICB2YXIgZmllbGQgPSBkYXRhLmZpZWxkO1xuICAgIHZhciBfbWF0Y2hlcyA9IHZvaWQgMDtcbiAgICB2YXIgZmllbGRWYWwgPSBwYXJhbXMuZmllbGRWYWx1ZShmaWVsZCk7XG5cbiAgICBpZiAob3BlcmF0b3IgIT0gbnVsbCAmJiB2YWx1ZSAhPSBudWxsKSB7XG4gICAgICB2YXIgZmllbGRTdHIgPSAhaXMuc3RyaW5nKGZpZWxkVmFsKSAmJiAhaXMubnVtYmVyKGZpZWxkVmFsKSA/ICcnIDogJycgKyBmaWVsZFZhbDtcbiAgICAgIHZhciB2YWxTdHIgPSAnJyArIHZhbHVlO1xuXG4gICAgICB2YXIgY2FzZUluc2Vuc2l0aXZlID0gZmFsc2U7XG4gICAgICBpZiAob3BlcmF0b3IuaW5kZXhPZignQCcpID49IDApIHtcbiAgICAgICAgZmllbGRTdHIgPSBmaWVsZFN0ci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB2YWxTdHIgPSB2YWxTdHIudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICBvcGVyYXRvciA9IG9wZXJhdG9yLnJlcGxhY2UoJ0AnLCAnJyk7XG4gICAgICAgIGNhc2VJbnNlbnNpdGl2ZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBub3RFeHByID0gZmFsc2U7XG4gICAgICBpZiAob3BlcmF0b3IuaW5kZXhPZignIScpID49IDApIHtcbiAgICAgICAgb3BlcmF0b3IgPSBvcGVyYXRvci5yZXBsYWNlKCchJywgJycpO1xuICAgICAgICBub3RFeHByID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgd2UncmUgZG9pbmcgYSBjYXNlIGluc2Vuc2l0aXZlIGNvbXBhcmlzb24sIHRoZW4gd2UncmUgdXNpbmcgYSBTVFJJTkcgY29tcGFyaXNvblxuICAgICAgLy8gZXZlbiBpZiB3ZSdyZSBjb21wYXJpbmcgbnVtYmVyc1xuICAgICAgaWYgKGNhc2VJbnNlbnNpdGl2ZSkge1xuICAgICAgICB2YWx1ZSA9IHZhbFN0ci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBmaWVsZFZhbCA9IGZpZWxkU3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBpc0luZXFDbXAgPSBmYWxzZTtcblxuICAgICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgICBjYXNlICcqPSc6XG4gICAgICAgICAgX21hdGNoZXMgPSBmaWVsZFN0ci5pbmRleE9mKHZhbFN0cikgPj0gMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnJD0nOlxuICAgICAgICAgIF9tYXRjaGVzID0gZmllbGRTdHIuaW5kZXhPZih2YWxTdHIsIGZpZWxkU3RyLmxlbmd0aCAtIHZhbFN0ci5sZW5ndGgpID49IDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ149JzpcbiAgICAgICAgICBfbWF0Y2hlcyA9IGZpZWxkU3RyLmluZGV4T2YodmFsU3RyKSA9PT0gMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnPSc6XG4gICAgICAgICAgX21hdGNoZXMgPSBmaWVsZFZhbCA9PT0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgIGlzSW5lcUNtcCA9IHRydWU7XG4gICAgICAgICAgX21hdGNoZXMgPSBmaWVsZFZhbCA+IHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICc+PSc6XG4gICAgICAgICAgaXNJbmVxQ21wID0gdHJ1ZTtcbiAgICAgICAgICBfbWF0Y2hlcyA9IGZpZWxkVmFsID49IHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICBpc0luZXFDbXAgPSB0cnVlO1xuICAgICAgICAgIF9tYXRjaGVzID0gZmllbGRWYWwgPCB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnPD0nOlxuICAgICAgICAgIGlzSW5lcUNtcCA9IHRydWU7XG4gICAgICAgICAgX21hdGNoZXMgPSBmaWVsZFZhbCA8PSB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBfbWF0Y2hlcyA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICAvLyBhcHBseSB0aGUgbm90IG9wLCBidXQgbnVsbCB2YWxzIGZvciBpbmVxdWFsaXRpZXMgc2hvdWxkIGFsd2F5cyBzdGF5IG5vbi1tYXRjaGluZ1xuICAgICAgaWYgKG5vdEV4cHIgJiYgKGZpZWxkVmFsICE9IG51bGwgfHwgIWlzSW5lcUNtcCkpIHtcbiAgICAgICAgX21hdGNoZXMgPSAhX21hdGNoZXM7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvcGVyYXRvciAhPSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICAgIGNhc2UgJz8nOlxuICAgICAgICAgIF9tYXRjaGVzID0gZmllbGRWYWwgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJyEnOlxuICAgICAgICAgIF9tYXRjaGVzID0gZmllbGRWYWwgPyBmYWxzZSA6IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ14nOlxuICAgICAgICAgIF9tYXRjaGVzID0gZmllbGRWYWwgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgX21hdGNoZXMgPSBmaWVsZFZhbCAhPT0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmICghX21hdGNoZXMpIHtcbiAgICAgIGFsbERhdGFNYXRjaGVzID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH0gLy8gZm9yXG5cbiAgcmV0dXJuIGFsbERhdGFNYXRjaGVzO1xufTsgLy8gb3BlcmFuZHNNYXRjaFxuXG4vLyBjaGVjayBwYXJlbnQvY2hpbGQgcmVsYXRpb25zXG52YXIgY29uZmlybVJlbGF0aW9ucyA9IGZ1bmN0aW9uIGNvbmZpcm1SZWxhdGlvbnMocXVlcnksIGlzTmVjZXNzYXJ5LCBlbGVzKSB7XG4gIGlmIChxdWVyeSAhPSBudWxsKSB7XG4gICAgdmFyIF9tYXRjaGVzMiA9IGZhbHNlO1xuXG4gICAgaWYgKCFpc05lY2Vzc2FyeSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGVsZXMgPSBlbGVzKCk7IC8vIHNhdmUgY3ljbGVzIGlmIHF1ZXJ5ID09IG51bGxcblxuICAgIC8vIHF1ZXJ5IG11c3QgbWF0Y2ggZm9yIGF0IGxlYXN0IG9uZSBlbGVtZW50IChtYXkgYmUgcmVjdXJzaXZlKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHF1ZXJ5TWF0Y2hlcyhxdWVyeSwgZWxlc1tpXSkpIHtcbiAgICAgICAgX21hdGNoZXMyID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIF9tYXRjaGVzMjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxudmFyIHF1ZXJ5TWF0Y2hlcyA9IGZ1bmN0aW9uIHF1ZXJ5TWF0Y2hlcyhxdWVyeSwgZWxlKSB7XG4gIC8vIG1ha2Ugc2luZ2xlIGdyb3VwLW9ubHkgc2VsZWN0b3JzIHJlYWxseSBjaGVhcCB0byBjaGVjayBzaW5jZSB0aGV5J3JlIHRoZSBtb3N0IGNvbW1vbiBvbmVzXG4gIGlmIChxdWVyeS5ncm91cE9ubHkpIHtcbiAgICByZXR1cm4gcXVlcnkuZ3JvdXAgPT09ICcqJyB8fCBxdWVyeS5ncm91cCA9PT0gZWxlLmdyb3VwKCk7XG4gIH1cblxuICAvLyBjaGVjayBncm91cFxuICBpZiAocXVlcnkuZ3JvdXAgIT0gbnVsbCAmJiBxdWVyeS5ncm91cCAhPSAnKicgJiYgcXVlcnkuZ3JvdXAgIT0gZWxlLmdyb3VwKCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgY3kgPSBlbGUuY3koKTtcbiAgdmFyIGsgPSB2b2lkIDA7XG5cbiAgLy8gY2hlY2sgY29sb24gc2VsZWN0b3JzXG4gIHZhciBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gdHJ1ZTtcbiAgZm9yIChrID0gMDsgayA8IHF1ZXJ5LmNvbG9uU2VsZWN0b3JzLmxlbmd0aDsgaysrKSB7XG4gICAgdmFyIHNlbCA9IHF1ZXJ5LmNvbG9uU2VsZWN0b3JzW2tdO1xuXG4gICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9IHN0YXRlU2VsZWN0b3JNYXRjaGVzKHNlbCwgZWxlKTtcblxuICAgIGlmICghYWxsQ29sb25TZWxlY3RvcnNNYXRjaCkgYnJlYWs7XG4gIH1cbiAgaWYgKCFhbGxDb2xvblNlbGVjdG9yc01hdGNoKSByZXR1cm4gZmFsc2U7XG5cbiAgLy8gY2hlY2sgaWRcbiAgdmFyIGFsbElkc01hdGNoID0gdHJ1ZTtcbiAgZm9yIChrID0gMDsgayA8IHF1ZXJ5Lmlkcy5sZW5ndGg7IGsrKykge1xuICAgIHZhciBpZCA9IHF1ZXJ5Lmlkc1trXTtcbiAgICB2YXIgYWN0dWFsSWQgPSBlbGUuaWQoKTtcblxuICAgIGFsbElkc01hdGNoID0gYWxsSWRzTWF0Y2ggJiYgaWQgPT0gYWN0dWFsSWQ7XG5cbiAgICBpZiAoIWFsbElkc01hdGNoKSBicmVhaztcbiAgfVxuICBpZiAoIWFsbElkc01hdGNoKSByZXR1cm4gZmFsc2U7XG5cbiAgLy8gY2hlY2sgY2xhc3Nlc1xuICB2YXIgYWxsQ2xhc3Nlc01hdGNoID0gdHJ1ZTtcbiAgZm9yIChrID0gMDsgayA8IHF1ZXJ5LmNsYXNzZXMubGVuZ3RoOyBrKyspIHtcbiAgICB2YXIgY2xzID0gcXVlcnkuY2xhc3Nlc1trXTtcblxuICAgIGFsbENsYXNzZXNNYXRjaCA9IGFsbENsYXNzZXNNYXRjaCAmJiBlbGUuaGFzQ2xhc3MoY2xzKTtcblxuICAgIGlmICghYWxsQ2xhc3Nlc01hdGNoKSBicmVhaztcbiAgfVxuICBpZiAoIWFsbENsYXNzZXNNYXRjaCkgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIGNoZWNrIGRhdGEgbWF0Y2hlc1xuICB2YXIgYWxsRGF0YU1hdGNoZXMgPSBvcGVyYW5kc01hdGNoKHF1ZXJ5LCB7XG4gICAgbmFtZTogJ2RhdGEnLFxuICAgIGZpZWxkVmFsdWU6IGZ1bmN0aW9uIGZpZWxkVmFsdWUoZmllbGQpIHtcbiAgICAgIHJldHVybiBlbGUuZGF0YShmaWVsZCk7XG4gICAgfVxuICB9KTtcblxuICBpZiAoIWFsbERhdGFNYXRjaGVzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gY2hlY2sgbWV0YWRhdGEgbWF0Y2hlc1xuICB2YXIgYWxsTWV0YU1hdGNoZXMgPSBvcGVyYW5kc01hdGNoKHF1ZXJ5LCB7XG4gICAgbmFtZTogJ21ldGEnLFxuICAgIGZpZWxkVmFsdWU6IGZ1bmN0aW9uIGZpZWxkVmFsdWUoZmllbGQpIHtcbiAgICAgIHJldHVybiBlbGVbZmllbGRdKCk7XG4gICAgfVxuICB9KTtcblxuICBpZiAoIWFsbE1ldGFNYXRjaGVzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gY2hlY2sgY29sbGVjdGlvblxuICBpZiAocXVlcnkuY29sbGVjdGlvbiAhPSBudWxsKSB7XG4gICAgdmFyIG1hdGNoZXNBbnkgPSBxdWVyeS5jb2xsZWN0aW9uLmhhc0VsZW1lbnRXaXRoSWQoZWxlLmlkKCkpO1xuXG4gICAgaWYgKCFtYXRjaGVzQW55KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLy8gY2hlY2sgZmlsdGVyIGZ1bmN0aW9uXG4gIGlmIChxdWVyeS5maWx0ZXIgIT0gbnVsbCAmJiBlbGUuY29sbGVjdGlvbigpLnNvbWUocXVlcnkuZmlsdGVyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBpc0NvbXBvdW5kID0gY3kuaGFzQ29tcG91bmROb2RlcygpO1xuICB2YXIgZ2V0U291cmNlID0gZnVuY3Rpb24gZ2V0U291cmNlKCkge1xuICAgIHJldHVybiBlbGUuc291cmNlKCk7XG4gIH07XG4gIHZhciBnZXRUYXJnZXQgPSBmdW5jdGlvbiBnZXRUYXJnZXQoKSB7XG4gICAgcmV0dXJuIGVsZS50YXJnZXQoKTtcbiAgfTtcblxuICBpZiAoIWNvbmZpcm1SZWxhdGlvbnMocXVlcnkucGFyZW50LCBpc0NvbXBvdW5kLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGVsZS5wYXJlbnQoKTtcbiAgfSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIWNvbmZpcm1SZWxhdGlvbnMocXVlcnkuYW5jZXN0b3IsIGlzQ29tcG91bmQsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZWxlLnBhcmVudHMoKTtcbiAgfSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIWNvbmZpcm1SZWxhdGlvbnMocXVlcnkuY2hpbGQsIGlzQ29tcG91bmQsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZWxlLmNoaWxkcmVuKCk7XG4gIH0pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFjb25maXJtUmVsYXRpb25zKHF1ZXJ5LmRlc2NlbmRhbnQsIGlzQ29tcG91bmQsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZWxlLmRlc2NlbmRhbnRzKCk7XG4gIH0pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFjb25maXJtUmVsYXRpb25zKHF1ZXJ5LnNvdXJjZSwgdHJ1ZSwgZ2V0U291cmNlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghY29uZmlybVJlbGF0aW9ucyhxdWVyeS50YXJnZXQsIHRydWUsIGdldFRhcmdldCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAocXVlcnkuY29ubmVjdGVkTm9kZXMpIHtcbiAgICB2YXIgcTAgPSBxdWVyeS5jb25uZWN0ZWROb2Rlc1swXTtcbiAgICB2YXIgcTEgPSBxdWVyeS5jb25uZWN0ZWROb2Rlc1sxXTtcblxuICAgIGlmIChjb25maXJtUmVsYXRpb25zKHEwLCB0cnVlLCBnZXRTb3VyY2UpICYmIGNvbmZpcm1SZWxhdGlvbnMocTEsIHRydWUsIGdldFRhcmdldCkpIHtcbiAgICAgIC8vIG1hdGNoXG4gICAgfSBlbHNlIGlmIChjb25maXJtUmVsYXRpb25zKHEwLCB0cnVlLCBnZXRUYXJnZXQpICYmIGNvbmZpcm1SZWxhdGlvbnMocTEsIHRydWUsIGdldFNvdXJjZSkpIHtcbiAgICAgIC8vIG1hdGNoXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvLyB3ZSd2ZSByZWFjaGVkIHRoZSBlbmQsIHNvIHdlJ3ZlIG1hdGNoZWQgZXZlcnl0aGluZyBmb3IgdGhpcyBxdWVyeVxuICByZXR1cm4gdHJ1ZTtcbn07IC8vIHF1ZXJ5TWF0Y2hlc1xuXG4vLyBmaWx0ZXIgYW4gZXhpc3RpbmcgY29sbGVjdGlvblxudmFyIGZpbHRlciA9IGZ1bmN0aW9uIGZpbHRlcihjb2xsZWN0aW9uKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGN5ID0gY29sbGVjdGlvbi5jeSgpO1xuXG4gIC8vIGRvbid0IGJvdGhlciB0cnlpbmcgaWYgaXQncyBpbnZhbGlkXG4gIGlmIChzZWxmLmludmFsaWQoKSkge1xuICAgIHJldHVybiBjeS5jb2xsZWN0aW9uKCk7XG4gIH1cblxuICAvLyBmb3IgMSBpZCAjZm9vIHF1ZXJpZXMsIGp1c3QgZ2V0IHRoZSBlbGVtZW50XG4gIGlmIChzZWxmLmxlbmd0aCA9PT0gMSAmJiBzZWxmWzBdLmxlbmd0aCA9PT0gMSAmJiBzZWxmWzBdLmlkcy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gY29sbGVjdGlvbi5nZXRFbGVtZW50QnlJZChzZWxmWzBdLmlkc1swXSkuY29sbGVjdGlvbigpO1xuICB9XG5cbiAgdmFyIHNlbGVjdG9yRnVuY3Rpb24gPSBmdW5jdGlvbiBzZWxlY3RvckZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNlbGYubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBxdWVyeSA9IHNlbGZbal07XG5cbiAgICAgIGlmIChxdWVyeU1hdGNoZXMocXVlcnksIGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBpZiAoc2VsZi50ZXh0KCkgPT0gbnVsbCkge1xuICAgIHNlbGVjdG9yRnVuY3Rpb24gPSBmdW5jdGlvbiBzZWxlY3RvckZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBmaWx0ZXJlZENvbGxlY3Rpb24gPSBjb2xsZWN0aW9uLmZpbHRlcihzZWxlY3RvckZ1bmN0aW9uKTtcblxuICByZXR1cm4gZmlsdGVyZWRDb2xsZWN0aW9uO1xufTsgLy8gZmlsdGVyXG5cbi8vIGRvZXMgc2VsZWN0b3IgbWF0Y2ggYSBzaW5nbGUgZWxlbWVudD9cbnZhciBtYXRjaGVzID0gZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIC8vIGRvbid0IGJvdGhlciB0cnlpbmcgaWYgaXQncyBpbnZhbGlkXG4gIGlmIChzZWxmLmludmFsaWQoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAodmFyIGogPSAwOyBqIDwgc2VsZi5sZW5ndGg7IGorKykge1xuICAgIHZhciBxdWVyeSA9IHNlbGZbal07XG5cbiAgICBpZiAocXVlcnlNYXRjaGVzKHF1ZXJ5LCBlbGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59OyAvLyBmaWx0ZXJcblxubW9kdWxlLmV4cG9ydHMgPSB7IG1hdGNoZXM6IG1hdGNoZXMsIGZpbHRlcjogZmlsdGVyIH07XG5cbi8qKiovIH0pLFxuLyogNTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIFNldCA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cbnZhciBlbGVzZm4gPSB7XG4gIHBhcmVudDogZnVuY3Rpb24gcGFyZW50KHNlbGVjdG9yKSB7XG4gICAgdmFyIHBhcmVudHMgPSBbXTtcblxuICAgIC8vIG9wdGltaXNhdGlvbiBmb3Igc2luZ2xlIGVsZSBjYWxsXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgcGFyZW50ID0gdGhpc1swXS5fcHJpdmF0ZS5wYXJlbnQ7XG5cbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgdmFyIF9wYXJlbnQgPSBlbGUuX3ByaXZhdGUucGFyZW50O1xuXG4gICAgICBpZiAoX3BhcmVudCkge1xuICAgICAgICBwYXJlbnRzLnB1c2goX3BhcmVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24ocGFyZW50cywgeyB1bmlxdWU6IHRydWUgfSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfSxcblxuICBwYXJlbnRzOiBmdW5jdGlvbiBwYXJlbnRzKHNlbGVjdG9yKSB7XG4gICAgdmFyIHBhcmVudHMgPSBbXTtcblxuICAgIHZhciBlbGVzID0gdGhpcy5wYXJlbnQoKTtcbiAgICB3aGlsZSAoZWxlcy5ub25lbXB0eSgpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICAgIHBhcmVudHMucHVzaChlbGUpO1xuICAgICAgfVxuXG4gICAgICBlbGVzID0gZWxlcy5wYXJlbnQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zcGF3bihwYXJlbnRzLCB7IHVuaXF1ZTogdHJ1ZSB9KS5maWx0ZXIoc2VsZWN0b3IpO1xuICB9LFxuXG4gIGNvbW1vbkFuY2VzdG9yczogZnVuY3Rpb24gY29tbW9uQW5jZXN0b3JzKHNlbGVjdG9yKSB7XG4gICAgdmFyIGFuY2VzdG9ycyA9IHZvaWQgMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICB2YXIgcGFyZW50cyA9IGVsZS5wYXJlbnRzKCk7XG5cbiAgICAgIGFuY2VzdG9ycyA9IGFuY2VzdG9ycyB8fCBwYXJlbnRzO1xuXG4gICAgICBhbmNlc3RvcnMgPSBhbmNlc3RvcnMuaW50ZXJzZWN0KHBhcmVudHMpOyAvLyBjdXJyZW50IGxpc3QgbXVzdCBiZSBjb21tb24gd2l0aCBjdXJyZW50IGVsZSBwYXJlbnRzIHNldFxuICAgIH1cblxuICAgIHJldHVybiBhbmNlc3RvcnMuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfSxcblxuICBvcnBoYW5zOiBmdW5jdGlvbiBvcnBoYW5zKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RkRmlsdGVyKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuaXNPcnBoYW4oKTtcbiAgICB9KS5maWx0ZXIoc2VsZWN0b3IpO1xuICB9LFxuXG4gIG5vbm9ycGhhbnM6IGZ1bmN0aW9uIG5vbm9ycGhhbnMoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5zdGRGaWx0ZXIoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5pc0NoaWxkKCk7XG4gICAgfSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfSxcblxuICBjaGlsZHJlbjogZnVuY3Rpb24gY2hpbGRyZW4oc2VsZWN0b3IpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmNvbmNhdChlbGUuX3ByaXZhdGUuY2hpbGRyZW4pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNwYXduKGNoaWxkcmVuLCB7IHVuaXF1ZTogdHJ1ZSB9KS5maWx0ZXIoc2VsZWN0b3IpO1xuICB9LFxuXG4gIHNpYmxpbmdzOiBmdW5jdGlvbiBzaWJsaW5ncyhzZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLnBhcmVudCgpLmNoaWxkcmVuKCkubm90KHRoaXMpLmZpbHRlcihzZWxlY3Rvcik7XG4gIH0sXG5cbiAgaXNQYXJlbnQ6IGZ1bmN0aW9uIGlzUGFyZW50KCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgaWYgKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5pc05vZGUoKSAmJiBlbGUuX3ByaXZhdGUuY2hpbGRyZW4ubGVuZ3RoICE9PSAwO1xuICAgIH1cbiAgfSxcblxuICBpc0NoaWxkbGVzczogZnVuY3Rpb24gaXNDaGlsZGxlc3MoKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICBpZiAoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLmlzTm9kZSgpICYmIGVsZS5fcHJpdmF0ZS5jaGlsZHJlbi5sZW5ndGggPT09IDA7XG4gICAgfVxuICB9LFxuXG4gIGlzQ2hpbGQ6IGZ1bmN0aW9uIGlzQ2hpbGQoKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICBpZiAoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLmlzTm9kZSgpICYmIGVsZS5fcHJpdmF0ZS5wYXJlbnQgIT0gbnVsbDtcbiAgICB9XG4gIH0sXG5cbiAgaXNPcnBoYW46IGZ1bmN0aW9uIGlzT3JwaGFuKCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgaWYgKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5pc05vZGUoKSAmJiBlbGUuX3ByaXZhdGUucGFyZW50ID09IG51bGw7XG4gICAgfVxuICB9LFxuXG4gIGRlc2NlbmRhbnRzOiBmdW5jdGlvbiBkZXNjZW5kYW50cyhzZWxlY3Rvcikge1xuICAgIHZhciBlbGVtZW50cyA9IFtdO1xuXG4gICAgZnVuY3Rpb24gYWRkKGVsZXMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcblxuICAgICAgICBlbGVtZW50cy5wdXNoKGVsZSk7XG5cbiAgICAgICAgaWYgKGVsZS5jaGlsZHJlbigpLm5vbmVtcHR5KCkpIHtcbiAgICAgICAgICBhZGQoZWxlLmNoaWxkcmVuKCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgYWRkKHRoaXMuY2hpbGRyZW4oKSk7XG5cbiAgICByZXR1cm4gdGhpcy5zcGF3bihlbGVtZW50cywgeyB1bmlxdWU6IHRydWUgfSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZm9yRWFjaENvbXBvdW5kKGVsZXMsIGZuLCBpbmNsdWRlU2VsZiwgcmVjdXJzaXZlU3RlcCkge1xuICB2YXIgcSA9IFtdO1xuICB2YXIgZGlkID0gbmV3IFNldCgpO1xuICB2YXIgY3kgPSBlbGVzLmN5KCk7XG4gIHZhciBoYXNDb21wb3VuZHMgPSBjeS5oYXNDb21wb3VuZE5vZGVzKCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsZSA9IGVsZXNbaV07XG5cbiAgICBpZiAoaW5jbHVkZVNlbGYpIHtcbiAgICAgIHEucHVzaChlbGUpO1xuICAgIH0gZWxzZSBpZiAoaGFzQ29tcG91bmRzKSB7XG4gICAgICByZWN1cnNpdmVTdGVwKHEsIGRpZCwgZWxlKTtcbiAgICB9XG4gIH1cblxuICB3aGlsZSAocS5sZW5ndGggPiAwKSB7XG4gICAgdmFyIF9lbGUgPSBxLnNoaWZ0KCk7XG5cbiAgICBmbihfZWxlKTtcblxuICAgIGRpZC5hZGQoX2VsZS5pZCgpKTtcblxuICAgIGlmIChoYXNDb21wb3VuZHMpIHtcbiAgICAgIHJlY3Vyc2l2ZVN0ZXAocSwgZGlkLCBfZWxlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlcztcbn1cblxuZnVuY3Rpb24gYWRkQ2hpbGRyZW4ocSwgZGlkLCBlbGUpIHtcbiAgaWYgKGVsZS5pc1BhcmVudCgpKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gZWxlLl9wcml2YXRlLmNoaWxkcmVuO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG5cbiAgICAgIGlmICghZGlkLmhhcyhjaGlsZC5pZCgpKSkge1xuICAgICAgICBxLnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyB2ZXJ5IGVmZmljaWVudCB2ZXJzaW9uIG9mIGVsZXMuYWRkKCBlbGVzLmRlc2NlbmRhbnRzKCkgKS5mb3JFYWNoKClcbi8vIGZvciBpbnRlcm5hbCB1c2VcbmVsZXNmbi5mb3JFYWNoRG93biA9IGZ1bmN0aW9uIChmbikge1xuICB2YXIgaW5jbHVkZVNlbGYgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG5cbiAgcmV0dXJuIGZvckVhY2hDb21wb3VuZCh0aGlzLCBmbiwgaW5jbHVkZVNlbGYsIGFkZENoaWxkcmVuKTtcbn07XG5cbmZ1bmN0aW9uIGFkZFBhcmVudChxLCBkaWQsIGVsZSkge1xuICBpZiAoZWxlLmlzQ2hpbGQoKSkge1xuICAgIHZhciBwYXJlbnQgPSBlbGUuX3ByaXZhdGUucGFyZW50O1xuXG4gICAgaWYgKCFkaWQuaGFzKHBhcmVudC5pZCgpKSkge1xuICAgICAgcS5wdXNoKHBhcmVudCk7XG4gICAgfVxuICB9XG59XG5cbmVsZXNmbi5mb3JFYWNoVXAgPSBmdW5jdGlvbiAoZm4pIHtcbiAgdmFyIGluY2x1ZGVTZWxmID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuXG4gIHJldHVybiBmb3JFYWNoQ29tcG91bmQodGhpcywgZm4sIGluY2x1ZGVTZWxmLCBhZGRQYXJlbnQpO1xufTtcblxuZnVuY3Rpb24gYWRkUGFyZW50QW5kQ2hpbGRyZW4ocSwgZGlkLCBlbGUpIHtcbiAgYWRkUGFyZW50KHEsIGRpZCwgZWxlKTtcbiAgYWRkQ2hpbGRyZW4ocSwgZGlkLCBlbGUpO1xufVxuXG5lbGVzZm4uZm9yRWFjaFVwQW5kRG93biA9IGZ1bmN0aW9uIChmbikge1xuICB2YXIgaW5jbHVkZVNlbGYgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG5cbiAgcmV0dXJuIGZvckVhY2hDb21wb3VuZCh0aGlzLCBmbiwgaW5jbHVkZVNlbGYsIGFkZFBhcmVudEFuZENoaWxkcmVuKTtcbn07XG5cbi8vIGFsaWFzZXNcbmVsZXNmbi5hbmNlc3RvcnMgPSBlbGVzZm4ucGFyZW50cztcblxubW9kdWxlLmV4cG9ydHMgPSBlbGVzZm47XG5cbi8qKiovIH0pLFxuLyogNTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG52YXIgZm4gPSB2b2lkIDAsXG4gICAgZWxlc2ZuID0gdm9pZCAwO1xuXG5mbiA9IGVsZXNmbiA9IHtcblxuICBkYXRhOiBkZWZpbmUuZGF0YSh7XG4gICAgZmllbGQ6ICdkYXRhJyxcbiAgICBiaW5kaW5nRXZlbnQ6ICdkYXRhJyxcbiAgICBhbGxvd0JpbmRpbmc6IHRydWUsXG4gICAgYWxsb3dTZXR0aW5nOiB0cnVlLFxuICAgIHNldHRpbmdFdmVudDogJ2RhdGEnLFxuICAgIHNldHRpbmdUcmlnZ2Vyc0V2ZW50OiB0cnVlLFxuICAgIHRyaWdnZXJGbk5hbWU6ICd0cmlnZ2VyJyxcbiAgICBhbGxvd0dldHRpbmc6IHRydWUsXG4gICAgaW1tdXRhYmxlS2V5czoge1xuICAgICAgJ2lkJzogdHJ1ZSxcbiAgICAgICdzb3VyY2UnOiB0cnVlLFxuICAgICAgJ3RhcmdldCc6IHRydWUsXG4gICAgICAncGFyZW50JzogdHJ1ZVxuICAgIH0sXG4gICAgdXBkYXRlU3R5bGU6IHRydWVcbiAgfSksXG5cbiAgcmVtb3ZlRGF0YTogZGVmaW5lLnJlbW92ZURhdGEoe1xuICAgIGZpZWxkOiAnZGF0YScsXG4gICAgZXZlbnQ6ICdkYXRhJyxcbiAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgdHJpZ2dlckV2ZW50OiB0cnVlLFxuICAgIGltbXV0YWJsZUtleXM6IHtcbiAgICAgICdpZCc6IHRydWUsXG4gICAgICAnc291cmNlJzogdHJ1ZSxcbiAgICAgICd0YXJnZXQnOiB0cnVlLFxuICAgICAgJ3BhcmVudCc6IHRydWVcbiAgICB9LFxuICAgIHVwZGF0ZVN0eWxlOiB0cnVlXG4gIH0pLFxuXG4gIHNjcmF0Y2g6IGRlZmluZS5kYXRhKHtcbiAgICBmaWVsZDogJ3NjcmF0Y2gnLFxuICAgIGJpbmRpbmdFdmVudDogJ3NjcmF0Y2gnLFxuICAgIGFsbG93QmluZGluZzogdHJ1ZSxcbiAgICBhbGxvd1NldHRpbmc6IHRydWUsXG4gICAgc2V0dGluZ0V2ZW50OiAnc2NyYXRjaCcsXG4gICAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IHRydWUsXG4gICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgIGFsbG93R2V0dGluZzogdHJ1ZSxcbiAgICB1cGRhdGVTdHlsZTogdHJ1ZVxuICB9KSxcblxuICByZW1vdmVTY3JhdGNoOiBkZWZpbmUucmVtb3ZlRGF0YSh7XG4gICAgZmllbGQ6ICdzY3JhdGNoJyxcbiAgICBldmVudDogJ3NjcmF0Y2gnLFxuICAgIHRyaWdnZXJGbk5hbWU6ICd0cmlnZ2VyJyxcbiAgICB0cmlnZ2VyRXZlbnQ6IHRydWUsXG4gICAgdXBkYXRlU3R5bGU6IHRydWVcbiAgfSksXG5cbiAgcnNjcmF0Y2g6IGRlZmluZS5kYXRhKHtcbiAgICBmaWVsZDogJ3JzY3JhdGNoJyxcbiAgICBhbGxvd0JpbmRpbmc6IGZhbHNlLFxuICAgIGFsbG93U2V0dGluZzogdHJ1ZSxcbiAgICBzZXR0aW5nVHJpZ2dlcnNFdmVudDogZmFsc2UsXG4gICAgYWxsb3dHZXR0aW5nOiB0cnVlXG4gIH0pLFxuXG4gIHJlbW92ZVJzY3JhdGNoOiBkZWZpbmUucmVtb3ZlRGF0YSh7XG4gICAgZmllbGQ6ICdyc2NyYXRjaCcsXG4gICAgdHJpZ2dlckV2ZW50OiBmYWxzZVxuICB9KSxcblxuICBpZDogZnVuY3Rpb24gaWQoKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICBpZiAoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgfVxuICB9XG5cbn07XG5cbi8vIGFsaWFzZXNcbmZuLmF0dHIgPSBmbi5kYXRhO1xuZm4ucmVtb3ZlQXR0ciA9IGZuLnJlbW92ZURhdGE7XG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuXG4vKioqLyB9KSxcbi8qIDU1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIGVsZXNmbiA9IHt9O1xuXG5mdW5jdGlvbiBkZWZpbmVEZWdyZWVGdW5jdGlvbihjYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24gKGluY2x1ZGVMb29wcykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmIChpbmNsdWRlTG9vcHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaW5jbHVkZUxvb3BzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoc2VsZi5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoc2VsZi5pc05vZGUoKSAmJiAhc2VsZi5yZW1vdmVkKCkpIHtcbiAgICAgIHZhciBkZWdyZWUgPSAwO1xuICAgICAgdmFyIG5vZGUgPSBzZWxmWzBdO1xuICAgICAgdmFyIGNvbm5lY3RlZEVkZ2VzID0gbm9kZS5fcHJpdmF0ZS5lZGdlcztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb25uZWN0ZWRFZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWRnZSA9IGNvbm5lY3RlZEVkZ2VzW2ldO1xuXG4gICAgICAgIGlmICghaW5jbHVkZUxvb3BzICYmIGVkZ2UuaXNMb29wKCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlZ3JlZSArPSBjYWxsYmFjayhub2RlLCBlZGdlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlZ3JlZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfTtcbn1cblxudXRpbC5leHRlbmQoZWxlc2ZuLCB7XG4gIGRlZ3JlZTogZGVmaW5lRGVncmVlRnVuY3Rpb24oZnVuY3Rpb24gKG5vZGUsIGVkZ2UpIHtcbiAgICBpZiAoZWRnZS5zb3VyY2UoKS5zYW1lKGVkZ2UudGFyZ2V0KCkpKSB7XG4gICAgICByZXR1cm4gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9KSxcblxuICBpbmRlZ3JlZTogZGVmaW5lRGVncmVlRnVuY3Rpb24oZnVuY3Rpb24gKG5vZGUsIGVkZ2UpIHtcbiAgICBpZiAoZWRnZS50YXJnZXQoKS5zYW1lKG5vZGUpKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9KSxcblxuICBvdXRkZWdyZWU6IGRlZmluZURlZ3JlZUZ1bmN0aW9uKGZ1bmN0aW9uIChub2RlLCBlZGdlKSB7XG4gICAgaWYgKGVkZ2Uuc291cmNlKCkuc2FtZShub2RlKSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfSlcbn0pO1xuXG5mdW5jdGlvbiBkZWZpbmVEZWdyZWVCb3VuZHNGdW5jdGlvbihkZWdyZWVGbiwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpbmNsdWRlTG9vcHMpIHtcbiAgICB2YXIgcmV0ID0gdm9pZCAwO1xuICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSBub2Rlc1tpXTtcbiAgICAgIHZhciBkZWdyZWUgPSBlbGVbZGVncmVlRm5dKGluY2x1ZGVMb29wcyk7XG4gICAgICBpZiAoZGVncmVlICE9PSB1bmRlZmluZWQgJiYgKHJldCA9PT0gdW5kZWZpbmVkIHx8IGNhbGxiYWNrKGRlZ3JlZSwgcmV0KSkpIHtcbiAgICAgICAgcmV0ID0gZGVncmVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH07XG59XG5cbnV0aWwuZXh0ZW5kKGVsZXNmbiwge1xuICBtaW5EZWdyZWU6IGRlZmluZURlZ3JlZUJvdW5kc0Z1bmN0aW9uKCdkZWdyZWUnLCBmdW5jdGlvbiAoZGVncmVlLCBtaW4pIHtcbiAgICByZXR1cm4gZGVncmVlIDwgbWluO1xuICB9KSxcblxuICBtYXhEZWdyZWU6IGRlZmluZURlZ3JlZUJvdW5kc0Z1bmN0aW9uKCdkZWdyZWUnLCBmdW5jdGlvbiAoZGVncmVlLCBtYXgpIHtcbiAgICByZXR1cm4gZGVncmVlID4gbWF4O1xuICB9KSxcblxuICBtaW5JbmRlZ3JlZTogZGVmaW5lRGVncmVlQm91bmRzRnVuY3Rpb24oJ2luZGVncmVlJywgZnVuY3Rpb24gKGRlZ3JlZSwgbWluKSB7XG4gICAgcmV0dXJuIGRlZ3JlZSA8IG1pbjtcbiAgfSksXG5cbiAgbWF4SW5kZWdyZWU6IGRlZmluZURlZ3JlZUJvdW5kc0Z1bmN0aW9uKCdpbmRlZ3JlZScsIGZ1bmN0aW9uIChkZWdyZWUsIG1heCkge1xuICAgIHJldHVybiBkZWdyZWUgPiBtYXg7XG4gIH0pLFxuXG4gIG1pbk91dGRlZ3JlZTogZGVmaW5lRGVncmVlQm91bmRzRnVuY3Rpb24oJ291dGRlZ3JlZScsIGZ1bmN0aW9uIChkZWdyZWUsIG1pbikge1xuICAgIHJldHVybiBkZWdyZWUgPCBtaW47XG4gIH0pLFxuXG4gIG1heE91dGRlZ3JlZTogZGVmaW5lRGVncmVlQm91bmRzRnVuY3Rpb24oJ291dGRlZ3JlZScsIGZ1bmN0aW9uIChkZWdyZWUsIG1heCkge1xuICAgIHJldHVybiBkZWdyZWUgPiBtYXg7XG4gIH0pXG59KTtcblxudXRpbC5leHRlbmQoZWxlc2ZuLCB7XG4gIHRvdGFsRGVncmVlOiBmdW5jdGlvbiB0b3RhbERlZ3JlZShpbmNsdWRlTG9vcHMpIHtcbiAgICB2YXIgdG90YWwgPSAwO1xuICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRvdGFsICs9IG5vZGVzW2ldLmRlZ3JlZShpbmNsdWRlTG9vcHMpO1xuICAgIH1cblxuICAgIHJldHVybiB0b3RhbDtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuXG4vKioqLyB9KSxcbi8qIDU2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbnZhciBwb3NpdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNTcpO1xudmFyIGJvdW5kcyA9IF9fd2VicGFja19yZXF1aXJlX18oNTgpO1xudmFyIHdpZHRoSGVpZ2h0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OSk7XG52YXIgZWRnZVBvaW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oNjApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHV0aWwuYXNzaWduKHt9LCBwb3NpdGlvbiwgYm91bmRzLCB3aWR0aEhlaWdodCwgZWRnZVBvaW50cyk7XG5cbi8qKiovIH0pLFxuLyogNTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG52YXIgaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIG1hdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xudmFyIGZuID0gdm9pZCAwLFxuICAgIGVsZXNmbiA9IHZvaWQgMDtcblxudmFyIGJlZm9yZVBvc2l0aW9uU2V0ID0gZnVuY3Rpb24gYmVmb3JlUG9zaXRpb25TZXQoZWxlcywgbmV3UG9zKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuXG4gICAgaWYgKGVsZS5pc1BhcmVudCgpICYmICFlbGUubG9ja2VkKCkpIHtcbiAgICAgIHZhciBvbGRQb3MgPSBlbGUuX3ByaXZhdGUucG9zaXRpb247XG4gICAgICB2YXIgZGVsdGEgPSB7XG4gICAgICAgIHg6IG5ld1Bvcy54IC0gb2xkUG9zLngsXG4gICAgICAgIHk6IG5ld1Bvcy55IC0gb2xkUG9zLnlcbiAgICAgIH07XG5cbiAgICAgIGVsZXMuY2hpbGRyZW4oKS5zaGlmdChkZWx0YSk7XG4gICAgfVxuICB9XG59O1xuXG5mbiA9IGVsZXNmbiA9IHtcblxuICBwb3NpdGlvbjogZGVmaW5lLmRhdGEoe1xuICAgIGZpZWxkOiAncG9zaXRpb24nLFxuICAgIGJpbmRpbmdFdmVudDogJ3Bvc2l0aW9uJyxcbiAgICBhbGxvd0JpbmRpbmc6IHRydWUsXG4gICAgYWxsb3dTZXR0aW5nOiB0cnVlLFxuICAgIHNldHRpbmdFdmVudDogJ3Bvc2l0aW9uJyxcbiAgICBzZXR0aW5nVHJpZ2dlcnNFdmVudDogdHJ1ZSxcbiAgICB0cmlnZ2VyRm5OYW1lOiAnZW1pdEFuZE5vdGlmeScsXG4gICAgYWxsb3dHZXR0aW5nOiB0cnVlLFxuICAgIHZhbGlkS2V5czogWyd4JywgJ3knXSxcbiAgICBiZWZvcmVHZXQ6IGZ1bmN0aW9uIGJlZm9yZUdldChlbGUpIHtcbiAgICAgIGVsZS51cGRhdGVDb21wb3VuZEJvdW5kcygpO1xuICAgIH0sXG4gICAgYmVmb3JlU2V0OiBiZWZvcmVQb3NpdGlvblNldCxcbiAgICBvblNldDogZnVuY3Rpb24gb25TZXQoZWxlcykge1xuICAgICAgZWxlcy5kaXJ0eUNvbXBvdW5kQm91bmRzQ2FjaGUoKTtcbiAgICB9LFxuICAgIGNhblNldDogZnVuY3Rpb24gY2FuU2V0KGVsZSkge1xuICAgICAgcmV0dXJuICFlbGUubG9ja2VkKCk7XG4gICAgfVxuICB9KSxcblxuICAvLyBwb3NpdGlvbiBidXQgbm8gbm90aWZpY2F0aW9uIHRvIHJlbmRlcmVyXG4gIHNpbGVudFBvc2l0aW9uOiBkZWZpbmUuZGF0YSh7XG4gICAgZmllbGQ6ICdwb3NpdGlvbicsXG4gICAgYmluZGluZ0V2ZW50OiAncG9zaXRpb24nLFxuICAgIGFsbG93QmluZGluZzogZmFsc2UsXG4gICAgYWxsb3dTZXR0aW5nOiB0cnVlLFxuICAgIHNldHRpbmdFdmVudDogJ3Bvc2l0aW9uJyxcbiAgICBzZXR0aW5nVHJpZ2dlcnNFdmVudDogZmFsc2UsXG4gICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgIGFsbG93R2V0dGluZzogZmFsc2UsXG4gICAgdmFsaWRLZXlzOiBbJ3gnLCAneSddLFxuICAgIGJlZm9yZVNldDogYmVmb3JlUG9zaXRpb25TZXQsXG4gICAgb25TZXQ6IGZ1bmN0aW9uIG9uU2V0KGVsZXMpIHtcbiAgICAgIGVsZXMuZGlydHlDb21wb3VuZEJvdW5kc0NhY2hlKCk7XG4gICAgfSxcbiAgICBjYW5TZXQ6IGZ1bmN0aW9uIGNhblNldChlbGUpIHtcbiAgICAgIHJldHVybiAhZWxlLmxvY2tlZCgpO1xuICAgIH1cbiAgfSksXG5cbiAgcG9zaXRpb25zOiBmdW5jdGlvbiBwb3NpdGlvbnMocG9zLCBzaWxlbnQpIHtcbiAgICBpZiAoaXMucGxhaW5PYmplY3QocG9zKSkge1xuICAgICAgaWYgKHNpbGVudCkge1xuICAgICAgICB0aGlzLnNpbGVudFBvc2l0aW9uKHBvcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBvc2l0aW9uKHBvcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpcy5mbihwb3MpKSB7XG4gICAgICB2YXIgX2ZuID0gcG9zO1xuICAgICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuXG4gICAgICBjeS5zdGFydEJhdGNoKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgICAgdmFyIF9wb3MgPSB2b2lkIDA7XG5cbiAgICAgICAgaWYgKF9wb3MgPSBfZm4oZWxlLCBpKSkge1xuICAgICAgICAgIGlmIChzaWxlbnQpIHtcbiAgICAgICAgICAgIGVsZS5zaWxlbnRQb3NpdGlvbihfcG9zKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlLnBvc2l0aW9uKF9wb3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjeS5lbmRCYXRjaCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIHNpbGVudFBvc2l0aW9uczogZnVuY3Rpb24gc2lsZW50UG9zaXRpb25zKHBvcykge1xuICAgIHJldHVybiB0aGlzLnBvc2l0aW9ucyhwb3MsIHRydWUpO1xuICB9LFxuXG4gIHNoaWZ0OiBmdW5jdGlvbiBzaGlmdChkaW0sIHZhbCkge1xuICAgIHZhciBkZWx0YSA9IHZvaWQgMDtcblxuICAgIGlmIChpcy5wbGFpbk9iamVjdChkaW0pKSB7XG4gICAgICBkZWx0YSA9IGRpbTtcbiAgICB9IGVsc2UgaWYgKGlzLnN0cmluZyhkaW0pICYmIGlzLm51bWJlcih2YWwpKSB7XG4gICAgICBkZWx0YSA9IHsgeDogMCwgeTogMCB9O1xuXG4gICAgICBkZWx0YVtkaW1dID0gdmFsO1xuICAgIH1cblxuICAgIGlmIChkZWx0YSAhPSBudWxsKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICAgIHZhciBwb3MgPSBlbGUucG9zaXRpb24oKTtcblxuICAgICAgICBlbGUucG9zaXRpb24oe1xuICAgICAgICAgIHg6IHBvcy54ICsgZGVsdGEueCxcbiAgICAgICAgICB5OiBwb3MueSArIGRlbHRhLnlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLy8gZ2V0L3NldCB0aGUgcmVuZGVyZWQgKGkuZS4gb24gc2NyZWVuKSBwb3NpdG9uIG9mIHRoZSBlbGVtZW50XG4gIHJlbmRlcmVkUG9zaXRpb246IGZ1bmN0aW9uIHJlbmRlcmVkUG9zaXRpb24oZGltLCB2YWwpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgdmFyIHBhbiA9IGN5LnBhbigpO1xuICAgIHZhciBycG9zID0gaXMucGxhaW5PYmplY3QoZGltKSA/IGRpbSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgc2V0dGluZyA9IHJwb3MgIT09IHVuZGVmaW5lZCB8fCB2YWwgIT09IHVuZGVmaW5lZCAmJiBpcy5zdHJpbmcoZGltKTtcblxuICAgIGlmIChlbGUgJiYgZWxlLmlzTm9kZSgpKSB7XG4gICAgICAvLyBtdXN0IGhhdmUgYW4gZWxlbWVudCBhbmQgbXVzdCBiZSBhIG5vZGUgdG8gcmV0dXJuIHBvc2l0aW9uXG4gICAgICBpZiAoc2V0dGluZykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgX2VsZSA9IHRoaXNbaV07XG5cbiAgICAgICAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIHNldCBvbmUgZGltZW5zaW9uXG4gICAgICAgICAgICBfZWxlLnBvc2l0aW9uKGRpbSwgKHZhbCAtIHBhbltkaW1dKSAvIHpvb20pO1xuICAgICAgICAgIH0gZWxzZSBpZiAocnBvcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBzZXQgd2hvbGUgcG9zaXRpb25cbiAgICAgICAgICAgIF9lbGUucG9zaXRpb24obWF0aC5yZW5kZXJlZFRvTW9kZWxQb3NpdGlvbihycG9zLCB6b29tLCBwYW4pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGdldHRpbmdcbiAgICAgICAgdmFyIHBvcyA9IGVsZS5wb3NpdGlvbigpO1xuICAgICAgICBycG9zID0gbWF0aC5tb2RlbFRvUmVuZGVyZWRQb3NpdGlvbihwb3MsIHpvb20sIHBhbik7XG5cbiAgICAgICAgaWYgKGRpbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gdGhlbiByZXR1cm4gdGhlIHdob2xlIHJlbmRlcmVkIHBvc2l0aW9uXG4gICAgICAgICAgcmV0dXJuIHJwb3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdGhlbiByZXR1cm4gdGhlIHNwZWNpZmllZCBkaW1lbnNpb25cbiAgICAgICAgICByZXR1cm4gcnBvc1tkaW1dO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghc2V0dGluZykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDsgLy8gZm9yIGVtcHR5IGNvbGxlY3Rpb24gY2FzZVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIC8vIGdldC9zZXQgdGhlIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBwYXJlbnRcbiAgcmVsYXRpdmVQb3NpdGlvbjogZnVuY3Rpb24gcmVsYXRpdmVQb3NpdGlvbihkaW0sIHZhbCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICB2YXIgcHBvcyA9IGlzLnBsYWluT2JqZWN0KGRpbSkgPyBkaW0gOiB1bmRlZmluZWQ7XG4gICAgdmFyIHNldHRpbmcgPSBwcG9zICE9PSB1bmRlZmluZWQgfHwgdmFsICE9PSB1bmRlZmluZWQgJiYgaXMuc3RyaW5nKGRpbSk7XG4gICAgdmFyIGhhc0NvbXBvdW5kTm9kZXMgPSBjeS5oYXNDb21wb3VuZE5vZGVzKCk7XG5cbiAgICBpZiAoZWxlICYmIGVsZS5pc05vZGUoKSkge1xuICAgICAgLy8gbXVzdCBoYXZlIGFuIGVsZW1lbnQgYW5kIG11c3QgYmUgYSBub2RlIHRvIHJldHVybiBwb3NpdGlvblxuICAgICAgaWYgKHNldHRpbmcpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIF9lbGUyID0gdGhpc1tpXTtcbiAgICAgICAgICB2YXIgcGFyZW50ID0gaGFzQ29tcG91bmROb2RlcyA/IF9lbGUyLnBhcmVudCgpIDogbnVsbDtcbiAgICAgICAgICB2YXIgaGFzUGFyZW50ID0gcGFyZW50ICYmIHBhcmVudC5sZW5ndGggPiAwO1xuICAgICAgICAgIHZhciByZWxhdGl2ZVRvUGFyZW50ID0gaGFzUGFyZW50O1xuXG4gICAgICAgICAgaWYgKGhhc1BhcmVudCkge1xuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50WzBdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBvcmlnaW4gPSByZWxhdGl2ZVRvUGFyZW50ID8gcGFyZW50LnBvc2l0aW9uKCkgOiB7IHg6IDAsIHk6IDAgfTtcblxuICAgICAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gc2V0IG9uZSBkaW1lbnNpb25cbiAgICAgICAgICAgIF9lbGUyLnBvc2l0aW9uKGRpbSwgdmFsICsgb3JpZ2luW2RpbV0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAocHBvcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBzZXQgd2hvbGUgcG9zaXRpb25cbiAgICAgICAgICAgIF9lbGUyLnBvc2l0aW9uKHtcbiAgICAgICAgICAgICAgeDogcHBvcy54ICsgb3JpZ2luLngsXG4gICAgICAgICAgICAgIHk6IHBwb3MueSArIG9yaWdpbi55XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGdldHRpbmdcbiAgICAgICAgdmFyIHBvcyA9IGVsZS5wb3NpdGlvbigpO1xuICAgICAgICB2YXIgX3BhcmVudCA9IGhhc0NvbXBvdW5kTm9kZXMgPyBlbGUucGFyZW50KCkgOiBudWxsO1xuICAgICAgICB2YXIgX2hhc1BhcmVudCA9IF9wYXJlbnQgJiYgX3BhcmVudC5sZW5ndGggPiAwO1xuICAgICAgICB2YXIgX3JlbGF0aXZlVG9QYXJlbnQgPSBfaGFzUGFyZW50O1xuXG4gICAgICAgIGlmIChfaGFzUGFyZW50KSB7XG4gICAgICAgICAgX3BhcmVudCA9IF9wYXJlbnRbMF07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX29yaWdpbiA9IF9yZWxhdGl2ZVRvUGFyZW50ID8gX3BhcmVudC5wb3NpdGlvbigpIDogeyB4OiAwLCB5OiAwIH07XG5cbiAgICAgICAgcHBvcyA9IHtcbiAgICAgICAgICB4OiBwb3MueCAtIF9vcmlnaW4ueCxcbiAgICAgICAgICB5OiBwb3MueSAtIF9vcmlnaW4ueVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChkaW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIHRoZW4gcmV0dXJuIHRoZSB3aG9sZSByZW5kZXJlZCBwb3NpdGlvblxuICAgICAgICAgIHJldHVybiBwcG9zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHRoZW4gcmV0dXJuIHRoZSBzcGVjaWZpZWQgZGltZW5zaW9uXG4gICAgICAgICAgcmV0dXJuIHBwb3NbZGltXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIXNldHRpbmcpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7IC8vIGZvciBlbXB0eSBjb2xsZWN0aW9uIGNhc2VcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfVxufTtcblxuLy8gYWxpYXNlc1xuZm4ubW9kZWxQb3NpdGlvbiA9IGZuLnBvaW50ID0gZm4ucG9zaXRpb247XG5mbi5tb2RlbFBvc2l0aW9ucyA9IGZuLnBvaW50cyA9IGZuLnBvc2l0aW9ucztcbmZuLnJlbmRlcmVkUG9pbnQgPSBmbi5yZW5kZXJlZFBvc2l0aW9uO1xuZm4ucmVsYXRpdmVQb2ludCA9IGZuLnJlbGF0aXZlUG9zaXRpb247XG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuXG4vKioqLyB9KSxcbi8qIDU4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBpcyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG52YXIgbWF0aCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG52YXIgZm4gPSB2b2lkIDAsXG4gICAgZWxlc2ZuID0gdm9pZCAwO1xuXG5mbiA9IGVsZXNmbiA9IHt9O1xuXG5lbGVzZm4ucmVuZGVyZWRCb3VuZGluZ0JveCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBiYiA9IHRoaXMuYm91bmRpbmdCb3gob3B0aW9ucyk7XG4gIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gIHZhciBwYW4gPSBjeS5wYW4oKTtcblxuICB2YXIgeDEgPSBiYi54MSAqIHpvb20gKyBwYW4ueDtcbiAgdmFyIHgyID0gYmIueDIgKiB6b29tICsgcGFuLng7XG4gIHZhciB5MSA9IGJiLnkxICogem9vbSArIHBhbi55O1xuICB2YXIgeTIgPSBiYi55MiAqIHpvb20gKyBwYW4ueTtcblxuICByZXR1cm4ge1xuICAgIHgxOiB4MSxcbiAgICB4MjogeDIsXG4gICAgeTE6IHkxLFxuICAgIHkyOiB5MixcbiAgICB3OiB4MiAtIHgxLFxuICAgIGg6IHkyIC0geTFcbiAgfTtcbn07XG5cbmVsZXNmbi5kaXJ0eUNvbXBvdW5kQm91bmRzQ2FjaGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpIHx8ICFjeS5oYXNDb21wb3VuZE5vZGVzKCkpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHRoaXMuZm9yRWFjaFVwKGZ1bmN0aW9uIChlbGUpIHtcbiAgICBlbGUuX3ByaXZhdGUuY29tcG91bmRCb3VuZHNDbGVhbiA9IGZhbHNlO1xuXG4gICAgaWYgKGVsZS5pc1BhcmVudCgpKSB7XG4gICAgICBlbGUuZW1pdCgnYm91bmRzJyk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbmVsZXNmbi51cGRhdGVDb21wb3VuZEJvdW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuXG4gIC8vIHNhdmUgY3ljbGVzIGZvciBub24gY29tcG91bmQgZ3JhcGhzIG9yIHdoZW4gc3R5bGUgZGlzYWJsZWRcbiAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSB8fCAhY3kuaGFzQ29tcG91bmROb2RlcygpKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzYXZlIGN5Y2xlcyB3aGVuIGJhdGNoaW5nIC0tIGJ1dCBib3VuZHMgd2lsbCBiZSBzdGFsZSAob3Igbm90IGV4aXN0IHlldClcbiAgaWYgKGN5LmJhdGNoaW5nKCkpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciB1cGRhdGVkID0gW107XG5cbiAgZnVuY3Rpb24gdXBkYXRlKHBhcmVudCkge1xuICAgIGlmICghcGFyZW50LmlzUGFyZW50KCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgX3AgPSBwYXJlbnQuX3ByaXZhdGU7XG4gICAgdmFyIGNoaWxkcmVuID0gcGFyZW50LmNoaWxkcmVuKCk7XG4gICAgdmFyIGluY2x1ZGVMYWJlbHMgPSBwYXJlbnQucHN0eWxlKCdjb21wb3VuZC1zaXppbmctd3J0LWxhYmVscycpLnZhbHVlID09PSAnaW5jbHVkZSc7XG5cbiAgICB2YXIgbWluID0ge1xuICAgICAgd2lkdGg6IHtcbiAgICAgICAgdmFsOiBwYXJlbnQucHN0eWxlKCdtaW4td2lkdGgnKS5wZlZhbHVlLFxuICAgICAgICBsZWZ0OiBwYXJlbnQucHN0eWxlKCdtaW4td2lkdGgtYmlhcy1sZWZ0JyksXG4gICAgICAgIHJpZ2h0OiBwYXJlbnQucHN0eWxlKCdtaW4td2lkdGgtYmlhcy1yaWdodCcpXG4gICAgICB9LFxuICAgICAgaGVpZ2h0OiB7XG4gICAgICAgIHZhbDogcGFyZW50LnBzdHlsZSgnbWluLWhlaWdodCcpLnBmVmFsdWUsXG4gICAgICAgIHRvcDogcGFyZW50LnBzdHlsZSgnbWluLWhlaWdodC1iaWFzLXRvcCcpLFxuICAgICAgICBib3R0b206IHBhcmVudC5wc3R5bGUoJ21pbi1oZWlnaHQtYmlhcy1ib3R0b20nKVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgYmIgPSBjaGlsZHJlbi5ib3VuZGluZ0JveCh7XG4gICAgICBpbmNsdWRlTGFiZWxzOiBpbmNsdWRlTGFiZWxzLFxuICAgICAgaW5jbHVkZU92ZXJsYXlzOiBmYWxzZSxcblxuICAgICAgLy8gdXBkYXRpbmcgdGhlIGNvbXBvdW5kIGJvdW5kcyBoYXBwZW5zIG91dHNpZGUgb2YgdGhlIHJlZ3VsYXJcbiAgICAgIC8vIGNhY2hlIGN5Y2xlIChpLmUuIGJlZm9yZSBmaXJlZCBldmVudHMpXG4gICAgICB1c2VDYWNoZTogZmFsc2VcbiAgICB9KTtcbiAgICB2YXIgcG9zID0gX3AucG9zaXRpb247XG5cbiAgICAvLyBpZiBjaGlsZHJlbiB0YWtlIHVwIHplcm8gYXJlYSB0aGVuIGtlZXAgcG9zaXRpb24gYW5kIGZhbGwgYmFjayBvbiBzdHlsZXNoZWV0IHcvaFxuICAgIGlmIChiYi53ID09PSAwIHx8IGJiLmggPT09IDApIHtcbiAgICAgIGJiID0ge1xuICAgICAgICB3OiBwYXJlbnQucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWUsXG4gICAgICAgIGg6IHBhcmVudC5wc3R5bGUoJ2hlaWdodCcpLnBmVmFsdWVcbiAgICAgIH07XG5cbiAgICAgIGJiLngxID0gcG9zLnggLSBiYi53IC8gMjtcbiAgICAgIGJiLngyID0gcG9zLnggKyBiYi53IC8gMjtcbiAgICAgIGJiLnkxID0gcG9zLnkgLSBiYi5oIC8gMjtcbiAgICAgIGJiLnkyID0gcG9zLnkgKyBiYi5oIC8gMjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlQmlhc1ZhbHVlcyhwcm9wRGlmZiwgcHJvcEJpYXMsIHByb3BCaWFzQ29tcGxlbWVudCkge1xuICAgICAgdmFyIGJpYXNEaWZmID0gMDtcbiAgICAgIHZhciBiaWFzQ29tcGxlbWVudERpZmYgPSAwO1xuICAgICAgdmFyIGJpYXNUb3RhbCA9IHByb3BCaWFzICsgcHJvcEJpYXNDb21wbGVtZW50O1xuXG4gICAgICBpZiAocHJvcERpZmYgPiAwICYmIGJpYXNUb3RhbCA+IDApIHtcbiAgICAgICAgYmlhc0RpZmYgPSBwcm9wQmlhcyAvIGJpYXNUb3RhbCAqIHByb3BEaWZmO1xuICAgICAgICBiaWFzQ29tcGxlbWVudERpZmYgPSBwcm9wQmlhc0NvbXBsZW1lbnQgLyBiaWFzVG90YWwgKiBwcm9wRGlmZjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJpYXNEaWZmOiBiaWFzRGlmZixcbiAgICAgICAgYmlhc0NvbXBsZW1lbnREaWZmOiBiaWFzQ29tcGxlbWVudERpZmZcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcHV0ZVBhZGRpbmdWYWx1ZXMod2lkdGgsIGhlaWdodCwgcGFkZGluZ09iamVjdCwgcmVsYXRpdmVUbykge1xuICAgICAgLy8gQXNzdW1pbmcgcGVyY2VudGFnZSBpcyBudW1iZXIgZnJvbSAwIHRvIDFcbiAgICAgIGlmIChwYWRkaW5nT2JqZWN0LnVuaXRzID09PSAnJScpIHtcbiAgICAgICAgc3dpdGNoIChyZWxhdGl2ZVRvKSB7XG4gICAgICAgICAgY2FzZSAnd2lkdGgnOlxuICAgICAgICAgICAgcmV0dXJuIHdpZHRoID4gMCA/IHBhZGRpbmdPYmplY3QucGZWYWx1ZSAqIHdpZHRoIDogMDtcbiAgICAgICAgICBjYXNlICdoZWlnaHQnOlxuICAgICAgICAgICAgcmV0dXJuIGhlaWdodCA+IDAgPyBwYWRkaW5nT2JqZWN0LnBmVmFsdWUgKiBoZWlnaHQgOiAwO1xuICAgICAgICAgIGNhc2UgJ2F2ZXJhZ2UnOlxuICAgICAgICAgICAgcmV0dXJuIHdpZHRoID4gMCAmJiBoZWlnaHQgPiAwID8gcGFkZGluZ09iamVjdC5wZlZhbHVlICogKHdpZHRoICsgaGVpZ2h0KSAvIDIgOiAwO1xuICAgICAgICAgIGNhc2UgJ21pbic6XG4gICAgICAgICAgICByZXR1cm4gd2lkdGggPiAwICYmIGhlaWdodCA+IDAgPyB3aWR0aCA+IGhlaWdodCA/IHBhZGRpbmdPYmplY3QucGZWYWx1ZSAqIGhlaWdodCA6IHBhZGRpbmdPYmplY3QucGZWYWx1ZSAqIHdpZHRoIDogMDtcbiAgICAgICAgICBjYXNlICdtYXgnOlxuICAgICAgICAgICAgcmV0dXJuIHdpZHRoID4gMCAmJiBoZWlnaHQgPiAwID8gd2lkdGggPiBoZWlnaHQgPyBwYWRkaW5nT2JqZWN0LnBmVmFsdWUgKiB3aWR0aCA6IHBhZGRpbmdPYmplY3QucGZWYWx1ZSAqIGhlaWdodCA6IDA7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhZGRpbmdPYmplY3QudW5pdHMgPT09ICdweCcpIHtcbiAgICAgICAgcmV0dXJuIHBhZGRpbmdPYmplY3QucGZWYWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsZWZ0VmFsID0gbWluLndpZHRoLmxlZnQudmFsdWU7XG4gICAgaWYgKG1pbi53aWR0aC5sZWZ0LnVuaXRzID09PSAncHgnICYmIG1pbi53aWR0aC52YWwgPiAwKSB7XG4gICAgICBsZWZ0VmFsID0gbGVmdFZhbCAqIDEwMCAvIG1pbi53aWR0aC52YWw7XG4gICAgfVxuICAgIHZhciByaWdodFZhbCA9IG1pbi53aWR0aC5yaWdodC52YWx1ZTtcbiAgICBpZiAobWluLndpZHRoLnJpZ2h0LnVuaXRzID09PSAncHgnICYmIG1pbi53aWR0aC52YWwgPiAwKSB7XG4gICAgICByaWdodFZhbCA9IHJpZ2h0VmFsICogMTAwIC8gbWluLndpZHRoLnZhbDtcbiAgICB9XG5cbiAgICB2YXIgdG9wVmFsID0gbWluLmhlaWdodC50b3AudmFsdWU7XG4gICAgaWYgKG1pbi5oZWlnaHQudG9wLnVuaXRzID09PSAncHgnICYmIG1pbi5oZWlnaHQudmFsID4gMCkge1xuICAgICAgdG9wVmFsID0gdG9wVmFsICogMTAwIC8gbWluLmhlaWdodC52YWw7XG4gICAgfVxuXG4gICAgdmFyIGJvdHRvbVZhbCA9IG1pbi5oZWlnaHQuYm90dG9tLnZhbHVlO1xuICAgIGlmIChtaW4uaGVpZ2h0LmJvdHRvbS51bml0cyA9PT0gJ3B4JyAmJiBtaW4uaGVpZ2h0LnZhbCA+IDApIHtcbiAgICAgIGJvdHRvbVZhbCA9IGJvdHRvbVZhbCAqIDEwMCAvIG1pbi5oZWlnaHQudmFsO1xuICAgIH1cblxuICAgIHZhciB3aWR0aEJpYXNEaWZmcyA9IGNvbXB1dGVCaWFzVmFsdWVzKG1pbi53aWR0aC52YWwgLSBiYi53LCBsZWZ0VmFsLCByaWdodFZhbCk7XG4gICAgdmFyIGRpZmZMZWZ0ID0gd2lkdGhCaWFzRGlmZnMuYmlhc0RpZmY7XG4gICAgdmFyIGRpZmZSaWdodCA9IHdpZHRoQmlhc0RpZmZzLmJpYXNDb21wbGVtZW50RGlmZjtcblxuICAgIHZhciBoZWlnaHRCaWFzRGlmZnMgPSBjb21wdXRlQmlhc1ZhbHVlcyhtaW4uaGVpZ2h0LnZhbCAtIGJiLmgsIHRvcFZhbCwgYm90dG9tVmFsKTtcbiAgICB2YXIgZGlmZlRvcCA9IGhlaWdodEJpYXNEaWZmcy5iaWFzRGlmZjtcbiAgICB2YXIgZGlmZkJvdHRvbSA9IGhlaWdodEJpYXNEaWZmcy5iaWFzQ29tcGxlbWVudERpZmY7XG5cbiAgICBfcC5hdXRvUGFkZGluZyA9IGNvbXB1dGVQYWRkaW5nVmFsdWVzKGJiLncsIGJiLmgsIHBhcmVudC5wc3R5bGUoJ3BhZGRpbmcnKSwgcGFyZW50LnBzdHlsZSgncGFkZGluZy1yZWxhdGl2ZS10bycpLnZhbHVlKTtcblxuICAgIF9wLmF1dG9XaWR0aCA9IE1hdGgubWF4KGJiLncsIG1pbi53aWR0aC52YWwpO1xuICAgIHBvcy54ID0gKC1kaWZmTGVmdCArIGJiLngxICsgYmIueDIgKyBkaWZmUmlnaHQpIC8gMjtcblxuICAgIF9wLmF1dG9IZWlnaHQgPSBNYXRoLm1heChiYi5oLCBtaW4uaGVpZ2h0LnZhbCk7XG4gICAgcG9zLnkgPSAoLWRpZmZUb3AgKyBiYi55MSArIGJiLnkyICsgZGlmZkJvdHRvbSkgLyAyO1xuXG4gICAgdXBkYXRlZC5wdXNoKHBhcmVudCk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG5cbiAgICBpZiAoIV9wLmNvbXBvdW5kQm91bmRzQ2xlYW4pIHtcbiAgICAgIHVwZGF0ZShlbGUpO1xuXG4gICAgICBpZiAoIWN5Ll9wcml2YXRlLmJhdGNoaW5nU3R5bGUpIHtcbiAgICAgICAgX3AuY29tcG91bmRCb3VuZHNDbGVhbiA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG52YXIgbm9uaW5mID0gZnVuY3Rpb24gbm9uaW5mKHgpIHtcbiAgaWYgKHggPT09IEluZmluaXR5IHx8IHggPT09IC1JbmZpbml0eSkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHg7XG59O1xuXG52YXIgdXBkYXRlQm91bmRzID0gZnVuY3Rpb24gdXBkYXRlQm91bmRzKGIsIHgxLCB5MSwgeDIsIHkyKSB7XG4gIC8vIGRvbid0IHVwZGF0ZSB3aXRoIHplcm8gYXJlYSBib3hlc1xuICBpZiAoeDIgLSB4MSA9PT0gMCB8fCB5MiAtIHkxID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gZG9uJ3QgdXBkYXRlIHdpdGggbnVsbCBkaW1cbiAgaWYgKHgxID09IG51bGwgfHwgeTEgPT0gbnVsbCB8fCB4MiA9PSBudWxsIHx8IHkyID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBiLngxID0geDEgPCBiLngxID8geDEgOiBiLngxO1xuICBiLngyID0geDIgPiBiLngyID8geDIgOiBiLngyO1xuICBiLnkxID0geTEgPCBiLnkxID8geTEgOiBiLnkxO1xuICBiLnkyID0geTIgPiBiLnkyID8geTIgOiBiLnkyO1xufTtcblxudmFyIHVwZGF0ZUJvdW5kc0Zyb21Cb3ggPSBmdW5jdGlvbiB1cGRhdGVCb3VuZHNGcm9tQm94KGIsIGIyKSB7XG4gIHJldHVybiB1cGRhdGVCb3VuZHMoYiwgYjIueDEsIGIyLnkxLCBiMi54MiwgYjIueTIpO1xufTtcblxudmFyIHByZWZpeGVkUHJvcGVydHkgPSBmdW5jdGlvbiBwcmVmaXhlZFByb3BlcnR5KG9iaiwgZmllbGQsIHByZWZpeCkge1xuICByZXR1cm4gdXRpbC5nZXRQcmVmaXhlZFByb3BlcnR5KG9iaiwgZmllbGQsIHByZWZpeCk7XG59O1xuXG52YXIgdXBkYXRlQm91bmRzRnJvbUFycm93ID0gZnVuY3Rpb24gdXBkYXRlQm91bmRzRnJvbUFycm93KGJvdW5kcywgZWxlLCBwcmVmaXgpIHtcbiAgaWYgKGVsZS5jeSgpLmhlYWRsZXNzKCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciByc3R5bGUgPSBfcC5yc3R5bGU7XG4gIHZhciBoYWxmQXJXID0gcnN0eWxlLmFycm93V2lkdGggLyAyO1xuICB2YXIgYXJyb3dUeXBlID0gZWxlLnBzdHlsZShwcmVmaXggKyAnLWFycm93LXNoYXBlJykudmFsdWU7XG4gIHZhciB4ID0gdm9pZCAwO1xuICB2YXIgeSA9IHZvaWQgMDtcblxuICBpZiAoYXJyb3dUeXBlICE9PSAnbm9uZScpIHtcbiAgICBpZiAocHJlZml4ID09PSAnc291cmNlJykge1xuICAgICAgeCA9IHJzdHlsZS5zcmNYO1xuICAgICAgeSA9IHJzdHlsZS5zcmNZO1xuICAgIH0gZWxzZSBpZiAocHJlZml4ID09PSAndGFyZ2V0Jykge1xuICAgICAgeCA9IHJzdHlsZS50Z3RYO1xuICAgICAgeSA9IHJzdHlsZS50Z3RZO1xuICAgIH0gZWxzZSB7XG4gICAgICB4ID0gcnN0eWxlLm1pZFg7XG4gICAgICB5ID0gcnN0eWxlLm1pZFk7XG4gICAgfVxuXG4gICAgdXBkYXRlQm91bmRzKGJvdW5kcywgeCAtIGhhbGZBclcsIHkgLSBoYWxmQXJXLCB4ICsgaGFsZkFyVywgeSArIGhhbGZBclcpO1xuICB9XG59O1xuXG52YXIgdXBkYXRlQm91bmRzRnJvbUxhYmVsID0gZnVuY3Rpb24gdXBkYXRlQm91bmRzRnJvbUxhYmVsKGJvdW5kcywgZWxlLCBwcmVmaXgpIHtcbiAgaWYgKGVsZS5jeSgpLmhlYWRsZXNzKCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcHJlZml4RGFzaCA9IHZvaWQgMDtcblxuICBpZiAocHJlZml4KSB7XG4gICAgcHJlZml4RGFzaCA9IHByZWZpeCArICctJztcbiAgfSBlbHNlIHtcbiAgICBwcmVmaXhEYXNoID0gJyc7XG4gIH1cblxuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciByc3R5bGUgPSBfcC5yc3R5bGU7XG4gIHZhciBsYWJlbCA9IGVsZS5wc3R5bGUocHJlZml4RGFzaCArICdsYWJlbCcpLnN0clZhbHVlO1xuXG4gIGlmIChsYWJlbCkge1xuICAgIHZhciBoYWxpZ24gPSBlbGUucHN0eWxlKCd0ZXh0LWhhbGlnbicpO1xuICAgIHZhciB2YWxpZ24gPSBlbGUucHN0eWxlKCd0ZXh0LXZhbGlnbicpO1xuICAgIHZhciBsYWJlbFdpZHRoID0gcHJlZml4ZWRQcm9wZXJ0eShyc3R5bGUsICdsYWJlbFdpZHRoJywgcHJlZml4KTtcbiAgICB2YXIgbGFiZWxIZWlnaHQgPSBwcmVmaXhlZFByb3BlcnR5KHJzdHlsZSwgJ2xhYmVsSGVpZ2h0JywgcHJlZml4KTtcbiAgICB2YXIgbGFiZWxYID0gcHJlZml4ZWRQcm9wZXJ0eShyc3R5bGUsICdsYWJlbFgnLCBwcmVmaXgpO1xuICAgIHZhciBsYWJlbFkgPSBwcmVmaXhlZFByb3BlcnR5KHJzdHlsZSwgJ2xhYmVsWScsIHByZWZpeCk7XG4gICAgdmFyIG1hcmdpblggPSBlbGUucHN0eWxlKHByZWZpeERhc2ggKyAndGV4dC1tYXJnaW4teCcpLnBmVmFsdWU7XG4gICAgdmFyIG1hcmdpblkgPSBlbGUucHN0eWxlKHByZWZpeERhc2ggKyAndGV4dC1tYXJnaW4teScpLnBmVmFsdWU7XG4gICAgdmFyIGlzRWRnZSA9IGVsZS5pc0VkZ2UoKTtcbiAgICB2YXIgcm90YXRpb24gPSBlbGUucHN0eWxlKHByZWZpeERhc2ggKyAndGV4dC1yb3RhdGlvbicpO1xuICAgIHZhciBvdXRsaW5lV2lkdGggPSBlbGUucHN0eWxlKCd0ZXh0LW91dGxpbmUtd2lkdGgnKS5wZlZhbHVlO1xuICAgIHZhciBib3JkZXJXaWR0aCA9IGVsZS5wc3R5bGUoJ3RleHQtYm9yZGVyLXdpZHRoJykucGZWYWx1ZTtcbiAgICB2YXIgaGFsZkJvcmRlcldpZHRoID0gYm9yZGVyV2lkdGggLyAyO1xuICAgIHZhciBwYWRkaW5nID0gZWxlLnBzdHlsZSgndGV4dC1iYWNrZ3JvdW5kLXBhZGRpbmcnKS5wZlZhbHVlO1xuXG4gICAgdmFyIGxoID0gbGFiZWxIZWlnaHQgKyAyICogcGFkZGluZztcbiAgICB2YXIgbHcgPSBsYWJlbFdpZHRoICsgMiAqIHBhZGRpbmc7XG4gICAgdmFyIGx3XzIgPSBsdyAvIDI7XG4gICAgdmFyIGxoXzIgPSBsaCAvIDI7XG4gICAgdmFyIGx4MSA9IHZvaWQgMCxcbiAgICAgICAgbHgyID0gdm9pZCAwLFxuICAgICAgICBseTEgPSB2b2lkIDAsXG4gICAgICAgIGx5MiA9IHZvaWQgMDtcblxuICAgIGlmIChpc0VkZ2UpIHtcbiAgICAgIGx4MSA9IGxhYmVsWCAtIGx3XzI7XG4gICAgICBseDIgPSBsYWJlbFggKyBsd18yO1xuICAgICAgbHkxID0gbGFiZWxZIC0gbGhfMjtcbiAgICAgIGx5MiA9IGxhYmVsWSArIGxoXzI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAoaGFsaWduLnZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgIGx4MSA9IGxhYmVsWCAtIGx3O1xuICAgICAgICAgIGx4MiA9IGxhYmVsWDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgIGx4MSA9IGxhYmVsWCAtIGx3XzI7XG4gICAgICAgICAgbHgyID0gbGFiZWxYICsgbHdfMjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgbHgxID0gbGFiZWxYO1xuICAgICAgICAgIGx4MiA9IGxhYmVsWCArIGx3O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHZhbGlnbi52YWx1ZSkge1xuICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgIGx5MSA9IGxhYmVsWSAtIGxoO1xuICAgICAgICAgIGx5MiA9IGxhYmVsWTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgIGx5MSA9IGxhYmVsWSAtIGxoXzI7XG4gICAgICAgICAgbHkyID0gbGFiZWxZICsgbGhfMjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgIGx5MSA9IGxhYmVsWTtcbiAgICAgICAgICBseTIgPSBsYWJlbFkgKyBsaDtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaXNBdXRvcm90YXRlID0gaXNFZGdlICYmIHJvdGF0aW9uLnN0clZhbHVlID09PSAnYXV0b3JvdGF0ZSc7XG4gICAgdmFyIGlzUGZWYWx1ZSA9IHJvdGF0aW9uLnBmVmFsdWUgIT0gbnVsbCAmJiByb3RhdGlvbi5wZlZhbHVlICE9PSAwO1xuXG4gICAgaWYgKGlzQXV0b3JvdGF0ZSB8fCBpc1BmVmFsdWUpIHtcbiAgICAgIHZhciB0aGV0YSA9IGlzQXV0b3JvdGF0ZSA/IHByZWZpeGVkUHJvcGVydHkoX3AucnN0eWxlLCAnbGFiZWxBbmdsZScsIHByZWZpeCkgOiByb3RhdGlvbi5wZlZhbHVlO1xuICAgICAgdmFyIGNvcyA9IE1hdGguY29zKHRoZXRhKTtcbiAgICAgIHZhciBzaW4gPSBNYXRoLnNpbih0aGV0YSk7XG5cbiAgICAgIHZhciByb3RhdGUgPSBmdW5jdGlvbiByb3RhdGUoeCwgeSkge1xuICAgICAgICB4ID0geCAtIGxhYmVsWDtcbiAgICAgICAgeSA9IHkgLSBsYWJlbFk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiB4ICogY29zIC0geSAqIHNpbiArIGxhYmVsWCxcbiAgICAgICAgICB5OiB4ICogc2luICsgeSAqIGNvcyArIGxhYmVsWVxuICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgdmFyIHB4MXkxID0gcm90YXRlKGx4MSwgbHkxKTtcbiAgICAgIHZhciBweDF5MiA9IHJvdGF0ZShseDEsIGx5Mik7XG4gICAgICB2YXIgcHgyeTEgPSByb3RhdGUobHgyLCBseTEpO1xuICAgICAgdmFyIHB4MnkyID0gcm90YXRlKGx4MiwgbHkyKTtcblxuICAgICAgbHgxID0gTWF0aC5taW4ocHgxeTEueCwgcHgxeTIueCwgcHgyeTEueCwgcHgyeTIueCk7XG4gICAgICBseDIgPSBNYXRoLm1heChweDF5MS54LCBweDF5Mi54LCBweDJ5MS54LCBweDJ5Mi54KTtcbiAgICAgIGx5MSA9IE1hdGgubWluKHB4MXkxLnksIHB4MXkyLnksIHB4MnkxLnksIHB4MnkyLnkpO1xuICAgICAgbHkyID0gTWF0aC5tYXgocHgxeTEueSwgcHgxeTIueSwgcHgyeTEueSwgcHgyeTIueSk7XG4gICAgfVxuXG4gICAgbHgxICs9IG1hcmdpblggLSBNYXRoLm1heChvdXRsaW5lV2lkdGgsIGhhbGZCb3JkZXJXaWR0aCk7XG4gICAgbHgyICs9IG1hcmdpblggKyBNYXRoLm1heChvdXRsaW5lV2lkdGgsIGhhbGZCb3JkZXJXaWR0aCk7XG4gICAgbHkxICs9IG1hcmdpblkgLSBNYXRoLm1heChvdXRsaW5lV2lkdGgsIGhhbGZCb3JkZXJXaWR0aCk7XG4gICAgbHkyICs9IG1hcmdpblkgKyBNYXRoLm1heChvdXRsaW5lV2lkdGgsIGhhbGZCb3JkZXJXaWR0aCk7XG5cbiAgICB1cGRhdGVCb3VuZHMoYm91bmRzLCBseDEsIGx5MSwgbHgyLCBseTIpO1xuICB9XG5cbiAgcmV0dXJuIGJvdW5kcztcbn07XG5cbi8vIGdldCB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSBlbGVtZW50cyAoaW4gcmF3IG1vZGVsIHBvc2l0aW9uKVxudmFyIGJvdW5kaW5nQm94SW1wbCA9IGZ1bmN0aW9uIGJvdW5kaW5nQm94SW1wbChlbGUsIG9wdGlvbnMpIHtcbiAgdmFyIGN5ID0gZWxlLl9wcml2YXRlLmN5O1xuICB2YXIgc3R5bGVFbmFibGVkID0gY3kuc3R5bGVFbmFibGVkKCk7XG4gIHZhciBoZWFkbGVzcyA9IGN5LmhlYWRsZXNzKCk7XG5cbiAgdmFyIGJvdW5kcyA9IHtcbiAgICB4MTogSW5maW5pdHksXG4gICAgeTE6IEluZmluaXR5LFxuICAgIHgyOiAtSW5maW5pdHksXG4gICAgeTI6IC1JbmZpbml0eVxuICB9O1xuXG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgdmFyIGRpc3BsYXkgPSBzdHlsZUVuYWJsZWQgPyBlbGUucHN0eWxlKCdkaXNwbGF5JykudmFsdWUgOiAnZWxlbWVudCc7XG4gIHZhciBpc05vZGUgPSBlbGUuaXNOb2RlKCk7XG4gIHZhciBpc0VkZ2UgPSBlbGUuaXNFZGdlKCk7XG4gIHZhciBleDEgPSB2b2lkIDAsXG4gICAgICBleDIgPSB2b2lkIDAsXG4gICAgICBleTEgPSB2b2lkIDAsXG4gICAgICBleTIgPSB2b2lkIDA7IC8vIGV4dHJlbWEgb2YgYm9keSAvIGxpbmVzXG4gIHZhciB4ID0gdm9pZCAwLFxuICAgICAgeSA9IHZvaWQgMDsgLy8gbm9kZSBwb3NcbiAgdmFyIGRpc3BsYXllZCA9IGRpc3BsYXkgIT09ICdub25lJztcblxuICBpZiAoZGlzcGxheWVkKSB7XG4gICAgdmFyIG92ZXJsYXlPcGFjaXR5ID0gMDtcbiAgICB2YXIgb3ZlcmxheVBhZGRpbmcgPSAwO1xuXG4gICAgaWYgKHN0eWxlRW5hYmxlZCAmJiBvcHRpb25zLmluY2x1ZGVPdmVybGF5cykge1xuICAgICAgb3ZlcmxheU9wYWNpdHkgPSBlbGUucHN0eWxlKCdvdmVybGF5LW9wYWNpdHknKS52YWx1ZTtcblxuICAgICAgaWYgKG92ZXJsYXlPcGFjaXR5ICE9PSAwKSB7XG4gICAgICAgIG92ZXJsYXlQYWRkaW5nID0gZWxlLnBzdHlsZSgnb3ZlcmxheS1wYWRkaW5nJykudmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHcgPSAwO1xuICAgIHZhciB3SGFsZiA9IDA7XG5cbiAgICBpZiAoc3R5bGVFbmFibGVkKSB7XG4gICAgICB3ID0gZWxlLnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlO1xuICAgICAgd0hhbGYgPSB3IC8gMjtcbiAgICB9XG5cbiAgICBpZiAoaXNOb2RlICYmIG9wdGlvbnMuaW5jbHVkZU5vZGVzKSB7XG4gICAgICB2YXIgcG9zID0gZWxlLnBvc2l0aW9uKCk7XG4gICAgICB4ID0gcG9zLng7XG4gICAgICB5ID0gcG9zLnk7XG4gICAgICB2YXIgX3cgPSBlbGUub3V0ZXJXaWR0aCgpO1xuICAgICAgdmFyIGhhbGZXID0gX3cgLyAyO1xuICAgICAgdmFyIGggPSBlbGUub3V0ZXJIZWlnaHQoKTtcbiAgICAgIHZhciBoYWxmSCA9IGggLyAyO1xuXG4gICAgICAvLyBoYW5kbGUgbm9kZSBkaW1lbnNpb25zXG4gICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAgIGV4MSA9IHggLSBoYWxmVyAtIG92ZXJsYXlQYWRkaW5nO1xuICAgICAgZXgyID0geCArIGhhbGZXICsgb3ZlcmxheVBhZGRpbmc7XG4gICAgICBleTEgPSB5IC0gaGFsZkggLSBvdmVybGF5UGFkZGluZztcbiAgICAgIGV5MiA9IHkgKyBoYWxmSCArIG92ZXJsYXlQYWRkaW5nO1xuXG4gICAgICB1cGRhdGVCb3VuZHMoYm91bmRzLCBleDEsIGV5MSwgZXgyLCBleTIpO1xuICAgIH0gZWxzZSBpZiAoaXNFZGdlICYmIG9wdGlvbnMuaW5jbHVkZUVkZ2VzKSB7XG4gICAgICB2YXIgcnN0eWxlID0gX3AucnN0eWxlIHx8IHt9O1xuXG4gICAgICAvLyBoYW5kbGUgZWRnZSBkaW1lbnNpb25zIChyb3VnaCBib3ggZXN0aW1hdGUpXG4gICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgICBpZiAoc3R5bGVFbmFibGVkICYmICFoZWFkbGVzcykge1xuICAgICAgICBleDEgPSBNYXRoLm1pbihyc3R5bGUuc3JjWCwgcnN0eWxlLm1pZFgsIHJzdHlsZS50Z3RYKTtcbiAgICAgICAgZXgyID0gTWF0aC5tYXgocnN0eWxlLnNyY1gsIHJzdHlsZS5taWRYLCByc3R5bGUudGd0WCk7XG4gICAgICAgIGV5MSA9IE1hdGgubWluKHJzdHlsZS5zcmNZLCByc3R5bGUubWlkWSwgcnN0eWxlLnRndFkpO1xuICAgICAgICBleTIgPSBNYXRoLm1heChyc3R5bGUuc3JjWSwgcnN0eWxlLm1pZFksIHJzdHlsZS50Z3RZKTtcblxuICAgICAgICAvLyB0YWtlIGludG8gYWNjb3VudCBlZGdlIHdpZHRoXG4gICAgICAgIGV4MSAtPSB3SGFsZjtcbiAgICAgICAgZXgyICs9IHdIYWxmO1xuICAgICAgICBleTEgLT0gd0hhbGY7XG4gICAgICAgIGV5MiArPSB3SGFsZjtcblxuICAgICAgICB1cGRhdGVCb3VuZHMoYm91bmRzLCBleDEsIGV5MSwgZXgyLCBleTIpO1xuICAgICAgfVxuXG4gICAgICAvLyBwcmVjaXNlIGhheXN0YWNrc1xuICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAgIGlmIChzdHlsZUVuYWJsZWQgJiYgIWhlYWRsZXNzICYmIGVsZS5wc3R5bGUoJ2N1cnZlLXN0eWxlJykuc3RyVmFsdWUgPT09ICdoYXlzdGFjaycpIHtcbiAgICAgICAgdmFyIGhwdHMgPSByc3R5bGUuaGF5c3RhY2tQdHMgfHwgW107XG5cbiAgICAgICAgZXgxID0gaHB0c1swXS54O1xuICAgICAgICBleTEgPSBocHRzWzBdLnk7XG4gICAgICAgIGV4MiA9IGhwdHNbMV0ueDtcbiAgICAgICAgZXkyID0gaHB0c1sxXS55O1xuXG4gICAgICAgIGlmIChleDEgPiBleDIpIHtcbiAgICAgICAgICB2YXIgdGVtcCA9IGV4MTtcbiAgICAgICAgICBleDEgPSBleDI7XG4gICAgICAgICAgZXgyID0gdGVtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChleTEgPiBleTIpIHtcbiAgICAgICAgICB2YXIgX3RlbXAgPSBleTE7XG4gICAgICAgICAgZXkxID0gZXkyO1xuICAgICAgICAgIGV5MiA9IF90ZW1wO1xuICAgICAgICB9XG5cbiAgICAgICAgdXBkYXRlQm91bmRzKGJvdW5kcywgZXgxIC0gd0hhbGYsIGV5MSAtIHdIYWxmLCBleDIgKyB3SGFsZiwgZXkyICsgd0hhbGYpO1xuXG4gICAgICAgIC8vIGhhbmRsZSBwb2ludHMgYWxvbmcgZWRnZVxuICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwdHMgPSByc3R5bGUuYmV6aWVyUHRzIHx8IHJzdHlsZS5saW5lUHRzIHx8IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcHRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdmFyIHB0ID0gcHRzW2pdO1xuXG4gICAgICAgICAgZXgxID0gcHQueCAtIHdIYWxmO1xuICAgICAgICAgIGV4MiA9IHB0LnggKyB3SGFsZjtcbiAgICAgICAgICBleTEgPSBwdC55IC0gd0hhbGY7XG4gICAgICAgICAgZXkyID0gcHQueSArIHdIYWxmO1xuXG4gICAgICAgICAgdXBkYXRlQm91bmRzKGJvdW5kcywgZXgxLCBleTEsIGV4MiwgZXkyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZhbGxiYWNrIG9uIHNvdXJjZSBhbmQgdGFyZ2V0IHBvc2l0aW9uc1xuICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAgICAgaWYgKHB0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB2YXIgbjEgPSBlbGUuc291cmNlKCk7XG4gICAgICAgICAgdmFyIG4xcG9zID0gbjEucG9zaXRpb24oKTtcblxuICAgICAgICAgIHZhciBuMiA9IGVsZS50YXJnZXQoKTtcbiAgICAgICAgICB2YXIgbjJwb3MgPSBuMi5wb3NpdGlvbigpO1xuXG4gICAgICAgICAgZXgxID0gbjFwb3MueDtcbiAgICAgICAgICBleDIgPSBuMnBvcy54O1xuICAgICAgICAgIGV5MSA9IG4xcG9zLnk7XG4gICAgICAgICAgZXkyID0gbjJwb3MueTtcblxuICAgICAgICAgIGlmIChleDEgPiBleDIpIHtcbiAgICAgICAgICAgIHZhciBfdGVtcDIgPSBleDE7XG4gICAgICAgICAgICBleDEgPSBleDI7XG4gICAgICAgICAgICBleDIgPSBfdGVtcDI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGV5MSA+IGV5Mikge1xuICAgICAgICAgICAgdmFyIF90ZW1wMyA9IGV5MTtcbiAgICAgICAgICAgIGV5MSA9IGV5MjtcbiAgICAgICAgICAgIGV5MiA9IF90ZW1wMztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB0YWtlIGludG8gYWNjb3VudCBlZGdlIHdpZHRoXG4gICAgICAgICAgZXgxIC09IHdIYWxmO1xuICAgICAgICAgIGV4MiArPSB3SGFsZjtcbiAgICAgICAgICBleTEgLT0gd0hhbGY7XG4gICAgICAgICAgZXkyICs9IHdIYWxmO1xuXG4gICAgICAgICAgdXBkYXRlQm91bmRzKGJvdW5kcywgZXgxLCBleTEsIGV4MiwgZXkyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gZWRnZXNcblxuXG4gICAgLy8gaGFuZGxlIGVkZ2UgYXJyb3cgc2l6ZVxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgIGlmIChzdHlsZUVuYWJsZWQgJiYgb3B0aW9ucy5pbmNsdWRlRWRnZXMgJiYgaXNFZGdlKSB7XG4gICAgICB1cGRhdGVCb3VuZHNGcm9tQXJyb3coYm91bmRzLCBlbGUsICdtaWQtc291cmNlJywgb3B0aW9ucyk7XG4gICAgICB1cGRhdGVCb3VuZHNGcm9tQXJyb3coYm91bmRzLCBlbGUsICdtaWQtdGFyZ2V0Jywgb3B0aW9ucyk7XG4gICAgICB1cGRhdGVCb3VuZHNGcm9tQXJyb3coYm91bmRzLCBlbGUsICdzb3VyY2UnLCBvcHRpb25zKTtcbiAgICAgIHVwZGF0ZUJvdW5kc0Zyb21BcnJvdyhib3VuZHMsIGVsZSwgJ3RhcmdldCcsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8vIGdob3N0XG4gICAgLy8vLy8vLy9cblxuICAgIGlmIChzdHlsZUVuYWJsZWQpIHtcbiAgICAgIHZhciBnaG9zdCA9IGVsZS5wc3R5bGUoJ2dob3N0JykudmFsdWUgPT09ICd5ZXMnO1xuXG4gICAgICBpZiAoZ2hvc3QpIHtcbiAgICAgICAgdmFyIGd4ID0gZWxlLnBzdHlsZSgnZ2hvc3Qtb2Zmc2V0LXgnKS5wZlZhbHVlO1xuICAgICAgICB2YXIgZ3kgPSBlbGUucHN0eWxlKCdnaG9zdC1vZmZzZXQteScpLnBmVmFsdWU7XG5cbiAgICAgICAgdXBkYXRlQm91bmRzKGJvdW5kcywgYm91bmRzLngxICsgZ3gsIGJvdW5kcy55MSArIGd5LCBib3VuZHMueDIgKyBneCwgYm91bmRzLnkyICsgZ3kpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIG92ZXJsYXlcbiAgICAvLy8vLy8vLy8vXG5cbiAgICBpZiAoc3R5bGVFbmFibGVkKSB7XG5cbiAgICAgIGV4MSA9IGJvdW5kcy54MTtcbiAgICAgIGV4MiA9IGJvdW5kcy54MjtcbiAgICAgIGV5MSA9IGJvdW5kcy55MTtcbiAgICAgIGV5MiA9IGJvdW5kcy55MjtcblxuICAgICAgdXBkYXRlQm91bmRzKGJvdW5kcywgZXgxIC0gb3ZlcmxheVBhZGRpbmcsIGV5MSAtIG92ZXJsYXlQYWRkaW5nLCBleDIgKyBvdmVybGF5UGFkZGluZywgZXkyICsgb3ZlcmxheVBhZGRpbmcpO1xuICAgIH1cblxuICAgIC8vIGhhbmRsZSBsYWJlbCBkaW1lbnNpb25zXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgIGlmIChzdHlsZUVuYWJsZWQgJiYgb3B0aW9ucy5pbmNsdWRlTGFiZWxzKSB7XG4gICAgICB1cGRhdGVCb3VuZHNGcm9tTGFiZWwoYm91bmRzLCBlbGUsIG51bGwsIG9wdGlvbnMpO1xuXG4gICAgICBpZiAoaXNFZGdlKSB7XG4gICAgICAgIHVwZGF0ZUJvdW5kc0Zyb21MYWJlbChib3VuZHMsIGVsZSwgJ3NvdXJjZScsIG9wdGlvbnMpO1xuICAgICAgICB1cGRhdGVCb3VuZHNGcm9tTGFiZWwoYm91bmRzLCBlbGUsICd0YXJnZXQnLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9IC8vIHN0eWxlIGVuYWJsZWQgZm9yIGxhYmVsc1xuICB9IC8vIGlmIGRpc3BsYXllZFxuXG4gIGJvdW5kcy54MSA9IG5vbmluZihib3VuZHMueDEpO1xuICBib3VuZHMueTEgPSBub25pbmYoYm91bmRzLnkxKTtcbiAgYm91bmRzLngyID0gbm9uaW5mKGJvdW5kcy54Mik7XG4gIGJvdW5kcy55MiA9IG5vbmluZihib3VuZHMueTIpO1xuICBib3VuZHMudyA9IG5vbmluZihib3VuZHMueDIgLSBib3VuZHMueDEpO1xuICBib3VuZHMuaCA9IG5vbmluZihib3VuZHMueTIgLSBib3VuZHMueTEpO1xuXG4gIC8vIGV4cGFuZCBib3VuZHMgYnkgMSBiZWNhdXNlIGFudGlhbGlhc2luZyBjYW4gaW5jcmVhc2UgdGhlIHZpc3VhbC9lZmZlY3RpdmUgc2l6ZSBieSAxIG9uIGFsbCBzaWRlc1xuICBpZiAoYm91bmRzLncgPiAwICYmIGJvdW5kcy5oID4gMCAmJiBkaXNwbGF5ZWQpIHtcbiAgICBtYXRoLmV4cGFuZEJvdW5kaW5nQm94KGJvdW5kcywgMSk7XG4gIH1cblxuICByZXR1cm4gYm91bmRzO1xufTtcblxudmFyIHRmID0gZnVuY3Rpb24gdGYodmFsKSB7XG4gIGlmICh2YWwpIHtcbiAgICByZXR1cm4gJ3QnO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAnZic7XG4gIH1cbn07XG5cbnZhciBnZXRLZXkgPSBmdW5jdGlvbiBnZXRLZXkob3B0cykge1xuICB2YXIga2V5ID0gJyc7XG5cbiAga2V5ICs9IHRmKG9wdHMuaW5jdWRlTm9kZXMpO1xuICBrZXkgKz0gdGYob3B0cy5pbmNsdWRlRWRnZXMpO1xuICBrZXkgKz0gdGYob3B0cy5pbmNsdWRlTGFiZWxzKTtcbiAga2V5ICs9IHRmKG9wdHMuaW5jbHVkZU92ZXJsYXlzKTtcblxuICByZXR1cm4ga2V5O1xufTtcblxudmFyIGNhY2hlZEJvdW5kaW5nQm94SW1wbCA9IGZ1bmN0aW9uIGNhY2hlZEJvdW5kaW5nQm94SW1wbChlbGUsIG9wdHMpIHtcbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICB2YXIgYmIgPSB2b2lkIDA7XG4gIHZhciBoZWFkbGVzcyA9IGVsZS5jeSgpLmhlYWRsZXNzKCk7XG4gIHZhciBrZXkgPSBvcHRzID09PSBkZWZCYk9wdHMgPyBkZWZCYk9wdHNLZXkgOiBnZXRLZXkob3B0cyk7XG5cbiAgaWYgKCFvcHRzLnVzZUNhY2hlIHx8IGhlYWRsZXNzIHx8ICFfcC5iYkNhY2hlIHx8ICFfcC5iYkNhY2hlW2tleV0pIHtcbiAgICBiYiA9IGJvdW5kaW5nQm94SW1wbChlbGUsIG9wdHMpO1xuXG4gICAgaWYgKCFoZWFkbGVzcykge1xuICAgICAgX3AuYmJDYWNoZSA9IF9wLmJiQ2FjaGUgfHwge307XG4gICAgICBfcC5iYkNhY2hlW2tleV0gPSBiYjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYmIgPSBfcC5iYkNhY2hlW2tleV07XG4gIH1cblxuICByZXR1cm4gYmI7XG59O1xuXG52YXIgZGVmQmJPcHRzID0ge1xuICBpbmNsdWRlTm9kZXM6IHRydWUsXG4gIGluY2x1ZGVFZGdlczogdHJ1ZSxcbiAgaW5jbHVkZUxhYmVsczogdHJ1ZSxcbiAgaW5jbHVkZU92ZXJsYXlzOiB0cnVlLFxuICB1c2VDYWNoZTogdHJ1ZVxufTtcblxudmFyIGRlZkJiT3B0c0tleSA9IGdldEtleShkZWZCYk9wdHMpO1xuXG5mdW5jdGlvbiBmaWxsZWRCYk9wdHMob3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIGluY2x1ZGVOb2RlczogdXRpbC5kZWZhdWx0KG9wdGlvbnMuaW5jbHVkZU5vZGVzLCBkZWZCYk9wdHMuaW5jbHVkZU5vZGVzKSxcbiAgICBpbmNsdWRlRWRnZXM6IHV0aWwuZGVmYXVsdChvcHRpb25zLmluY2x1ZGVFZGdlcywgZGVmQmJPcHRzLmluY2x1ZGVFZGdlcyksXG4gICAgaW5jbHVkZUxhYmVsczogdXRpbC5kZWZhdWx0KG9wdGlvbnMuaW5jbHVkZUxhYmVscywgZGVmQmJPcHRzLmluY2x1ZGVMYWJlbHMpLFxuICAgIGluY2x1ZGVPdmVybGF5czogdXRpbC5kZWZhdWx0KG9wdGlvbnMuaW5jbHVkZU92ZXJsYXlzLCBkZWZCYk9wdHMuaW5jbHVkZU92ZXJsYXlzKSxcbiAgICB1c2VDYWNoZTogdXRpbC5kZWZhdWx0KG9wdGlvbnMudXNlQ2FjaGUsIGRlZkJiT3B0cy51c2VDYWNoZSlcbiAgfTtcbn1cblxuZWxlc2ZuLmJvdW5kaW5nQm94ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgLy8gdGhlIG1haW4gdXNlY2FzZSBpcyBlbGUuYm91bmRpbmdCb3goKSBmb3IgYSBzaW5nbGUgZWxlbWVudCB3aXRoIG5vL2RlZiBvcHRpb25zXG4gIC8vIHNwZWNpZmllZCBzLnQuIHRoZSBjYWNoZSBpcyB1c2VkLCBzbyBjaGVjayBmb3IgdGhpcyBjYXNlIHRvIG1ha2UgaXQgZmFzdGVyIGJ5XG4gIC8vIGF2b2lkaW5nIHRoZSBvdmVyaGVhZCBvZiB0aGUgcmVzdCBvZiB0aGUgZnVuY3Rpb25cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXNbMF0uX3ByaXZhdGUuYmJDYWNoZSAmJiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMudXNlQ2FjaGUgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLnVzZUNhY2hlID09PSB0cnVlKSkge1xuICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdGlvbnMgPSBkZWZCYk9wdHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMgPSBmaWxsZWRCYk9wdHMob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhY2hlZEJvdW5kaW5nQm94SW1wbCh0aGlzWzBdLCBvcHRpb25zKTtcbiAgfVxuXG4gIHZhciBib3VuZHMgPSB7XG4gICAgeDE6IEluZmluaXR5LFxuICAgIHkxOiBJbmZpbml0eSxcbiAgICB4MjogLUluZmluaXR5LFxuICAgIHkyOiAtSW5maW5pdHlcbiAgfTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB1dGlsLnN0YXRpY0VtcHR5T2JqZWN0KCk7XG5cbiAgdmFyIG9wdHMgPSBmaWxsZWRCYk9wdHMob3B0aW9ucyk7XG5cbiAgdmFyIGVsZXMgPSB0aGlzO1xuICB2YXIgY3kgPSBlbGVzLmN5KCk7XG4gIHZhciBzdHlsZUVuYWJsZWQgPSBjeS5zdHlsZUVuYWJsZWQoKTtcblxuICBpZiAoc3R5bGVFbmFibGVkKSB7XG4gICAgdGhpcy5yZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGUob3B0cy51c2VDYWNoZSk7XG4gIH1cblxuICB0aGlzLnVwZGF0ZUNvbXBvdW5kQm91bmRzKCk7XG5cbiAgdmFyIHVwZGF0ZWRFZGdlID0ge307IC8vIHVzZSB0byBhdm9pZCBkdXBsaWNhdGVkIGVkZ2UgdXBkYXRlc1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuXG4gICAgaWYgKHN0eWxlRW5hYmxlZCAmJiBlbGUuaXNFZGdlKCkgJiYgZWxlLnBzdHlsZSgnY3VydmUtc3R5bGUnKS5zdHJWYWx1ZSA9PT0gJ2JlemllcicgJiYgIXVwZGF0ZWRFZGdlW2VsZS5pZCgpXSkge1xuICAgICAgdmFyIGVkZ2VzID0gZWxlLnBhcmFsbGVsRWRnZXMoKTtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBlZGdlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAvLyBtYWtlIGFsbCBhcyB1cGRhdGVkXG4gICAgICAgIHVwZGF0ZWRFZGdlW2VkZ2VzW2pdLmlkKCldID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgZWRnZXMucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlKG9wdHMudXNlQ2FjaGUpOyAvLyBuLmIuIGVsZS5wYXJhbGxlbEVkZ2VzKCkgc2luZ2xlIGlzIGNhY2hlZFxuICAgIH1cblxuICAgIHVwZGF0ZUJvdW5kc0Zyb21Cb3goYm91bmRzLCBjYWNoZWRCb3VuZGluZ0JveEltcGwoZWxlLCBvcHRzKSk7XG4gIH1cblxuICBib3VuZHMueDEgPSBub25pbmYoYm91bmRzLngxKTtcbiAgYm91bmRzLnkxID0gbm9uaW5mKGJvdW5kcy55MSk7XG4gIGJvdW5kcy54MiA9IG5vbmluZihib3VuZHMueDIpO1xuICBib3VuZHMueTIgPSBub25pbmYoYm91bmRzLnkyKTtcbiAgYm91bmRzLncgPSBub25pbmYoYm91bmRzLngyIC0gYm91bmRzLngxKTtcbiAgYm91bmRzLmggPSBub25pbmYoYm91bmRzLnkyIC0gYm91bmRzLnkxKTtcblxuICByZXR1cm4gYm91bmRzO1xufTtcblxuLy8gcHJpdmF0ZSBoZWxwZXIgdG8gZ2V0IGJvdW5kaW5nIGJveCBmb3IgY3VzdG9tIG5vZGUgcG9zaXRpb25zXG4vLyAtIGdvb2QgZm9yIHBlcmYgaW4gY2VydGFpbiBjYXNlcyBidXQgY3VycmVudGx5IHJlcXVpcmVzIGRpcnR5aW5nIHRoZSByZW5kZXJlZCBzdHlsZVxuLy8gLSB3b3VsZCBiZSBiZXR0ZXIgdG8gbm90IG1vZGlmeSB0aGUgbm9kZXMgYnV0IHRoZSBub2RlcyBhcmUgcmVhZCBkaXJlY3RseSBldmVyeXdoZXJlIGluIHRoZSByZW5kZXJlci4uLlxuLy8gLSB0cnkgdG8gdXNlIGZvciBvbmx5IHRoaW5ncyBsaWtlIGRpc2NyZXRlIGxheW91dHMgd2hlcmUgdGhlIG5vZGUgcG9zaXRpb24gd291bGQgY2hhbmdlIGFueXdheVxuZWxlc2ZuLmJvdW5kaW5nQm94QXQgPSBmdW5jdGlvbiAoZm4pIHtcbiAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuXG4gIGlmIChpcy5wbGFpbk9iamVjdChmbikpIHtcbiAgICB2YXIgb2JqID0gZm47XG5cbiAgICBmbiA9IGZ1bmN0aW9uIGZuKCkge1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuICB9XG5cbiAgLy8gc2F2ZSB0aGUgY3VycmVudCBwb3NpdGlvbiBhbmQgc2V0IHRoZSBuZXcgb25lLCBwZXIgbm9kZVxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG4gPSBub2Rlc1tpXTtcbiAgICB2YXIgX3AgPSBuLl9wcml2YXRlO1xuICAgIHZhciBwb3MgPSBfcC5wb3NpdGlvbjtcbiAgICB2YXIgbmV3UG9zID0gZm4uY2FsbChuLCBuLCBpKTtcblxuICAgIF9wLmJiQXRPbGRQb3MgPSB7IHg6IHBvcy54LCB5OiBwb3MueSB9O1xuXG4gICAgaWYgKG5ld1Bvcykge1xuICAgICAgcG9zLnggPSBuZXdQb3MueDtcbiAgICAgIHBvcy55ID0gbmV3UG9zLnk7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5lbWl0KCdkaXJ0eScpOyAvLyBsZXQgdGhlIHJlbmRlcmVyIGtub3cgd2UndmUgbWFudWFsbHkgZGlydGllZCByZW5kZXJlZCBkaW0gY2FsY3NcblxuICBub2Rlcy5kaXJ0eUNvbXBvdW5kQm91bmRzQ2FjaGUoKS51cGRhdGVDb21wb3VuZEJvdW5kcygpO1xuXG4gIHZhciBiYiA9IHRoaXMuYm91bmRpbmdCb3goeyB1c2VDYWNoZTogZmFsc2UgfSk7XG5cbiAgLy8gcmVzdG9yZSB0aGUgb3JpZ2luYWwgcG9zaXRpb24sIHBlciBub2RlXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBub2Rlcy5sZW5ndGg7IF9pKyspIHtcbiAgICB2YXIgX24gPSBub2Rlc1tfaV07XG4gICAgdmFyIF9wMiA9IF9uLl9wcml2YXRlO1xuICAgIHZhciBfcG9zID0gX24uX3ByaXZhdGUucG9zaXRpb247XG4gICAgdmFyIG9sZCA9IF9wMi5iYkF0T2xkUG9zO1xuXG4gICAgX3Bvcy54ID0gb2xkLng7XG4gICAgX3Bvcy55ID0gb2xkLnk7XG4gIH1cblxuICBub2Rlcy5kaXJ0eUNvbXBvdW5kQm91bmRzQ2FjaGUoKTtcblxuICB0aGlzLmVtaXQoJ2RpcnR5Jyk7IC8vIGxldCB0aGUgcmVuZGVyZXIga25vdyB3ZSd2ZSBtYW51YWxseSBkaXJ0aWVkIHJlbmRlcmVkIGRpbSBjYWxjc1xuXG4gIHJldHVybiBiYjtcbn07XG5cbmZuLmJvdW5kaW5nYm94ID0gZm4uYm91bmRpbmdCb3g7XG5mbi5yZW5kZXJlZEJvdW5kaW5nYm94ID0gZm4ucmVuZGVyZWRCb3VuZGluZ0JveDtcblxubW9kdWxlLmV4cG9ydHMgPSBlbGVzZm47XG5cbi8qKiovIH0pLFxuLyogNTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xudmFyIGZuID0gdm9pZCAwLFxuICAgIGVsZXNmbiA9IHZvaWQgMDtcblxuZm4gPSBlbGVzZm4gPSB7fTtcblxudmFyIGRlZmluZURpbUZucyA9IGZ1bmN0aW9uIGRlZmluZURpbUZucyhvcHRzKSB7XG4gIG9wdHMudXBwZXJjYXNlTmFtZSA9IHV0aWwuY2FwaXRhbGl6ZShvcHRzLm5hbWUpO1xuICBvcHRzLmF1dG9OYW1lID0gJ2F1dG8nICsgb3B0cy51cHBlcmNhc2VOYW1lO1xuICBvcHRzLmxhYmVsTmFtZSA9ICdsYWJlbCcgKyBvcHRzLnVwcGVyY2FzZU5hbWU7XG4gIG9wdHMub3V0ZXJOYW1lID0gJ291dGVyJyArIG9wdHMudXBwZXJjYXNlTmFtZTtcbiAgb3B0cy51cHBlcmNhc2VPdXRlck5hbWUgPSB1dGlsLmNhcGl0YWxpemUob3B0cy5vdXRlck5hbWUpO1xuXG4gIGZuW29wdHMubmFtZV0gPSBmdW5jdGlvbiBkaW1JbXBsKCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICB2YXIgY3kgPSBfcC5jeTtcbiAgICB2YXIgc3R5bGVFbmFibGVkID0gY3kuX3ByaXZhdGUuc3R5bGVFbmFibGVkO1xuXG4gICAgaWYgKGVsZSkge1xuICAgICAgaWYgKHN0eWxlRW5hYmxlZCkge1xuICAgICAgICBpZiAoZWxlLmlzUGFyZW50KCkpIHtcbiAgICAgICAgICBlbGUudXBkYXRlQ29tcG91bmRCb3VuZHMoKTtcblxuICAgICAgICAgIHJldHVybiBfcFtvcHRzLmF1dG9OYW1lXSB8fCAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGQgPSBlbGUucHN0eWxlKG9wdHMubmFtZSk7XG5cbiAgICAgICAgc3dpdGNoIChkLnN0clZhbHVlKSB7XG4gICAgICAgICAgY2FzZSAnbGFiZWwnOlxuICAgICAgICAgICAgZWxlLnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZSgpO1xuXG4gICAgICAgICAgICByZXR1cm4gX3AucnN0eWxlW29wdHMubGFiZWxOYW1lXSB8fCAwO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBkLnBmVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmblsnb3V0ZXInICsgb3B0cy51cHBlcmNhc2VOYW1lXSA9IGZ1bmN0aW9uIG91dGVyRGltSW1wbCgpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgdmFyIGN5ID0gX3AuY3k7XG4gICAgdmFyIHN0eWxlRW5hYmxlZCA9IGN5Ll9wcml2YXRlLnN0eWxlRW5hYmxlZDtcblxuICAgIGlmIChlbGUpIHtcbiAgICAgIGlmIChzdHlsZUVuYWJsZWQpIHtcbiAgICAgICAgdmFyIGRpbSA9IGVsZVtvcHRzLm5hbWVdKCk7XG4gICAgICAgIHZhciBib3JkZXIgPSBlbGUucHN0eWxlKCdib3JkZXItd2lkdGgnKS5wZlZhbHVlOyAvLyBuLmIuIDEvMiBlYWNoIHNpZGVcbiAgICAgICAgdmFyIHBhZGRpbmcgPSAyICogZWxlLnBhZGRpbmcoKTtcblxuICAgICAgICByZXR1cm4gZGltICsgYm9yZGVyICsgcGFkZGluZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmblsncmVuZGVyZWQnICsgb3B0cy51cHBlcmNhc2VOYW1lXSA9IGZ1bmN0aW9uIHJlbmRlcmVkRGltSW1wbCgpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgIGlmIChlbGUpIHtcbiAgICAgIHZhciBkID0gZWxlW29wdHMubmFtZV0oKTtcbiAgICAgIHJldHVybiBkICogdGhpcy5jeSgpLnpvb20oKTtcbiAgICB9XG4gIH07XG5cbiAgZm5bJ3JlbmRlcmVkJyArIG9wdHMudXBwZXJjYXNlT3V0ZXJOYW1lXSA9IGZ1bmN0aW9uIHJlbmRlcmVkT3V0ZXJEaW1JbXBsKCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgaWYgKGVsZSkge1xuICAgICAgdmFyIG9kID0gZWxlW29wdHMub3V0ZXJOYW1lXSgpO1xuICAgICAgcmV0dXJuIG9kICogdGhpcy5jeSgpLnpvb20oKTtcbiAgICB9XG4gIH07XG59O1xuXG5kZWZpbmVEaW1GbnMoe1xuICBuYW1lOiAnd2lkdGgnXG59KTtcblxuZGVmaW5lRGltRm5zKHtcbiAgbmFtZTogJ2hlaWdodCdcbn0pO1xuXG5lbGVzZm4ucGFkZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVsZSA9IHRoaXNbMF07XG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgaWYgKGVsZS5pc1BhcmVudCgpKSB7XG4gICAgZWxlLnVwZGF0ZUNvbXBvdW5kQm91bmRzKCk7XG5cbiAgICBpZiAoX3AuYXV0b1BhZGRpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIF9wLmF1dG9QYWRkaW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZWxlLnBzdHlsZSgncGFkZGluZycpLnBmVmFsdWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBlbGUucHN0eWxlKCdwYWRkaW5nJykucGZWYWx1ZTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbGVzZm47XG5cbi8qKiovIH0pLFxuLyogNjAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGlmRWRnZSA9IGZ1bmN0aW9uIGlmRWRnZShzZWxmLCB0aGVuKSB7XG4gIGlmIChzZWxmLmlzRWRnZSgpKSB7XG4gICAgcmV0dXJuIHRoZW4oc2VsZi5yZW5kZXJlcigpKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvbnRyb2xQb2ludHM6IGZ1bmN0aW9uIGNvbnRyb2xQb2ludHMoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHJldHVybiBpZkVkZ2UodGhpcywgZnVuY3Rpb24gKHJlbmRlcmVyKSB7XG4gICAgICByZXR1cm4gcmVuZGVyZXIuZ2V0Q29udHJvbFBvaW50cyhfdGhpcyk7XG4gICAgfSk7XG4gIH0sXG4gIHNlZ21lbnRQb2ludHM6IGZ1bmN0aW9uIHNlZ21lbnRQb2ludHMoKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICByZXR1cm4gaWZFZGdlKHRoaXMsIGZ1bmN0aW9uIChyZW5kZXJlcikge1xuICAgICAgcmV0dXJuIHJlbmRlcmVyLmdldFNlZ21lbnRQb2ludHMoX3RoaXMyKTtcbiAgICB9KTtcbiAgfSxcbiAgc291cmNlRW5kcG9pbnQ6IGZ1bmN0aW9uIHNvdXJjZUVuZHBvaW50KCkge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgcmV0dXJuIGlmRWRnZSh0aGlzLCBmdW5jdGlvbiAocmVuZGVyZXIpIHtcbiAgICAgIHJldHVybiByZW5kZXJlci5nZXRTb3VyY2VFbmRwb2ludChfdGhpczMpO1xuICAgIH0pO1xuICB9LFxuICB0YXJnZXRFbmRwb2ludDogZnVuY3Rpb24gdGFyZ2V0RW5kcG9pbnQoKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICByZXR1cm4gaWZFZGdlKHRoaXMsIGZ1bmN0aW9uIChyZW5kZXJlcikge1xuICAgICAgcmV0dXJuIHJlbmRlcmVyLmdldFRhcmdldEVuZHBvaW50KF90aGlzNCk7XG4gICAgfSk7XG4gIH0sXG4gIG1pZHBvaW50OiBmdW5jdGlvbiBtaWRwb2ludCgpIHtcbiAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgIHJldHVybiBpZkVkZ2UodGhpcywgZnVuY3Rpb24gKHJlbmRlcmVyKSB7XG4gICAgICByZXR1cm4gcmVuZGVyZXIuZ2V0RWRnZU1pZHBvaW50KF90aGlzNSk7XG4gICAgfSk7XG4gIH1cbn07XG5cbi8qKiovIH0pLFxuLyogNjEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIEVtaXR0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcbnZhciBkZWZpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xudmFyIGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbnZhciBTZWxlY3RvciA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cbnZhciBlbWl0dGVyT3B0aW9ucyA9IHtcbiAgcXVhbGlmaWVyQ29tcGFyZTogZnVuY3Rpb24gcXVhbGlmaWVyQ29tcGFyZShzZWxlY3RvcjEsIHNlbGVjdG9yMikge1xuICAgIGlmIChzZWxlY3RvcjEgPT0gbnVsbCB8fCBzZWxlY3RvcjIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHNlbGVjdG9yMSA9PSBudWxsICYmIHNlbGVjdG9yMiA9PSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc2VsZWN0b3IxLnNhbWVUZXh0KHNlbGVjdG9yMik7XG4gICAgfVxuICB9LFxuICBldmVudE1hdGNoZXM6IGZ1bmN0aW9uIGV2ZW50TWF0Y2hlcyhlbGUsIGxpc3RlbmVyLCBldmVudE9iaikge1xuICAgIHZhciBzZWxlY3RvciA9IGxpc3RlbmVyLnF1YWxpZmllcjtcblxuICAgIGlmIChzZWxlY3RvciAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gZWxlICE9PSBldmVudE9iai50YXJnZXQgJiYgaXMuZWxlbWVudChldmVudE9iai50YXJnZXQpICYmIHNlbGVjdG9yLm1hdGNoZXMoZXZlbnRPYmoudGFyZ2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgZXZlbnRGaWVsZHM6IGZ1bmN0aW9uIGV2ZW50RmllbGRzKGVsZSkge1xuICAgIHJldHVybiB7XG4gICAgICBjeTogZWxlLmN5KCksXG4gICAgICB0YXJnZXQ6IGVsZVxuICAgIH07XG4gIH0sXG4gIGNhbGxiYWNrQ29udGV4dDogZnVuY3Rpb24gY2FsbGJhY2tDb250ZXh0KGVsZSwgbGlzdGVuZXIsIGV2ZW50T2JqKSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyLnF1YWxpZmllciAhPSBudWxsID8gZXZlbnRPYmoudGFyZ2V0IDogZWxlO1xuICB9LFxuICBiZWZvcmVFbWl0OiBmdW5jdGlvbiBiZWZvcmVFbWl0KGNvbnRleHQsIGxpc3RlbmVyIC8qLCBldmVudE9iaiovKSB7XG4gICAgaWYgKGxpc3RlbmVyLmNvbmYgJiYgbGlzdGVuZXIuY29uZi5vbmNlKSB7XG4gICAgICBsaXN0ZW5lci5jb25mLm9uY2VDb2xsZWN0aW9uLnJlbW92ZUxpc3RlbmVyKGxpc3RlbmVyLmV2ZW50LCBsaXN0ZW5lci5xdWFsaWZpZXIsIGxpc3RlbmVyLmNhbGxiYWNrKTtcbiAgICB9XG4gIH0sXG4gIGJ1YmJsZTogZnVuY3Rpb24gYnViYmxlKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBwYXJlbnQ6IGZ1bmN0aW9uIHBhcmVudChlbGUpIHtcbiAgICByZXR1cm4gZWxlLmlzQ2hpbGQoKSA/IGVsZS5wYXJlbnQoKSA6IGVsZS5jeSgpO1xuICB9XG59O1xuXG52YXIgYXJnU2VsZWN0b3IgPSBmdW5jdGlvbiBhcmdTZWxlY3RvcihhcmcpIHtcbiAgaWYgKGlzLnN0cmluZyhhcmcpKSB7XG4gICAgcmV0dXJuIG5ldyBTZWxlY3RvcihhcmcpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhcmc7XG4gIH1cbn07XG5cbnZhciBlbGVzZm4gPSB7XG4gIGNyZWF0ZUVtaXR0ZXI6IGZ1bmN0aW9uIGNyZWF0ZUVtaXR0ZXIoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcblxuICAgICAgaWYgKCFfcC5lbWl0dGVyKSB7XG4gICAgICAgIF9wLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcih1dGlsLmFzc2lnbih7XG4gICAgICAgICAgY29udGV4dDogZWxlXG4gICAgICAgIH0sIGVtaXR0ZXJPcHRpb25zKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgZW1pdHRlcjogZnVuY3Rpb24gZW1pdHRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5lbWl0dGVyO1xuICB9LFxuXG4gIG9uOiBmdW5jdGlvbiBvbihldmVudHMsIHNlbGVjdG9yLCBjYWxsYmFjaykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG5cbiAgICAgIGVsZS5lbWl0dGVyKCkub24oZXZlbnRzLCBhcmdTZWxlY3RvcihzZWxlY3RvciksIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICByZW1vdmVMaXN0ZW5lcjogZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZXZlbnRzLCBzZWxlY3RvciwgY2FsbGJhY2spIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuXG4gICAgICBlbGUuZW1pdHRlcigpLnJlbW92ZUxpc3RlbmVyKGV2ZW50cywgYXJnU2VsZWN0b3Ioc2VsZWN0b3IpLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgb25lOiBmdW5jdGlvbiBvbmUoZXZlbnRzLCBzZWxlY3RvciwgY2FsbGJhY2spIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuXG4gICAgICBlbGUuZW1pdHRlcigpLm9uZShldmVudHMsIGFyZ1NlbGVjdG9yKHNlbGVjdG9yKSwgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIG9uY2U6IGZ1bmN0aW9uIG9uY2UoZXZlbnRzLCBzZWxlY3RvciwgY2FsbGJhY2spIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuXG4gICAgICBlbGUuZW1pdHRlcigpLm9uKGV2ZW50cywgYXJnU2VsZWN0b3Ioc2VsZWN0b3IpLCBjYWxsYmFjaywge1xuICAgICAgICBvbmNlOiB0cnVlLFxuICAgICAgICBvbmNlQ29sbGVjdGlvbjogdGhpc1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIGVtaXQ6IGZ1bmN0aW9uIGVtaXQoZXZlbnRzLCBleHRyYVBhcmFtcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG5cbiAgICAgIGVsZS5lbWl0dGVyKCkuZW1pdChldmVudHMsIGV4dHJhUGFyYW1zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBlbWl0QW5kTm90aWZ5OiBmdW5jdGlvbiBlbWl0QW5kTm90aWZ5KGV2ZW50LCBleHRyYVBhcmFtcykge1xuICAgIC8vIGZvciBpbnRlcm5hbCB1c2Ugb25seVxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gZW1wdHkgY29sbGVjdGlvbnMgZG9uJ3QgbmVlZCB0byBub3RpZnkgYW55dGhpbmdcblxuICAgIC8vIG5vdGlmeSByZW5kZXJlclxuICAgIHRoaXMuY3koKS5ub3RpZnkoe1xuICAgICAgdHlwZTogZXZlbnQsXG4gICAgICBlbGVzOiB0aGlzXG4gICAgfSk7XG5cbiAgICB0aGlzLmVtaXQoZXZlbnQsIGV4dHJhUGFyYW1zKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59O1xuXG5kZWZpbmUuZXZlbnRBbGlhc2VzT24oZWxlc2ZuKTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbGVzZm47XG5cbi8qKiovIH0pLFxuLyogNjIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBTZWxlY3RvciA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cbnZhciBlbGVzZm4gPSB7XG4gIG5vZGVzOiBmdW5jdGlvbiBub2RlcyhzZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbiAoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLmlzTm9kZSgpO1xuICAgIH0pLmZpbHRlcihzZWxlY3Rvcik7XG4gIH0sXG5cbiAgZWRnZXM6IGZ1bmN0aW9uIGVkZ2VzKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuaXNFZGdlKCk7XG4gICAgfSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfSxcblxuICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihfZmlsdGVyLCB0aGlzQXJnKSB7XG4gICAgaWYgKF9maWx0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gY2hlY2sgdGhpcyBmaXJzdCBiL2MgaXQncyB0aGUgbW9zdCBjb21tb24vcGVyZm9ybWFudCBjYXNlXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2UgaWYgKGlzLnN0cmluZyhfZmlsdGVyKSB8fCBpcy5lbGVtZW50T3JDb2xsZWN0aW9uKF9maWx0ZXIpKSB7XG4gICAgICByZXR1cm4gbmV3IFNlbGVjdG9yKF9maWx0ZXIpLmZpbHRlcih0aGlzKTtcbiAgICB9IGVsc2UgaWYgKGlzLmZuKF9maWx0ZXIpKSB7XG4gICAgICB2YXIgZmlsdGVyRWxlcyA9IHRoaXMuc3Bhd24oKTtcbiAgICAgIHZhciBlbGVzID0gdGhpcztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICB2YXIgaW5jbHVkZSA9IHRoaXNBcmcgPyBfZmlsdGVyLmFwcGx5KHRoaXNBcmcsIFtlbGUsIGksIGVsZXNdKSA6IF9maWx0ZXIoZWxlLCBpLCBlbGVzKTtcblxuICAgICAgICBpZiAoaW5jbHVkZSkge1xuICAgICAgICAgIGZpbHRlckVsZXMubWVyZ2UoZWxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmlsdGVyRWxlcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zcGF3bigpOyAvLyBpZiBub3QgaGFuZGxlZCBieSBhYm92ZSwgZ2l2ZSAnZW0gYW4gZW1wdHkgY29sbGVjdGlvblxuICB9LFxuXG4gIG5vdDogZnVuY3Rpb24gbm90KHRvUmVtb3ZlKSB7XG4gICAgaWYgKCF0b1JlbW92ZSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcblxuICAgICAgaWYgKGlzLnN0cmluZyh0b1JlbW92ZSkpIHtcbiAgICAgICAgdG9SZW1vdmUgPSB0aGlzLmZpbHRlcih0b1JlbW92ZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbGVtZW50cyA9IFtdO1xuICAgICAgdmFyIHJNYXAgPSB0b1JlbW92ZS5fcHJpdmF0ZS5tYXA7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXNbaV07XG5cbiAgICAgICAgdmFyIHJlbW92ZSA9IHJNYXAuaGFzKGVsZW1lbnQuaWQoKSk7XG4gICAgICAgIGlmICghcmVtb3ZlKSB7XG4gICAgICAgICAgZWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5zcGF3bihlbGVtZW50cyk7XG4gICAgfVxuICB9LFxuXG4gIGFic29sdXRlQ29tcGxlbWVudDogZnVuY3Rpb24gYWJzb2x1dGVDb21wbGVtZW50KCkge1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICAgIHJldHVybiBjeS5tdXRhYmxlRWxlbWVudHMoKS5ub3QodGhpcyk7XG4gIH0sXG5cbiAgaW50ZXJzZWN0OiBmdW5jdGlvbiBpbnRlcnNlY3Qob3RoZXIpIHtcbiAgICAvLyBpZiBhIHNlbGVjdG9yIGlzIHNwZWNpZmllZCwgdGhlbiBmaWx0ZXIgYnkgaXQgaW5zdGVhZFxuICAgIGlmIChpcy5zdHJpbmcob3RoZXIpKSB7XG4gICAgICB2YXIgc2VsZWN0b3IgPSBvdGhlcjtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihzZWxlY3Rvcik7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnRzID0gW107XG4gICAgdmFyIGNvbDEgPSB0aGlzO1xuICAgIHZhciBjb2wyID0gb3RoZXI7XG4gICAgdmFyIGNvbDFTbWFsbGVyID0gdGhpcy5sZW5ndGggPCBvdGhlci5sZW5ndGg7XG4gICAgdmFyIG1hcDIgPSBjb2wxU21hbGxlciA/IGNvbDIuX3ByaXZhdGUubWFwIDogY29sMS5fcHJpdmF0ZS5tYXA7XG4gICAgdmFyIGNvbCA9IGNvbDFTbWFsbGVyID8gY29sMSA6IGNvbDI7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlkID0gY29sW2ldLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICB2YXIgZW50cnkgPSBtYXAyLmdldChpZCk7XG5cbiAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICBlbGVtZW50cy5wdXNoKGVudHJ5LmVsZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oZWxlbWVudHMpO1xuICB9LFxuXG4gIHhvcjogZnVuY3Rpb24geG9yKG90aGVyKSB7XG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcblxuICAgIGlmIChpcy5zdHJpbmcob3RoZXIpKSB7XG4gICAgICBvdGhlciA9IGN5LiQob3RoZXIpO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50cyA9IFtdO1xuICAgIHZhciBjb2wxID0gdGhpcztcbiAgICB2YXIgY29sMiA9IG90aGVyO1xuXG4gICAgdmFyIGFkZCA9IGZ1bmN0aW9uIGFkZChjb2wsIG90aGVyKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gY29sW2ldO1xuICAgICAgICB2YXIgaWQgPSBlbGUuX3ByaXZhdGUuZGF0YS5pZDtcbiAgICAgICAgdmFyIGluT3RoZXIgPSBvdGhlci5oYXNFbGVtZW50V2l0aElkKGlkKTtcblxuICAgICAgICBpZiAoIWluT3RoZXIpIHtcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKGVsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgYWRkKGNvbDEsIGNvbDIpO1xuICAgIGFkZChjb2wyLCBjb2wxKTtcblxuICAgIHJldHVybiB0aGlzLnNwYXduKGVsZW1lbnRzKTtcbiAgfSxcblxuICBkaWZmOiBmdW5jdGlvbiBkaWZmKG90aGVyKSB7XG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcblxuICAgIGlmIChpcy5zdHJpbmcob3RoZXIpKSB7XG4gICAgICBvdGhlciA9IGN5LiQob3RoZXIpO1xuICAgIH1cblxuICAgIHZhciBsZWZ0ID0gW107XG4gICAgdmFyIHJpZ2h0ID0gW107XG4gICAgdmFyIGJvdGggPSBbXTtcbiAgICB2YXIgY29sMSA9IHRoaXM7XG4gICAgdmFyIGNvbDIgPSBvdGhlcjtcblxuICAgIHZhciBhZGQgPSBmdW5jdGlvbiBhZGQoY29sLCBvdGhlciwgcmV0RWxlcykge1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gY29sW2ldO1xuICAgICAgICB2YXIgaWQgPSBlbGUuX3ByaXZhdGUuZGF0YS5pZDtcbiAgICAgICAgdmFyIGluT3RoZXIgPSBvdGhlci5oYXNFbGVtZW50V2l0aElkKGlkKTtcblxuICAgICAgICBpZiAoaW5PdGhlcikge1xuICAgICAgICAgIGJvdGgucHVzaChlbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldEVsZXMucHVzaChlbGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGFkZChjb2wxLCBjb2wyLCBsZWZ0KTtcbiAgICBhZGQoY29sMiwgY29sMSwgcmlnaHQpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6IHRoaXMuc3Bhd24obGVmdCwgeyB1bmlxdWU6IHRydWUgfSksXG4gICAgICByaWdodDogdGhpcy5zcGF3bihyaWdodCwgeyB1bmlxdWU6IHRydWUgfSksXG4gICAgICBib3RoOiB0aGlzLnNwYXduKGJvdGgsIHsgdW5pcXVlOiB0cnVlIH0pXG4gICAgfTtcbiAgfSxcblxuICBhZGQ6IGZ1bmN0aW9uIGFkZCh0b0FkZCkge1xuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgICBpZiAoIXRvQWRkKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAoaXMuc3RyaW5nKHRvQWRkKSkge1xuICAgICAgdmFyIHNlbGVjdG9yID0gdG9BZGQ7XG4gICAgICB0b0FkZCA9IGN5Lm11dGFibGVFbGVtZW50cygpLmZpbHRlcihzZWxlY3Rvcik7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnRzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGVsZW1lbnRzLnB1c2godGhpc1tpXSk7XG4gICAgfVxuXG4gICAgdmFyIG1hcCA9IHRoaXMuX3ByaXZhdGUubWFwO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHRvQWRkLmxlbmd0aDsgX2krKykge1xuXG4gICAgICB2YXIgYWRkID0gIW1hcC5oYXModG9BZGRbX2ldLmlkKCkpO1xuICAgICAgaWYgKGFkZCkge1xuICAgICAgICBlbGVtZW50cy5wdXNoKHRvQWRkW19pXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oZWxlbWVudHMpO1xuICB9LFxuXG4gIC8vIGluIHBsYWNlIG1lcmdlIG9uIGNhbGxpbmcgY29sbGVjdGlvblxuICBtZXJnZTogZnVuY3Rpb24gbWVyZ2UodG9BZGQpIHtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIHZhciBjeSA9IF9wLmN5O1xuXG4gICAgaWYgKCF0b0FkZCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKHRvQWRkICYmIGlzLnN0cmluZyh0b0FkZCkpIHtcbiAgICAgIHZhciBzZWxlY3RvciA9IHRvQWRkO1xuICAgICAgdG9BZGQgPSBjeS5tdXRhYmxlRWxlbWVudHMoKS5maWx0ZXIoc2VsZWN0b3IpO1xuICAgIH1cblxuICAgIHZhciBtYXAgPSBfcC5tYXA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvQWRkLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdG9BZGRFbGUgPSB0b0FkZFtpXTtcbiAgICAgIHZhciBpZCA9IHRvQWRkRWxlLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICB2YXIgYWRkID0gIW1hcC5oYXMoaWQpO1xuXG4gICAgICBpZiAoYWRkKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMubGVuZ3RoKys7XG5cbiAgICAgICAgdGhpc1tpbmRleF0gPSB0b0FkZEVsZTtcblxuICAgICAgICBtYXAuc2V0KGlkLCB7IGVsZTogdG9BZGRFbGUsIGluZGV4OiBpbmRleCB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJlcGxhY2VcbiAgICAgICAgdmFyIF9pbmRleCA9IG1hcC5nZXQoaWQpLmluZGV4O1xuXG4gICAgICAgIHRoaXNbX2luZGV4XSA9IHRvQWRkRWxlO1xuICAgICAgICBtYXAuc2V0KGlkLCB7IGVsZTogdG9BZGRFbGUsIGluZGV4OiBfaW5kZXggfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgLy8gcmVtb3ZlIHNpbmdsZSBlbGUgaW4gcGxhY2UgaW4gY2FsbGluZyBjb2xsZWN0aW9uXG4gIHVubWVyZ2VPbmU6IGZ1bmN0aW9uIHVubWVyZ2VPbmUoZWxlKSB7XG4gICAgZWxlID0gZWxlWzBdO1xuXG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICB2YXIgaWQgPSBlbGUuX3ByaXZhdGUuZGF0YS5pZDtcbiAgICB2YXIgbWFwID0gX3AubWFwO1xuICAgIHZhciBlbnRyeSA9IG1hcC5nZXQoaWQpO1xuXG4gICAgaWYgKCFlbnRyeSkge1xuICAgICAgcmV0dXJuIHRoaXM7IC8vIG5vIG5lZWQgdG8gcmVtb3ZlXG4gICAgfVxuXG4gICAgdmFyIGkgPSBlbnRyeS5pbmRleDtcblxuICAgIC8vIHJlbW92ZSBlbGVcbiAgICB0aGlzW2ldID0gdW5kZWZpbmVkO1xuICAgIG1hcC5kZWxldGUoaWQpO1xuXG4gICAgdmFyIHVubWVyZ2VkTGFzdEVsZSA9IGkgPT09IHRoaXMubGVuZ3RoIC0gMTtcblxuICAgIC8vIHJlcGxhY2UgZW1wdHkgc3BvdCB3aXRoIGxhc3QgZWxlIGluIGNvbGxlY3Rpb25cbiAgICBpZiAodGhpcy5sZW5ndGggPiAxICYmICF1bm1lcmdlZExhc3RFbGUpIHtcbiAgICAgIHZhciBsYXN0RWxlSSA9IHRoaXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBsYXN0RWxlID0gdGhpc1tsYXN0RWxlSV07XG4gICAgICB2YXIgbGFzdEVsZUlkID0gbGFzdEVsZS5fcHJpdmF0ZS5kYXRhLmlkO1xuXG4gICAgICB0aGlzW2xhc3RFbGVJXSA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXNbaV0gPSBsYXN0RWxlO1xuICAgICAgbWFwLnNldChsYXN0RWxlSWQsIHsgZWxlOiBsYXN0RWxlLCBpbmRleDogaSB9KTtcbiAgICB9XG5cbiAgICAvLyB0aGUgY29sbGVjdGlvbiBpcyBub3cgMSBlbGUgc21hbGxlclxuICAgIHRoaXMubGVuZ3RoLS07XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvLyByZW1vdmUgZWxlcyBpbiBwbGFjZSBvbiBjYWxsaW5nIGNvbGxlY3Rpb25cbiAgdW5tZXJnZTogZnVuY3Rpb24gdW5tZXJnZSh0b1JlbW92ZSkge1xuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgICBpZiAoIXRvUmVtb3ZlKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAodG9SZW1vdmUgJiYgaXMuc3RyaW5nKHRvUmVtb3ZlKSkge1xuICAgICAgdmFyIHNlbGVjdG9yID0gdG9SZW1vdmU7XG4gICAgICB0b1JlbW92ZSA9IGN5Lm11dGFibGVFbGVtZW50cygpLmZpbHRlcihzZWxlY3Rvcik7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b1JlbW92ZS5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy51bm1lcmdlT25lKHRvUmVtb3ZlW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICBtYXA6IGZ1bmN0aW9uIG1hcChtYXBGbiwgdGhpc0FyZykge1xuICAgIHZhciBhcnIgPSBbXTtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgdmFyIHJldCA9IHRoaXNBcmcgPyBtYXBGbi5hcHBseSh0aGlzQXJnLCBbZWxlLCBpLCBlbGVzXSkgOiBtYXBGbihlbGUsIGksIGVsZXMpO1xuXG4gICAgICBhcnIucHVzaChyZXQpO1xuICAgIH1cblxuICAgIHJldHVybiBhcnI7XG4gIH0sXG5cbiAgcmVkdWNlOiBmdW5jdGlvbiByZWR1Y2UoZm4sIGluaXRpYWxWYWx1ZSkge1xuICAgIHZhciB2YWwgPSBpbml0aWFsVmFsdWU7XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWwgPSBmbih2YWwsIGVsZXNbaV0sIGksIGVsZXMpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWw7XG4gIH0sXG5cbiAgbWF4OiBmdW5jdGlvbiBtYXgodmFsRm4sIHRoaXNBcmcpIHtcbiAgICB2YXIgbWF4ID0gLUluZmluaXR5O1xuICAgIHZhciBtYXhFbGUgPSB2b2lkIDA7XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgIHZhciB2YWwgPSB0aGlzQXJnID8gdmFsRm4uYXBwbHkodGhpc0FyZywgW2VsZSwgaSwgZWxlc10pIDogdmFsRm4oZWxlLCBpLCBlbGVzKTtcblxuICAgICAgaWYgKHZhbCA+IG1heCkge1xuICAgICAgICBtYXggPSB2YWw7XG4gICAgICAgIG1heEVsZSA9IGVsZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IG1heCxcbiAgICAgIGVsZTogbWF4RWxlXG4gICAgfTtcbiAgfSxcblxuICBtaW46IGZ1bmN0aW9uIG1pbih2YWxGbiwgdGhpc0FyZykge1xuICAgIHZhciBtaW4gPSBJbmZpbml0eTtcbiAgICB2YXIgbWluRWxlID0gdm9pZCAwO1xuICAgIHZhciBlbGVzID0gdGhpcztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICB2YXIgdmFsID0gdGhpc0FyZyA/IHZhbEZuLmFwcGx5KHRoaXNBcmcsIFtlbGUsIGksIGVsZXNdKSA6IHZhbEZuKGVsZSwgaSwgZWxlcyk7XG5cbiAgICAgIGlmICh2YWwgPCBtaW4pIHtcbiAgICAgICAgbWluID0gdmFsO1xuICAgICAgICBtaW5FbGUgPSBlbGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBtaW4sXG4gICAgICBlbGU6IG1pbkVsZVxuICAgIH07XG4gIH1cbn07XG5cbi8vIGFsaWFzZXNcbnZhciBmbiA9IGVsZXNmbjtcbmZuWyd1J10gPSBmblsnfCddID0gZm5bJysnXSA9IGZuLnVuaW9uID0gZm4ub3IgPSBmbi5hZGQ7XG5mblsnXFxcXCddID0gZm5bJyEnXSA9IGZuWyctJ10gPSBmbi5kaWZmZXJlbmNlID0gZm4ucmVsYXRpdmVDb21wbGVtZW50ID0gZm4uc3VidHJhY3QgPSBmbi5ub3Q7XG5mblsnbiddID0gZm5bJyYnXSA9IGZuWycuJ10gPSBmbi5hbmQgPSBmbi5pbnRlcnNlY3Rpb24gPSBmbi5pbnRlcnNlY3Q7XG5mblsnXiddID0gZm5bJygrKSddID0gZm5bJygtKSddID0gZm4uc3ltbWV0cmljRGlmZmVyZW5jZSA9IGZuLnN5bWRpZmYgPSBmbi54b3I7XG5mbi5mbkZpbHRlciA9IGZuLmZpbHRlckZuID0gZm4uc3RkRmlsdGVyID0gZm4uZmlsdGVyO1xuZm4uY29tcGxlbWVudCA9IGZuLmFic2NvbXAgPSBmbi5hYnNvbHV0ZUNvbXBsZW1lbnQ7XG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuXG4vKioqLyB9KSxcbi8qIDYzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBlbGVzZm4gPSB7XG4gIGlzTm9kZTogZnVuY3Rpb24gaXNOb2RlKCkge1xuICAgIHJldHVybiB0aGlzLmdyb3VwKCkgPT09ICdub2Rlcyc7XG4gIH0sXG5cbiAgaXNFZGdlOiBmdW5jdGlvbiBpc0VkZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ3JvdXAoKSA9PT0gJ2VkZ2VzJztcbiAgfSxcblxuICBpc0xvb3A6IGZ1bmN0aW9uIGlzTG9vcCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc0VkZ2UoKSAmJiB0aGlzLnNvdXJjZSgpLmlkKCkgPT09IHRoaXMudGFyZ2V0KCkuaWQoKTtcbiAgfSxcblxuICBpc1NpbXBsZTogZnVuY3Rpb24gaXNTaW1wbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNFZGdlKCkgJiYgdGhpcy5zb3VyY2UoKS5pZCgpICE9PSB0aGlzLnRhcmdldCgpLmlkKCk7XG4gIH0sXG5cbiAgZ3JvdXA6IGZ1bmN0aW9uIGdyb3VwKCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgaWYgKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5ncm91cDtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuXG4vKioqLyB9KSxcbi8qIDY0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBpcyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgekluZGV4U29ydCA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgZWxlc2ZuID0ge1xuICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGZuLCB0aGlzQXJnKSB7XG4gICAgaWYgKGlzLmZuKGZuKSkge1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICAgIHZhciByZXQgPSB0aGlzQXJnID8gZm4uYXBwbHkodGhpc0FyZywgW2VsZSwgaSwgdGhpc10pIDogZm4oZWxlLCBpLCB0aGlzKTtcblxuICAgICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IC8vIGV4aXQgZWFjaCBlYXJseSBvbiByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICB0b0FycmF5OiBmdW5jdGlvbiB0b0FycmF5KCkge1xuICAgIHZhciBhcnJheSA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcnJheS5wdXNoKHRoaXNbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiBhcnJheTtcbiAgfSxcblxuICBzbGljZTogZnVuY3Rpb24gc2xpY2Uoc3RhcnQsIGVuZCkge1xuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIHZhciB0aGlzU2l6ZSA9IHRoaXMubGVuZ3RoO1xuXG4gICAgaWYgKGVuZCA9PSBudWxsKSB7XG4gICAgICBlbmQgPSB0aGlzU2l6ZTtcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPT0gbnVsbCkge1xuICAgICAgc3RhcnQgPSAwO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgIHN0YXJ0ID0gdGhpc1NpemUgKyBzdGFydDtcbiAgICB9XG5cbiAgICBpZiAoZW5kIDwgMCkge1xuICAgICAgZW5kID0gdGhpc1NpemUgKyBlbmQ7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpID49IDAgJiYgaSA8IGVuZCAmJiBpIDwgdGhpc1NpemU7IGkrKykge1xuICAgICAgYXJyYXkucHVzaCh0aGlzW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zcGF3bihhcnJheSk7XG4gIH0sXG5cbiAgc2l6ZTogZnVuY3Rpb24gc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5sZW5ndGg7XG4gIH0sXG5cbiAgZXE6IGZ1bmN0aW9uIGVxKGkpIHtcbiAgICByZXR1cm4gdGhpc1tpXSB8fCB0aGlzLnNwYXduKCk7XG4gIH0sXG5cbiAgZmlyc3Q6IGZ1bmN0aW9uIGZpcnN0KCkge1xuICAgIHJldHVybiB0aGlzWzBdIHx8IHRoaXMuc3Bhd24oKTtcbiAgfSxcblxuICBsYXN0OiBmdW5jdGlvbiBsYXN0KCkge1xuICAgIHJldHVybiB0aGlzW3RoaXMubGVuZ3RoIC0gMV0gfHwgdGhpcy5zcGF3bigpO1xuICB9LFxuXG4gIGVtcHR5OiBmdW5jdGlvbiBlbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5sZW5ndGggPT09IDA7XG4gIH0sXG5cbiAgbm9uZW1wdHk6IGZ1bmN0aW9uIG5vbmVtcHR5KCkge1xuICAgIHJldHVybiAhdGhpcy5lbXB0eSgpO1xuICB9LFxuXG4gIHNvcnQ6IGZ1bmN0aW9uIHNvcnQoc29ydEZuKSB7XG4gICAgaWYgKCFpcy5mbihzb3J0Rm4pKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgc29ydGVkID0gdGhpcy50b0FycmF5KCkuc29ydChzb3J0Rm4pO1xuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oc29ydGVkKTtcbiAgfSxcblxuICBzb3J0QnlaSW5kZXg6IGZ1bmN0aW9uIHNvcnRCeVpJbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy5zb3J0KHpJbmRleFNvcnQpO1xuICB9LFxuXG4gIHpEZXB0aDogZnVuY3Rpb24gekRlcHRoKCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIGlmICghZWxlKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIGxldCBjeSA9IGVsZS5jeSgpO1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICB2YXIgZ3JvdXAgPSBfcC5ncm91cDtcblxuICAgIGlmIChncm91cCA9PT0gJ25vZGVzJykge1xuICAgICAgdmFyIGRlcHRoID0gX3AuZGF0YS5wYXJlbnQgPyBlbGUucGFyZW50cygpLnNpemUoKSA6IDA7XG5cbiAgICAgIGlmICghZWxlLmlzUGFyZW50KCkpIHtcbiAgICAgICAgcmV0dXJuIHV0aWwuTUFYX0lOVCAtIDE7IC8vIGNoaWxkbGVzcyBub2RlcyBhbHdheXMgb24gdG9wXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkZXB0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNyYyA9IF9wLnNvdXJjZTtcbiAgICAgIHZhciB0Z3QgPSBfcC50YXJnZXQ7XG4gICAgICB2YXIgc3JjRGVwdGggPSBzcmMuekRlcHRoKCk7XG4gICAgICB2YXIgdGd0RGVwdGggPSB0Z3QuekRlcHRoKCk7XG5cbiAgICAgIHJldHVybiBNYXRoLm1heChzcmNEZXB0aCwgdGd0RGVwdGgsIDApOyAvLyBkZXB0aCBvZiBkZWVwZXN0IHBhcmVudFxuICAgIH1cbiAgfVxufTtcblxuZWxlc2ZuLmVhY2ggPSBlbGVzZm4uZm9yRWFjaDtcblxubW9kdWxlLmV4cG9ydHMgPSBlbGVzZm47XG5cbi8qKiovIH0pLFxuLyogNjUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbnZhciBQcm9taXNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBtYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIGVsZXNmbiA9IHtcbiAgLy8gQ2FsY3VsYXRlcyBhbmQgcmV0dXJucyBub2RlIGRpbWVuc2lvbnMgeyB4LCB5IH0gYmFzZWQgb24gb3B0aW9ucyBnaXZlblxuICBsYXlvdXREaW1lbnNpb25zOiBmdW5jdGlvbiBsYXlvdXREaW1lbnNpb25zKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gdXRpbC5hc3NpZ24oe1xuICAgICAgbm9kZURpbWVuc2lvbnNJbmNsdWRlTGFiZWxzOiB0cnVlXG4gICAgfSwgb3B0aW9ucyk7XG5cbiAgICBpZiAob3B0aW9ucy5ub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHMpIHtcbiAgICAgIHZhciBiYkRpbSA9IHRoaXMuYm91bmRpbmdCb3goKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHc6IGJiRGltLncsXG4gICAgICAgIGg6IGJiRGltLmhcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHc6IHRoaXMub3V0ZXJXaWR0aCgpLFxuICAgICAgICBoOiB0aGlzLm91dGVySGVpZ2h0KClcbiAgICAgIH07XG4gICAgfVxuICB9LFxuXG4gIC8vIHVzaW5nIHN0YW5kYXJkIGxheW91dCBvcHRpb25zLCBhcHBseSBwb3NpdGlvbiBmdW5jdGlvbiAody8gb3Igdy9vIGFuaW1hdGlvbilcbiAgbGF5b3V0UG9zaXRpb25zOiBmdW5jdGlvbiBsYXlvdXRQb3NpdGlvbnMobGF5b3V0LCBvcHRpb25zLCBmbikge1xuICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgdmFyIGxheW91dEVsZXMgPSBvcHRpb25zLmVsZXM7IC8vIG5vZGVzICYgZWRnZXNcbiAgICB2YXIgZ2V0TWVtb2l6ZUtleSA9IGZ1bmN0aW9uIGdldE1lbW9pemVLZXkobm9kZSwgaSkge1xuICAgICAgcmV0dXJuIG5vZGUuaWQoKSArICckJyArIGk7XG4gICAgfTtcbiAgICB2YXIgZm5NZW0gPSB1dGlsLm1lbW9pemUoZm4sIGdldE1lbW9pemVLZXkpOyAvLyBtZW1vaXplZCB2ZXJzaW9uIG9mIHBvc2l0aW9uIGZ1bmN0aW9uXG5cbiAgICBsYXlvdXQuZW1pdCh7IHR5cGU6ICdsYXlvdXRzdGFydCcsIGxheW91dDogbGF5b3V0IH0pO1xuXG4gICAgbGF5b3V0LmFuaW1hdGlvbnMgPSBbXTtcblxuICAgIHZhciBjYWxjdWxhdGVTcGFjaW5nID0gZnVuY3Rpb24gY2FsY3VsYXRlU3BhY2luZyhzcGFjaW5nLCBub2Rlc0JiLCBwb3MpIHtcbiAgICAgIHZhciBjZW50ZXIgPSB7XG4gICAgICAgIHg6IG5vZGVzQmIueDEgKyBub2Rlc0JiLncgLyAyLFxuICAgICAgICB5OiBub2Rlc0JiLnkxICsgbm9kZXNCYi5oIC8gMlxuICAgICAgfTtcblxuICAgICAgdmFyIHNwYWNpbmdWZWN0b3IgPSB7IC8vIHNjYWxlIGZyb20gY2VudGVyIG9mIGJvdW5kaW5nIGJveCAobm90IG5lY2Vzc2FyaWx5IDAsMClcbiAgICAgICAgeDogKHBvcy54IC0gY2VudGVyLngpICogc3BhY2luZyxcbiAgICAgICAgeTogKHBvcy55IC0gY2VudGVyLnkpICogc3BhY2luZ1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogY2VudGVyLnggKyBzcGFjaW5nVmVjdG9yLngsXG4gICAgICAgIHk6IGNlbnRlci55ICsgc3BhY2luZ1ZlY3Rvci55XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgdXNlU3BhY2luZ0ZhY3RvciA9IG9wdGlvbnMuc3BhY2luZ0ZhY3RvciAmJiBvcHRpb25zLnNwYWNpbmdGYWN0b3IgIT09IDE7XG5cbiAgICB2YXIgc3BhY2luZ0JiID0gZnVuY3Rpb24gc3BhY2luZ0JiKCkge1xuICAgICAgaWYgKCF1c2VTcGFjaW5nRmFjdG9yKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgYmIgPSBtYXRoLm1ha2VCb3VuZGluZ0JveCgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIHZhciBwb3MgPSBmbk1lbShub2RlLCBpKTtcblxuICAgICAgICBtYXRoLmV4cGFuZEJvdW5kaW5nQm94QnlQb2ludChiYiwgcG9zLngsIHBvcy55KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJiO1xuICAgIH07XG5cbiAgICB2YXIgYmIgPSBzcGFjaW5nQmIoKTtcblxuICAgIHZhciBnZXRGaW5hbFBvcyA9IHV0aWwubWVtb2l6ZShmdW5jdGlvbiAobm9kZSwgaSkge1xuICAgICAgdmFyIG5ld1BvcyA9IGZuTWVtKG5vZGUsIGkpO1xuICAgICAgdmFyIHBvcyA9IG5vZGUucG9zaXRpb24oKTtcblxuICAgICAgaWYgKCFpcy5udW1iZXIocG9zLngpIHx8ICFpcy5udW1iZXIocG9zLnkpKSB7XG4gICAgICAgIG5vZGUuc2lsZW50UG9zaXRpb24oeyB4OiAwLCB5OiAwIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodXNlU3BhY2luZ0ZhY3Rvcikge1xuICAgICAgICB2YXIgc3BhY2luZyA9IE1hdGguYWJzKG9wdGlvbnMuc3BhY2luZ0ZhY3Rvcik7XG5cbiAgICAgICAgbmV3UG9zID0gY2FsY3VsYXRlU3BhY2luZyhzcGFjaW5nLCBiYiwgbmV3UG9zKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMudHJhbnNmb3JtICE9IG51bGwpIHtcbiAgICAgICAgbmV3UG9zID0gb3B0aW9ucy50cmFuc2Zvcm0obm9kZSwgbmV3UG9zKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ld1BvcztcbiAgICB9LCBnZXRNZW1vaXplS2V5KTtcblxuICAgIGlmIChvcHRpb25zLmFuaW1hdGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgdmFyIG5ld1BvcyA9IGdldEZpbmFsUG9zKG5vZGUsIGkpO1xuICAgICAgICB2YXIgYW5pbWF0ZU5vZGUgPSBvcHRpb25zLmFuaW1hdGVGaWx0ZXIgPT0gbnVsbCB8fCBvcHRpb25zLmFuaW1hdGVGaWx0ZXIobm9kZSwgaSk7XG5cbiAgICAgICAgaWYgKGFuaW1hdGVOb2RlKSB7XG4gICAgICAgICAgdmFyIGFuaSA9IG5vZGUuYW5pbWF0aW9uKHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBuZXdQb3MsXG4gICAgICAgICAgICBkdXJhdGlvbjogb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbixcbiAgICAgICAgICAgIGVhc2luZzogb3B0aW9ucy5hbmltYXRpb25FYXNpbmdcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGxheW91dC5hbmltYXRpb25zLnB1c2goYW5pKTtcblxuICAgICAgICAgIGFuaS5wbGF5KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS5wb3NpdGlvbihuZXdQb3MpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmZpdCkge1xuICAgICAgICB2YXIgZml0QW5pID0gY3kuYW5pbWF0aW9uKHtcbiAgICAgICAgICBmaXQ6IHtcbiAgICAgICAgICAgIGJvdW5kaW5nQm94OiBsYXlvdXRFbGVzLmJvdW5kaW5nQm94QXQoZ2V0RmluYWxQb3MpLFxuICAgICAgICAgICAgcGFkZGluZzogb3B0aW9ucy5wYWRkaW5nXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbixcbiAgICAgICAgICBlYXNpbmc6IG9wdGlvbnMuYW5pbWF0aW9uRWFzaW5nXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGxheW91dC5hbmltYXRpb25zLnB1c2goZml0QW5pKTtcblxuICAgICAgICBmaXRBbmkucGxheSgpO1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnpvb20gIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnBhbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciB6b29tUGFuQW5pID0gY3kuYW5pbWF0aW9uKHtcbiAgICAgICAgICB6b29tOiBvcHRpb25zLnpvb20sXG4gICAgICAgICAgcGFuOiBvcHRpb25zLnBhbixcbiAgICAgICAgICBkdXJhdGlvbjogb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbixcbiAgICAgICAgICBlYXNpbmc6IG9wdGlvbnMuYW5pbWF0aW9uRWFzaW5nXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGxheW91dC5hbmltYXRpb25zLnB1c2goem9vbVBhbkFuaSk7XG5cbiAgICAgICAgem9vbVBhbkFuaS5wbGF5KCk7XG4gICAgICB9XG5cbiAgICAgIGxheW91dC5vbmUoJ2xheW91dHJlYWR5Jywgb3B0aW9ucy5yZWFkeSk7XG4gICAgICBsYXlvdXQuZW1pdCh7IHR5cGU6ICdsYXlvdXRyZWFkeScsIGxheW91dDogbGF5b3V0IH0pO1xuXG4gICAgICBQcm9taXNlLmFsbChsYXlvdXQuYW5pbWF0aW9ucy5tYXAoZnVuY3Rpb24gKGFuaSkge1xuICAgICAgICByZXR1cm4gYW5pLnByb21pc2UoKTtcbiAgICAgIH0pKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbGF5b3V0Lm9uZSgnbGF5b3V0c3RvcCcsIG9wdGlvbnMuc3RvcCk7XG4gICAgICAgIGxheW91dC5lbWl0KHsgdHlwZTogJ2xheW91dHN0b3AnLCBsYXlvdXQ6IGxheW91dCB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG5cbiAgICAgIG5vZGVzLnBvc2l0aW9ucyhnZXRGaW5hbFBvcyk7XG5cbiAgICAgIGlmIChvcHRpb25zLmZpdCkge1xuICAgICAgICBjeS5maXQob3B0aW9ucy5lbGVzLCBvcHRpb25zLnBhZGRpbmcpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy56b29tICE9IG51bGwpIHtcbiAgICAgICAgY3kuem9vbShvcHRpb25zLnpvb20pO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5wYW4pIHtcbiAgICAgICAgY3kucGFuKG9wdGlvbnMucGFuKTtcbiAgICAgIH1cblxuICAgICAgbGF5b3V0Lm9uZSgnbGF5b3V0cmVhZHknLCBvcHRpb25zLnJlYWR5KTtcbiAgICAgIGxheW91dC5lbWl0KHsgdHlwZTogJ2xheW91dHJlYWR5JywgbGF5b3V0OiBsYXlvdXQgfSk7XG5cbiAgICAgIGxheW91dC5vbmUoJ2xheW91dHN0b3AnLCBvcHRpb25zLnN0b3ApO1xuICAgICAgbGF5b3V0LmVtaXQoeyB0eXBlOiAnbGF5b3V0c3RvcCcsIGxheW91dDogbGF5b3V0IH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIGxheW91dDogZnVuY3Rpb24gbGF5b3V0KG9wdGlvbnMpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICByZXR1cm4gY3kubWFrZUxheW91dCh1dGlsLmV4dGVuZCh7fSwgb3B0aW9ucywge1xuICAgICAgZWxlczogdGhpc1xuICAgIH0pKTtcbiAgfVxuXG59O1xuXG4vLyBhbGlhc2VzOlxuZWxlc2ZuLmNyZWF0ZUxheW91dCA9IGVsZXNmbi5tYWtlTGF5b3V0ID0gZWxlc2ZuLmxheW91dDtcblxubW9kdWxlLmV4cG9ydHMgPSBlbGVzZm47XG5cbi8qKiovIH0pLFxuLyogNjYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuZnVuY3Rpb24gc3R5bGVDYWNoZShrZXksIGZuLCBlbGUpIHtcbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICB2YXIgY2FjaGUgPSBfcC5zdHlsZUNhY2hlID0gX3Auc3R5bGVDYWNoZSB8fCB7fTtcbiAgdmFyIHZhbDtcblxuICBpZiAoKHZhbCA9IGNhY2hlW2tleV0pICE9IG51bGwpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9IGVsc2Uge1xuICAgIHZhbCA9IGNhY2hlW2tleV0gPSBmbihlbGUpO1xuXG4gICAgcmV0dXJuIHZhbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWNoZVN0eWxlRnVuY3Rpb24oa2V5LCBmbikge1xuICByZXR1cm4gZnVuY3Rpb24gY2FjaGVkU3R5bGVGdW5jdGlvbihlbGUpIHtcbiAgICByZXR1cm4gc3R5bGVDYWNoZShrZXksIGZuLCBlbGUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjYWNoZVByb3RvdHlwZVN0eWxlRnVuY3Rpb24oa2V5LCBmbikge1xuICB2YXIgc2VsZkZuID0gZnVuY3Rpb24gc2VsZkZuKGVsZSkge1xuICAgIHJldHVybiBmbi5jYWxsKGVsZSk7XG4gIH07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGNhY2hlZFByb3RvdHlwZVN0eWxlRnVuY3Rpb24oKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICBpZiAoZWxlKSB7XG4gICAgICByZXR1cm4gc3R5bGVDYWNoZShrZXksIHNlbGZGbiwgZWxlKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBlbGVzZm4gPSB7XG5cbiAgcmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlOiBmdW5jdGlvbiByZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGUodXNlQ2FjaGUpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgdmFyIHJlbmRlcmVyID0gY3kucmVuZGVyZXIoKTtcbiAgICB2YXIgc3R5bGVFbmFibGVkID0gY3kuc3R5bGVFbmFibGVkKCk7XG5cbiAgICBpZiAocmVuZGVyZXIgJiYgc3R5bGVFbmFibGVkKSB7XG4gICAgICByZW5kZXJlci5yZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGUodGhpcywgdXNlQ2FjaGUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGRpcnR5U3R5bGVDYWNoZTogZnVuY3Rpb24gZGlydHlTdHlsZUNhY2hlKCkge1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICB2YXIgZGlydHkgPSBmdW5jdGlvbiBkaXJ0eShlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuX3ByaXZhdGUuc3R5bGVDYWNoZSA9IHt9O1xuICAgIH07XG5cbiAgICBpZiAoY3kuaGFzQ29tcG91bmROb2RlcygpKSB7XG4gICAgICB2YXIgZWxlcyA9IHZvaWQgMDtcblxuICAgICAgZWxlcyA9IHRoaXMuc3Bhd25TZWxmKCkubWVyZ2UodGhpcy5kZXNjZW5kYW50cygpKS5tZXJnZSh0aGlzLnBhcmVudHMoKSk7XG5cbiAgICAgIGVsZXMubWVyZ2UoZWxlcy5jb25uZWN0ZWRFZGdlcygpKTtcblxuICAgICAgZWxlcy5mb3JFYWNoKGRpcnR5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgZGlydHkoZWxlKTtcblxuICAgICAgICBlbGUuY29ubmVjdGVkRWRnZXMoKS5mb3JFYWNoKGRpcnR5KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8vIGZ1bGx5IHVwZGF0ZXMgKHJlY2FsY3VsYXRlcykgdGhlIHN0eWxlIGZvciB0aGUgZWxlbWVudHNcbiAgdXBkYXRlU3R5bGU6IGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG5vdGlmeVJlbmRlcmVyKSB7XG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcblxuICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmIChjeS5fcHJpdmF0ZS5iYXRjaGluZ1N0eWxlKSB7XG4gICAgICB2YXIgYkVsZXMgPSBjeS5fcHJpdmF0ZS5iYXRjaFN0eWxlRWxlcztcblxuICAgICAgYkVsZXMubWVyZ2UodGhpcyk7XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZyBhbmQgZXhpdCBlYXJseSB3aGVuIGJhdGNoaW5nXG4gICAgfVxuXG4gICAgdmFyIGhhc0NvbXBvdW5kcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcbiAgICB2YXIgc3R5bGUgPSBjeS5zdHlsZSgpO1xuICAgIHZhciB1cGRhdGVkRWxlcyA9IHRoaXM7XG5cbiAgICBub3RpZnlSZW5kZXJlciA9IG5vdGlmeVJlbmRlcmVyIHx8IG5vdGlmeVJlbmRlcmVyID09PSB1bmRlZmluZWQgPyB0cnVlIDogZmFsc2U7XG5cbiAgICBpZiAoaGFzQ29tcG91bmRzKSB7XG4gICAgICAvLyB0aGVuIGFkZCBldmVyeXRoaW5nIHVwIGFuZCBkb3duIGZvciBjb21wb3VuZCBzZWxlY3RvciBjaGVja3NcbiAgICAgIHVwZGF0ZWRFbGVzID0gdGhpcy5zcGF3blNlbGYoKS5tZXJnZSh0aGlzLmRlc2NlbmRhbnRzKCkpLm1lcmdlKHRoaXMucGFyZW50cygpKTtcbiAgICB9XG5cbiAgICB2YXIgY2hhbmdlZEVsZXMgPSBzdHlsZS5hcHBseSh1cGRhdGVkRWxlcyk7XG5cbiAgICBjaGFuZ2VkRWxlcy5kaXJ0eVN0eWxlQ2FjaGUoKTtcbiAgICBjaGFuZ2VkRWxlcy5kaXJ0eUNvbXBvdW5kQm91bmRzQ2FjaGUoKTtcblxuICAgIGlmIChub3RpZnlSZW5kZXJlcikge1xuICAgICAgY2hhbmdlZEVsZXMuZW1pdEFuZE5vdGlmeSgnc3R5bGUnKTsgLy8gbGV0IHJlbmRlcmVyIGtub3cgd2UgY2hhbmdlZCBzdHlsZVxuICAgIH0gZWxzZSB7XG4gICAgICBjaGFuZ2VkRWxlcy5lbWl0KCdzdHlsZScpOyAvLyBqdXN0IGZpcmUgdGhlIGV2ZW50XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgLy8ganVzdCB1cGRhdGUgdGhlIG1hcHBlcnMgaW4gdGhlIGVsZW1lbnRzJyBzdHlsZXM7IGNoZWFwZXIgdGhhbiBlbGVzLnVwZGF0ZVN0eWxlKClcbiAgdXBkYXRlTWFwcGVyczogZnVuY3Rpb24gdXBkYXRlTWFwcGVycyhub3RpZnlSZW5kZXJlcikge1xuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgdmFyIHN0eWxlID0gY3kuc3R5bGUoKTtcbiAgICBub3RpZnlSZW5kZXJlciA9IG5vdGlmeVJlbmRlcmVyIHx8IG5vdGlmeVJlbmRlcmVyID09PSB1bmRlZmluZWQgPyB0cnVlIDogZmFsc2U7XG5cbiAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgY2hhbmdlZEVsZXMgPSBzdHlsZS51cGRhdGVNYXBwZXJzKHRoaXMpO1xuXG4gICAgY2hhbmdlZEVsZXMuZGlydHlTdHlsZUNhY2hlKCk7XG4gICAgY2hhbmdlZEVsZXMuZGlydHlDb21wb3VuZEJvdW5kc0NhY2hlKCk7XG5cbiAgICBpZiAobm90aWZ5UmVuZGVyZXIpIHtcbiAgICAgIGNoYW5nZWRFbGVzLmVtaXRBbmROb3RpZnkoJ3N0eWxlJyk7IC8vIGxldCByZW5kZXJlciBrbm93IHdlIGNoYW5nZWQgc3R5bGVcbiAgICB9IGVsc2Uge1xuICAgICAgY2hhbmdlZEVsZXMuZW1pdCgnc3R5bGUnKTsgLy8ganVzdCBmaXJlIHRoZSBldmVudFxuICAgIH1cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICAvLyBnZXQgdGhlIGludGVybmFsIHBhcnNlZCBzdHlsZSBvYmplY3QgZm9yIHRoZSBzcGVjaWZpZWQgcHJvcGVydHlcbiAgcGFyc2VkU3R5bGU6IGZ1bmN0aW9uIHBhcnNlZFN0eWxlKHByb3BlcnR5KSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgdmFyIGN5ID0gZWxlLmN5KCk7XG5cbiAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5zdHlsZVtwcm9wZXJ0eV0gfHwgY3kuc3R5bGUoKS5nZXREZWZhdWx0UHJvcGVydHkocHJvcGVydHkpO1xuICAgIH1cbiAgfSxcblxuICBudW1lcmljU3R5bGU6IGZ1bmN0aW9uIG51bWVyaWNTdHlsZShwcm9wZXJ0eSkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgaWYgKCFlbGUuY3koKS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChlbGUpIHtcbiAgICAgIHZhciBwc3R5bGUgPSBlbGUucHN0eWxlKHByb3BlcnR5KTtcblxuICAgICAgcmV0dXJuIHBzdHlsZS5wZlZhbHVlICE9PSB1bmRlZmluZWQgPyBwc3R5bGUucGZWYWx1ZSA6IHBzdHlsZS52YWx1ZTtcbiAgICB9XG4gIH0sXG5cbiAgbnVtZXJpY1N0eWxlVW5pdHM6IGZ1bmN0aW9uIG51bWVyaWNTdHlsZVVuaXRzKHByb3BlcnR5KSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICBpZiAoIWVsZS5jeSgpLnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5wc3R5bGUocHJvcGVydHkpLnVuaXRzO1xuICAgIH1cbiAgfSxcblxuICAvLyBnZXQgdGhlIHNwZWNpZmllZCBjc3MgcHJvcGVydHkgYXMgYSByZW5kZXJlZCB2YWx1ZSAoaS5lLiBvbi1zY3JlZW4gdmFsdWUpXG4gIC8vIG9yIGdldCB0aGUgd2hvbGUgcmVuZGVyZWQgc3R5bGUgaWYgbm8gcHJvcGVydHkgc3BlY2lmaWVkIChOQiBkb2Vzbid0IGFsbG93IHNldHRpbmcpXG4gIHJlbmRlcmVkU3R5bGU6IGZ1bmN0aW9uIHJlbmRlcmVkU3R5bGUocHJvcGVydHkpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICBpZiAoZWxlKSB7XG4gICAgICByZXR1cm4gY3kuc3R5bGUoKS5nZXRSZW5kZXJlZFN0eWxlKGVsZSwgcHJvcGVydHkpO1xuICAgIH1cbiAgfSxcblxuICAvLyByZWFkIHRoZSBjYWxjdWxhdGVkIGNzcyBzdHlsZSBvZiB0aGUgZWxlbWVudCBvciBvdmVycmlkZSB0aGUgc3R5bGUgKHZpYSBhIGJ5cGFzcylcbiAgc3R5bGU6IGZ1bmN0aW9uIHN0eWxlKG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuXG4gICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIHVwZGF0ZVRyYW5zaXRpb25zID0gZmFsc2U7XG4gICAgdmFyIHN0eWxlID0gY3kuc3R5bGUoKTtcblxuICAgIGlmIChpcy5wbGFpbk9iamVjdChuYW1lKSkge1xuICAgICAgLy8gdGhlbiBleHRlbmQgdGhlIGJ5cGFzc1xuICAgICAgdmFyIHByb3BzID0gbmFtZTtcbiAgICAgIHN0eWxlLmFwcGx5QnlwYXNzKHRoaXMsIHByb3BzLCB1cGRhdGVUcmFuc2l0aW9ucyk7XG5cbiAgICAgIHRoaXMuZGlydHlTdHlsZUNhY2hlKCk7XG4gICAgICB0aGlzLmRpcnR5Q29tcG91bmRCb3VuZHNDYWNoZSgpO1xuXG4gICAgICB0aGlzLmVtaXRBbmROb3RpZnkoJ3N0eWxlJyk7IC8vIGxldCB0aGUgcmVuZGVyZXIga25vdyB3ZSd2ZSB1cGRhdGVkIHN0eWxlXG4gICAgfSBlbHNlIGlmIChpcy5zdHJpbmcobmFtZSkpIHtcblxuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gdGhlbiBnZXQgdGhlIHByb3BlcnR5IGZyb20gdGhlIHN0eWxlXG4gICAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgICAgIGlmIChlbGUpIHtcbiAgICAgICAgICByZXR1cm4gc3R5bGUuZ2V0U3R5bGVQcm9wZXJ0eVZhbHVlKGVsZSwgbmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZW1wdHkgY29sbGVjdGlvbiA9PiBjYW4ndCBnZXQgYW55IHZhbHVlXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGVuIHNldCB0aGUgYnlwYXNzIHdpdGggdGhlIHByb3BlcnR5IHZhbHVlXG4gICAgICAgIHN0eWxlLmFwcGx5QnlwYXNzKHRoaXMsIG5hbWUsIHZhbHVlLCB1cGRhdGVUcmFuc2l0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5kaXJ0eVN0eWxlQ2FjaGUoKTtcbiAgICAgICAgdGhpcy5kaXJ0eUNvbXBvdW5kQm91bmRzQ2FjaGUoKTtcblxuICAgICAgICB0aGlzLmVtaXRBbmROb3RpZnkoJ3N0eWxlJyk7IC8vIGxldCB0aGUgcmVuZGVyZXIga25vdyB3ZSd2ZSB1cGRhdGVkIHN0eWxlXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBfZWxlID0gdGhpc1swXTtcblxuICAgICAgaWYgKF9lbGUpIHtcbiAgICAgICAgcmV0dXJuIHN0eWxlLmdldFJhd1N0eWxlKF9lbGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZW1wdHkgY29sbGVjdGlvbiA9PiBjYW4ndCBnZXQgYW55IHZhbHVlXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICByZW1vdmVTdHlsZTogZnVuY3Rpb24gcmVtb3ZlU3R5bGUobmFtZXMpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgdXBkYXRlVHJhbnNpdGlvbnMgPSBmYWxzZTtcbiAgICB2YXIgc3R5bGUgPSBjeS5zdHlsZSgpO1xuICAgIHZhciBlbGVzID0gdGhpcztcblxuICAgIGlmIChuYW1lcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG5cbiAgICAgICAgc3R5bGUucmVtb3ZlQWxsQnlwYXNzZXMoZWxlLCB1cGRhdGVUcmFuc2l0aW9ucyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWVzID0gbmFtZXMuc3BsaXQoL1xccysvKTtcblxuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGVsZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBfZWxlMiA9IGVsZXNbX2ldO1xuXG4gICAgICAgIHN0eWxlLnJlbW92ZUJ5cGFzc2VzKF9lbGUyLCBuYW1lcywgdXBkYXRlVHJhbnNpdGlvbnMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuZGlydHlTdHlsZUNhY2hlKCk7XG4gICAgdGhpcy5kaXJ0eUNvbXBvdW5kQm91bmRzQ2FjaGUoKTtcblxuICAgIHRoaXMuZW1pdEFuZE5vdGlmeSgnc3R5bGUnKTsgLy8gbGV0IHRoZSByZW5kZXJlciBrbm93IHdlJ3ZlIHVwZGF0ZWQgc3R5bGVcblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIHNob3c6IGZ1bmN0aW9uIHNob3coKSB7XG4gICAgdGhpcy5jc3MoJ2Rpc3BsYXknLCAnZWxlbWVudCcpO1xuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIGhpZGU6IGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgdGhpcy5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpO1xuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIGVmZmVjdGl2ZU9wYWNpdHk6IGZ1bmN0aW9uIGVmZmVjdGl2ZU9wYWNpdHkoKSB7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIHZhciBoYXNDb21wb3VuZE5vZGVzID0gY3kuaGFzQ29tcG91bmROb2RlcygpO1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgaWYgKGVsZSkge1xuICAgICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgICAgdmFyIHBhcmVudE9wYWNpdHkgPSBlbGUucHN0eWxlKCdvcGFjaXR5JykudmFsdWU7XG5cbiAgICAgIGlmICghaGFzQ29tcG91bmROb2Rlcykge1xuICAgICAgICByZXR1cm4gcGFyZW50T3BhY2l0eTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBhcmVudHMgPSAhX3AuZGF0YS5wYXJlbnQgPyBudWxsIDogZWxlLnBhcmVudHMoKTtcblxuICAgICAgaWYgKHBhcmVudHMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHBhcmVudCA9IHBhcmVudHNbaV07XG4gICAgICAgICAgdmFyIG9wYWNpdHkgPSBwYXJlbnQucHN0eWxlKCdvcGFjaXR5JykudmFsdWU7XG5cbiAgICAgICAgICBwYXJlbnRPcGFjaXR5ID0gb3BhY2l0eSAqIHBhcmVudE9wYWNpdHk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcmVudE9wYWNpdHk7XG4gICAgfVxuICB9LFxuXG4gIHRyYW5zcGFyZW50OiBmdW5jdGlvbiB0cmFuc3BhcmVudCgpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHZhciBoYXNDb21wb3VuZE5vZGVzID0gZWxlLmN5KCkuaGFzQ29tcG91bmROb2RlcygpO1xuXG4gICAgaWYgKGVsZSkge1xuICAgICAgaWYgKCFoYXNDb21wb3VuZE5vZGVzKSB7XG4gICAgICAgIHJldHVybiBlbGUucHN0eWxlKCdvcGFjaXR5JykudmFsdWUgPT09IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZWxlLmVmZmVjdGl2ZU9wYWNpdHkoKSA9PT0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgYmFja2dyb3VuZGluZzogZnVuY3Rpb24gYmFja2dyb3VuZGluZygpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5iYWNrZ3JvdW5kaW5nID8gdHJ1ZSA6IGZhbHNlO1xuICB9XG5cbn07XG5cbmZ1bmN0aW9uIGNoZWNrQ29tcG91bmQoZWxlLCBwYXJlbnRPaykge1xuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciBwYXJlbnRzID0gX3AuZGF0YS5wYXJlbnQgPyBlbGUucGFyZW50cygpIDogbnVsbDtcblxuICBpZiAocGFyZW50cykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHBhcmVudCA9IHBhcmVudHNbaV07XG5cbiAgICAgIGlmICghcGFyZW50T2socGFyZW50KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGRlZmluZURlcml2ZWRTdGF0ZUZ1bmN0aW9uKHNwZWNzKSB7XG4gIHZhciBvayA9IHNwZWNzLm9rO1xuICB2YXIgZWRnZU9rVmlhTm9kZSA9IHNwZWNzLmVkZ2VPa1ZpYU5vZGUgfHwgc3BlY3Mub2s7XG4gIHZhciBwYXJlbnRPayA9IHNwZWNzLnBhcmVudE9rIHx8IHNwZWNzLm9rO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHZhciBoYXNDb21wb3VuZE5vZGVzID0gY3kuaGFzQ29tcG91bmROb2RlcygpO1xuXG4gICAgaWYgKGVsZSkge1xuICAgICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuXG4gICAgICBpZiAoIW9rKGVsZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICAgIHJldHVybiAhaGFzQ29tcG91bmROb2RlcyB8fCBjaGVja0NvbXBvdW5kKGVsZSwgcGFyZW50T2spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNyYyA9IF9wLnNvdXJjZTtcbiAgICAgICAgdmFyIHRndCA9IF9wLnRhcmdldDtcblxuICAgICAgICByZXR1cm4gZWRnZU9rVmlhTm9kZShzcmMpICYmICghaGFzQ29tcG91bmROb2RlcyB8fCBjaGVja0NvbXBvdW5kKHNyYywgZWRnZU9rVmlhTm9kZSkpICYmIChzcmMgPT09IHRndCB8fCBlZGdlT2tWaWFOb2RlKHRndCkgJiYgKCFoYXNDb21wb3VuZE5vZGVzIHx8IGNoZWNrQ29tcG91bmQodGd0LCBlZGdlT2tWaWFOb2RlKSkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxudmFyIGVsZVRha2VzVXBTcGFjZSA9IGNhY2hlU3R5bGVGdW5jdGlvbignZWxlVGFrZXNVcFNwYWNlJywgZnVuY3Rpb24gKGVsZSkge1xuICByZXR1cm4gZWxlLnBzdHlsZSgnZGlzcGxheScpLnZhbHVlID09PSAnZWxlbWVudCcgJiYgZWxlLndpZHRoKCkgIT09IDAgJiYgKGVsZS5pc05vZGUoKSA/IGVsZS5oZWlnaHQoKSAhPT0gMCA6IHRydWUpO1xufSk7XG5cbmVsZXNmbi50YWtlc1VwU3BhY2UgPSBjYWNoZVByb3RvdHlwZVN0eWxlRnVuY3Rpb24oJ3Rha2VzVXBTcGFjZScsIGRlZmluZURlcml2ZWRTdGF0ZUZ1bmN0aW9uKHtcbiAgb2s6IGVsZVRha2VzVXBTcGFjZVxufSkpO1xuXG52YXIgZWxlSW50ZXJhY3RpdmUgPSBjYWNoZVN0eWxlRnVuY3Rpb24oJ2VsZUludGVyYWN0aXZlJywgZnVuY3Rpb24gKGVsZSkge1xuICByZXR1cm4gZWxlLnBzdHlsZSgnZXZlbnRzJykudmFsdWUgPT09ICd5ZXMnICYmIGVsZS5wc3R5bGUoJ3Zpc2liaWxpdHknKS52YWx1ZSA9PT0gJ3Zpc2libGUnICYmIGVsZVRha2VzVXBTcGFjZShlbGUpO1xufSk7XG5cbnZhciBwYXJlbnRJbnRlcmFjdGl2ZSA9IGNhY2hlU3R5bGVGdW5jdGlvbigncGFyZW50SW50ZXJhY3RpdmUnLCBmdW5jdGlvbiAocGFyZW50KSB7XG4gIHJldHVybiBwYXJlbnQucHN0eWxlKCd2aXNpYmlsaXR5JykudmFsdWUgPT09ICd2aXNpYmxlJyAmJiBlbGVUYWtlc1VwU3BhY2UocGFyZW50KTtcbn0pO1xuXG5lbGVzZm4uaW50ZXJhY3RpdmUgPSBjYWNoZVByb3RvdHlwZVN0eWxlRnVuY3Rpb24oJ2ludGVyYWN0aXZlJywgZGVmaW5lRGVyaXZlZFN0YXRlRnVuY3Rpb24oe1xuICBvazogZWxlSW50ZXJhY3RpdmUsXG4gIHBhcmVudE9rOiBwYXJlbnRJbnRlcmFjdGl2ZSxcbiAgZWRnZU9rVmlhTm9kZTogZWxlVGFrZXNVcFNwYWNlXG59KSk7XG5cbmVsZXNmbi5ub25pbnRlcmFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgaWYgKGVsZSkge1xuICAgIHJldHVybiAhZWxlLmludGVyYWN0aXZlKCk7XG4gIH1cbn07XG5cbnZhciBlbGVWaXNpYmxlID0gY2FjaGVTdHlsZUZ1bmN0aW9uKCdlbGVWaXNpYmxlJywgZnVuY3Rpb24gKGVsZSkge1xuICByZXR1cm4gZWxlLnBzdHlsZSgndmlzaWJpbGl0eScpLnZhbHVlID09PSAndmlzaWJsZScgJiYgZWxlLnBzdHlsZSgnb3BhY2l0eScpLnBmVmFsdWUgIT09IDAgJiYgZWxlVGFrZXNVcFNwYWNlKGVsZSk7XG59KTtcblxudmFyIGVkZ2VWaXNpYmxlVmlhTm9kZSA9IGVsZVRha2VzVXBTcGFjZTtcblxuZWxlc2ZuLnZpc2libGUgPSBjYWNoZVByb3RvdHlwZVN0eWxlRnVuY3Rpb24oJ3Zpc2libGUnLCBkZWZpbmVEZXJpdmVkU3RhdGVGdW5jdGlvbih7XG4gIG9rOiBlbGVWaXNpYmxlLFxuICBlZGdlT2tWaWFOb2RlOiBlZGdlVmlzaWJsZVZpYU5vZGVcbn0pKTtcblxuZWxlc2ZuLmhpZGRlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgaWYgKGVsZSkge1xuICAgIHJldHVybiAhZWxlLnZpc2libGUoKTtcbiAgfVxufTtcblxuZWxlc2ZuLmJ5cGFzcyA9IGVsZXNmbi5jc3MgPSBlbGVzZm4uc3R5bGU7XG5lbGVzZm4ucmVuZGVyZWRDc3MgPSBlbGVzZm4ucmVuZGVyZWRTdHlsZTtcbmVsZXNmbi5yZW1vdmVCeXBhc3MgPSBlbGVzZm4ucmVtb3ZlQ3NzID0gZWxlc2ZuLnJlbW92ZVN0eWxlO1xuZWxlc2ZuLnBzdHlsZSA9IGVsZXNmbi5wYXJzZWRTdHlsZTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbGVzZm47XG5cbi8qKiovIH0pLFxuLyogNjcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGVsZXNmbiA9IHt9O1xuXG5mdW5jdGlvbiBkZWZpbmVTd2l0Y2hGdW5jdGlvbihwYXJhbXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICB2YXIgY2hhbmdlZEVsZXMgPSBbXTtcblxuICAgIC8vIGUuZy4gY3kubm9kZXMoKS5zZWxlY3QoIGRhdGEsIGhhbmRsZXIgKVxuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdmFyIGRhdGEgPSBhcmdzWzBdO1xuICAgICAgdmFyIGhhbmRsZXIgPSBhcmdzWzFdO1xuICAgICAgdGhpcy5vbihwYXJhbXMuZXZlbnQsIGRhdGEsIGhhbmRsZXIpO1xuICAgIH1cblxuICAgIC8vIGUuZy4gY3kubm9kZXMoKS5zZWxlY3QoIGhhbmRsZXIgKVxuICAgIGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHZhciBfaGFuZGxlciA9IGFyZ3NbMF07XG4gICAgICAgIHRoaXMub24ocGFyYW1zLmV2ZW50LCBfaGFuZGxlcik7XG4gICAgICB9XG5cbiAgICAgIC8vIGUuZy4gY3kubm9kZXMoKS5zZWxlY3QoKVxuICAgICAgZWxzZSBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgICAgICAgdmFyIGFibGUgPSAhcGFyYW1zLmFibGVGaWVsZCB8fCBlbGUuX3ByaXZhdGVbcGFyYW1zLmFibGVGaWVsZF07XG4gICAgICAgICAgICB2YXIgY2hhbmdlZCA9IGVsZS5fcHJpdmF0ZVtwYXJhbXMuZmllbGRdICE9IHBhcmFtcy52YWx1ZTtcblxuICAgICAgICAgICAgaWYgKHBhcmFtcy5vdmVycmlkZUFibGUpIHtcbiAgICAgICAgICAgICAgdmFyIG92ZXJyaWRlQWJsZSA9IHBhcmFtcy5vdmVycmlkZUFibGUoZWxlKTtcblxuICAgICAgICAgICAgICBpZiAob3ZlcnJpZGVBYmxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBhYmxlID0gb3ZlcnJpZGVBYmxlO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFvdmVycmlkZUFibGUpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH0gLy8gdG8gc2F2ZSBjeWNsZXMgYXNzdW1lIG5vdCBhYmxlIGZvciBhbGwgb24gb3ZlcnJpZGVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYWJsZSkge1xuICAgICAgICAgICAgICBlbGUuX3ByaXZhdGVbcGFyYW1zLmZpZWxkXSA9IHBhcmFtcy52YWx1ZTtcblxuICAgICAgICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIGNoYW5nZWRFbGVzLnB1c2goZWxlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBjaGFuZ2VkQ29sbCA9IHRoaXMuc3Bhd24oY2hhbmdlZEVsZXMpO1xuICAgICAgICAgIGNoYW5nZWRDb2xsLnVwZGF0ZVN0eWxlKCk7IC8vIGNoYW5nZSBvZiBzdGF0ZSA9PiBwb3NzaWJsZSBjaGFuZ2Ugb2Ygc3R5bGVcbiAgICAgICAgICBjaGFuZ2VkQ29sbC5lbWl0KHBhcmFtcy5ldmVudCk7XG4gICAgICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xufVxuXG5mdW5jdGlvbiBkZWZpbmVTd2l0Y2hTZXQocGFyYW1zKSB7XG4gIGVsZXNmbltwYXJhbXMuZmllbGRdID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgaWYgKGVsZSkge1xuICAgICAgaWYgKHBhcmFtcy5vdmVycmlkZUZpZWxkKSB7XG4gICAgICAgIHZhciB2YWwgPSBwYXJhbXMub3ZlcnJpZGVGaWVsZChlbGUpO1xuXG4gICAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZVtwYXJhbXMuZmllbGRdO1xuICAgIH1cbiAgfTtcblxuICBlbGVzZm5bcGFyYW1zLm9uXSA9IGRlZmluZVN3aXRjaEZ1bmN0aW9uKHtcbiAgICBldmVudDogcGFyYW1zLm9uLFxuICAgIGZpZWxkOiBwYXJhbXMuZmllbGQsXG4gICAgYWJsZUZpZWxkOiBwYXJhbXMuYWJsZUZpZWxkLFxuICAgIG92ZXJyaWRlQWJsZTogcGFyYW1zLm92ZXJyaWRlQWJsZSxcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcblxuICBlbGVzZm5bcGFyYW1zLm9mZl0gPSBkZWZpbmVTd2l0Y2hGdW5jdGlvbih7XG4gICAgZXZlbnQ6IHBhcmFtcy5vZmYsXG4gICAgZmllbGQ6IHBhcmFtcy5maWVsZCxcbiAgICBhYmxlRmllbGQ6IHBhcmFtcy5hYmxlRmllbGQsXG4gICAgb3ZlcnJpZGVBYmxlOiBwYXJhbXMub3ZlcnJpZGVBYmxlLFxuICAgIHZhbHVlOiBmYWxzZVxuICB9KTtcbn1cblxuZGVmaW5lU3dpdGNoU2V0KHtcbiAgZmllbGQ6ICdsb2NrZWQnLFxuICBvdmVycmlkZUZpZWxkOiBmdW5jdGlvbiBvdmVycmlkZUZpZWxkKGVsZSkge1xuICAgIHJldHVybiBlbGUuY3koKS5hdXRvbG9jaygpID8gdHJ1ZSA6IHVuZGVmaW5lZDtcbiAgfSxcbiAgb246ICdsb2NrJyxcbiAgb2ZmOiAndW5sb2NrJ1xufSk7XG5cbmRlZmluZVN3aXRjaFNldCh7XG4gIGZpZWxkOiAnZ3JhYmJhYmxlJyxcbiAgb3ZlcnJpZGVGaWVsZDogZnVuY3Rpb24gb3ZlcnJpZGVGaWVsZChlbGUpIHtcbiAgICByZXR1cm4gZWxlLmN5KCkuYXV0b3VuZ3JhYmlmeSgpID8gZmFsc2UgOiB1bmRlZmluZWQ7XG4gIH0sXG4gIG9uOiAnZ3JhYmlmeScsXG4gIG9mZjogJ3VuZ3JhYmlmeSdcbn0pO1xuXG5kZWZpbmVTd2l0Y2hTZXQoe1xuICBmaWVsZDogJ3NlbGVjdGVkJyxcbiAgYWJsZUZpZWxkOiAnc2VsZWN0YWJsZScsXG4gIG92ZXJyaWRlQWJsZTogZnVuY3Rpb24gb3ZlcnJpZGVBYmxlKGVsZSkge1xuICAgIHJldHVybiBlbGUuY3koKS5hdXRvdW5zZWxlY3RpZnkoKSA/IGZhbHNlIDogdW5kZWZpbmVkO1xuICB9LFxuICBvbjogJ3NlbGVjdCcsXG4gIG9mZjogJ3Vuc2VsZWN0J1xufSk7XG5cbmRlZmluZVN3aXRjaFNldCh7XG4gIGZpZWxkOiAnc2VsZWN0YWJsZScsXG4gIG92ZXJyaWRlRmllbGQ6IGZ1bmN0aW9uIG92ZXJyaWRlRmllbGQoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5jeSgpLmF1dG91bnNlbGVjdGlmeSgpID8gZmFsc2UgOiB1bmRlZmluZWQ7XG4gIH0sXG4gIG9uOiAnc2VsZWN0aWZ5JyxcbiAgb2ZmOiAndW5zZWxlY3RpZnknXG59KTtcblxuZWxlc2ZuLmRlc2VsZWN0ID0gZWxlc2ZuLnVuc2VsZWN0O1xuXG5lbGVzZm4uZ3JhYmJlZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVsZSA9IHRoaXNbMF07XG4gIGlmIChlbGUpIHtcbiAgICByZXR1cm4gZWxlLl9wcml2YXRlLmdyYWJiZWQ7XG4gIH1cbn07XG5cbmRlZmluZVN3aXRjaFNldCh7XG4gIGZpZWxkOiAnYWN0aXZlJyxcbiAgb246ICdhY3RpdmF0ZScsXG4gIG9mZjogJ3VuYWN0aXZhdGUnXG59KTtcblxuZWxlc2ZuLmluYWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZWxlID0gdGhpc1swXTtcbiAgaWYgKGVsZSkge1xuICAgIHJldHVybiAhZWxlLl9wcml2YXRlLmFjdGl2ZTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbGVzZm47XG5cbi8qKiovIH0pLFxuLyogNjggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xudmFyIGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIGVsZXNmbiA9IHt9O1xuXG52YXIgY2FjaGUgPSBmdW5jdGlvbiBjYWNoZShmbiwgbmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24gdHJhdmVyc2FsQ2FjaGUoYXJnMSwgYXJnMiwgYXJnMywgYXJnNCkge1xuICAgIHZhciBzZWxlY3Rvck9yRWxlcyA9IGFyZzE7XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgIHZhciBrZXkgPSB2b2lkIDA7XG5cbiAgICBpZiAoc2VsZWN0b3JPckVsZXMgPT0gbnVsbCkge1xuICAgICAga2V5ID0gJ251bGwnO1xuICAgIH0gZWxzZSBpZiAoaXMuZWxlbWVudE9yQ29sbGVjdGlvbihzZWxlY3Rvck9yRWxlcykgJiYgc2VsZWN0b3JPckVsZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICBrZXkgPSAnIycgKyBzZWxlY3Rvck9yRWxlcy5pZCgpO1xuICAgIH1cblxuICAgIGlmIChlbGVzLmxlbmd0aCA9PT0gMSAmJiBrZXkpIHtcbiAgICAgIHZhciBfcCA9IGVsZXNbMF0uX3ByaXZhdGU7XG4gICAgICB2YXIgdGNoID0gX3AudHJhdmVyc2FsQ2FjaGUgPSBfcC50cmF2ZXJzYWxDYWNoZSB8fCB7fTtcbiAgICAgIHZhciBjaCA9IHRjaFtuYW1lXSA9IHRjaFtuYW1lXSB8fCB7fTtcbiAgICAgIHZhciBjYWNoZUhpdCA9IGNoW2tleV07XG5cbiAgICAgIGlmIChjYWNoZUhpdCkge1xuICAgICAgICByZXR1cm4gY2FjaGVIaXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY2hba2V5XSA9IGZuLmNhbGwoZWxlcywgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKGVsZXMsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQpO1xuICAgIH1cbiAgfTtcbn07XG5cbi8vIERBRyBmdW5jdGlvbnNcbi8vLy8vLy8vLy8vLy8vLy9cblxudmFyIGRlZmluZURhZ0V4dHJlbWl0eSA9IGZ1bmN0aW9uIGRlZmluZURhZ0V4dHJlbWl0eShwYXJhbXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGRhZ0V4dHJlbWl0eUltcGwoc2VsZWN0b3IpIHtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgdmFyIHJldCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgIGlmICghZWxlLmlzTm9kZSgpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGlzcXVhbGlmaWVkID0gZmFsc2U7XG4gICAgICB2YXIgZWRnZXMgPSBlbGUuY29ubmVjdGVkRWRnZXMoKTtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBlZGdlcy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2pdO1xuICAgICAgICB2YXIgc3JjID0gZWRnZS5zb3VyY2UoKTtcbiAgICAgICAgdmFyIHRndCA9IGVkZ2UudGFyZ2V0KCk7XG5cbiAgICAgICAgaWYgKHBhcmFtcy5ub0luY29taW5nRWRnZXMgJiYgdGd0ID09PSBlbGUgJiYgc3JjICE9PSBlbGUgfHwgcGFyYW1zLm5vT3V0Z29pbmdFZGdlcyAmJiBzcmMgPT09IGVsZSAmJiB0Z3QgIT09IGVsZSkge1xuICAgICAgICAgIGRpc3F1YWxpZmllZCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFkaXNxdWFsaWZpZWQpIHtcbiAgICAgICAgcmV0LnB1c2goZWxlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zcGF3bihyZXQsIHsgdW5pcXVlOiB0cnVlIH0pLmZpbHRlcihzZWxlY3Rvcik7XG4gIH07XG59O1xuXG52YXIgZGVmaW5lRGFnT25lSG9wID0gZnVuY3Rpb24gZGVmaW5lRGFnT25lSG9wKHBhcmFtcykge1xuICByZXR1cm4gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgIHZhciBvRWxlcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gZWxlc1tpXTtcblxuICAgICAgaWYgKCFlbGUuaXNOb2RlKCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBlZGdlcyA9IGVsZS5jb25uZWN0ZWRFZGdlcygpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBlZGdlcy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2pdO1xuICAgICAgICB2YXIgc3JjID0gZWRnZS5zb3VyY2UoKTtcbiAgICAgICAgdmFyIHRndCA9IGVkZ2UudGFyZ2V0KCk7XG5cbiAgICAgICAgaWYgKHBhcmFtcy5vdXRnb2luZyAmJiBzcmMgPT09IGVsZSkge1xuICAgICAgICAgIG9FbGVzLnB1c2goZWRnZSk7XG4gICAgICAgICAgb0VsZXMucHVzaCh0Z3QpO1xuICAgICAgICB9IGVsc2UgaWYgKHBhcmFtcy5pbmNvbWluZyAmJiB0Z3QgPT09IGVsZSkge1xuICAgICAgICAgIG9FbGVzLnB1c2goZWRnZSk7XG4gICAgICAgICAgb0VsZXMucHVzaChzcmMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24ob0VsZXMsIHsgdW5pcXVlOiB0cnVlIH0pLmZpbHRlcihzZWxlY3Rvcik7XG4gIH07XG59O1xuXG52YXIgZGVmaW5lRGFnQWxsSG9wcyA9IGZ1bmN0aW9uIGRlZmluZURhZ0FsbEhvcHMocGFyYW1zKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgdmFyIHNFbGVzID0gW107XG4gICAgdmFyIHNFbGVzSWRzID0ge307XG5cbiAgICBmb3IgKDs7KSB7XG4gICAgICB2YXIgbmV4dCA9IHBhcmFtcy5vdXRnb2luZyA/IGVsZXMub3V0Z29lcnMoKSA6IGVsZXMuaW5jb21lcnMoKTtcblxuICAgICAgaWYgKG5leHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSAvLyBkb25lIGlmIG5vbmUgbGVmdFxuXG4gICAgICB2YXIgbmV3TmV4dCA9IGZhbHNlO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBuID0gbmV4dFtpXTtcbiAgICAgICAgdmFyIG5pZCA9IG4uaWQoKTtcblxuICAgICAgICBpZiAoIXNFbGVzSWRzW25pZF0pIHtcbiAgICAgICAgICBzRWxlc0lkc1tuaWRdID0gdHJ1ZTtcbiAgICAgICAgICBzRWxlcy5wdXNoKG4pO1xuICAgICAgICAgIG5ld05leHQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghbmV3TmV4dCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gLy8gZG9uZSBpZiB0b3VjaGVkIGFsbCBvdXRnb2VycyBhbHJlYWR5XG5cbiAgICAgIGVsZXMgPSBuZXh0O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNwYXduKHNFbGVzLCB7IHVuaXF1ZTogdHJ1ZSB9KS5maWx0ZXIoc2VsZWN0b3IpO1xuICB9O1xufTtcblxuZWxlc2ZuLmNsZWFyVHJhdmVyc2FsQ2FjaGUgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXNbaV0uX3ByaXZhdGUudHJhdmVyc2FsQ2FjaGUgPSBudWxsO1xuICB9XG59O1xuXG51dGlsLmV4dGVuZChlbGVzZm4sIHtcbiAgLy8gZ2V0IHRoZSByb290IG5vZGVzIGluIHRoZSBEQUdcbiAgcm9vdHM6IGRlZmluZURhZ0V4dHJlbWl0eSh7IG5vSW5jb21pbmdFZGdlczogdHJ1ZSB9KSxcblxuICAvLyBnZXQgdGhlIGxlYWYgbm9kZXMgaW4gdGhlIERBR1xuICBsZWF2ZXM6IGRlZmluZURhZ0V4dHJlbWl0eSh7IG5vT3V0Z29pbmdFZGdlczogdHJ1ZSB9KSxcblxuICAvLyBub3JtYWxseSBjYWxsZWQgY2hpbGRyZW4gaW4gZ3JhcGggdGhlb3J5XG4gIC8vIHRoZXNlIG5vZGVzID1lZGdlcz0+IG91dGdvaW5nIG5vZGVzXG4gIG91dGdvZXJzOiBjYWNoZShkZWZpbmVEYWdPbmVIb3AoeyBvdXRnb2luZzogdHJ1ZSB9KSwgJ291dGdvZXJzJyksXG5cbiAgLy8gYWthIERBRyBkZXNjZW5kYW50c1xuICBzdWNjZXNzb3JzOiBkZWZpbmVEYWdBbGxIb3BzKHsgb3V0Z29pbmc6IHRydWUgfSksXG5cbiAgLy8gbm9ybWFsbHkgY2FsbGVkIHBhcmVudHMgaW4gZ3JhcGggdGhlb3J5XG4gIC8vIHRoZXNlIG5vZGVzIDw9ZWRnZXM9IGluY29taW5nIG5vZGVzXG4gIGluY29tZXJzOiBjYWNoZShkZWZpbmVEYWdPbmVIb3AoeyBpbmNvbWluZzogdHJ1ZSB9KSwgJ2luY29tZXJzJyksXG5cbiAgLy8gYWthIERBRyBhbmNlc3RvcnNcbiAgcHJlZGVjZXNzb3JzOiBkZWZpbmVEYWdBbGxIb3BzKHsgaW5jb21pbmc6IHRydWUgfSlcbn0pO1xuXG4vLyBOZWlnaGJvdXJob29kIGZ1bmN0aW9uc1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxudXRpbC5leHRlbmQoZWxlc2ZuLCB7XG4gIG5laWdoYm9yaG9vZDogY2FjaGUoZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgdmFyIGVsZW1lbnRzID0gW107XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gZm9yIGFsbCBub2Rlc1xuICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgIHZhciBjb25uZWN0ZWRFZGdlcyA9IG5vZGUuY29ubmVjdGVkRWRnZXMoKTtcblxuICAgICAgLy8gZm9yIGVhY2ggY29ubmVjdGVkIGVkZ2UsIGFkZCB0aGUgZWRnZSBhbmQgdGhlIG90aGVyIG5vZGVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29ubmVjdGVkRWRnZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBjb25uZWN0ZWRFZGdlc1tqXTtcbiAgICAgICAgdmFyIHNyYyA9IGVkZ2Uuc291cmNlKCk7XG4gICAgICAgIHZhciB0Z3QgPSBlZGdlLnRhcmdldCgpO1xuICAgICAgICB2YXIgb3RoZXJOb2RlID0gbm9kZSA9PT0gc3JjID8gdGd0IDogc3JjO1xuXG4gICAgICAgIC8vIG5lZWQgY2hlY2sgaW4gY2FzZSBvZiBsb29wXG4gICAgICAgIGlmIChvdGhlck5vZGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGVsZW1lbnRzLnB1c2gob3RoZXJOb2RlWzBdKTsgLy8gYWRkIG5vZGUgMSBob3AgYXdheVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIGNvbm5lY3RlZCBlZGdlXG4gICAgICAgIGVsZW1lbnRzLnB1c2goZWRnZVswXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oZWxlbWVudHMsIHsgdW5pcXVlOiB0cnVlIH0pLmZpbHRlcihzZWxlY3Rvcik7XG4gIH0sICduZWlnaGJvcmhvb2QnKSxcblxuICBjbG9zZWROZWlnaGJvcmhvb2Q6IGZ1bmN0aW9uIGNsb3NlZE5laWdoYm9yaG9vZChzZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLm5laWdoYm9yaG9vZCgpLmFkZCh0aGlzKS5maWx0ZXIoc2VsZWN0b3IpO1xuICB9LFxuXG4gIG9wZW5OZWlnaGJvcmhvb2Q6IGZ1bmN0aW9uIG9wZW5OZWlnaGJvcmhvb2Qoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5uZWlnaGJvcmhvb2Qoc2VsZWN0b3IpO1xuICB9XG59KTtcblxuLy8gYWxpYXNlc1xuZWxlc2ZuLm5laWdoYm91cmhvb2QgPSBlbGVzZm4ubmVpZ2hib3Job29kO1xuZWxlc2ZuLmNsb3NlZE5laWdoYm91cmhvb2QgPSBlbGVzZm4uY2xvc2VkTmVpZ2hib3Job29kO1xuZWxlc2ZuLm9wZW5OZWlnaGJvdXJob29kID0gZWxlc2ZuLm9wZW5OZWlnaGJvcmhvb2Q7XG5cbi8vIEVkZ2UgZnVuY3Rpb25zXG4vLy8vLy8vLy8vLy8vLy8vL1xuXG51dGlsLmV4dGVuZChlbGVzZm4sIHtcbiAgc291cmNlOiBjYWNoZShmdW5jdGlvbiBzb3VyY2VJbXBsKHNlbGVjdG9yKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgdmFyIHNyYyA9IHZvaWQgMDtcblxuICAgIGlmIChlbGUpIHtcbiAgICAgIHNyYyA9IGVsZS5fcHJpdmF0ZS5zb3VyY2UgfHwgZWxlLmN5KCkuY29sbGVjdGlvbigpO1xuICAgIH1cblxuICAgIHJldHVybiBzcmMgJiYgc2VsZWN0b3IgPyBzcmMuZmlsdGVyKHNlbGVjdG9yKSA6IHNyYztcbiAgfSwgJ3NvdXJjZScpLFxuXG4gIHRhcmdldDogY2FjaGUoZnVuY3Rpb24gdGFyZ2V0SW1wbChzZWxlY3Rvcikge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHZhciB0Z3QgPSB2b2lkIDA7XG5cbiAgICBpZiAoZWxlKSB7XG4gICAgICB0Z3QgPSBlbGUuX3ByaXZhdGUudGFyZ2V0IHx8IGVsZS5jeSgpLmNvbGxlY3Rpb24oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGd0ICYmIHNlbGVjdG9yID8gdGd0LmZpbHRlcihzZWxlY3RvcikgOiB0Z3Q7XG4gIH0sICd0YXJnZXQnKSxcblxuICBzb3VyY2VzOiBkZWZpbmVTb3VyY2VGdW5jdGlvbih7XG4gICAgYXR0cjogJ3NvdXJjZSdcbiAgfSksXG5cbiAgdGFyZ2V0czogZGVmaW5lU291cmNlRnVuY3Rpb24oe1xuICAgIGF0dHI6ICd0YXJnZXQnXG4gIH0pXG59KTtcblxuZnVuY3Rpb24gZGVmaW5lU291cmNlRnVuY3Rpb24ocGFyYW1zKSB7XG4gIHJldHVybiBmdW5jdGlvbiBzb3VyY2VJbXBsKHNlbGVjdG9yKSB7XG4gICAgdmFyIHNvdXJjZXMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICB2YXIgc3JjID0gZWxlLl9wcml2YXRlW3BhcmFtcy5hdHRyXTtcblxuICAgICAgaWYgKHNyYykge1xuICAgICAgICBzb3VyY2VzLnB1c2goc3JjKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zcGF3bihzb3VyY2VzLCB7IHVuaXF1ZTogdHJ1ZSB9KS5maWx0ZXIoc2VsZWN0b3IpO1xuICB9O1xufVxuXG51dGlsLmV4dGVuZChlbGVzZm4sIHtcbiAgZWRnZXNXaXRoOiBjYWNoZShkZWZpbmVFZGdlc1dpdGhGdW5jdGlvbigpLCAnZWRnZXNXaXRoJyksXG5cbiAgZWRnZXNUbzogY2FjaGUoZGVmaW5lRWRnZXNXaXRoRnVuY3Rpb24oe1xuICAgIHRoaXNJc1NyYzogdHJ1ZVxuICB9KSwgJ2VkZ2VzVG8nKVxufSk7XG5cbmZ1bmN0aW9uIGRlZmluZUVkZ2VzV2l0aEZ1bmN0aW9uKHBhcmFtcykge1xuXG4gIHJldHVybiBmdW5jdGlvbiBlZGdlc1dpdGhJbXBsKG90aGVyTm9kZXMpIHtcbiAgICB2YXIgZWxlbWVudHMgPSBbXTtcbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgIHZhciBwID0gcGFyYW1zIHx8IHt9O1xuXG4gICAgLy8gZ2V0IGVsZW1lbnRzIGlmIGEgc2VsZWN0b3IgaXMgc3BlY2lmaWVkXG4gICAgaWYgKGlzLnN0cmluZyhvdGhlck5vZGVzKSkge1xuICAgICAgb3RoZXJOb2RlcyA9IGN5LiQob3RoZXJOb2Rlcyk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaCA9IDA7IGggPCBvdGhlck5vZGVzLmxlbmd0aDsgaCsrKSB7XG4gICAgICB2YXIgZWRnZXMgPSBvdGhlck5vZGVzW2hdLl9wcml2YXRlLmVkZ2VzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlZGdlID0gZWRnZXNbaV07XG4gICAgICAgIHZhciBlZGdlRGF0YSA9IGVkZ2UuX3ByaXZhdGUuZGF0YTtcbiAgICAgICAgdmFyIHRoaXNUb090aGVyID0gdGhpcy5oYXNFbGVtZW50V2l0aElkKGVkZ2VEYXRhLnNvdXJjZSkgJiYgb3RoZXJOb2Rlcy5oYXNFbGVtZW50V2l0aElkKGVkZ2VEYXRhLnRhcmdldCk7XG4gICAgICAgIHZhciBvdGhlclRvVGhpcyA9IG90aGVyTm9kZXMuaGFzRWxlbWVudFdpdGhJZChlZGdlRGF0YS5zb3VyY2UpICYmIHRoaXMuaGFzRWxlbWVudFdpdGhJZChlZGdlRGF0YS50YXJnZXQpO1xuICAgICAgICB2YXIgZWRnZUNvbm5lY3RzVGhpc0FuZE90aGVyID0gdGhpc1RvT3RoZXIgfHwgb3RoZXJUb1RoaXM7XG5cbiAgICAgICAgaWYgKCFlZGdlQ29ubmVjdHNUaGlzQW5kT3RoZXIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwLnRoaXNJc1NyYyB8fCBwLnRoaXNJc1RndCkge1xuICAgICAgICAgIGlmIChwLnRoaXNJc1NyYyAmJiAhdGhpc1RvT3RoZXIpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwLnRoaXNJc1RndCAmJiAhb3RoZXJUb1RoaXMpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnRzLnB1c2goZWRnZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oZWxlbWVudHMsIHsgdW5pcXVlOiB0cnVlIH0pO1xuICB9O1xufVxuXG51dGlsLmV4dGVuZChlbGVzZm4sIHtcbiAgY29ubmVjdGVkRWRnZXM6IGNhY2hlKGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgIHZhciByZXRFbGVzID0gW107XG5cbiAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbm9kZSA9IGVsZXNbaV07XG4gICAgICBpZiAoIW5vZGUuaXNOb2RlKCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBlZGdlcyA9IG5vZGUuX3ByaXZhdGUuZWRnZXM7XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZWRnZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tqXTtcbiAgICAgICAgcmV0RWxlcy5wdXNoKGVkZ2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNwYXduKHJldEVsZXMsIHsgdW5pcXVlOiB0cnVlIH0pLmZpbHRlcihzZWxlY3Rvcik7XG4gIH0sICdjb25uZWN0ZWRFZGdlcycpLFxuXG4gIGNvbm5lY3RlZE5vZGVzOiBjYWNoZShmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICB2YXIgcmV0RWxlcyA9IFtdO1xuXG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVkZ2UgPSBlbGVzW2ldO1xuICAgICAgaWYgKCFlZGdlLmlzRWRnZSgpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICByZXRFbGVzLnB1c2goZWRnZS5zb3VyY2UoKVswXSk7XG4gICAgICByZXRFbGVzLnB1c2goZWRnZS50YXJnZXQoKVswXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24ocmV0RWxlcywgeyB1bmlxdWU6IHRydWUgfSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfSwgJ2Nvbm5lY3RlZE5vZGVzJyksXG5cbiAgcGFyYWxsZWxFZGdlczogY2FjaGUoZGVmaW5lUGFyYWxsZWxFZGdlc0Z1bmN0aW9uKCksICdwYXJhbGxlbEVkZ2VzJyksXG5cbiAgY29kaXJlY3RlZEVkZ2VzOiBjYWNoZShkZWZpbmVQYXJhbGxlbEVkZ2VzRnVuY3Rpb24oe1xuICAgIGNvZGlyZWN0ZWQ6IHRydWVcbiAgfSksICdjb2RpcmVjdGVkRWRnZXMnKVxufSk7XG5cbmZ1bmN0aW9uIGRlZmluZVBhcmFsbGVsRWRnZXNGdW5jdGlvbihwYXJhbXMpIHtcbiAgdmFyIGRlZmF1bHRzID0ge1xuICAgIGNvZGlyZWN0ZWQ6IGZhbHNlXG4gIH07XG4gIHBhcmFtcyA9IHV0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0cywgcGFyYW1zKTtcblxuICByZXR1cm4gZnVuY3Rpb24gcGFyYWxsZWxFZGdlc0ltcGwoc2VsZWN0b3IpIHtcbiAgICAvLyBtaWNyby1vcHRpbWlzZWQgZm9yIHJlbmRlcmVyXG4gICAgdmFyIGVsZW1lbnRzID0gW107XG4gICAgdmFyIGVkZ2VzID0gdGhpcy5lZGdlcygpO1xuICAgIHZhciBwID0gcGFyYW1zO1xuXG4gICAgLy8gbG9vayBhdCBhbGwgdGhlIGVkZ2VzIGluIHRoZSBjb2xsZWN0aW9uXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVkZ2UxID0gZWRnZXNbaV07XG4gICAgICB2YXIgZWRnZTFfcCA9IGVkZ2UxLl9wcml2YXRlO1xuICAgICAgdmFyIHNyYzEgPSBlZGdlMV9wLnNvdXJjZTtcbiAgICAgIHZhciBzcmNpZDEgPSBzcmMxLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICB2YXIgdGd0aWQxID0gZWRnZTFfcC5kYXRhLnRhcmdldDtcbiAgICAgIHZhciBzcmNFZGdlczEgPSBzcmMxLl9wcml2YXRlLmVkZ2VzO1xuXG4gICAgICAvLyBsb29rIGF0IGVkZ2VzIGNvbm5lY3RlZCB0byB0aGUgc3JjIG5vZGUgb2YgdGhpcyBlZGdlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNyY0VkZ2VzMS5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgZWRnZTIgPSBzcmNFZGdlczFbal07XG4gICAgICAgIHZhciBlZGdlMmRhdGEgPSBlZGdlMi5fcHJpdmF0ZS5kYXRhO1xuICAgICAgICB2YXIgdGd0aWQyID0gZWRnZTJkYXRhLnRhcmdldDtcbiAgICAgICAgdmFyIHNyY2lkMiA9IGVkZ2UyZGF0YS5zb3VyY2U7XG5cbiAgICAgICAgdmFyIGNvZGlyZWN0ZWQgPSB0Z3RpZDIgPT09IHRndGlkMSAmJiBzcmNpZDIgPT09IHNyY2lkMTtcbiAgICAgICAgdmFyIG9wcGRpcmVjdGVkID0gc3JjaWQxID09PSB0Z3RpZDIgJiYgdGd0aWQxID09PSBzcmNpZDI7XG5cbiAgICAgICAgaWYgKHAuY29kaXJlY3RlZCAmJiBjb2RpcmVjdGVkIHx8ICFwLmNvZGlyZWN0ZWQgJiYgKGNvZGlyZWN0ZWQgfHwgb3BwZGlyZWN0ZWQpKSB7XG4gICAgICAgICAgZWxlbWVudHMucHVzaChlZGdlMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zcGF3bihlbGVtZW50cywgeyB1bmlxdWU6IHRydWUgfSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfTtcbn1cblxuLy8gTWlzYyBmdW5jdGlvbnNcbi8vLy8vLy8vLy8vLy8vLy8vXG5cbnV0aWwuZXh0ZW5kKGVsZXNmbiwge1xuICBjb21wb25lbnRzOiBmdW5jdGlvbiBjb21wb25lbnRzKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY3kgPSBzZWxmLmN5KCk7XG4gICAgdmFyIHZpc2l0ZWQgPSBzZWxmLnNwYXduKCk7XG4gICAgdmFyIHVudmlzaXRlZCA9IHNlbGYubm9kZXMoKS5zcGF3blNlbGYoKTtcbiAgICB2YXIgY29tcG9uZW50cyA9IFtdO1xuXG4gICAgdmFyIHZpc2l0SW5Db21wb25lbnQgPSBmdW5jdGlvbiB2aXNpdEluQ29tcG9uZW50KG5vZGUsIGNvbXBvbmVudCkge1xuICAgICAgdmlzaXRlZC5tZXJnZShub2RlKTtcbiAgICAgIHVudmlzaXRlZC51bm1lcmdlKG5vZGUpO1xuICAgICAgY29tcG9uZW50Lm1lcmdlKG5vZGUpO1xuICAgIH07XG5cbiAgICBpZiAodW52aXNpdGVkLmVtcHR5KCkpIHtcbiAgICAgIHJldHVybiBzZWxmLnNwYXduKCk7XG4gICAgfVxuXG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgICB2YXIgY29tcG9uZW50ID0gY3kuY29sbGVjdGlvbigpO1xuICAgICAgY29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG5cbiAgICAgIHZhciByb290ID0gdW52aXNpdGVkWzBdO1xuICAgICAgdmlzaXRJbkNvbXBvbmVudChyb290LCBjb21wb25lbnQpO1xuXG4gICAgICBzZWxmLmJmcyh7XG4gICAgICAgIGRpcmVjdGVkOiBmYWxzZSxcbiAgICAgICAgcm9vdHM6IHJvb3QsXG4gICAgICAgIHZpc2l0OiBmdW5jdGlvbiB2aXNpdCh2LCBlLCB1LCBpLCBkZXB0aCkge1xuICAgICAgICAgIHZpc2l0SW5Db21wb25lbnQodiwgY29tcG9uZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGRvIHtcbiAgICAgIF9sb29wKCk7XG4gICAgfSB3aGlsZSAodW52aXNpdGVkLmxlbmd0aCA+IDApO1xuXG4gICAgcmV0dXJuIGNvbXBvbmVudHMubWFwKGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgIHZhciBjb25uZWN0ZWRFZGdlcyA9IGNvbXBvbmVudC5jb25uZWN0ZWRFZGdlcygpLnN0ZEZpbHRlcihmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICByZXR1cm4gY29tcG9uZW50LmFueVNhbWUoZWRnZS5zb3VyY2UoKSkgJiYgY29tcG9uZW50LmFueVNhbWUoZWRnZS50YXJnZXQoKSk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGNvbXBvbmVudC51bmlvbihjb25uZWN0ZWRFZGdlcyk7XG4gICAgfSk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVsZXNmbjtcblxuLyoqKi8gfSksXG4vKiA2OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xudmFyIENvbGxlY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xudmFyIEVsZW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcblxudmFyIGNvcmVmbiA9IHtcbiAgYWRkOiBmdW5jdGlvbiBhZGQob3B0cykge1xuXG4gICAgdmFyIGVsZW1lbnRzID0gdm9pZCAwO1xuICAgIHZhciBjeSA9IHRoaXM7XG5cbiAgICAvLyBhZGQgdGhlIGVsZW1lbnRzXG4gICAgaWYgKGlzLmVsZW1lbnRPckNvbGxlY3Rpb24ob3B0cykpIHtcbiAgICAgIHZhciBlbGVzID0gb3B0cztcblxuICAgICAgaWYgKGVsZXMuX3ByaXZhdGUuY3kgPT09IGN5KSB7XG4gICAgICAgIC8vIHNhbWUgaW5zdGFuY2UgPT4ganVzdCByZXN0b3JlXG4gICAgICAgIGVsZW1lbnRzID0gZWxlcy5yZXN0b3JlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBvdGhlcndpc2UsIGNvcHkgZnJvbSBqc29uXG4gICAgICAgIHZhciBqc29ucyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICAgIGpzb25zLnB1c2goZWxlLmpzb24oKSk7XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtZW50cyA9IG5ldyBDb2xsZWN0aW9uKGN5LCBqc29ucyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gc3BlY2lmeSBhbiBhcnJheSBvZiBvcHRpb25zXG4gICAgZWxzZSBpZiAoaXMuYXJyYXkob3B0cykpIHtcbiAgICAgICAgdmFyIF9qc29ucyA9IG9wdHM7XG5cbiAgICAgICAgZWxlbWVudHMgPSBuZXcgQ29sbGVjdGlvbihjeSwgX2pzb25zKTtcbiAgICAgIH1cblxuICAgICAgLy8gc3BlY2lmeSB2aWEgb3B0cy5ub2RlcyBhbmQgb3B0cy5lZGdlc1xuICAgICAgZWxzZSBpZiAoaXMucGxhaW5PYmplY3Qob3B0cykgJiYgKGlzLmFycmF5KG9wdHMubm9kZXMpIHx8IGlzLmFycmF5KG9wdHMuZWRnZXMpKSkge1xuICAgICAgICAgIHZhciBlbGVzQnlHcm91cCA9IG9wdHM7XG4gICAgICAgICAgdmFyIF9qc29uczIgPSBbXTtcblxuICAgICAgICAgIHZhciBncnMgPSBbJ25vZGVzJywgJ2VkZ2VzJ107XG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBpbCA9IGdycy5sZW5ndGg7IF9pIDwgaWw7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBncm91cCA9IGdyc1tfaV07XG4gICAgICAgICAgICB2YXIgZWxlc0FycmF5ID0gZWxlc0J5R3JvdXBbZ3JvdXBdO1xuXG4gICAgICAgICAgICBpZiAoaXMuYXJyYXkoZWxlc0FycmF5KSkge1xuXG4gICAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBqbCA9IGVsZXNBcnJheS5sZW5ndGg7IGogPCBqbDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGpzb24gPSB1dGlsLmV4dGVuZCh7IGdyb3VwOiBncm91cCB9LCBlbGVzQXJyYXlbal0pO1xuXG4gICAgICAgICAgICAgICAgX2pzb25zMi5wdXNoKGpzb24pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZWxlbWVudHMgPSBuZXcgQ29sbGVjdGlvbihjeSwgX2pzb25zMik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzcGVjaWZ5IG9wdGlvbnMgZm9yIG9uZSBlbGVtZW50XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIF9qc29uID0gb3B0cztcbiAgICAgICAgICAgIGVsZW1lbnRzID0gbmV3IEVsZW1lbnQoY3ksIF9qc29uKS5jb2xsZWN0aW9uKCk7XG4gICAgICAgICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnRzO1xuICB9LFxuXG4gIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKGNvbGxlY3Rpb24pIHtcbiAgICBpZiAoaXMuZWxlbWVudE9yQ29sbGVjdGlvbihjb2xsZWN0aW9uKSkge1xuICAgICAgLy8gYWxyZWFkeSBoYXZlIHJpZ2h0IHJlZlxuICAgIH0gZWxzZSBpZiAoaXMuc3RyaW5nKGNvbGxlY3Rpb24pKSB7XG4gICAgICB2YXIgc2VsZWN0b3IgPSBjb2xsZWN0aW9uO1xuICAgICAgY29sbGVjdGlvbiA9IHRoaXMuJChzZWxlY3Rvcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbGxlY3Rpb24ucmVtb3ZlKCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY29yZWZuO1xuXG4vKioqLyB9KSxcbi8qIDcwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBkZWZpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xudmFyIHN0ZXBBbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcxKTtcblxudmFyIGNvcmVmbiA9IHtcblxuICAvLyBwdWxsIGluIGFuaW1hdGlvbiBmdW5jdGlvbnNcbiAgYW5pbWF0ZTogZGVmaW5lLmFuaW1hdGUoKSxcbiAgYW5pbWF0aW9uOiBkZWZpbmUuYW5pbWF0aW9uKCksXG4gIGFuaW1hdGVkOiBkZWZpbmUuYW5pbWF0ZWQoKSxcbiAgY2xlYXJRdWV1ZTogZGVmaW5lLmNsZWFyUXVldWUoKSxcbiAgZGVsYXk6IGRlZmluZS5kZWxheSgpLFxuICBkZWxheUFuaW1hdGlvbjogZGVmaW5lLmRlbGF5QW5pbWF0aW9uKCksXG4gIHN0b3A6IGRlZmluZS5zdG9wKCksXG5cbiAgYWRkVG9BbmltYXRpb25Qb29sOiBmdW5jdGlvbiBhZGRUb0FuaW1hdGlvblBvb2woZWxlcykge1xuICAgIHZhciBjeSA9IHRoaXM7XG5cbiAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBzYXZlIGN5Y2xlcyB3aGVuIG5vIHN0eWxlIHVzZWRcblxuICAgIGN5Ll9wcml2YXRlLmFuaUVsZXMubWVyZ2UoZWxlcyk7XG4gIH0sXG5cbiAgc3RvcEFuaW1hdGlvbkxvb3A6IGZ1bmN0aW9uIHN0b3BBbmltYXRpb25Mb29wKCkge1xuICAgIHRoaXMuX3ByaXZhdGUuYW5pbWF0aW9uc1J1bm5pbmcgPSBmYWxzZTtcbiAgfSxcblxuICBzdGFydEFuaW1hdGlvbkxvb3A6IGZ1bmN0aW9uIHN0YXJ0QW5pbWF0aW9uTG9vcCgpIHtcbiAgICB2YXIgY3kgPSB0aGlzO1xuXG4gICAgY3kuX3ByaXZhdGUuYW5pbWF0aW9uc1J1bm5pbmcgPSB0cnVlO1xuXG4gICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gc2F2ZSBjeWNsZXMgd2hlbiBubyBzdHlsZSB1c2VkXG5cbiAgICAvLyBOQiB0aGUgYW5pbWF0aW9uIGxvb3Agd2lsbCBleGVjIGluIGhlYWRsZXNzIGVudmlyb25tZW50cyBpZiBzdHlsZSBlbmFibGVkXG4gICAgLy8gYW5kIGV4cGxpY2l0IGN5LmRlc3Ryb3koKSBpcyBuZWNlc3NhcnkgdG8gc3RvcCB0aGUgbG9vcFxuXG4gICAgZnVuY3Rpb24gaGVhZGxlc3NTdGVwKCkge1xuICAgICAgaWYgKCFjeS5fcHJpdmF0ZS5hbmltYXRpb25zUnVubmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHV0aWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uIGFuaW1hdGlvblN0ZXAobm93KSB7XG4gICAgICAgIHN0ZXBBbGwobm93LCBjeSk7XG4gICAgICAgIGhlYWRsZXNzU3RlcCgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIHJlbmRlcmVyID0gY3kucmVuZGVyZXIoKTtcblxuICAgIGlmIChyZW5kZXJlciAmJiByZW5kZXJlci5iZWZvcmVSZW5kZXIpIHtcbiAgICAgIC8vIGxldCB0aGUgcmVuZGVyZXIgc2NoZWR1bGUgYW5pbWF0aW9uc1xuICAgICAgcmVuZGVyZXIuYmVmb3JlUmVuZGVyKGZ1bmN0aW9uIHJlbmRlcmVyQW5pbWF0aW9uU3RlcCh3aWxsRHJhdywgbm93KSB7XG4gICAgICAgIHN0ZXBBbGwobm93LCBjeSk7XG4gICAgICB9LCByZW5kZXJlci5iZWZvcmVSZW5kZXJQcmlvcml0aWVzLmFuaW1hdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBtYW5hZ2UgdGhlIGFuaW1hdGlvbiBsb29wIG91cnNlbHZlc1xuICAgICAgaGVhZGxlc3NTdGVwKCk7IC8vIGZpcnN0IGNhbGxcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb3JlZm47XG5cbi8qKiovIH0pLFxuLyogNzEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIHN0ZXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcyKTtcbnZhciBzdGFydEFuaW1hdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNzcpO1xuXG5mdW5jdGlvbiBzdGVwQWxsKG5vdywgY3kpIHtcbiAgdmFyIGVsZXMgPSBjeS5fcHJpdmF0ZS5hbmlFbGVzO1xuICB2YXIgZG9uZUVsZXMgPSBbXTtcblxuICBmdW5jdGlvbiBzdGVwT25lKGVsZSwgaXNDb3JlKSB7XG4gICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgIHZhciBjdXJyZW50ID0gX3AuYW5pbWF0aW9uLmN1cnJlbnQ7XG4gICAgdmFyIHF1ZXVlID0gX3AuYW5pbWF0aW9uLnF1ZXVlO1xuICAgIHZhciByYW5BbmlzID0gZmFsc2U7XG5cbiAgICAvLyBjYW5jZWwgYWxsIGFuaW1hdGlvbnMgb24gZGlzcGxheTpub25lIGVsZVxuICAgIGlmICghaXNDb3JlICYmIGVsZS5wc3R5bGUoJ2Rpc3BsYXknKS52YWx1ZSA9PT0gJ25vbmUnKSB7XG4gICAgICAvLyBwdXQgYWxsIGN1cnJlbnQgYW5kIHF1ZXVlIGFuaW1hdGlvbnMgaW4gdGhpcyB0aWNrJ3MgY3VycmVudCBsaXN0XG4gICAgICAvLyBhbmQgZW1wdHkgdGhlIGxpc3RzIGZvciB0aGUgZWxlbWVudFxuICAgICAgY3VycmVudCA9IGN1cnJlbnQuc3BsaWNlKDAsIGN1cnJlbnQubGVuZ3RoKS5jb25jYXQocXVldWUuc3BsaWNlKDAsIHF1ZXVlLmxlbmd0aCkpO1xuXG4gICAgICAvLyBzdG9wIGFsbCBhbmltYXRpb25zXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN1cnJlbnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY3VycmVudFtpXS5zdG9wKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgbm90aGluZyBjdXJyZW50bHkgYW5pbWF0aW5nLCBnZXQgc29tZXRoaW5nIGZyb20gdGhlIHF1ZXVlXG4gICAgaWYgKGN1cnJlbnQubGVuZ3RoID09PSAwKSB7XG4gICAgICB2YXIgbmV4dCA9IHF1ZXVlLnNoaWZ0KCk7XG5cbiAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgIGN1cnJlbnQucHVzaChuZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2FsbGJhY2tzID0gZnVuY3Rpb24gY2FsbGJhY2tzKF9jYWxsYmFja3MpIHtcbiAgICAgIGZvciAodmFyIGogPSBfY2FsbGJhY2tzLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgIHZhciBjYiA9IF9jYWxsYmFja3Nbal07XG5cbiAgICAgICAgY2IoKTtcbiAgICAgIH1cblxuICAgICAgX2NhbGxiYWNrcy5zcGxpY2UoMCwgX2NhbGxiYWNrcy5sZW5ndGgpO1xuICAgIH07XG5cbiAgICAvLyBzdGVwIGFuZCByZW1vdmUgaWYgZG9uZVxuICAgIGZvciAodmFyIF9pID0gY3VycmVudC5sZW5ndGggLSAxOyBfaSA+PSAwOyBfaS0tKSB7XG4gICAgICB2YXIgYW5pID0gY3VycmVudFtfaV07XG4gICAgICB2YXIgYW5pX3AgPSBhbmkuX3ByaXZhdGU7XG5cbiAgICAgIGlmIChhbmlfcC5zdG9wcGVkKSB7XG4gICAgICAgIGN1cnJlbnQuc3BsaWNlKF9pLCAxKTtcblxuICAgICAgICBhbmlfcC5ob29rZWQgPSBmYWxzZTtcbiAgICAgICAgYW5pX3AucGxheWluZyA9IGZhbHNlO1xuICAgICAgICBhbmlfcC5zdGFydGVkID0gZmFsc2U7XG5cbiAgICAgICAgY2FsbGJhY2tzKGFuaV9wLmZyYW1lcyk7XG5cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghYW5pX3AucGxheWluZyAmJiAhYW5pX3AuYXBwbHlpbmcpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGFuIGFwcGx5KCkgd2hpbGUgcGxheWluZyBzaG91bGRuJ3QgZG8gYW55dGhpbmdcbiAgICAgIGlmIChhbmlfcC5wbGF5aW5nICYmIGFuaV9wLmFwcGx5aW5nKSB7XG4gICAgICAgIGFuaV9wLmFwcGx5aW5nID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICghYW5pX3Auc3RhcnRlZCkge1xuICAgICAgICBzdGFydEFuaW1hdGlvbihlbGUsIGFuaSwgbm93LCBpc0NvcmUpO1xuICAgICAgfVxuXG4gICAgICBzdGVwKGVsZSwgYW5pLCBub3csIGlzQ29yZSk7XG5cbiAgICAgIGlmIChhbmlfcC5hcHBseWluZykge1xuICAgICAgICBhbmlfcC5hcHBseWluZyA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBjYWxsYmFja3MoYW5pX3AuZnJhbWVzKTtcblxuICAgICAgaWYgKGFuaS5jb21wbGV0ZWQoKSkge1xuICAgICAgICBjdXJyZW50LnNwbGljZShfaSwgMSk7XG5cbiAgICAgICAgYW5pX3AuaG9va2VkID0gZmFsc2U7XG4gICAgICAgIGFuaV9wLnBsYXlpbmcgPSBmYWxzZTtcbiAgICAgICAgYW5pX3Auc3RhcnRlZCA9IGZhbHNlO1xuXG4gICAgICAgIGNhbGxiYWNrcyhhbmlfcC5jb21wbGV0ZXMpO1xuICAgICAgfVxuXG4gICAgICByYW5BbmlzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoIWlzQ29yZSAmJiBjdXJyZW50Lmxlbmd0aCA9PT0gMCAmJiBxdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgIGRvbmVFbGVzLnB1c2goZWxlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmFuQW5pcztcbiAgfSAvLyBzdGVwRWxlbWVudFxuXG4gIC8vIGhhbmRsZSBhbGwgZWxlc1xuICB2YXIgcmFuRWxlQW5pID0gZmFsc2U7XG4gIGZvciAodmFyIGUgPSAwOyBlIDwgZWxlcy5sZW5ndGg7IGUrKykge1xuICAgIHZhciBlbGUgPSBlbGVzW2VdO1xuICAgIHZhciBoYW5kbGVkVGhpc0VsZSA9IHN0ZXBPbmUoZWxlKTtcblxuICAgIHJhbkVsZUFuaSA9IHJhbkVsZUFuaSB8fCBoYW5kbGVkVGhpc0VsZTtcbiAgfSAvLyBlYWNoIGVsZW1lbnRcblxuICB2YXIgcmFuQ29yZUFuaSA9IHN0ZXBPbmUoY3ksIHRydWUpO1xuXG4gIC8vIG5vdGlmeSByZW5kZXJlclxuICBpZiAocmFuRWxlQW5pIHx8IHJhbkNvcmVBbmkpIHtcbiAgICBpZiAoZWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICBlbGVzLmRpcnR5Q29tcG91bmRCb3VuZHNDYWNoZSgpO1xuXG4gICAgICBjeS5ub3RpZnkoe1xuICAgICAgICB0eXBlOiAnZHJhdycsXG4gICAgICAgIGVsZXM6IGVsZXNcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjeS5ub3RpZnkoe1xuICAgICAgICB0eXBlOiAnZHJhdydcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIHJlbW92ZSBlbGVtZW50cyBmcm9tIGxpc3Qgb2YgY3VycmVudGx5IGFuaW1hdGluZyBpZiBpdHMgcXVldWVzIGFyZSBlbXB0eVxuICBlbGVzLnVubWVyZ2UoZG9uZUVsZXMpO1xuXG4gIGN5LmVtaXQoJ3N0ZXAnKTtcbn0gLy8gc3RlcEFsbFxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0ZXBBbGw7XG5cbi8qKiovIH0pLFxuLyogNzIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGVhc2luZ3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDczKTtcbnZhciBlYXNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Nik7XG52YXIgaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5mdW5jdGlvbiBzdGVwKHNlbGYsIGFuaSwgbm93LCBpc0NvcmUpIHtcbiAgdmFyIGlzRWxlcyA9ICFpc0NvcmU7XG4gIHZhciBfcCA9IHNlbGYuX3ByaXZhdGU7XG4gIHZhciBhbmlfcCA9IGFuaS5fcHJpdmF0ZTtcbiAgdmFyIHBFYXNpbmcgPSBhbmlfcC5lYXNpbmc7XG4gIHZhciBzdGFydFRpbWUgPSBhbmlfcC5zdGFydFRpbWU7XG4gIHZhciBjeSA9IGlzQ29yZSA/IHNlbGYgOiBzZWxmLmN5KCk7XG4gIHZhciBzdHlsZSA9IGN5LnN0eWxlKCk7XG5cbiAgaWYgKCFhbmlfcC5lYXNpbmdJbXBsKSB7XG5cbiAgICBpZiAocEVhc2luZyA9PSBudWxsKSB7XG4gICAgICAvLyB1c2UgZGVmYXVsdFxuICAgICAgYW5pX3AuZWFzaW5nSW1wbCA9IGVhc2luZ3NbJ2xpbmVhciddO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0aGVuIGRlZmluZSB3LyBuYW1lXG4gICAgICB2YXIgZWFzaW5nVmFscyA9IHZvaWQgMDtcblxuICAgICAgaWYgKGlzLnN0cmluZyhwRWFzaW5nKSkge1xuICAgICAgICB2YXIgZWFzaW5nUHJvcCA9IHN0eWxlLnBhcnNlKCd0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbicsIHBFYXNpbmcpO1xuXG4gICAgICAgIGVhc2luZ1ZhbHMgPSBlYXNpbmdQcm9wLnZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdGhlbiBhc3N1bWUgcHJlcGFyc2VkIGFycmF5XG4gICAgICAgIGVhc2luZ1ZhbHMgPSBwRWFzaW5nO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmFtZSA9IHZvaWQgMCxcbiAgICAgICAgICBhcmdzID0gdm9pZCAwO1xuXG4gICAgICBpZiAoaXMuc3RyaW5nKGVhc2luZ1ZhbHMpKSB7XG4gICAgICAgIG5hbWUgPSBlYXNpbmdWYWxzO1xuICAgICAgICBhcmdzID0gW107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuYW1lID0gZWFzaW5nVmFsc1sxXTtcbiAgICAgICAgYXJncyA9IGVhc2luZ1ZhbHMuc2xpY2UoMikubWFwKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgcmV0dXJuICtuO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBjcmVhdGUgd2l0aCBhcmdzXG4gICAgICAgIGlmIChuYW1lID09PSAnc3ByaW5nJykge1xuICAgICAgICAgIGFyZ3MucHVzaChhbmlfcC5kdXJhdGlvbik7IC8vIG5lZWQgZHVyYXRpb24gdG8gZ2VuZXJhdGUgc3ByaW5nXG4gICAgICAgIH1cblxuICAgICAgICBhbmlfcC5lYXNpbmdJbXBsID0gZWFzaW5nc1tuYW1lXS5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHN0YXRpYyBpbXBsIGJ5IG5hbWVcbiAgICAgICAgYW5pX3AuZWFzaW5nSW1wbCA9IGVhc2luZ3NbbmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGVhc2luZyA9IGFuaV9wLmVhc2luZ0ltcGw7XG4gIHZhciBwZXJjZW50ID0gdm9pZCAwO1xuXG4gIGlmIChhbmlfcC5kdXJhdGlvbiA9PT0gMCkge1xuICAgIHBlcmNlbnQgPSAxO1xuICB9IGVsc2Uge1xuICAgIHBlcmNlbnQgPSAobm93IC0gc3RhcnRUaW1lKSAvIGFuaV9wLmR1cmF0aW9uO1xuICB9XG5cbiAgaWYgKGFuaV9wLmFwcGx5aW5nKSB7XG4gICAgcGVyY2VudCA9IGFuaV9wLnByb2dyZXNzO1xuICB9XG5cbiAgaWYgKHBlcmNlbnQgPCAwKSB7XG4gICAgcGVyY2VudCA9IDA7XG4gIH0gZWxzZSBpZiAocGVyY2VudCA+IDEpIHtcbiAgICBwZXJjZW50ID0gMTtcbiAgfVxuXG4gIGlmIChhbmlfcC5kZWxheSA9PSBudWxsKSB7XG4gICAgLy8gdGhlbiB1cGRhdGVcblxuICAgIHZhciBzdGFydFBvcyA9IGFuaV9wLnN0YXJ0UG9zaXRpb247XG4gICAgdmFyIGVuZFBvcyA9IGFuaV9wLnBvc2l0aW9uO1xuXG4gICAgaWYgKGVuZFBvcyAmJiBpc0VsZXMgJiYgIXNlbGYubG9ja2VkKCkpIHtcbiAgICAgIHZhciBwb3MgPSBzZWxmLnBvc2l0aW9uKCk7XG5cbiAgICAgIGlmICh2YWxpZChzdGFydFBvcy54LCBlbmRQb3MueCkpIHtcbiAgICAgICAgcG9zLnggPSBlYXNlKHN0YXJ0UG9zLngsIGVuZFBvcy54LCBwZXJjZW50LCBlYXNpbmcpO1xuICAgICAgfVxuXG4gICAgICBpZiAodmFsaWQoc3RhcnRQb3MueSwgZW5kUG9zLnkpKSB7XG4gICAgICAgIHBvcy55ID0gZWFzZShzdGFydFBvcy55LCBlbmRQb3MueSwgcGVyY2VudCwgZWFzaW5nKTtcbiAgICAgIH1cblxuICAgICAgc2VsZi5lbWl0KCdwb3NpdGlvbicpO1xuICAgIH1cblxuICAgIHZhciBzdGFydFBhbiA9IGFuaV9wLnN0YXJ0UGFuO1xuICAgIHZhciBlbmRQYW4gPSBhbmlfcC5wYW47XG4gICAgdmFyIHBhbiA9IF9wLnBhbjtcbiAgICB2YXIgYW5pbWF0aW5nUGFuID0gZW5kUGFuICE9IG51bGwgJiYgaXNDb3JlO1xuICAgIGlmIChhbmltYXRpbmdQYW4pIHtcbiAgICAgIGlmICh2YWxpZChzdGFydFBhbi54LCBlbmRQYW4ueCkpIHtcbiAgICAgICAgcGFuLnggPSBlYXNlKHN0YXJ0UGFuLngsIGVuZFBhbi54LCBwZXJjZW50LCBlYXNpbmcpO1xuICAgICAgfVxuXG4gICAgICBpZiAodmFsaWQoc3RhcnRQYW4ueSwgZW5kUGFuLnkpKSB7XG4gICAgICAgIHBhbi55ID0gZWFzZShzdGFydFBhbi55LCBlbmRQYW4ueSwgcGVyY2VudCwgZWFzaW5nKTtcbiAgICAgIH1cblxuICAgICAgc2VsZi5lbWl0KCdwYW4nKTtcbiAgICB9XG5cbiAgICB2YXIgc3RhcnRab29tID0gYW5pX3Auc3RhcnRab29tO1xuICAgIHZhciBlbmRab29tID0gYW5pX3Auem9vbTtcbiAgICB2YXIgYW5pbWF0aW5nWm9vbSA9IGVuZFpvb20gIT0gbnVsbCAmJiBpc0NvcmU7XG4gICAgaWYgKGFuaW1hdGluZ1pvb20pIHtcbiAgICAgIGlmICh2YWxpZChzdGFydFpvb20sIGVuZFpvb20pKSB7XG4gICAgICAgIF9wLnpvb20gPSBlYXNlKHN0YXJ0Wm9vbSwgZW5kWm9vbSwgcGVyY2VudCwgZWFzaW5nKTtcbiAgICAgIH1cblxuICAgICAgc2VsZi5lbWl0KCd6b29tJyk7XG4gICAgfVxuXG4gICAgaWYgKGFuaW1hdGluZ1BhbiB8fCBhbmltYXRpbmdab29tKSB7XG4gICAgICBzZWxmLmVtaXQoJ3ZpZXdwb3J0Jyk7XG4gICAgfVxuXG4gICAgdmFyIHByb3BzID0gYW5pX3Auc3R5bGU7XG4gICAgaWYgKHByb3BzICYmIHByb3BzLmxlbmd0aCA+IDAgJiYgaXNFbGVzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwcm9wID0gcHJvcHNbaV07XG4gICAgICAgIHZhciBfbmFtZSA9IHByb3AubmFtZTtcbiAgICAgICAgdmFyIGVuZCA9IHByb3A7XG4gICAgICAgIHZhciBzdGFydCA9IGFuaV9wLnN0YXJ0U3R5bGVbX25hbWVdO1xuICAgICAgICB2YXIgcHJvcFNwZWMgPSBzdHlsZS5wcm9wZXJ0aWVzW3N0YXJ0Lm5hbWVdO1xuICAgICAgICB2YXIgZWFzZWRWYWwgPSBlYXNlKHN0YXJ0LCBlbmQsIHBlcmNlbnQsIGVhc2luZywgcHJvcFNwZWMpO1xuXG4gICAgICAgIHN0eWxlLm92ZXJyaWRlQnlwYXNzKHNlbGYsIF9uYW1lLCBlYXNlZFZhbCk7XG4gICAgICB9IC8vIGZvciBwcm9wc1xuXG4gICAgICBzZWxmLmVtaXQoJ3N0eWxlJyk7XG4gICAgfSAvLyBpZlxuICB9XG5cbiAgYW5pX3AucHJvZ3Jlc3MgPSBwZXJjZW50O1xuXG4gIHJldHVybiBwZXJjZW50O1xufVxuXG5mdW5jdGlvbiB2YWxpZChzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PSBudWxsIHx8IGVuZCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGlzLm51bWJlcihzdGFydCkgJiYgaXMubnVtYmVyKGVuZCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChzdGFydCAmJiBlbmQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGVwO1xuXG4vKioqLyB9KSxcbi8qIDczICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBnZW5lcmF0ZUN1YmljQmV6aWVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NCk7XG52YXIgZ2VuZXJhdGVTcHJpbmdSSzQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc1KTtcblxudmFyIGN1YmljQmV6aWVyID0gZnVuY3Rpb24gY3ViaWNCZXppZXIodDEsIHAxLCB0MiwgcDIpIHtcbiAgdmFyIGJlemllciA9IGdlbmVyYXRlQ3ViaWNCZXppZXIodDEsIHAxLCB0MiwgcDIpO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgcGVyY2VudCkge1xuICAgIHJldHVybiBzdGFydCArIChlbmQgLSBzdGFydCkgKiBiZXppZXIocGVyY2VudCk7XG4gIH07XG59O1xuXG52YXIgZWFzaW5ncyA9IHtcbiAgJ2xpbmVhcic6IGZ1bmN0aW9uIGxpbmVhcihzdGFydCwgZW5kLCBwZXJjZW50KSB7XG4gICAgcmV0dXJuIHN0YXJ0ICsgKGVuZCAtIHN0YXJ0KSAqIHBlcmNlbnQ7XG4gIH0sXG5cbiAgLy8gZGVmYXVsdCBlYXNpbmdzXG4gICdlYXNlJzogY3ViaWNCZXppZXIoMC4yNSwgMC4xLCAwLjI1LCAxKSxcbiAgJ2Vhc2UtaW4nOiBjdWJpY0JlemllcigwLjQyLCAwLCAxLCAxKSxcbiAgJ2Vhc2Utb3V0JzogY3ViaWNCZXppZXIoMCwgMCwgMC41OCwgMSksXG4gICdlYXNlLWluLW91dCc6IGN1YmljQmV6aWVyKDAuNDIsIDAsIDAuNTgsIDEpLFxuXG4gIC8vIHNpbmVcbiAgJ2Vhc2UtaW4tc2luZSc6IGN1YmljQmV6aWVyKDAuNDcsIDAsIDAuNzQ1LCAwLjcxNSksXG4gICdlYXNlLW91dC1zaW5lJzogY3ViaWNCZXppZXIoMC4zOSwgMC41NzUsIDAuNTY1LCAxKSxcbiAgJ2Vhc2UtaW4tb3V0LXNpbmUnOiBjdWJpY0JlemllcigwLjQ0NSwgMC4wNSwgMC41NSwgMC45NSksXG5cbiAgLy8gcXVhZFxuICAnZWFzZS1pbi1xdWFkJzogY3ViaWNCZXppZXIoMC41NSwgMC4wODUsIDAuNjgsIDAuNTMpLFxuICAnZWFzZS1vdXQtcXVhZCc6IGN1YmljQmV6aWVyKDAuMjUsIDAuNDYsIDAuNDUsIDAuOTQpLFxuICAnZWFzZS1pbi1vdXQtcXVhZCc6IGN1YmljQmV6aWVyKDAuNDU1LCAwLjAzLCAwLjUxNSwgMC45NTUpLFxuXG4gIC8vIGN1YmljXG4gICdlYXNlLWluLWN1YmljJzogY3ViaWNCZXppZXIoMC41NSwgMC4wNTUsIDAuNjc1LCAwLjE5KSxcbiAgJ2Vhc2Utb3V0LWN1YmljJzogY3ViaWNCZXppZXIoMC4yMTUsIDAuNjEsIDAuMzU1LCAxKSxcbiAgJ2Vhc2UtaW4tb3V0LWN1YmljJzogY3ViaWNCZXppZXIoMC42NDUsIDAuMDQ1LCAwLjM1NSwgMSksXG5cbiAgLy8gcXVhcnRcbiAgJ2Vhc2UtaW4tcXVhcnQnOiBjdWJpY0JlemllcigwLjg5NSwgMC4wMywgMC42ODUsIDAuMjIpLFxuICAnZWFzZS1vdXQtcXVhcnQnOiBjdWJpY0JlemllcigwLjE2NSwgMC44NCwgMC40NCwgMSksXG4gICdlYXNlLWluLW91dC1xdWFydCc6IGN1YmljQmV6aWVyKDAuNzcsIDAsIDAuMTc1LCAxKSxcblxuICAvLyBxdWludFxuICAnZWFzZS1pbi1xdWludCc6IGN1YmljQmV6aWVyKDAuNzU1LCAwLjA1LCAwLjg1NSwgMC4wNiksXG4gICdlYXNlLW91dC1xdWludCc6IGN1YmljQmV6aWVyKDAuMjMsIDEsIDAuMzIsIDEpLFxuICAnZWFzZS1pbi1vdXQtcXVpbnQnOiBjdWJpY0JlemllcigwLjg2LCAwLCAwLjA3LCAxKSxcblxuICAvLyBleHBvXG4gICdlYXNlLWluLWV4cG8nOiBjdWJpY0JlemllcigwLjk1LCAwLjA1LCAwLjc5NSwgMC4wMzUpLFxuICAnZWFzZS1vdXQtZXhwbyc6IGN1YmljQmV6aWVyKDAuMTksIDEsIDAuMjIsIDEpLFxuICAnZWFzZS1pbi1vdXQtZXhwbyc6IGN1YmljQmV6aWVyKDEsIDAsIDAsIDEpLFxuXG4gIC8vIGNpcmNcbiAgJ2Vhc2UtaW4tY2lyYyc6IGN1YmljQmV6aWVyKDAuNiwgMC4wNCwgMC45OCwgMC4zMzUpLFxuICAnZWFzZS1vdXQtY2lyYyc6IGN1YmljQmV6aWVyKDAuMDc1LCAwLjgyLCAwLjE2NSwgMSksXG4gICdlYXNlLWluLW91dC1jaXJjJzogY3ViaWNCZXppZXIoMC43ODUsIDAuMTM1LCAwLjE1LCAwLjg2KSxcblxuICAvLyB1c2VyIHBhcmFtIGVhc2luZ3MuLi5cblxuICAnc3ByaW5nJzogZnVuY3Rpb24gc3ByaW5nKHRlbnNpb24sIGZyaWN0aW9uLCBkdXJhdGlvbikge1xuICAgIGlmIChkdXJhdGlvbiA9PT0gMCkge1xuICAgICAgLy8gY2FuJ3QgZ2V0IGEgc3ByaW5nIHcvIGR1cmF0aW9uIDBcbiAgICAgIHJldHVybiBlYXNpbmdzLmxpbmVhcjsgLy8gZHVyYXRpb24gMCA9PiBqdW1wIHRvIGVuZCBzbyBpbXBsIGRvZXNuJ3QgbWF0dGVyXG4gICAgfVxuXG4gICAgdmFyIHNwcmluZyA9IGdlbmVyYXRlU3ByaW5nUks0KHRlbnNpb24sIGZyaWN0aW9uLCBkdXJhdGlvbik7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIHBlcmNlbnQpIHtcbiAgICAgIHJldHVybiBzdGFydCArIChlbmQgLSBzdGFydCkgKiBzcHJpbmcocGVyY2VudCk7XG4gICAgfTtcbiAgfSxcblxuICAnY3ViaWMtYmV6aWVyJzogY3ViaWNCZXppZXJcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZWFzaW5ncztcblxuLyoqKi8gfSksXG4vKiA3NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKiBnbG9iYWwgRmxvYXQzMkFycmF5ICovXG5cbi8qISBCZXppZXIgY3VydmUgZnVuY3Rpb24gZ2VuZXJhdG9yLiBDb3B5cmlnaHQgR2FldGFuIFJlbmF1ZGVhdS4gTUlUIExpY2Vuc2U6IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTUlUX0xpY2Vuc2UgKi9cbmZ1bmN0aW9uIGdlbmVyYXRlQ3ViaWNCZXppZXIobVgxLCBtWTEsIG1YMiwgbVkyKSB7XG4gIHZhciBORVdUT05fSVRFUkFUSU9OUyA9IDQsXG4gICAgICBORVdUT05fTUlOX1NMT1BFID0gMC4wMDEsXG4gICAgICBTVUJESVZJU0lPTl9QUkVDSVNJT04gPSAwLjAwMDAwMDEsXG4gICAgICBTVUJESVZJU0lPTl9NQVhfSVRFUkFUSU9OUyA9IDEwLFxuICAgICAga1NwbGluZVRhYmxlU2l6ZSA9IDExLFxuICAgICAga1NhbXBsZVN0ZXBTaXplID0gMS4wIC8gKGtTcGxpbmVUYWJsZVNpemUgLSAxLjApLFxuICAgICAgZmxvYXQzMkFycmF5U3VwcG9ydGVkID0gdHlwZW9mIEZsb2F0MzJBcnJheSAhPT0gJ3VuZGVmaW5lZCc7XG5cbiAgLyogTXVzdCBjb250YWluIGZvdXIgYXJndW1lbnRzLiAqL1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gNCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qIEFyZ3VtZW50cyBtdXN0IGJlIG51bWJlcnMuICovXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgKytpKSB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbaV0gIT09IFwibnVtYmVyXCIgfHwgaXNOYU4oYXJndW1lbnRzW2ldKSB8fCAhaXNGaW5pdGUoYXJndW1lbnRzW2ldKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qIFggdmFsdWVzIG11c3QgYmUgaW4gdGhlIFswLCAxXSByYW5nZS4gKi9cbiAgbVgxID0gTWF0aC5taW4obVgxLCAxKTtcbiAgbVgyID0gTWF0aC5taW4obVgyLCAxKTtcbiAgbVgxID0gTWF0aC5tYXgobVgxLCAwKTtcbiAgbVgyID0gTWF0aC5tYXgobVgyLCAwKTtcblxuICB2YXIgbVNhbXBsZVZhbHVlcyA9IGZsb2F0MzJBcnJheVN1cHBvcnRlZCA/IG5ldyBGbG9hdDMyQXJyYXkoa1NwbGluZVRhYmxlU2l6ZSkgOiBuZXcgQXJyYXkoa1NwbGluZVRhYmxlU2l6ZSk7XG5cbiAgZnVuY3Rpb24gQShhQTEsIGFBMikge1xuICAgIHJldHVybiAxLjAgLSAzLjAgKiBhQTIgKyAzLjAgKiBhQTE7XG4gIH1cblxuICBmdW5jdGlvbiBCKGFBMSwgYUEyKSB7XG4gICAgcmV0dXJuIDMuMCAqIGFBMiAtIDYuMCAqIGFBMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEMoYUExKSB7XG4gICAgcmV0dXJuIDMuMCAqIGFBMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGNCZXppZXIoYVQsIGFBMSwgYUEyKSB7XG4gICAgcmV0dXJuICgoQShhQTEsIGFBMikgKiBhVCArIEIoYUExLCBhQTIpKSAqIGFUICsgQyhhQTEpKSAqIGFUO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0U2xvcGUoYVQsIGFBMSwgYUEyKSB7XG4gICAgcmV0dXJuIDMuMCAqIEEoYUExLCBhQTIpICogYVQgKiBhVCArIDIuMCAqIEIoYUExLCBhQTIpICogYVQgKyBDKGFBMSk7XG4gIH1cblxuICBmdW5jdGlvbiBuZXd0b25SYXBoc29uSXRlcmF0ZShhWCwgYUd1ZXNzVCkge1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBORVdUT05fSVRFUkFUSU9OUzsgKytfaSkge1xuICAgICAgdmFyIGN1cnJlbnRTbG9wZSA9IGdldFNsb3BlKGFHdWVzc1QsIG1YMSwgbVgyKTtcblxuICAgICAgaWYgKGN1cnJlbnRTbG9wZSA9PT0gMC4wKSB7XG4gICAgICAgIHJldHVybiBhR3Vlc3NUO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3VycmVudFggPSBjYWxjQmV6aWVyKGFHdWVzc1QsIG1YMSwgbVgyKSAtIGFYO1xuICAgICAgYUd1ZXNzVCAtPSBjdXJyZW50WCAvIGN1cnJlbnRTbG9wZTtcbiAgICB9XG5cbiAgICByZXR1cm4gYUd1ZXNzVDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGNTYW1wbGVWYWx1ZXMoKSB7XG4gICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwga1NwbGluZVRhYmxlU2l6ZTsgKytfaTIpIHtcbiAgICAgIG1TYW1wbGVWYWx1ZXNbX2kyXSA9IGNhbGNCZXppZXIoX2kyICoga1NhbXBsZVN0ZXBTaXplLCBtWDEsIG1YMik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYmluYXJ5U3ViZGl2aWRlKGFYLCBhQSwgYUIpIHtcbiAgICB2YXIgY3VycmVudFggPSB2b2lkIDAsXG4gICAgICAgIGN1cnJlbnRUID0gdm9pZCAwLFxuICAgICAgICBpID0gMDtcblxuICAgIGRvIHtcbiAgICAgIGN1cnJlbnRUID0gYUEgKyAoYUIgLSBhQSkgLyAyLjA7XG4gICAgICBjdXJyZW50WCA9IGNhbGNCZXppZXIoY3VycmVudFQsIG1YMSwgbVgyKSAtIGFYO1xuICAgICAgaWYgKGN1cnJlbnRYID4gMC4wKSB7XG4gICAgICAgIGFCID0gY3VycmVudFQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhQSA9IGN1cnJlbnRUO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKE1hdGguYWJzKGN1cnJlbnRYKSA+IFNVQkRJVklTSU9OX1BSRUNJU0lPTiAmJiArK2kgPCBTVUJESVZJU0lPTl9NQVhfSVRFUkFUSU9OUyk7XG5cbiAgICByZXR1cm4gY3VycmVudFQ7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRURm9yWChhWCkge1xuICAgIHZhciBpbnRlcnZhbFN0YXJ0ID0gMC4wLFxuICAgICAgICBjdXJyZW50U2FtcGxlID0gMSxcbiAgICAgICAgbGFzdFNhbXBsZSA9IGtTcGxpbmVUYWJsZVNpemUgLSAxO1xuXG4gICAgZm9yICg7IGN1cnJlbnRTYW1wbGUgIT09IGxhc3RTYW1wbGUgJiYgbVNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSA8PSBhWDsgKytjdXJyZW50U2FtcGxlKSB7XG4gICAgICBpbnRlcnZhbFN0YXJ0ICs9IGtTYW1wbGVTdGVwU2l6ZTtcbiAgICB9XG5cbiAgICAtLWN1cnJlbnRTYW1wbGU7XG5cbiAgICB2YXIgZGlzdCA9IChhWCAtIG1TYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0pIC8gKG1TYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZSArIDFdIC0gbVNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSksXG4gICAgICAgIGd1ZXNzRm9yVCA9IGludGVydmFsU3RhcnQgKyBkaXN0ICoga1NhbXBsZVN0ZXBTaXplLFxuICAgICAgICBpbml0aWFsU2xvcGUgPSBnZXRTbG9wZShndWVzc0ZvclQsIG1YMSwgbVgyKTtcblxuICAgIGlmIChpbml0aWFsU2xvcGUgPj0gTkVXVE9OX01JTl9TTE9QRSkge1xuICAgICAgcmV0dXJuIG5ld3RvblJhcGhzb25JdGVyYXRlKGFYLCBndWVzc0ZvclQpO1xuICAgIH0gZWxzZSBpZiAoaW5pdGlhbFNsb3BlID09PSAwLjApIHtcbiAgICAgIHJldHVybiBndWVzc0ZvclQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBiaW5hcnlTdWJkaXZpZGUoYVgsIGludGVydmFsU3RhcnQsIGludGVydmFsU3RhcnQgKyBrU2FtcGxlU3RlcFNpemUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBfcHJlY29tcHV0ZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBwcmVjb21wdXRlKCkge1xuICAgIF9wcmVjb21wdXRlZCA9IHRydWU7XG4gICAgaWYgKG1YMSAhPT0gbVkxIHx8IG1YMiAhPT0gbVkyKSB7XG4gICAgICBjYWxjU2FtcGxlVmFsdWVzKCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGYgPSBmdW5jdGlvbiBmKGFYKSB7XG4gICAgaWYgKCFfcHJlY29tcHV0ZWQpIHtcbiAgICAgIHByZWNvbXB1dGUoKTtcbiAgICB9XG4gICAgaWYgKG1YMSA9PT0gbVkxICYmIG1YMiA9PT0gbVkyKSB7XG4gICAgICByZXR1cm4gYVg7XG4gICAgfVxuICAgIGlmIChhWCA9PT0gMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmIChhWCA9PT0gMSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhbGNCZXppZXIoZ2V0VEZvclgoYVgpLCBtWTEsIG1ZMik7XG4gIH07XG5cbiAgZi5nZXRDb250cm9sUG9pbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBbe1xuICAgICAgeDogbVgxLFxuICAgICAgeTogbVkxXG4gICAgfSwge1xuICAgICAgeDogbVgyLFxuICAgICAgeTogbVkyXG4gICAgfV07XG4gIH07XG5cbiAgdmFyIHN0ciA9IFwiZ2VuZXJhdGVCZXppZXIoXCIgKyBbbVgxLCBtWTEsIG1YMiwgbVkyXSArIFwiKVwiO1xuICBmLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBzdHI7XG4gIH07XG5cbiAgcmV0dXJuIGY7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2VuZXJhdGVDdWJpY0JlemllcjtcblxuLyoqKi8gfSksXG4vKiA3NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKiEgUnVuZ2UtS3V0dGEgc3ByaW5nIHBoeXNpY3MgZnVuY3Rpb24gZ2VuZXJhdG9yLiBBZGFwdGVkIGZyb20gRnJhbWVyLmpzLCBjb3B5cmlnaHQgS29lbiBCb2suIE1JVCBMaWNlbnNlOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01JVF9MaWNlbnNlICovXG4vKiBHaXZlbiBhIHRlbnNpb24sIGZyaWN0aW9uLCBhbmQgZHVyYXRpb24sIGEgc2ltdWxhdGlvbiBhdCA2MEZQUyB3aWxsIGZpcnN0IHJ1biB3aXRob3V0IGEgZGVmaW5lZCBkdXJhdGlvbiBpbiBvcmRlciB0byBjYWxjdWxhdGUgdGhlIGZ1bGwgcGF0aC4gQSBzZWNvbmQgcGFzc1xuICAgdGhlbiBhZGp1c3RzIHRoZSB0aW1lIGRlbHRhIC0tIHVzaW5nIHRoZSByZWxhdGlvbiBiZXR3ZWVuIGFjdHVhbCB0aW1lIGFuZCBkdXJhdGlvbiAtLSB0byBjYWxjdWxhdGUgdGhlIHBhdGggZm9yIHRoZSBkdXJhdGlvbi1jb25zdHJhaW5lZCBhbmltYXRpb24uICovXG52YXIgZ2VuZXJhdGVTcHJpbmdSSzQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIHNwcmluZ0FjY2VsZXJhdGlvbkZvclN0YXRlKHN0YXRlKSB7XG4gICAgcmV0dXJuIC1zdGF0ZS50ZW5zaW9uICogc3RhdGUueCAtIHN0YXRlLmZyaWN0aW9uICogc3RhdGUudjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNwcmluZ0V2YWx1YXRlU3RhdGVXaXRoRGVyaXZhdGl2ZShpbml0aWFsU3RhdGUsIGR0LCBkZXJpdmF0aXZlKSB7XG4gICAgdmFyIHN0YXRlID0ge1xuICAgICAgeDogaW5pdGlhbFN0YXRlLnggKyBkZXJpdmF0aXZlLmR4ICogZHQsXG4gICAgICB2OiBpbml0aWFsU3RhdGUudiArIGRlcml2YXRpdmUuZHYgKiBkdCxcbiAgICAgIHRlbnNpb246IGluaXRpYWxTdGF0ZS50ZW5zaW9uLFxuICAgICAgZnJpY3Rpb246IGluaXRpYWxTdGF0ZS5mcmljdGlvblxuICAgIH07XG5cbiAgICByZXR1cm4geyBkeDogc3RhdGUudiwgZHY6IHNwcmluZ0FjY2VsZXJhdGlvbkZvclN0YXRlKHN0YXRlKSB9O1xuICB9XG5cbiAgZnVuY3Rpb24gc3ByaW5nSW50ZWdyYXRlU3RhdGUoc3RhdGUsIGR0KSB7XG4gICAgdmFyIGEgPSB7XG4gICAgICBkeDogc3RhdGUudixcbiAgICAgIGR2OiBzcHJpbmdBY2NlbGVyYXRpb25Gb3JTdGF0ZShzdGF0ZSlcbiAgICB9LFxuICAgICAgICBiID0gc3ByaW5nRXZhbHVhdGVTdGF0ZVdpdGhEZXJpdmF0aXZlKHN0YXRlLCBkdCAqIDAuNSwgYSksXG4gICAgICAgIGMgPSBzcHJpbmdFdmFsdWF0ZVN0YXRlV2l0aERlcml2YXRpdmUoc3RhdGUsIGR0ICogMC41LCBiKSxcbiAgICAgICAgZCA9IHNwcmluZ0V2YWx1YXRlU3RhdGVXaXRoRGVyaXZhdGl2ZShzdGF0ZSwgZHQsIGMpLFxuICAgICAgICBkeGR0ID0gMS4wIC8gNi4wICogKGEuZHggKyAyLjAgKiAoYi5keCArIGMuZHgpICsgZC5keCksXG4gICAgICAgIGR2ZHQgPSAxLjAgLyA2LjAgKiAoYS5kdiArIDIuMCAqIChiLmR2ICsgYy5kdikgKyBkLmR2KTtcblxuICAgIHN0YXRlLnggPSBzdGF0ZS54ICsgZHhkdCAqIGR0O1xuICAgIHN0YXRlLnYgPSBzdGF0ZS52ICsgZHZkdCAqIGR0O1xuXG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHNwcmluZ1JLNEZhY3RvcnkodGVuc2lvbiwgZnJpY3Rpb24sIGR1cmF0aW9uKSB7XG5cbiAgICB2YXIgaW5pdFN0YXRlID0ge1xuICAgICAgeDogLTEsXG4gICAgICB2OiAwLFxuICAgICAgdGVuc2lvbjogbnVsbCxcbiAgICAgIGZyaWN0aW9uOiBudWxsXG4gICAgfSxcbiAgICAgICAgcGF0aCA9IFswXSxcbiAgICAgICAgdGltZV9sYXBzZWQgPSAwLFxuICAgICAgICB0b2xlcmFuY2UgPSAxIC8gMTAwMDAsXG4gICAgICAgIERUID0gMTYgLyAxMDAwLFxuICAgICAgICBoYXZlX2R1cmF0aW9uID0gdm9pZCAwLFxuICAgICAgICBkdCA9IHZvaWQgMCxcbiAgICAgICAgbGFzdF9zdGF0ZSA9IHZvaWQgMDtcblxuICAgIHRlbnNpb24gPSBwYXJzZUZsb2F0KHRlbnNpb24pIHx8IDUwMDtcbiAgICBmcmljdGlvbiA9IHBhcnNlRmxvYXQoZnJpY3Rpb24pIHx8IDIwO1xuICAgIGR1cmF0aW9uID0gZHVyYXRpb24gfHwgbnVsbDtcblxuICAgIGluaXRTdGF0ZS50ZW5zaW9uID0gdGVuc2lvbjtcbiAgICBpbml0U3RhdGUuZnJpY3Rpb24gPSBmcmljdGlvbjtcblxuICAgIGhhdmVfZHVyYXRpb24gPSBkdXJhdGlvbiAhPT0gbnVsbDtcblxuICAgIC8qIENhbGN1bGF0ZSB0aGUgYWN0dWFsIHRpbWUgaXQgdGFrZXMgZm9yIHRoaXMgYW5pbWF0aW9uIHRvIGNvbXBsZXRlIHdpdGggdGhlIHByb3ZpZGVkIGNvbmRpdGlvbnMuICovXG4gICAgaWYgKGhhdmVfZHVyYXRpb24pIHtcbiAgICAgIC8qIFJ1biB0aGUgc2ltdWxhdGlvbiB3aXRob3V0IGEgZHVyYXRpb24uICovXG4gICAgICB0aW1lX2xhcHNlZCA9IHNwcmluZ1JLNEZhY3RvcnkodGVuc2lvbiwgZnJpY3Rpb24pO1xuICAgICAgLyogQ29tcHV0ZSB0aGUgYWRqdXN0ZWQgdGltZSBkZWx0YS4gKi9cbiAgICAgIGR0ID0gdGltZV9sYXBzZWQgLyBkdXJhdGlvbiAqIERUO1xuICAgIH0gZWxzZSB7XG4gICAgICBkdCA9IERUO1xuICAgIH1cblxuICAgIGZvciAoOzspIHtcbiAgICAgIC8qIE5leHQvc3RlcCBmdW5jdGlvbiAuKi9cbiAgICAgIGxhc3Rfc3RhdGUgPSBzcHJpbmdJbnRlZ3JhdGVTdGF0ZShsYXN0X3N0YXRlIHx8IGluaXRTdGF0ZSwgZHQpO1xuICAgICAgLyogU3RvcmUgdGhlIHBvc2l0aW9uLiAqL1xuICAgICAgcGF0aC5wdXNoKDEgKyBsYXN0X3N0YXRlLngpO1xuICAgICAgdGltZV9sYXBzZWQgKz0gMTY7XG4gICAgICAvKiBJZiB0aGUgY2hhbmdlIHRocmVzaG9sZCBpcyByZWFjaGVkLCBicmVhay4gKi9cbiAgICAgIGlmICghKE1hdGguYWJzKGxhc3Rfc3RhdGUueCkgPiB0b2xlcmFuY2UgJiYgTWF0aC5hYnMobGFzdF9zdGF0ZS52KSA+IHRvbGVyYW5jZSkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogSWYgZHVyYXRpb24gaXMgbm90IGRlZmluZWQsIHJldHVybiB0aGUgYWN0dWFsIHRpbWUgcmVxdWlyZWQgZm9yIGNvbXBsZXRpbmcgdGhpcyBhbmltYXRpb24uIE90aGVyd2lzZSwgcmV0dXJuIGEgY2xvc3VyZSB0aGF0IGhvbGRzIHRoZVxuICAgICAgIGNvbXB1dGVkIHBhdGggYW5kIHJldHVybnMgYSBzbmFwc2hvdCBvZiB0aGUgcG9zaXRpb24gYWNjb3JkaW5nIHRvIGEgZ2l2ZW4gcGVyY2VudENvbXBsZXRlLiAqL1xuICAgIHJldHVybiAhaGF2ZV9kdXJhdGlvbiA/IHRpbWVfbGFwc2VkIDogZnVuY3Rpb24gKHBlcmNlbnRDb21wbGV0ZSkge1xuICAgICAgcmV0dXJuIHBhdGhbcGVyY2VudENvbXBsZXRlICogKHBhdGgubGVuZ3RoIC0gMSkgfCAwXTtcbiAgICB9O1xuICB9O1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdlbmVyYXRlU3ByaW5nUks0O1xuXG4vKioqLyB9KSxcbi8qIDc2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBpcyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbmZ1bmN0aW9uIGdldEVhc2VkVmFsdWUodHlwZSwgc3RhcnQsIGVuZCwgcGVyY2VudCwgZWFzaW5nRm4pIHtcbiAgaWYgKHBlcmNlbnQgPT09IDEpIHtcbiAgICByZXR1cm4gZW5kO1xuICB9XG5cbiAgdmFyIHZhbCA9IGVhc2luZ0ZuKHN0YXJ0LCBlbmQsIHBlcmNlbnQpO1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgaWYgKHR5cGUucm91bmRWYWx1ZSB8fCB0eXBlLmNvbG9yKSB7XG4gICAgdmFsID0gTWF0aC5yb3VuZCh2YWwpO1xuICB9XG5cbiAgaWYgKHR5cGUubWluICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YWwgPSBNYXRoLm1heCh2YWwsIHR5cGUubWluKTtcbiAgfVxuXG4gIGlmICh0eXBlLm1heCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsID0gTWF0aC5taW4odmFsLCB0eXBlLm1heCk7XG4gIH1cblxuICByZXR1cm4gdmFsO1xufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZShwcm9wLCBzcGVjKSB7XG4gIGlmIChwcm9wLnBmVmFsdWUgIT0gbnVsbCB8fCBwcm9wLnZhbHVlICE9IG51bGwpIHtcbiAgICBpZiAocHJvcC5wZlZhbHVlICE9IG51bGwgJiYgKHNwZWMgPT0gbnVsbCB8fCBzcGVjLnR5cGUudW5pdHMgIT09ICclJykpIHtcbiAgICAgIHJldHVybiBwcm9wLnBmVmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwcm9wLnZhbHVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcHJvcDtcbiAgfVxufVxuXG5mdW5jdGlvbiBlYXNlKHN0YXJ0UHJvcCwgZW5kUHJvcCwgcGVyY2VudCwgZWFzaW5nRm4sIHByb3BTcGVjKSB7XG4gIHZhciB0eXBlID0gcHJvcFNwZWMgIT0gbnVsbCA/IHByb3BTcGVjLnR5cGUgOiBudWxsO1xuXG4gIGlmIChwZXJjZW50IDwgMCkge1xuICAgIHBlcmNlbnQgPSAwO1xuICB9IGVsc2UgaWYgKHBlcmNlbnQgPiAxKSB7XG4gICAgcGVyY2VudCA9IDE7XG4gIH1cblxuICB2YXIgc3RhcnQgPSBnZXRWYWx1ZShzdGFydFByb3AsIHByb3BTcGVjKTtcbiAgdmFyIGVuZCA9IGdldFZhbHVlKGVuZFByb3AsIHByb3BTcGVjKTtcblxuICBpZiAoaXMubnVtYmVyKHN0YXJ0KSAmJiBpcy5udW1iZXIoZW5kKSkge1xuICAgIHJldHVybiBnZXRFYXNlZFZhbHVlKHR5cGUsIHN0YXJ0LCBlbmQsIHBlcmNlbnQsIGVhc2luZ0ZuKTtcbiAgfSBlbHNlIGlmIChpcy5hcnJheShzdGFydCkgJiYgaXMuYXJyYXkoZW5kKSkge1xuICAgIHZhciBlYXNlZEFyciA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzaSA9IHN0YXJ0W2ldO1xuICAgICAgdmFyIGVpID0gZW5kW2ldO1xuXG4gICAgICBpZiAoc2kgIT0gbnVsbCAmJiBlaSAhPSBudWxsKSB7XG4gICAgICAgIHZhciB2YWwgPSBnZXRFYXNlZFZhbHVlKHR5cGUsIHNpLCBlaSwgcGVyY2VudCwgZWFzaW5nRm4pO1xuXG4gICAgICAgIGVhc2VkQXJyLnB1c2godmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVhc2VkQXJyLnB1c2goZWkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBlYXNlZEFycjtcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZWFzZTtcblxuLyoqKi8gfSksXG4vKiA3NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBzdGFydEFuaW1hdGlvbihzZWxmLCBhbmksIG5vdywgaXNDb3JlKSB7XG4gIHZhciBpc0VsZXMgPSAhaXNDb3JlO1xuICB2YXIgZWxlID0gc2VsZjtcbiAgdmFyIGFuaV9wID0gYW5pLl9wcml2YXRlO1xuICB2YXIgY3kgPSBpc0NvcmUgPyBzZWxmIDogc2VsZi5jeSgpO1xuICB2YXIgc3R5bGUgPSBjeS5zdHlsZSgpO1xuXG4gIGlmIChpc0VsZXMpIHtcbiAgICB2YXIgcG9zID0gZWxlLnBvc2l0aW9uKCk7XG5cbiAgICBhbmlfcC5zdGFydFBvc2l0aW9uID0gYW5pX3Auc3RhcnRQb3NpdGlvbiB8fCB7XG4gICAgICB4OiBwb3MueCxcbiAgICAgIHk6IHBvcy55XG4gICAgfTtcblxuICAgIGFuaV9wLnN0YXJ0U3R5bGUgPSBhbmlfcC5zdGFydFN0eWxlIHx8IHN0eWxlLmdldEFuaW1hdGlvblN0YXJ0U3R5bGUoZWxlLCBhbmlfcC5zdHlsZSk7XG4gIH1cblxuICBpZiAoaXNDb3JlKSB7XG4gICAgdmFyIHBhbiA9IGN5Ll9wcml2YXRlLnBhbjtcblxuICAgIGFuaV9wLnN0YXJ0UGFuID0gYW5pX3Auc3RhcnRQYW4gfHwge1xuICAgICAgeDogcGFuLngsXG4gICAgICB5OiBwYW4ueVxuICAgIH07XG5cbiAgICBhbmlfcC5zdGFydFpvb20gPSBhbmlfcC5zdGFydFpvb20gIT0gbnVsbCA/IGFuaV9wLnN0YXJ0Wm9vbSA6IGN5Ll9wcml2YXRlLnpvb207XG4gIH1cblxuICBhbmlfcC5zdGFydGVkID0gdHJ1ZTtcbiAgYW5pX3Auc3RhcnRUaW1lID0gbm93IC0gYW5pX3AucHJvZ3Jlc3MgKiBhbmlfcC5kdXJhdGlvbjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFydEFuaW1hdGlvbjtcblxuLyoqKi8gfSksXG4vKiA3OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgRW1pdHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xudmFyIGRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG52YXIgaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xudmFyIFNlbGVjdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxudmFyIGVtaXR0ZXJPcHRpb25zID0ge1xuICBxdWFsaWZpZXJDb21wYXJlOiBmdW5jdGlvbiBxdWFsaWZpZXJDb21wYXJlKHNlbGVjdG9yMSwgc2VsZWN0b3IyKSB7XG4gICAgaWYgKHNlbGVjdG9yMSA9PSBudWxsIHx8IHNlbGVjdG9yMiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gc2VsZWN0b3IxID09IG51bGwgJiYgc2VsZWN0b3IyID09IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzZWxlY3RvcjEuc2FtZVRleHQoc2VsZWN0b3IyKTtcbiAgICB9XG4gIH0sXG4gIGV2ZW50TWF0Y2hlczogZnVuY3Rpb24gZXZlbnRNYXRjaGVzKGN5LCBsaXN0ZW5lciwgZXZlbnRPYmopIHtcbiAgICB2YXIgc2VsZWN0b3IgPSBsaXN0ZW5lci5xdWFsaWZpZXI7XG5cbiAgICBpZiAoc2VsZWN0b3IgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGN5ICE9PSBldmVudE9iai50YXJnZXQgJiYgaXMuZWxlbWVudChldmVudE9iai50YXJnZXQpICYmIHNlbGVjdG9yLm1hdGNoZXMoZXZlbnRPYmoudGFyZ2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgZXZlbnRGaWVsZHM6IGZ1bmN0aW9uIGV2ZW50RmllbGRzKGN5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGN5OiBjeSxcbiAgICAgIHRhcmdldDogY3lcbiAgICB9O1xuICB9LFxuICBjYWxsYmFja0NvbnRleHQ6IGZ1bmN0aW9uIGNhbGxiYWNrQ29udGV4dChjeSwgbGlzdGVuZXIsIGV2ZW50T2JqKSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyLnF1YWxpZmllciAhPSBudWxsID8gZXZlbnRPYmoudGFyZ2V0IDogY3k7XG4gIH1cbn07XG5cbnZhciBhcmdTZWxlY3RvciA9IGZ1bmN0aW9uIGFyZ1NlbGVjdG9yKGFyZykge1xuICBpZiAoaXMuc3RyaW5nKGFyZykpIHtcbiAgICByZXR1cm4gbmV3IFNlbGVjdG9yKGFyZyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGFyZztcbiAgfVxufTtcblxudmFyIGVsZXNmbiA9IHtcbiAgY3JlYXRlRW1pdHRlcjogZnVuY3Rpb24gY3JlYXRlRW1pdHRlcigpIHtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgaWYgKCFfcC5lbWl0dGVyKSB7XG4gICAgICBfcC5lbWl0dGVyID0gbmV3IEVtaXR0ZXIodXRpbC5hc3NpZ24oe1xuICAgICAgICBjb250ZXh0OiB0aGlzXG4gICAgICB9LCBlbWl0dGVyT3B0aW9ucykpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGVtaXR0ZXI6IGZ1bmN0aW9uIGVtaXR0ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuZW1pdHRlcjtcbiAgfSxcblxuICBvbjogZnVuY3Rpb24gb24oZXZlbnRzLCBzZWxlY3RvciwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmVtaXR0ZXIoKS5vbihldmVudHMsIGFyZ1NlbGVjdG9yKHNlbGVjdG9yKSwgY2FsbGJhY2spO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgcmVtb3ZlTGlzdGVuZXI6IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGV2ZW50cywgc2VsZWN0b3IsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5lbWl0dGVyKCkucmVtb3ZlTGlzdGVuZXIoZXZlbnRzLCBhcmdTZWxlY3RvcihzZWxlY3RvciksIGNhbGxiYWNrKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIG9uZTogZnVuY3Rpb24gb25lKGV2ZW50cywgc2VsZWN0b3IsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5lbWl0dGVyKCkub25lKGV2ZW50cywgYXJnU2VsZWN0b3Ioc2VsZWN0b3IpLCBjYWxsYmFjayk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBvbmNlOiBmdW5jdGlvbiBvbmNlKGV2ZW50cywgc2VsZWN0b3IsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5lbWl0dGVyKCkub25lKGV2ZW50cywgYXJnU2VsZWN0b3Ioc2VsZWN0b3IpLCBjYWxsYmFjayk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBlbWl0OiBmdW5jdGlvbiBlbWl0KGV2ZW50cywgZXh0cmFQYXJhbXMpIHtcbiAgICB0aGlzLmVtaXR0ZXIoKS5lbWl0KGV2ZW50cywgZXh0cmFQYXJhbXMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG5cbmRlZmluZS5ldmVudEFsaWFzZXNPbihlbGVzZm4pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVsZXNmbjtcblxuLyoqKi8gfSksXG4vKiA3OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgY29yZWZuID0ge1xuXG4gIHBuZzogZnVuY3Rpb24gcG5nKG9wdGlvbnMpIHtcbiAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLl9wcml2YXRlLnJlbmRlcmVyO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgcmV0dXJuIHJlbmRlcmVyLnBuZyhvcHRpb25zKTtcbiAgfSxcblxuICBqcGc6IGZ1bmN0aW9uIGpwZyhvcHRpb25zKSB7XG4gICAgdmFyIHJlbmRlcmVyID0gdGhpcy5fcHJpdmF0ZS5yZW5kZXJlcjtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIG9wdGlvbnMuYmcgPSBvcHRpb25zLmJnIHx8ICcjZmZmJztcblxuICAgIHJldHVybiByZW5kZXJlci5qcGcob3B0aW9ucyk7XG4gIH1cblxufTtcblxuY29yZWZuLmpwZWcgPSBjb3JlZm4uanBnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcmVmbjtcblxuLyoqKi8gfSksXG4vKiA4MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG52YXIgaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgY29yZWZuID0ge1xuXG4gIGxheW91dDogZnVuY3Rpb24gbGF5b3V0KG9wdGlvbnMpIHtcbiAgICB2YXIgY3kgPSB0aGlzO1xuXG4gICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgdXRpbC5lcnJvcignTGF5b3V0IG9wdGlvbnMgbXVzdCBiZSBzcGVjaWZpZWQgdG8gbWFrZSBhIGxheW91dCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLm5hbWUgPT0gbnVsbCkge1xuICAgICAgdXRpbC5lcnJvcignQSBgbmFtZWAgbXVzdCBiZSBzcGVjaWZpZWQgdG8gbWFrZSBhIGxheW91dCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuYW1lID0gb3B0aW9ucy5uYW1lO1xuICAgIHZhciBMYXlvdXQgPSBjeS5leHRlbnNpb24oJ2xheW91dCcsIG5hbWUpO1xuXG4gICAgaWYgKExheW91dCA9PSBudWxsKSB7XG4gICAgICB1dGlsLmVycm9yKCdDYW4gbm90IGFwcGx5IGxheW91dDogTm8gc3VjaCBsYXlvdXQgYCcgKyBuYW1lICsgJ2AgZm91bmQ7IGRpZCB5b3UgaW5jbHVkZSBpdHMgSlMgZmlsZT8nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZWxlcyA9IHZvaWQgMDtcbiAgICBpZiAoaXMuc3RyaW5nKG9wdGlvbnMuZWxlcykpIHtcbiAgICAgIGVsZXMgPSBjeS4kKG9wdGlvbnMuZWxlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZXMgPSBvcHRpb25zLmVsZXMgIT0gbnVsbCA/IG9wdGlvbnMuZWxlcyA6IGN5LiQoKTtcbiAgICB9XG5cbiAgICB2YXIgbGF5b3V0ID0gbmV3IExheW91dCh1dGlsLmV4dGVuZCh7fSwgb3B0aW9ucywge1xuICAgICAgY3k6IGN5LFxuICAgICAgZWxlczogZWxlc1xuICAgIH0pKTtcblxuICAgIHJldHVybiBsYXlvdXQ7XG4gIH1cblxufTtcblxuY29yZWZuLmNyZWF0ZUxheW91dCA9IGNvcmVmbi5tYWtlTGF5b3V0ID0gY29yZWZuLmxheW91dDtcblxubW9kdWxlLmV4cG9ydHMgPSBjb3JlZm47XG5cbi8qKiovIH0pLFxuLyogODEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGNvcmVmbiA9IHtcbiAgbm90aWZ5OiBmdW5jdGlvbiBub3RpZnkocGFyYW1zKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcblxuICAgIGlmIChfcC5iYXRjaGluZ05vdGlmeSkge1xuICAgICAgdmFyIGJFbGVzID0gX3AuYmF0Y2hOb3RpZnlFbGVzO1xuICAgICAgdmFyIGJUeXBlcyA9IF9wLmJhdGNoTm90aWZ5VHlwZXM7XG5cbiAgICAgIGlmIChwYXJhbXMuZWxlcykge1xuICAgICAgICBiRWxlcy5tZXJnZShwYXJhbXMuZWxlcyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghYlR5cGVzLmlkc1twYXJhbXMudHlwZV0pIHtcbiAgICAgICAgYlR5cGVzLnB1c2gocGFyYW1zLnR5cGUpO1xuICAgICAgICBiVHlwZXMuaWRzW3BhcmFtcy50eXBlXSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjsgLy8gbm90aWZpY2F0aW9ucyBhcmUgZGlzYWJsZWQgZHVyaW5nIGJhdGNoaW5nXG4gICAgfVxuXG4gICAgaWYgKCFfcC5ub3RpZmljYXRpb25zRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gZXhpdCBvbiBkaXNhYmxlZFxuXG4gICAgdmFyIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcigpO1xuXG4gICAgLy8gZXhpdCBpZiBkZXN0cm95KCkgY2FsbGVkIG9uIGNvcmUgb3IgcmVuZGVyZXIgaW4gYmV0d2VlbiBmcmFtZXMgIzE0OTkgIzE1MjhcbiAgICBpZiAodGhpcy5pc0Rlc3Ryb3llZCgpIHx8ICFyZW5kZXJlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJlbmRlcmVyLm5vdGlmeShwYXJhbXMpO1xuICB9LFxuXG4gIG5vdGlmaWNhdGlvbnM6IGZ1bmN0aW9uIG5vdGlmaWNhdGlvbnMoYm9vbCkge1xuICAgIHZhciBwID0gdGhpcy5fcHJpdmF0ZTtcblxuICAgIGlmIChib29sID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBwLm5vdGlmaWNhdGlvbnNFbmFibGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICBwLm5vdGlmaWNhdGlvbnNFbmFibGVkID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgbm9Ob3RpZmljYXRpb25zOiBmdW5jdGlvbiBub05vdGlmaWNhdGlvbnMoY2FsbGJhY2spIHtcbiAgICB0aGlzLm5vdGlmaWNhdGlvbnMoZmFsc2UpO1xuICAgIGNhbGxiYWNrKCk7XG4gICAgdGhpcy5ub3RpZmljYXRpb25zKHRydWUpO1xuICB9LFxuXG4gIGJhdGNoaW5nOiBmdW5jdGlvbiBiYXRjaGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5iYXRjaENvdW50ID4gMDtcbiAgfSxcblxuICBzdGFydEJhdGNoOiBmdW5jdGlvbiBzdGFydEJhdGNoKCkge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICBpZiAoX3AuYmF0Y2hDb3VudCA9PSBudWxsKSB7XG4gICAgICBfcC5iYXRjaENvdW50ID0gMDtcbiAgICB9XG5cbiAgICBpZiAoX3AuYmF0Y2hDb3VudCA9PT0gMCkge1xuICAgICAgX3AuYmF0Y2hpbmdTdHlsZSA9IF9wLmJhdGNoaW5nTm90aWZ5ID0gdHJ1ZTtcbiAgICAgIF9wLmJhdGNoU3R5bGVFbGVzID0gdGhpcy5jb2xsZWN0aW9uKCk7XG4gICAgICBfcC5iYXRjaE5vdGlmeUVsZXMgPSB0aGlzLmNvbGxlY3Rpb24oKTtcbiAgICAgIF9wLmJhdGNoTm90aWZ5VHlwZXMgPSBbXTtcbiAgICAgIF9wLmJhdGNoTm90aWZ5VHlwZXMuaWRzID0ge307XG4gICAgfVxuXG4gICAgX3AuYmF0Y2hDb3VudCsrO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgZW5kQmF0Y2g6IGZ1bmN0aW9uIGVuZEJhdGNoKCkge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICBfcC5iYXRjaENvdW50LS07XG5cbiAgICBpZiAoX3AuYmF0Y2hDb3VudCA9PT0gMCkge1xuICAgICAgLy8gdXBkYXRlIHN0eWxlIGZvciBkaXJ0eSBlbGVzXG4gICAgICBfcC5iYXRjaGluZ1N0eWxlID0gZmFsc2U7XG4gICAgICBfcC5iYXRjaFN0eWxlRWxlcy51cGRhdGVTdHlsZSgpO1xuXG4gICAgICAvLyBub3RpZnkgdGhlIHJlbmRlcmVyIG9mIHF1ZXVlZCBlbGVzIGFuZCBldmVudCB0eXBlc1xuICAgICAgX3AuYmF0Y2hpbmdOb3RpZnkgPSBmYWxzZTtcbiAgICAgIHRoaXMubm90aWZ5KHtcbiAgICAgICAgdHlwZTogX3AuYmF0Y2hOb3RpZnlUeXBlcyxcbiAgICAgICAgZWxlczogX3AuYmF0Y2hOb3RpZnlFbGVzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBiYXRjaDogZnVuY3Rpb24gYmF0Y2goY2FsbGJhY2spIHtcbiAgICB0aGlzLnN0YXJ0QmF0Y2goKTtcbiAgICBjYWxsYmFjaygpO1xuICAgIHRoaXMuZW5kQmF0Y2goKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8vIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICBiYXRjaERhdGE6IGZ1bmN0aW9uIGJhdGNoRGF0YShtYXApIHtcbiAgICB2YXIgY3kgPSB0aGlzO1xuXG4gICAgcmV0dXJuIHRoaXMuYmF0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGlkcyA9IE9iamVjdC5rZXlzKG1hcCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpZCA9IGlkc1tpXTtcbiAgICAgICAgdmFyIGRhdGEgPSBtYXBbaWRdO1xuICAgICAgICB2YXIgZWxlID0gY3kuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuXG4gICAgICAgIGVsZS5kYXRhKGRhdGEpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcmVmbjtcblxuLyoqKi8gfSksXG4vKiA4MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBjb3JlZm4gPSB7XG5cbiAgcmVuZGVyVG86IGZ1bmN0aW9uIHJlbmRlclRvKGNvbnRleHQsIHpvb20sIHBhbiwgcHhSYXRpbykge1xuICAgIHZhciByID0gdGhpcy5fcHJpdmF0ZS5yZW5kZXJlcjtcblxuICAgIHIucmVuZGVyVG8oY29udGV4dCwgem9vbSwgcGFuLCBweFJhdGlvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICByZW5kZXJlcjogZnVuY3Rpb24gcmVuZGVyZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUucmVuZGVyZXI7XG4gIH0sXG5cbiAgZm9yY2VSZW5kZXI6IGZ1bmN0aW9uIGZvcmNlUmVuZGVyKCkge1xuICAgIHRoaXMubm90aWZ5KHtcbiAgICAgIHR5cGU6ICdkcmF3J1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgcmVzaXplOiBmdW5jdGlvbiByZXNpemUoKSB7XG4gICAgdGhpcy5pbnZhbGlkYXRlU2l6ZSgpO1xuXG4gICAgdGhpcy5ub3RpZnkoe1xuICAgICAgdHlwZTogJ3Jlc2l6ZSdcbiAgICB9KTtcblxuICAgIHRoaXMuZW1pdCgncmVzaXplJyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBpbml0UmVuZGVyZXI6IGZ1bmN0aW9uIGluaXRSZW5kZXJlcihvcHRpb25zKSB7XG4gICAgdmFyIGN5ID0gdGhpcztcblxuICAgIHZhciBSZW5kZXJlclByb3RvID0gY3kuZXh0ZW5zaW9uKCdyZW5kZXJlcicsIG9wdGlvbnMubmFtZSk7XG4gICAgaWYgKFJlbmRlcmVyUHJvdG8gPT0gbnVsbCkge1xuICAgICAgdXRpbC5lcnJvcignQ2FuIG5vdCBpbml0aWFsaXNlOiBObyBzdWNoIHJlbmRlcmVyIGAlc2AgZm91bmQ7IGRpZCB5b3UgaW5jbHVkZSBpdHMgSlMgZmlsZT8nLCBvcHRpb25zLm5hbWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGN5Ll9wcml2YXRlLnJlbmRlcmVyID0gbmV3IFJlbmRlcmVyUHJvdG8odXRpbC5leHRlbmQoe30sIG9wdGlvbnMsIHsgY3k6IGN5IH0pKTtcblxuICAgIHRoaXMubm90aWZ5KHsgdHlwZTogJ2luaXQnIH0pO1xuICB9LFxuXG4gIGRlc3Ryb3lSZW5kZXJlcjogZnVuY3Rpb24gZGVzdHJveVJlbmRlcmVyKCkge1xuICAgIHZhciBjeSA9IHRoaXM7XG5cbiAgICBjeS5ub3RpZnkoeyB0eXBlOiAnZGVzdHJveScgfSk7IC8vIGRlc3Ryb3kgdGhlIHJlbmRlcmVyXG5cbiAgICB2YXIgZG9tRWxlID0gY3kuY29udGFpbmVyKCk7XG4gICAgaWYgKGRvbUVsZSkge1xuICAgICAgZG9tRWxlLl9jeXJlZyA9IG51bGw7XG5cbiAgICAgIHdoaWxlIChkb21FbGUuY2hpbGROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGRvbUVsZS5yZW1vdmVDaGlsZChkb21FbGUuY2hpbGROb2Rlc1swXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY3kuX3ByaXZhdGUucmVuZGVyZXIgPSBudWxsOyAvLyB0byBiZSBleHRyYSBzYWZlLCByZW1vdmUgdGhlIHJlZlxuICB9LFxuXG4gIG9uUmVuZGVyOiBmdW5jdGlvbiBvblJlbmRlcihmbikge1xuICAgIHJldHVybiB0aGlzLm9uKCdyZW5kZXInLCBmbik7XG4gIH0sXG5cbiAgb2ZmUmVuZGVyOiBmdW5jdGlvbiBvZmZSZW5kZXIoZm4pIHtcbiAgICByZXR1cm4gdGhpcy5vZmYoJ3JlbmRlcicsIGZuKTtcbiAgfVxuXG59O1xuXG5jb3JlZm4uaW52YWxpZGF0ZURpbWVuc2lvbnMgPSBjb3JlZm4ucmVzaXplO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcmVmbjtcblxuLyoqKi8gfSksXG4vKiA4MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIENvbGxlY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXG52YXIgY29yZWZuID0ge1xuXG4gIC8vIGdldCBhIGNvbGxlY3Rpb25cbiAgLy8gLSBlbXB0eSBjb2xsZWN0aW9uIG9uIG5vIGFyZ3NcbiAgLy8gLSBjb2xsZWN0aW9uIG9mIGVsZW1lbnRzIGluIHRoZSBncmFwaCBvbiBzZWxlY3RvciBhcmdcbiAgLy8gLSBndWFyYW50ZWUgYSByZXR1cm5lZCBjb2xsZWN0aW9uIHdoZW4gZWxlbWVudHMgb3IgY29sbGVjdGlvbiBzcGVjaWZpZWRcbiAgY29sbGVjdGlvbjogZnVuY3Rpb24gY29sbGVjdGlvbihlbGVzLCBvcHRzKSB7XG5cbiAgICBpZiAoaXMuc3RyaW5nKGVsZXMpKSB7XG4gICAgICByZXR1cm4gdGhpcy4kKGVsZXMpO1xuICAgIH0gZWxzZSBpZiAoaXMuZWxlbWVudE9yQ29sbGVjdGlvbihlbGVzKSkge1xuICAgICAgcmV0dXJuIGVsZXMuY29sbGVjdGlvbigpO1xuICAgIH0gZWxzZSBpZiAoaXMuYXJyYXkoZWxlcykpIHtcbiAgICAgIHJldHVybiBuZXcgQ29sbGVjdGlvbih0aGlzLCBlbGVzLCBvcHRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IENvbGxlY3Rpb24odGhpcyk7XG4gIH0sXG5cbiAgbm9kZXM6IGZ1bmN0aW9uIG5vZGVzKHNlbGVjdG9yKSB7XG4gICAgdmFyIG5vZGVzID0gdGhpcy4kKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuaXNOb2RlKCk7XG4gICAgfSk7XG5cbiAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiBub2Rlcy5maWx0ZXIoc2VsZWN0b3IpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlcztcbiAgfSxcblxuICBlZGdlczogZnVuY3Rpb24gZWRnZXMoc2VsZWN0b3IpIHtcbiAgICB2YXIgZWRnZXMgPSB0aGlzLiQoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5pc0VkZ2UoKTtcbiAgICB9KTtcblxuICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIGVkZ2VzLmZpbHRlcihzZWxlY3Rvcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVkZ2VzO1xuICB9LFxuXG4gIC8vIHNlYXJjaCB0aGUgZ3JhcGggbGlrZSBqUXVlcnlcbiAgJDogZnVuY3Rpb24gJChzZWxlY3Rvcikge1xuICAgIHZhciBlbGVzID0gdGhpcy5fcHJpdmF0ZS5lbGVtZW50cztcblxuICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIGVsZXMuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGVsZXMuc3Bhd25TZWxmKCk7XG4gICAgfVxuICB9LFxuXG4gIG11dGFibGVFbGVtZW50czogZnVuY3Rpb24gbXV0YWJsZUVsZW1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmVsZW1lbnRzO1xuICB9XG5cbn07XG5cbi8vIGFsaWFzZXNcbmNvcmVmbi5lbGVtZW50cyA9IGNvcmVmbi5maWx0ZXIgPSBjb3JlZm4uJDtcblxubW9kdWxlLmV4cG9ydHMgPSBjb3JlZm47XG5cbi8qKiovIH0pLFxuLyogODQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBTdHlsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xuXG52YXIgY29yZWZuID0ge1xuXG4gIHN0eWxlOiBmdW5jdGlvbiBzdHlsZShuZXdTdHlsZSkge1xuICAgIGlmIChuZXdTdHlsZSkge1xuICAgICAgdmFyIHMgPSB0aGlzLnNldFN0eWxlKG5ld1N0eWxlKTtcblxuICAgICAgcy51cGRhdGUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5zdHlsZTtcbiAgfSxcblxuICBzZXRTdHlsZTogZnVuY3Rpb24gc2V0U3R5bGUoc3R5bGUpIHtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgaWYgKGlzLnN0eWxlc2hlZXQoc3R5bGUpKSB7XG4gICAgICBfcC5zdHlsZSA9IHN0eWxlLmdlbmVyYXRlU3R5bGUodGhpcyk7XG4gICAgfSBlbHNlIGlmIChpcy5hcnJheShzdHlsZSkpIHtcbiAgICAgIF9wLnN0eWxlID0gU3R5bGUuZnJvbUpzb24odGhpcywgc3R5bGUpO1xuICAgIH0gZWxzZSBpZiAoaXMuc3RyaW5nKHN0eWxlKSkge1xuICAgICAgX3Auc3R5bGUgPSBTdHlsZS5mcm9tU3RyaW5nKHRoaXMsIHN0eWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3Auc3R5bGUgPSBTdHlsZSh0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3Auc3R5bGU7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY29yZWZuO1xuXG4vKioqLyB9KSxcbi8qIDg1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbnZhciBpcyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgUHJvbWlzZSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbnZhciBzdHlmbiA9IHt9O1xuXG4vLyAocG90ZW50aWFsbHkgZXhwZW5zaXZlIGNhbGN1bGF0aW9uKVxuLy8gYXBwbHkgdGhlIHN0eWxlIHRvIHRoZSBlbGVtZW50IGJhc2VkIG9uXG4vLyAtIGl0cyBieXBhc3Ncbi8vIC0gd2hhdCBzZWxlY3RvcnMgbWF0Y2ggaXRcbnN0eWZuLmFwcGx5ID0gZnVuY3Rpb24gKGVsZXMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgX3AgPSBzZWxmLl9wcml2YXRlO1xuICB2YXIgY3kgPSBfcC5jeTtcbiAgdmFyIHVwZGF0ZWRFbGVzID0gY3kuY29sbGVjdGlvbigpO1xuXG4gIGlmIChfcC5uZXdTdHlsZSkge1xuICAgIC8vIGNsZWFyIHN0eWxlIGNhY2hlc1xuICAgIF9wLmNvbnRleHRTdHlsZXMgPSB7fTtcbiAgICBfcC5wcm9wRGlmZnMgPSB7fTtcblxuICAgIHNlbGYuY2xlYW5FbGVtZW50cyhlbGVzLCB0cnVlKTtcbiAgfVxuXG4gIGZvciAodmFyIGllID0gMDsgaWUgPCBlbGVzLmxlbmd0aDsgaWUrKykge1xuICAgIHZhciBlbGUgPSBlbGVzW2llXTtcblxuICAgIHZhciBjeHRNZXRhID0gc2VsZi5nZXRDb250ZXh0TWV0YShlbGUpO1xuXG4gICAgaWYgKGN4dE1ldGEuZW1wdHkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB1cGRhdGVkRWxlcy5tZXJnZShlbGUpO1xuICAgIH1cblxuICAgIHZhciBjeHRTdHlsZSA9IHNlbGYuZ2V0Q29udGV4dFN0eWxlKGN4dE1ldGEpO1xuICAgIHZhciBhcHAgPSBzZWxmLmFwcGx5Q29udGV4dFN0eWxlKGN4dE1ldGEsIGN4dFN0eWxlLCBlbGUpO1xuXG4gICAgaWYgKCFfcC5uZXdTdHlsZSkge1xuICAgICAgc2VsZi51cGRhdGVUcmFuc2l0aW9ucyhlbGUsIGFwcC5kaWZmUHJvcHMpO1xuICAgIH1cblxuICAgIHNlbGYudXBkYXRlU3R5bGVIaW50cyhlbGUpO1xuICB9IC8vIGZvciBlbGVtZW50c1xuXG4gIF9wLm5ld1N0eWxlID0gZmFsc2U7XG5cbiAgcmV0dXJuIHVwZGF0ZWRFbGVzO1xufTtcblxuc3R5Zm4uZ2V0UHJvcGVydGllc0RpZmYgPSBmdW5jdGlvbiAob2xkQ3h0S2V5LCBuZXdDeHRLZXkpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgY2FjaGUgPSBzZWxmLl9wcml2YXRlLnByb3BEaWZmcyA9IHNlbGYuX3ByaXZhdGUucHJvcERpZmZzIHx8IHt9O1xuICB2YXIgZHVhbEN4dEtleSA9IG9sZEN4dEtleSArICctJyArIG5ld0N4dEtleTtcbiAgdmFyIGNhY2hlZFZhbCA9IGNhY2hlW2R1YWxDeHRLZXldO1xuXG4gIGlmIChjYWNoZWRWYWwpIHtcbiAgICByZXR1cm4gY2FjaGVkVmFsO1xuICB9XG5cbiAgdmFyIGRpZmZQcm9wcyA9IFtdO1xuICB2YXIgYWRkZWRQcm9wID0ge307XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGN4dCA9IHNlbGZbaV07XG4gICAgdmFyIG9sZEhhc0N4dCA9IG9sZEN4dEtleVtpXSA9PT0gJ3QnO1xuICAgIHZhciBuZXdIYXNDeHQgPSBuZXdDeHRLZXlbaV0gPT09ICd0JztcbiAgICB2YXIgY3h0SGFzRGlmZmVkID0gb2xkSGFzQ3h0ICE9PSBuZXdIYXNDeHQ7XG4gICAgdmFyIGN4dEhhc01hcHBlZFByb3BzID0gY3h0Lm1hcHBlZFByb3BlcnRpZXMubGVuZ3RoID4gMDtcblxuICAgIGlmIChjeHRIYXNEaWZmZWQgfHwgY3h0SGFzTWFwcGVkUHJvcHMpIHtcbiAgICAgIHZhciBwcm9wcyA9IHZvaWQgMDtcblxuICAgICAgaWYgKGN4dEhhc0RpZmZlZCAmJiBjeHRIYXNNYXBwZWRQcm9wcykge1xuICAgICAgICBwcm9wcyA9IGN4dC5wcm9wZXJ0aWVzOyAvLyBzdWZmaWNlcyBiL2MgbWFwcGVkUHJvcGVydGllcyBpcyBhIHN1YnNldCBvZiBwcm9wZXJ0aWVzXG4gICAgICB9IGVsc2UgaWYgKGN4dEhhc0RpZmZlZCkge1xuICAgICAgICBwcm9wcyA9IGN4dC5wcm9wZXJ0aWVzOyAvLyBuZWVkIHRvIGNoZWNrIHRoZW0gYWxsXG4gICAgICB9IGVsc2UgaWYgKGN4dEhhc01hcHBlZFByb3BzKSB7XG4gICAgICAgIHByb3BzID0gY3h0Lm1hcHBlZFByb3BlcnRpZXM7IC8vIG9ubHkgbmVlZCB0byBjaGVjayBtYXBwZWRcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwcm9wcy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgcHJvcCA9IHByb3BzW2pdO1xuICAgICAgICB2YXIgbmFtZSA9IHByb3AubmFtZTtcblxuICAgICAgICAvLyBpZiBhIGxhdGVyIGNvbnRleHQgb3ZlcnJpZGVzIHRoaXMgcHJvcGVydHksIHRoZW4gdGhlIGZhY3QgdGhhdCB0aGlzIGNvbnRleHQgaGFzIHN3aXRjaGVkL2RpZmZlZCBkb2Vzbid0IG1hdHRlclxuICAgICAgICAvLyAoc2VtaSBleHBlbnNpdmUgY2hlY2sgc2luY2UgaXQgbWFrZXMgdGhpcyBmdW5jdGlvbiBPKG5eMikgb24gY29udGV4dCBsZW5ndGgsIGJ1dCB3b3J0aCBpdCBzaW5jZSBvdmVyYWxsIHJlc3VsdFxuICAgICAgICAvLyBpcyBjYWNoZWQpXG4gICAgICAgIHZhciBsYXRlckN4dE92ZXJyaWRlcyA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBrID0gaSArIDE7IGsgPCBzZWxmLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgdmFyIGxhdGVyQ3h0ID0gc2VsZltrXTtcbiAgICAgICAgICB2YXIgaGFzTGF0ZXJDeHQgPSBuZXdDeHRLZXlba10gPT09ICd0JztcblxuICAgICAgICAgIGlmICghaGFzTGF0ZXJDeHQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gLy8gY2FuJ3Qgb3ZlcnJpZGUgdW5sZXNzIHRoZSBjb250ZXh0IGlzIGFjdGl2ZVxuXG4gICAgICAgICAgbGF0ZXJDeHRPdmVycmlkZXMgPSBsYXRlckN4dC5wcm9wZXJ0aWVzW3Byb3AubmFtZV0gIT0gbnVsbDtcblxuICAgICAgICAgIGlmIChsYXRlckN4dE92ZXJyaWRlcykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSAvLyBleGl0IGVhcmx5IGFzIGxvbmcgYXMgb25lIGxhdGVyIGNvbnRleHQgb3ZlcnJpZGVzXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWFkZGVkUHJvcFtuYW1lXSAmJiAhbGF0ZXJDeHRPdmVycmlkZXMpIHtcbiAgICAgICAgICBhZGRlZFByb3BbbmFtZV0gPSB0cnVlO1xuICAgICAgICAgIGRpZmZQcm9wcy5wdXNoKG5hbWUpO1xuICAgICAgICB9XG4gICAgICB9IC8vIGZvciBwcm9wc1xuICAgIH0gLy8gaWZcbiAgfSAvLyBmb3IgY29udGV4dHNcblxuICBjYWNoZVtkdWFsQ3h0S2V5XSA9IGRpZmZQcm9wcztcbiAgcmV0dXJuIGRpZmZQcm9wcztcbn07XG5cbnN0eWZuLmdldENvbnRleHRNZXRhID0gZnVuY3Rpb24gKGVsZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBjeHRLZXkgPSAnJztcbiAgdmFyIGRpZmZQcm9wcyA9IHZvaWQgMDtcbiAgdmFyIHByZXZLZXkgPSBlbGUuX3ByaXZhdGUuc3R5bGVDeHRLZXkgfHwgJyc7XG5cbiAgaWYgKHNlbGYuX3ByaXZhdGUubmV3U3R5bGUpIHtcbiAgICBwcmV2S2V5ID0gJyc7IC8vIHNpbmNlIHdlIG5lZWQgdG8gYXBwbHkgYWxsIHN0eWxlIGlmIGEgZnJlc2ggc3R5bGVzaGVldFxuICB9XG5cbiAgLy8gZ2V0IHRoZSBjeHQga2V5XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjb250ZXh0ID0gc2VsZltpXTtcbiAgICB2YXIgY29udGV4dFNlbGVjdG9yTWF0Y2hlcyA9IGNvbnRleHQuc2VsZWN0b3IgJiYgY29udGV4dC5zZWxlY3Rvci5tYXRjaGVzKGVsZSk7IC8vIE5COiBjb250ZXh0LnNlbGVjdG9yIG1heSBiZSBudWxsIGZvciAnY29yZSdcblxuICAgIGlmIChjb250ZXh0U2VsZWN0b3JNYXRjaGVzKSB7XG4gICAgICBjeHRLZXkgKz0gJ3QnO1xuICAgIH0gZWxzZSB7XG4gICAgICBjeHRLZXkgKz0gJ2YnO1xuICAgIH1cbiAgfSAvLyBmb3IgY29udGV4dFxuXG4gIGRpZmZQcm9wcyA9IHNlbGYuZ2V0UHJvcGVydGllc0RpZmYocHJldktleSwgY3h0S2V5KTtcblxuICBlbGUuX3ByaXZhdGUuc3R5bGVDeHRLZXkgPSBjeHRLZXk7XG5cbiAgcmV0dXJuIHtcbiAgICBrZXk6IGN4dEtleSxcbiAgICBkaWZmUHJvcE5hbWVzOiBkaWZmUHJvcHMsXG4gICAgZW1wdHk6IGRpZmZQcm9wcy5sZW5ndGggPT09IDBcbiAgfTtcbn07XG5cbi8vIGdldHMgYSBjb21wdXRlZCBlbGUgc3R5bGUgb2JqZWN0IGJhc2VkIG9uIG1hdGNoZWQgY29udGV4dHNcbnN0eWZuLmdldENvbnRleHRTdHlsZSA9IGZ1bmN0aW9uIChjeHRNZXRhKSB7XG4gIHZhciBjeHRLZXkgPSBjeHRNZXRhLmtleTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgY3h0U3R5bGVzID0gdGhpcy5fcHJpdmF0ZS5jb250ZXh0U3R5bGVzID0gdGhpcy5fcHJpdmF0ZS5jb250ZXh0U3R5bGVzIHx8IHt9O1xuXG4gIC8vIGlmIGFscmVhZHkgY29tcHV0ZWQgc3R5bGUsIHJldHVybmVkIGNhY2hlZCBjb3B5XG4gIGlmIChjeHRTdHlsZXNbY3h0S2V5XSkge1xuICAgIHJldHVybiBjeHRTdHlsZXNbY3h0S2V5XTtcbiAgfVxuXG4gIHZhciBzdHlsZSA9IHtcbiAgICBfcHJpdmF0ZToge1xuICAgICAga2V5OiBjeHRLZXlcbiAgICB9XG4gIH07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGN4dCA9IHNlbGZbaV07XG4gICAgdmFyIGhhc0N4dCA9IGN4dEtleVtpXSA9PT0gJ3QnO1xuXG4gICAgaWYgKCFoYXNDeHQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgY3h0LnByb3BlcnRpZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBwcm9wID0gY3h0LnByb3BlcnRpZXNbal07XG5cbiAgICAgIHN0eWxlW3Byb3AubmFtZV0gPSBwcm9wO1xuICAgIH1cbiAgfVxuXG4gIGN4dFN0eWxlc1tjeHRLZXldID0gc3R5bGU7XG4gIHJldHVybiBzdHlsZTtcbn07XG5cbnN0eWZuLmFwcGx5Q29udGV4dFN0eWxlID0gZnVuY3Rpb24gKGN4dE1ldGEsIGN4dFN0eWxlLCBlbGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgZGlmZlByb3BzID0gY3h0TWV0YS5kaWZmUHJvcE5hbWVzO1xuICB2YXIgcmV0RGlmZlByb3BzID0ge307XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaWZmUHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGlmZlByb3BOYW1lID0gZGlmZlByb3BzW2ldO1xuICAgIHZhciBjeHRQcm9wID0gY3h0U3R5bGVbZGlmZlByb3BOYW1lXTtcbiAgICB2YXIgZWxlUHJvcCA9IGVsZS5wc3R5bGUoZGlmZlByb3BOYW1lKTtcblxuICAgIGlmICghY3h0UHJvcCkge1xuICAgICAgLy8gbm8gY29udGV4dCBwcm9wIG1lYW5zIGRlbGV0ZVxuICAgICAgaWYgKCFlbGVQcm9wKSB7XG4gICAgICAgIGNvbnRpbnVlOyAvLyBubyBleGlzdGluZyBwcm9wIG1lYW5zIG5vdGhpbmcgbmVlZHMgdG8gYmUgcmVtb3ZlZFxuICAgICAgICAvLyBuYiBhZmZlY3RzIGluaXRpYWwgYXBwbGljYXRpb24gb24gbWFwcGVkIHZhbHVlcyBsaWtlIGNvbnRyb2wtcG9pbnQtZGlzdGFuY2VzXG4gICAgICB9IGVsc2UgaWYgKGVsZVByb3AuYnlwYXNzKSB7XG4gICAgICAgIGN4dFByb3AgPSB7IG5hbWU6IGRpZmZQcm9wTmFtZSwgZGVsZXRlQnlwYXNzZWQ6IHRydWUgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN4dFByb3AgPSB7IG5hbWU6IGRpZmZQcm9wTmFtZSwgZGVsZXRlOiB0cnVlIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gc2F2ZSBjeWNsZXMgd2hlbiB0aGUgY29udGV4dCBwcm9wIGRvZXNuJ3QgbmVlZCB0byBiZSBhcHBsaWVkXG4gICAgaWYgKGVsZVByb3AgPT09IGN4dFByb3ApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciByZXREaWZmUHJvcCA9IHJldERpZmZQcm9wc1tkaWZmUHJvcE5hbWVdID0ge1xuICAgICAgcHJldjogZWxlUHJvcFxuICAgIH07XG5cbiAgICBzZWxmLmFwcGx5UGFyc2VkUHJvcGVydHkoZWxlLCBjeHRQcm9wKTtcblxuICAgIHJldERpZmZQcm9wLm5leHQgPSBlbGUucHN0eWxlKGRpZmZQcm9wTmFtZSk7XG5cbiAgICBpZiAocmV0RGlmZlByb3AubmV4dCAmJiByZXREaWZmUHJvcC5uZXh0LmJ5cGFzcykge1xuICAgICAgcmV0RGlmZlByb3AubmV4dCA9IHJldERpZmZQcm9wLm5leHQuYnlwYXNzZWQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBkaWZmUHJvcHM6IHJldERpZmZQcm9wc1xuICB9O1xufTtcblxuc3R5Zm4udXBkYXRlU3R5bGVIaW50cyA9IGZ1bmN0aW9uIChlbGUpIHtcbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKGVsZS5yZW1vdmVkKCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBzZXQgd2hldGhlciBoYXMgcGllIG9yIG5vdDsgZm9yIGdyZWF0ZXIgZWZmaWNpZW5jeVxuICB2YXIgaGFzUGllID0gZmFsc2U7XG4gIGlmIChfcC5ncm91cCA9PT0gJ25vZGVzJykge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IHNlbGYucGllQmFja2dyb3VuZE47IGkrKykge1xuICAgICAgLy8gMS4uTlxuICAgICAgdmFyIF9zaXplID0gZWxlLnBzdHlsZSgncGllLScgKyBpICsgJy1iYWNrZ3JvdW5kLXNpemUnKS52YWx1ZTtcblxuICAgICAgaWYgKF9zaXplID4gMCkge1xuICAgICAgICBoYXNQaWUgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfcC5oYXNQaWUgPSBoYXNQaWU7XG5cbiAgdmFyIHRyYW5zZm9ybSA9IGVsZS5wc3R5bGUoJ3RleHQtdHJhbnNmb3JtJykuc3RyVmFsdWU7XG4gIHZhciBjb250ZW50ID0gZWxlLnBzdHlsZSgnbGFiZWwnKS5zdHJWYWx1ZTtcbiAgdmFyIHNyY0NvbnRlbnQgPSBlbGUucHN0eWxlKCdzb3VyY2UtbGFiZWwnKS5zdHJWYWx1ZTtcbiAgdmFyIHRndENvbnRlbnQgPSBlbGUucHN0eWxlKCd0YXJnZXQtbGFiZWwnKS5zdHJWYWx1ZTtcbiAgdmFyIGZTdHlsZSA9IGVsZS5wc3R5bGUoJ2ZvbnQtc3R5bGUnKS5zdHJWYWx1ZTtcbiAgdmFyIHNpemUgPSBlbGUucHN0eWxlKCdmb250LXNpemUnKS5wZlZhbHVlICsgJ3B4JztcbiAgdmFyIGZhbWlseSA9IGVsZS5wc3R5bGUoJ2ZvbnQtZmFtaWx5Jykuc3RyVmFsdWU7XG4gIC8vIGxldCBsZXRpYW50ID0gc3R5bGVbJ2ZvbnQtbGV0aWFudCddLnN0clZhbHVlO1xuICB2YXIgd2VpZ2h0ID0gZWxlLnBzdHlsZSgnZm9udC13ZWlnaHQnKS5zdHJWYWx1ZTtcbiAgdmFyIHZhbGlnbiA9IGVsZS5wc3R5bGUoJ3RleHQtdmFsaWduJykuc3RyVmFsdWU7XG4gIHZhciBoYWxpZ24gPSBlbGUucHN0eWxlKCd0ZXh0LXZhbGlnbicpLnN0clZhbHVlO1xuICB2YXIgb1dpZHRoID0gZWxlLnBzdHlsZSgndGV4dC1vdXRsaW5lLXdpZHRoJykucGZWYWx1ZTtcbiAgdmFyIHdyYXAgPSBlbGUucHN0eWxlKCd0ZXh0LXdyYXAnKS5zdHJWYWx1ZTtcbiAgdmFyIHdyYXBXID0gZWxlLnBzdHlsZSgndGV4dC1tYXgtd2lkdGgnKS5wZlZhbHVlO1xuICB2YXIgbGFiZWxTdHlsZUtleSA9IGZTdHlsZSArICckJyArIHNpemUgKyAnJCcgKyBmYW1pbHkgKyAnJCcgKyB3ZWlnaHQgKyAnJCcgKyB0cmFuc2Zvcm0gKyAnJCcgKyB2YWxpZ24gKyAnJCcgKyBoYWxpZ24gKyAnJCcgKyBvV2lkdGggKyAnJCcgKyB3cmFwICsgJyQnICsgd3JhcFc7XG4gIF9wLmxhYmVsU3R5bGVLZXkgPSBsYWJlbFN0eWxlS2V5O1xuICBfcC5zb3VyY2VMYWJlbEtleSA9IGxhYmVsU3R5bGVLZXkgKyAnJCcgKyBzcmNDb250ZW50O1xuICBfcC50YXJnZXRMYWJlbEtleSA9IGxhYmVsU3R5bGVLZXkgKyAnJCcgKyB0Z3RDb250ZW50O1xuICBfcC5sYWJlbEtleSA9IGxhYmVsU3R5bGVLZXkgKyAnJCcgKyBjb250ZW50O1xuICBfcC5mb250S2V5ID0gZlN0eWxlICsgJyQnICsgd2VpZ2h0ICsgJyQnICsgc2l6ZSArICckJyArIGZhbWlseTtcblxuICBfcC5zdHlsZUtleSA9IERhdGUubm93KCk7XG59O1xuXG4vLyBhcHBseSBhIHByb3BlcnR5IHRvIHRoZSBzdHlsZSAoZm9yIGludGVybmFsIHVzZSlcbi8vIHJldHVybnMgd2hldGhlciBhcHBsaWNhdGlvbiB3YXMgc3VjY2Vzc2Z1bFxuLy9cbi8vIG5vdywgdGhpcyBmdW5jdGlvbiBmbGF0dGVucyB0aGUgcHJvcGVydHksIGFuZCBoZXJlJ3MgaG93OlxuLy9cbi8vIGZvciBwYXJzZWRQcm9wOnsgYnlwYXNzOiB0cnVlLCBkZWxldGVCeXBhc3M6IHRydWUgfVxuLy8gbm8gcHJvcGVydHkgaXMgZ2VuZXJhdGVkLCBpbnN0ZWFkIHRoZSBieXBhc3MgcHJvcGVydHkgaW4gdGhlXG4vLyBlbGVtZW50J3Mgc3R5bGUgaXMgcmVwbGFjZWQgYnkgd2hhdCdzIHBvaW50ZWQgdG8gYnkgdGhlIGBieXBhc3NlZGBcbi8vIGZpZWxkIGluIHRoZSBieXBhc3MgcHJvcGVydHkgKGkuZS4gcmVzdG9yaW5nIHRoZSBwcm9wZXJ0eSB0aGVcbi8vIGJ5cGFzcyB3YXMgb3ZlcnJpZGluZylcbi8vXG4vLyBmb3IgcGFyc2VkUHJvcDp7IG1hcHBlZDogdHJ1dGh5IH1cbi8vIHRoZSBnZW5lcmF0ZWQgZmxhdHRlbmVkUHJvcDp7IG1hcHBpbmc6IHByb3AgfVxuLy9cbi8vIGZvciBwYXJzZWRQcm9wOnsgYnlwYXNzOiB0cnVlIH1cbi8vIHRoZSBnZW5lcmF0ZWQgZmxhdHRlbmVkUHJvcDp7IGJ5cGFzc2VkOiBwYXJzZWRQcm9wIH1cbnN0eWZuLmFwcGx5UGFyc2VkUHJvcGVydHkgPSBmdW5jdGlvbiAoZWxlLCBwYXJzZWRQcm9wKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHByb3AgPSBwYXJzZWRQcm9wO1xuICB2YXIgc3R5bGUgPSBlbGUuX3ByaXZhdGUuc3R5bGU7XG4gIHZhciBmaWVsZFZhbCA9IHZvaWQgMCxcbiAgICAgIGZsYXRQcm9wID0gdm9pZCAwO1xuICB2YXIgdHlwZXMgPSBzZWxmLnR5cGVzO1xuICB2YXIgdHlwZSA9IHNlbGYucHJvcGVydGllc1twcm9wLm5hbWVdLnR5cGU7XG4gIHZhciBwcm9wSXNCeXBhc3MgPSBwcm9wLmJ5cGFzcztcbiAgdmFyIG9yaWdQcm9wID0gc3R5bGVbcHJvcC5uYW1lXTtcbiAgdmFyIG9yaWdQcm9wSXNCeXBhc3MgPSBvcmlnUHJvcCAmJiBvcmlnUHJvcC5ieXBhc3M7XG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgdmFyIGZsYXRQcm9wTWFwcGluZyA9ICdtYXBwaW5nJztcblxuICB2YXIgY2hlY2taT3JkZXIgPSBmdW5jdGlvbiBjaGVja1pPcmRlcigpIHtcbiAgICBzZWxmLmNoZWNrWk9yZGVyVHJpZ2dlcihlbGUsIHByb3AubmFtZSwgb3JpZ1Byb3AgPyBvcmlnUHJvcC52YWx1ZSA6IG51bGwsIHByb3AudmFsdWUpO1xuICB9O1xuXG4gIC8vIGVkZ2VzIGNvbm5lY3RlZCB0byBjb21wb3VuZCBub2RlcyBjYW4gbm90IGJlIGhheXN0YWNrc1xuICBpZiAocGFyc2VkUHJvcC5uYW1lID09PSAnY3VydmUtc3R5bGUnICYmIHBhcnNlZFByb3AudmFsdWUgPT09ICdoYXlzdGFjaycgJiYgZWxlLmlzRWRnZSgpICYmIChlbGUuaXNMb29wKCkgfHwgZWxlLnNvdXJjZSgpLmlzUGFyZW50KCkgfHwgZWxlLnRhcmdldCgpLmlzUGFyZW50KCkpKSB7XG4gICAgcHJvcCA9IHBhcnNlZFByb3AgPSB0aGlzLnBhcnNlKHBhcnNlZFByb3AubmFtZSwgJ2JlemllcicsIHByb3BJc0J5cGFzcyk7XG4gIH1cblxuICBpZiAocHJvcC5kZWxldGUpIHtcbiAgICAvLyBkZWxldGUgdGhlIHByb3BlcnR5IGFuZCB1c2UgdGhlIGRlZmF1bHQgdmFsdWUgb24gZmFsc2V5IHZhbHVlXG4gICAgc3R5bGVbcHJvcC5uYW1lXSA9IHVuZGVmaW5lZDtcblxuICAgIGNoZWNrWk9yZGVyKCk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChwcm9wLmRlbGV0ZUJ5cGFzc2VkKSB7XG4gICAgLy8gZGVsZXRlIHRoZSBwcm9wZXJ0eSB0aGF0IHRoZVxuICAgIGlmICghb3JpZ1Byb3ApIHtcbiAgICAgIGNoZWNrWk9yZGVyKCk7XG5cbiAgICAgIHJldHVybiB0cnVlOyAvLyBjYW4ndCBkZWxldGUgaWYgbm8gcHJvcFxuICAgIH0gZWxzZSBpZiAob3JpZ1Byb3AuYnlwYXNzKSB7XG4gICAgICAvLyBkZWxldGUgYnlwYXNzZWRcbiAgICAgIG9yaWdQcm9wLmJ5cGFzc2VkID0gdW5kZWZpbmVkO1xuXG4gICAgICBjaGVja1pPcmRlcigpO1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlOyAvLyB3ZSdyZSB1bnN1Y2Nlc3NmdWwgZGVsZXRpbmcgdGhlIGJ5cGFzc2VkXG4gICAgfVxuICB9XG5cbiAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBkZWxldGUgdGhlIGN1cnJlbnQgYnlwYXNzXG4gIGlmIChwcm9wLmRlbGV0ZUJ5cGFzcykge1xuICAgIC8vIHRoZW4gdGhpcyBwcm9wZXJ0eSBpcyBqdXN0IGhlcmUgdG8gaW5kaWNhdGUgd2UgbmVlZCB0byBkZWxldGVcbiAgICBpZiAoIW9yaWdQcm9wKSB7XG4gICAgICBjaGVja1pPcmRlcigpO1xuXG4gICAgICByZXR1cm4gdHJ1ZTsgLy8gcHJvcGVydHkgaXMgYWxyZWFkeSBub3QgZGVmaW5lZFxuICAgIH0gZWxzZSBpZiAob3JpZ1Byb3AuYnlwYXNzKSB7XG4gICAgICAvLyB0aGVuIHJlcGxhY2UgdGhlIGJ5cGFzcyBwcm9wZXJ0eSB3aXRoIHRoZSBvcmlnaW5hbFxuICAgICAgLy8gYmVjYXVzZSB0aGUgYnlwYXNzZWQgcHJvcGVydHkgd2FzIGFscmVhZHkgYXBwbGllZCAoYW5kIHRoZXJlZm9yZSBwYXJzZWQpLCB3ZSBjYW4ganVzdCByZXBsYWNlIGl0IChubyByZWFwcGx5aW5nIG5lY2Vzc2FyeSlcbiAgICAgIHN0eWxlW3Byb3AubmFtZV0gPSBvcmlnUHJvcC5ieXBhc3NlZDtcblxuICAgICAgY2hlY2taT3JkZXIoKTtcblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTsgLy8gd2UncmUgdW5zdWNjZXNzZnVsIGRlbGV0aW5nIHRoZSBieXBhc3NcbiAgICB9XG4gIH1cblxuICB2YXIgcHJpbnRNYXBwaW5nRXJyID0gZnVuY3Rpb24gcHJpbnRNYXBwaW5nRXJyKCkge1xuICAgIHV0aWwuZXJyb3IoJ0RvIG5vdCBhc3NpZ24gbWFwcGluZ3MgdG8gZWxlbWVudHMgd2l0aG91dCBjb3JyZXNwb25kaW5nIGRhdGEgKGUuZy4gZWxlIGAnICsgZWxlLmlkKCkgKyAnYCBmb3IgcHJvcGVydHkgYCcgKyBwcm9wLm5hbWUgKyAnYCB3aXRoIGRhdGEgZmllbGQgYCcgKyBwcm9wLmZpZWxkICsgJ2ApOyB0cnkgYSBgWycgKyBwcm9wLmZpZWxkICsgJ11gIHNlbGVjdG9yIHRvIGxpbWl0IHNjb3BlIHRvIGVsZW1lbnRzIHdpdGggYCcgKyBwcm9wLmZpZWxkICsgJ2AgZGVmaW5lZCcpO1xuICB9O1xuXG4gIC8vIHB1dCB0aGUgcHJvcGVydHkgaW4gdGhlIHN0eWxlIG9iamVjdHNcbiAgc3dpdGNoIChwcm9wLm1hcHBlZCkgey8vIGZsYXR0ZW4gdGhlIHByb3BlcnR5IGlmIG1hcHBlZFxuICAgIGNhc2UgdHlwZXMubWFwRGF0YTpcbiAgICAgIHtcbiAgICAgICAgLy8gZmxhdHRlbiB0aGUgZmllbGQgKGUuZy4gZGF0YS5mb28uYmFyKVxuICAgICAgICB2YXIgZmllbGRzID0gcHJvcC5maWVsZC5zcGxpdCgnLicpO1xuICAgICAgICB2YXIgX2ZpZWxkVmFsID0gX3AuZGF0YTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGggJiYgX2ZpZWxkVmFsOyBpKyspIHtcbiAgICAgICAgICB2YXIgZmllbGQgPSBmaWVsZHNbaV07XG4gICAgICAgICAgX2ZpZWxkVmFsID0gX2ZpZWxkVmFsW2ZpZWxkXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwZXJjZW50ID0gdm9pZCAwO1xuICAgICAgICBpZiAoIWlzLm51bWJlcihfZmllbGRWYWwpKSB7XG4gICAgICAgICAgLy8gdGhlbiBrZWVwIHRoZSBtYXBwaW5nIGJ1dCBhc3N1bWUgMCUgZm9yIG5vd1xuICAgICAgICAgIHBlcmNlbnQgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlcmNlbnQgPSAoX2ZpZWxkVmFsIC0gcHJvcC5maWVsZE1pbikgLyAocHJvcC5maWVsZE1heCAtIHByb3AuZmllbGRNaW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWFrZSBzdXJlIHRvIGJvdW5kIHBlcmNlbnQgdmFsdWVcbiAgICAgICAgaWYgKHBlcmNlbnQgPCAwKSB7XG4gICAgICAgICAgcGVyY2VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAocGVyY2VudCA+IDEpIHtcbiAgICAgICAgICBwZXJjZW50ID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlLmNvbG9yKSB7XG4gICAgICAgICAgdmFyIHIxID0gcHJvcC52YWx1ZU1pblswXTtcbiAgICAgICAgICB2YXIgcjIgPSBwcm9wLnZhbHVlTWF4WzBdO1xuICAgICAgICAgIHZhciBnMSA9IHByb3AudmFsdWVNaW5bMV07XG4gICAgICAgICAgdmFyIGcyID0gcHJvcC52YWx1ZU1heFsxXTtcbiAgICAgICAgICB2YXIgYjEgPSBwcm9wLnZhbHVlTWluWzJdO1xuICAgICAgICAgIHZhciBiMiA9IHByb3AudmFsdWVNYXhbMl07XG4gICAgICAgICAgdmFyIGExID0gcHJvcC52YWx1ZU1pblszXSA9PSBudWxsID8gMSA6IHByb3AudmFsdWVNaW5bM107XG4gICAgICAgICAgdmFyIGEyID0gcHJvcC52YWx1ZU1heFszXSA9PSBudWxsID8gMSA6IHByb3AudmFsdWVNYXhbM107XG5cbiAgICAgICAgICB2YXIgY2xyID0gW01hdGgucm91bmQocjEgKyAocjIgLSByMSkgKiBwZXJjZW50KSwgTWF0aC5yb3VuZChnMSArIChnMiAtIGcxKSAqIHBlcmNlbnQpLCBNYXRoLnJvdW5kKGIxICsgKGIyIC0gYjEpICogcGVyY2VudCksIE1hdGgucm91bmQoYTEgKyAoYTIgLSBhMSkgKiBwZXJjZW50KV07XG5cbiAgICAgICAgICBmbGF0UHJvcCA9IHsgLy8gY29sb3VycyBhcmUgc2ltcGxlLCBzbyBqdXN0IGNyZWF0ZSB0aGUgZmxhdCBwcm9wZXJ0eSBpbnN0ZWFkIG9mIGV4cGVuc2l2ZSBzdHJpbmcgcGFyc2luZ1xuICAgICAgICAgICAgYnlwYXNzOiBwcm9wLmJ5cGFzcywgLy8gd2UncmUgYSBieXBhc3MgaWYgdGhlIG1hcHBpbmcgcHJvcGVydHkgaXMgYSBieXBhc3NcbiAgICAgICAgICAgIG5hbWU6IHByb3AubmFtZSxcbiAgICAgICAgICAgIHZhbHVlOiBjbHIsXG4gICAgICAgICAgICBzdHJWYWx1ZTogJ3JnYignICsgY2xyWzBdICsgJywgJyArIGNsclsxXSArICcsICcgKyBjbHJbMl0gKyAnKSdcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUubnVtYmVyKSB7XG4gICAgICAgICAgdmFyIGNhbGNWYWx1ZSA9IHByb3AudmFsdWVNaW4gKyAocHJvcC52YWx1ZU1heCAtIHByb3AudmFsdWVNaW4pICogcGVyY2VudDtcbiAgICAgICAgICBmbGF0UHJvcCA9IHRoaXMucGFyc2UocHJvcC5uYW1lLCBjYWxjVmFsdWUsIHByb3AuYnlwYXNzLCBmbGF0UHJvcE1hcHBpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gY2FuIG9ubHkgbWFwIHRvIGNvbG91cnMgYW5kIG51bWJlcnNcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZmxhdFByb3ApIHtcbiAgICAgICAgICAvLyBpZiB3ZSBjYW4ndCBmbGF0dGVuIHRoZSBwcm9wZXJ0eSwgdGhlbiB1c2UgdGhlIG9yaWdQcm9wIHNvIHdlIHN0aWxsIGtlZXAgdGhlIG1hcHBpbmcgaXRzZWxmXG4gICAgICAgICAgZmxhdFByb3AgPSB0aGlzLnBhcnNlKHByb3AubmFtZSwgb3JpZ1Byb3Auc3RyVmFsdWUsIHByb3AuYnlwYXNzLCBmbGF0UHJvcE1hcHBpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFmbGF0UHJvcCkge1xuICAgICAgICAgIHByaW50TWFwcGluZ0VycigpO1xuICAgICAgICB9XG4gICAgICAgIGZsYXRQcm9wLm1hcHBpbmcgPSBwcm9wOyAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBtYXBwaW5nXG4gICAgICAgIHByb3AgPSBmbGF0UHJvcDsgLy8gdGhlIGZsYXR0ZW5lZCAobWFwcGVkKSBwcm9wZXJ0eSBpcyB0aGUgb25lIHdlIHdhbnRcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIC8vIGRpcmVjdCBtYXBwaW5nXG4gICAgY2FzZSB0eXBlcy5kYXRhOlxuICAgICAge1xuICAgICAgICAvLyBmbGF0dGVuIHRoZSBmaWVsZCAoZS5nLiBkYXRhLmZvby5iYXIpXG4gICAgICAgIHZhciBfZmllbGRzID0gcHJvcC5maWVsZC5zcGxpdCgnLicpO1xuICAgICAgICB2YXIgX2ZpZWxkVmFsMiA9IF9wLmRhdGE7XG5cbiAgICAgICAgaWYgKF9maWVsZFZhbDIpIHtcbiAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgX2ZpZWxkcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBfZmllbGQgPSBfZmllbGRzW19pXTtcbiAgICAgICAgICAgIF9maWVsZFZhbDIgPSBfZmllbGRWYWwyW19maWVsZF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZmxhdFByb3AgPSB0aGlzLnBhcnNlKHByb3AubmFtZSwgX2ZpZWxkVmFsMiwgcHJvcC5ieXBhc3MsIGZsYXRQcm9wTWFwcGluZyk7XG5cbiAgICAgICAgaWYgKCFmbGF0UHJvcCkge1xuICAgICAgICAgIC8vIGlmIHdlIGNhbid0IGZsYXR0ZW4gdGhlIHByb3BlcnR5LCB0aGVuIHVzZSB0aGUgb3JpZ1Byb3Agc28gd2Ugc3RpbGwga2VlcCB0aGUgbWFwcGluZyBpdHNlbGZcbiAgICAgICAgICB2YXIgZmxhdFByb3BWYWwgPSBvcmlnUHJvcCA/IG9yaWdQcm9wLnN0clZhbHVlIDogJyc7XG5cbiAgICAgICAgICBmbGF0UHJvcCA9IHRoaXMucGFyc2UocHJvcC5uYW1lLCBmbGF0UHJvcFZhbCwgcHJvcC5ieXBhc3MsIGZsYXRQcm9wTWFwcGluZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWZsYXRQcm9wKSB7XG4gICAgICAgICAgcHJpbnRNYXBwaW5nRXJyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZmxhdFByb3AubWFwcGluZyA9IHByb3A7IC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIG1hcHBpbmdcbiAgICAgICAgcHJvcCA9IGZsYXRQcm9wOyAvLyB0aGUgZmxhdHRlbmVkIChtYXBwZWQpIHByb3BlcnR5IGlzIHRoZSBvbmUgd2Ugd2FudFxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSB0eXBlcy5mbjpcbiAgICAgIHtcbiAgICAgICAgdmFyIGZuID0gcHJvcC52YWx1ZTtcbiAgICAgICAgdmFyIGZuUmV0VmFsID0gZm4oZWxlKTtcblxuICAgICAgICBmbGF0UHJvcCA9IHRoaXMucGFyc2UocHJvcC5uYW1lLCBmblJldFZhbCwgcHJvcC5ieXBhc3MsIGZsYXRQcm9wTWFwcGluZyk7XG4gICAgICAgIGZsYXRQcm9wLm1hcHBpbmcgPSBwcm9wOyAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBtYXBwaW5nXG4gICAgICAgIHByb3AgPSBmbGF0UHJvcDsgLy8gdGhlIGZsYXR0ZW5lZCAobWFwcGVkKSBwcm9wZXJ0eSBpcyB0aGUgb25lIHdlIHdhbnRcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgYnJlYWs7IC8vIGp1c3Qgc2V0IHRoZSBwcm9wZXJ0eVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTsgLy8gbm90IGEgdmFsaWQgbWFwcGluZ1xuICB9XG5cbiAgLy8gaWYgdGhlIHByb3BlcnR5IGlzIGEgYnlwYXNzIHByb3BlcnR5LCB0aGVuIGxpbmsgdGhlIHJlc3VsdGFudCBwcm9wZXJ0eSB0byB0aGUgb3JpZ2luYWwgb25lXG4gIGlmIChwcm9wSXNCeXBhc3MpIHtcbiAgICBpZiAob3JpZ1Byb3BJc0J5cGFzcykge1xuICAgICAgLy8gdGhlbiB0aGlzIGJ5cGFzcyBvdmVycmlkZXMgdGhlIGV4aXN0aW5nIG9uZVxuICAgICAgcHJvcC5ieXBhc3NlZCA9IG9yaWdQcm9wLmJ5cGFzc2VkOyAvLyBzdGVhbCBieXBhc3NlZCBwcm9wIGZyb20gb2xkIGJ5cGFzc1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0aGVuIGxpbmsgdGhlIG9yaWcgcHJvcCB0byB0aGUgbmV3IGJ5cGFzc1xuICAgICAgcHJvcC5ieXBhc3NlZCA9IG9yaWdQcm9wO1xuICAgIH1cblxuICAgIHN0eWxlW3Byb3AubmFtZV0gPSBwcm9wOyAvLyBhbmQgc2V0XG4gIH0gZWxzZSB7XG4gICAgLy8gcHJvcCBpcyBub3QgYnlwYXNzXG4gICAgaWYgKG9yaWdQcm9wSXNCeXBhc3MpIHtcbiAgICAgIC8vIHRoZW4ga2VlcCB0aGUgb3JpZyBwcm9wIChzaW5jZSBpdCdzIGEgYnlwYXNzKSBhbmQgbGluayB0byB0aGUgbmV3IHByb3BcbiAgICAgIG9yaWdQcm9wLmJ5cGFzc2VkID0gcHJvcDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdGhlbiBqdXN0IHJlcGxhY2UgdGhlIG9sZCBwcm9wIHdpdGggdGhlIG5ldyBvbmVcbiAgICAgIHN0eWxlW3Byb3AubmFtZV0gPSBwcm9wO1xuICAgIH1cbiAgfVxuXG4gIGNoZWNrWk9yZGVyKCk7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5zdHlmbi5jbGVhbkVsZW1lbnRzID0gZnVuY3Rpb24gKGVsZXMsIGtlZXBCeXBhc3Nlcykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBwcm9wcyA9IHNlbGYucHJvcGVydGllcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlID0gZWxlc1tpXTtcblxuICAgIGlmICgha2VlcEJ5cGFzc2VzKSB7XG4gICAgICBlbGUuX3ByaXZhdGUuc3R5bGUgPSB7fTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0eWxlID0gZWxlLl9wcml2YXRlLnN0eWxlO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHByb3BzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBwcm9wID0gcHJvcHNbal07XG4gICAgICAgIHZhciBlbGVQcm9wID0gc3R5bGVbcHJvcC5uYW1lXTtcblxuICAgICAgICBpZiAoZWxlUHJvcCkge1xuICAgICAgICAgIGlmIChlbGVQcm9wLmJ5cGFzcykge1xuICAgICAgICAgICAgZWxlUHJvcC5ieXBhc3NlZCA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0eWxlW3Byb3AubmFtZV0gPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLy8gdXBkYXRlcyB0aGUgdmlzdWFsIHN0eWxlIGZvciBhbGwgZWxlbWVudHMgKHVzZWZ1bCBmb3IgbWFudWFsIHN0eWxlIG1vZGlmaWNhdGlvbiBhZnRlciBpbml0KVxuc3R5Zm4udXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICB2YXIgZWxlcyA9IGN5Lm11dGFibGVFbGVtZW50cygpO1xuXG4gIGVsZXMudXBkYXRlU3R5bGUoKTtcbn07XG5cbi8vIGp1c3QgdXBkYXRlIHRoZSBmdW5jdGlvbmFsIHByb3BlcnRpZXMgKGkuZS4gbWFwcGluZ3MpIGluIHRoZSBlbGVtZW50cydcbi8vIHN0eWxlcyAobGVzcyBleHBlbnNpdmUgdGhhbiByZWNhbGN1bGF0aW9uKVxuc3R5Zm4udXBkYXRlTWFwcGVycyA9IGZ1bmN0aW9uIChlbGVzKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgdmFyIHVwZGF0ZWRFbGVzID0gY3kuY29sbGVjdGlvbigpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgIC8vIGZvciBlYWNoIGVsZVxuICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgIHZhciBzdHlsZSA9IGVsZS5fcHJpdmF0ZS5zdHlsZTtcbiAgICB2YXIgdXBkYXRlZEVsZSA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZWxmLnByb3BlcnRpZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIC8vIGZvciBlYWNoIHByb3BcbiAgICAgIHZhciBwcm9wID0gc2VsZi5wcm9wZXJ0aWVzW2pdO1xuICAgICAgdmFyIHByb3BJblN0eWxlID0gc3R5bGVbcHJvcC5uYW1lXTtcblxuICAgICAgaWYgKHByb3BJblN0eWxlICYmIHByb3BJblN0eWxlLm1hcHBpbmcpIHtcbiAgICAgICAgdmFyIG1hcHBpbmcgPSBwcm9wSW5TdHlsZS5tYXBwaW5nO1xuXG4gICAgICAgIHRoaXMuYXBwbHlQYXJzZWRQcm9wZXJ0eShlbGUsIG1hcHBpbmcpOyAvLyByZWFwcGx5IHRoZSBtYXBwaW5nIHByb3BlcnR5XG5cbiAgICAgICAgdXBkYXRlZEVsZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHVwZGF0ZWRFbGUpIHtcbiAgICAgIHRoaXMudXBkYXRlU3R5bGVIaW50cyhlbGUpO1xuXG4gICAgICB1cGRhdGVkRWxlcy5tZXJnZShlbGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1cGRhdGVkRWxlcztcbn07XG5cbi8vIGRpZmZQcm9wcyA6IHsgbmFtZSA9PiB7IHByZXYsIG5leHQgfSB9XG5zdHlmbi51cGRhdGVUcmFuc2l0aW9ucyA9IGZ1bmN0aW9uIChlbGUsIGRpZmZQcm9wcywgaXNCeXBhc3MpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciBwcm9wcyA9IGVsZS5wc3R5bGUoJ3RyYW5zaXRpb24tcHJvcGVydHknKS52YWx1ZTtcbiAgdmFyIGR1cmF0aW9uID0gZWxlLnBzdHlsZSgndHJhbnNpdGlvbi1kdXJhdGlvbicpLnBmVmFsdWU7XG4gIHZhciBkZWxheSA9IGVsZS5wc3R5bGUoJ3RyYW5zaXRpb24tZGVsYXknKS5wZlZhbHVlO1xuXG4gIGlmIChwcm9wcy5sZW5ndGggPiAwICYmIGR1cmF0aW9uID4gMCkge1xuXG4gICAgdmFyIHN0eWxlID0ge307XG5cbiAgICAvLyBidWlsZCB1cCB0aGUgc3R5bGUgdG8gYW5pbWF0ZSB0b3dhcmRzXG4gICAgdmFyIGFueVByZXYgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgdmFyIHN0eVByb3AgPSBlbGUucHN0eWxlKHByb3ApO1xuICAgICAgdmFyIGRpZmZQcm9wID0gZGlmZlByb3BzW3Byb3BdO1xuXG4gICAgICBpZiAoIWRpZmZQcm9wKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJldlByb3AgPSBkaWZmUHJvcC5wcmV2O1xuICAgICAgdmFyIGZyb21Qcm9wID0gcHJldlByb3A7XG4gICAgICB2YXIgdG9Qcm9wID0gZGlmZlByb3AubmV4dCAhPSBudWxsID8gZGlmZlByb3AubmV4dCA6IHN0eVByb3A7XG4gICAgICB2YXIgZGlmZiA9IGZhbHNlO1xuICAgICAgdmFyIGluaXRWYWwgPSB2b2lkIDA7XG4gICAgICB2YXIgaW5pdER0ID0gMC4wMDAwMDE7IC8vIGRlbHRhIHRpbWUgJSB2YWx1ZSBmb3IgaW5pdFZhbCAoYWxsb3dzIGFuaW1hdGluZyBvdXQgb2YgaW5pdCB6ZXJvIG9wYWNpdHkpXG5cbiAgICAgIGlmICghZnJvbVByb3ApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGNvbnNpZGVyIHB4IHZhbHVlc1xuICAgICAgaWYgKGlzLm51bWJlcihmcm9tUHJvcC5wZlZhbHVlKSAmJiBpcy5udW1iZXIodG9Qcm9wLnBmVmFsdWUpKSB7XG4gICAgICAgIGRpZmYgPSB0b1Byb3AucGZWYWx1ZSAtIGZyb21Qcm9wLnBmVmFsdWU7IC8vIG5vbnplcm8gaXMgdHJ1dGh5XG4gICAgICAgIGluaXRWYWwgPSBmcm9tUHJvcC5wZlZhbHVlICsgaW5pdER0ICogZGlmZjtcblxuICAgICAgICAvLyBjb25zaWRlciBudW1lcmljYWwgdmFsdWVzXG4gICAgICB9IGVsc2UgaWYgKGlzLm51bWJlcihmcm9tUHJvcC52YWx1ZSkgJiYgaXMubnVtYmVyKHRvUHJvcC52YWx1ZSkpIHtcbiAgICAgICAgZGlmZiA9IHRvUHJvcC52YWx1ZSAtIGZyb21Qcm9wLnZhbHVlOyAvLyBub256ZXJvIGlzIHRydXRoeVxuICAgICAgICBpbml0VmFsID0gZnJvbVByb3AudmFsdWUgKyBpbml0RHQgKiBkaWZmO1xuXG4gICAgICAgIC8vIGNvbnNpZGVyIGNvbG91ciB2YWx1ZXNcbiAgICAgIH0gZWxzZSBpZiAoaXMuYXJyYXkoZnJvbVByb3AudmFsdWUpICYmIGlzLmFycmF5KHRvUHJvcC52YWx1ZSkpIHtcbiAgICAgICAgZGlmZiA9IGZyb21Qcm9wLnZhbHVlWzBdICE9PSB0b1Byb3AudmFsdWVbMF0gfHwgZnJvbVByb3AudmFsdWVbMV0gIT09IHRvUHJvcC52YWx1ZVsxXSB8fCBmcm9tUHJvcC52YWx1ZVsyXSAhPT0gdG9Qcm9wLnZhbHVlWzJdO1xuXG4gICAgICAgIGluaXRWYWwgPSBmcm9tUHJvcC5zdHJWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gdGhlIHByZXZpb3VzIHZhbHVlIGlzIGdvb2QgZm9yIGFuIGFuaW1hdGlvbiBvbmx5IGlmIGl0J3MgZGlmZmVyZW50XG4gICAgICBpZiAoZGlmZikge1xuICAgICAgICBzdHlsZVtwcm9wXSA9IHRvUHJvcC5zdHJWYWx1ZTsgLy8gdG8gdmFsXG4gICAgICAgIHRoaXMuYXBwbHlCeXBhc3MoZWxlLCBwcm9wLCBpbml0VmFsKTsgLy8gZnJvbSB2YWxcbiAgICAgICAgYW55UHJldiA9IHRydWU7XG4gICAgICB9XG4gICAgfSAvLyBlbmQgaWYgcHJvcHMgYWxsb3cgYW5pXG5cbiAgICAvLyBjYW4ndCB0cmFuc2l0aW9uIGlmIHRoZXJlJ3Mgbm90aGluZyBwcmV2aW91cyB0byB0cmFuc2l0aW9uIGZyb21cbiAgICBpZiAoIWFueVByZXYpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBfcC50cmFuc2l0aW9uaW5nID0gdHJ1ZTtcblxuICAgIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICBpZiAoZGVsYXkgPiAwKSB7XG4gICAgICAgIGVsZS5kZWxheUFuaW1hdGlvbihkZWxheSkucGxheSgpLnByb21pc2UoKS50aGVuKHJlc29sdmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfVxuICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGVsZS5hbmltYXRpb24oe1xuICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgICAgZWFzaW5nOiBlbGUucHN0eWxlKCd0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbicpLnZhbHVlLFxuICAgICAgICBxdWV1ZTogZmFsc2VcbiAgICAgIH0pLnBsYXkoKS5wcm9taXNlKCk7XG4gICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBpZiggIWlzQnlwYXNzICl7XG4gICAgICBzZWxmLnJlbW92ZUJ5cGFzc2VzKGVsZSwgcHJvcHMpO1xuICAgICAgZWxlLmVtaXRBbmROb3RpZnkoJ3N0eWxlJyk7XG4gICAgICAvLyB9XG5cbiAgICAgIF9wLnRyYW5zaXRpb25pbmcgPSBmYWxzZTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChfcC50cmFuc2l0aW9uaW5nKSB7XG4gICAgdGhpcy5yZW1vdmVCeXBhc3NlcyhlbGUsIHByb3BzKTtcbiAgICBlbGUuZW1pdEFuZE5vdGlmeSgnc3R5bGUnKTtcblxuICAgIF9wLnRyYW5zaXRpb25pbmcgPSBmYWxzZTtcbiAgfVxufTtcblxuc3R5Zm4uY2hlY2taT3JkZXJUcmlnZ2VyID0gZnVuY3Rpb24gKGVsZSwgbmFtZSwgZnJvbVZhbHVlLCB0b1ZhbHVlKSB7XG4gIHZhciBwcm9wID0gdGhpcy5wcm9wZXJ0aWVzW25hbWVdO1xuXG4gIGlmIChwcm9wLnRyaWdnZXJzWk9yZGVyICE9IG51bGwgJiYgKGZyb21WYWx1ZSA9PSBudWxsIHx8IHByb3AudHJpZ2dlcnNaT3JkZXIoZnJvbVZhbHVlLCB0b1ZhbHVlKSkpIHtcbiAgICB0aGlzLl9wcml2YXRlLmN5Lm5vdGlmeSh7XG4gICAgICB0eXBlOiAnem9yZGVyJyxcbiAgICAgIGVsZXM6IGVsZVxuICAgIH0pO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN0eWZuO1xuXG4vKioqLyB9KSxcbi8qIDg2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBpcyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBzdHlmbiA9IHt9O1xuXG4vLyBieXBhc3NlcyBhcmUgYXBwbGllZCB0byBhbiBleGlzdGluZyBzdHlsZSBvbiBhbiBlbGVtZW50LCBhbmQganVzdCB0YWNrZWQgb24gdGVtcG9yYXJpbHlcbi8vIHJldHVybnMgdHJ1ZSBpZmYgYXBwbGljYXRpb24gd2FzIHN1Y2Nlc3NmdWwgZm9yIGF0IGxlYXN0IDEgc3BlY2lmaWVkIHByb3BlcnR5XG5zdHlmbi5hcHBseUJ5cGFzcyA9IGZ1bmN0aW9uIChlbGVzLCBuYW1lLCB2YWx1ZSwgdXBkYXRlVHJhbnNpdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcHJvcHMgPSBbXTtcbiAgdmFyIGlzQnlwYXNzID0gdHJ1ZTtcblxuICAvLyBwdXQgYWxsIHRoZSBwcm9wZXJ0aWVzIChjYW4gc3BlY2lmeSBvbmUgb3IgbWFueSkgaW4gYW4gYXJyYXkgYWZ0ZXIgcGFyc2luZyB0aGVtXG4gIGlmIChuYW1lID09PSAnKicgfHwgbmFtZSA9PT0gJyoqJykge1xuICAgIC8vIGFwcGx5IHRvIGFsbCBwcm9wZXJ0eSBuYW1lc1xuXG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwcm9wID0gc2VsZi5wcm9wZXJ0aWVzW2ldO1xuICAgICAgICB2YXIgX25hbWUgPSBwcm9wLm5hbWU7XG5cbiAgICAgICAgdmFyIHBhcnNlZFByb3AgPSB0aGlzLnBhcnNlKF9uYW1lLCB2YWx1ZSwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKHBhcnNlZFByb3ApIHtcbiAgICAgICAgICBwcm9wcy5wdXNoKHBhcnNlZFByb3ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzLnN0cmluZyhuYW1lKSkge1xuICAgIC8vIHRoZW4gcGFyc2UgdGhlIHNpbmdsZSBwcm9wZXJ0eVxuICAgIHZhciBfcGFyc2VkUHJvcCA9IHRoaXMucGFyc2UobmFtZSwgdmFsdWUsIHRydWUpO1xuXG4gICAgaWYgKF9wYXJzZWRQcm9wKSB7XG4gICAgICBwcm9wcy5wdXNoKF9wYXJzZWRQcm9wKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXMucGxhaW5PYmplY3QobmFtZSkpIHtcbiAgICAvLyB0aGVuIHBhcnNlIGVhY2ggcHJvcGVydHlcbiAgICB2YXIgc3BlY2lmaWVkUHJvcHMgPSBuYW1lO1xuICAgIHVwZGF0ZVRyYW5zaXRpb25zID0gdmFsdWU7XG5cbiAgICB2YXIgbmFtZXMgPSBPYmplY3Qua2V5cyhzcGVjaWZpZWRQcm9wcyk7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbmFtZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX25hbWUyID0gbmFtZXNbX2ldO1xuICAgICAgdmFyIF9wcm9wID0gc2VsZi5wcm9wZXJ0aWVzW19uYW1lMl07XG4gICAgICB2YXIgX3ZhbHVlID0gc3BlY2lmaWVkUHJvcHNbX25hbWUyXTtcblxuICAgICAgaWYgKF92YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHRyeSBjYW1lbCBjYXNlIG5hbWUgdG9vXG4gICAgICAgIF92YWx1ZSA9IHNwZWNpZmllZFByb3BzW3V0aWwuZGFzaDJjYW1lbChfbmFtZTIpXTtcbiAgICAgIH1cblxuICAgICAgaWYgKF92YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBfcGFyc2VkUHJvcDIgPSB0aGlzLnBhcnNlKF9uYW1lMiwgX3ZhbHVlLCB0cnVlKTtcblxuICAgICAgICBpZiAoX3BhcnNlZFByb3AyKSB7XG4gICAgICAgICAgcHJvcHMucHVzaChfcGFyc2VkUHJvcDIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGNhbid0IGRvIGFueXRoaW5nIHdpdGhvdXQgd2VsbCBkZWZpbmVkIHByb3BlcnRpZXNcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyB3ZSd2ZSBmYWlsZWQgaWYgdGhlcmUgYXJlIG5vIHZhbGlkIHByb3BlcnRpZXNcbiAgaWYgKHByb3BzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIG5vdywgYXBwbHkgdGhlIGJ5cGFzcyBwcm9wZXJ0aWVzIG9uIHRoZSBlbGVtZW50c1xuICB2YXIgcmV0ID0gZmFsc2U7IC8vIHJldHVybiB0cnVlIGlmIGF0IGxlYXN0IG9uZSBzdWNjZXNmdWwgYnlwYXNzIGFwcGxpZWRcbiAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgZWxlcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgLy8gZm9yIGVhY2ggZWxlXG4gICAgdmFyIGVsZSA9IGVsZXNbX2kyXTtcbiAgICB2YXIgZGlmZlByb3BzID0ge307XG4gICAgdmFyIGRpZmZQcm9wID0gdm9pZCAwO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBwcm9wcy5sZW5ndGg7IGorKykge1xuICAgICAgLy8gZm9yIGVhY2ggcHJvcFxuICAgICAgdmFyIF9wcm9wMiA9IHByb3BzW2pdO1xuXG4gICAgICBpZiAodXBkYXRlVHJhbnNpdGlvbnMpIHtcbiAgICAgICAgdmFyIHByZXZQcm9wID0gZWxlLnBzdHlsZShfcHJvcDIubmFtZSk7XG4gICAgICAgIGRpZmZQcm9wID0gZGlmZlByb3BzW19wcm9wMi5uYW1lXSA9IHsgcHJldjogcHJldlByb3AgfTtcbiAgICAgIH1cblxuICAgICAgcmV0ID0gdGhpcy5hcHBseVBhcnNlZFByb3BlcnR5KGVsZSwgX3Byb3AyKSB8fCByZXQ7XG5cbiAgICAgIGlmICh1cGRhdGVUcmFuc2l0aW9ucykge1xuICAgICAgICBkaWZmUHJvcC5uZXh0ID0gZWxlLnBzdHlsZShfcHJvcDIubmFtZSk7XG4gICAgICB9XG4gICAgfSAvLyBmb3IgcHJvcHNcblxuICAgIGlmIChyZXQpIHtcbiAgICAgIHRoaXMudXBkYXRlU3R5bGVIaW50cyhlbGUpO1xuICAgIH1cblxuICAgIGlmICh1cGRhdGVUcmFuc2l0aW9ucykge1xuICAgICAgdGhpcy51cGRhdGVUcmFuc2l0aW9ucyhlbGUsIGRpZmZQcm9wcywgaXNCeXBhc3MpO1xuICAgIH1cbiAgfSAvLyBmb3IgZWxlc1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG4vLyBvbmx5IHVzZWZ1bCBpbiBzcGVjaWZpYyBjYXNlcyBsaWtlIGFuaW1hdGlvblxuc3R5Zm4ub3ZlcnJpZGVCeXBhc3MgPSBmdW5jdGlvbiAoZWxlcywgbmFtZSwgdmFsdWUpIHtcbiAgbmFtZSA9IHV0aWwuY2FtZWwyZGFzaChuYW1lKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICB2YXIgcHJvcCA9IGVsZS5fcHJpdmF0ZS5zdHlsZVtuYW1lXTtcbiAgICB2YXIgdHlwZSA9IHRoaXMucHJvcGVydGllc1tuYW1lXS50eXBlO1xuICAgIHZhciBpc0NvbG9yID0gdHlwZS5jb2xvcjtcbiAgICB2YXIgaXNNdWx0aSA9IHR5cGUubXV0aXBsZTtcblxuICAgIGlmICghcHJvcCB8fCAhcHJvcC5ieXBhc3MpIHtcbiAgICAgIC8vIG5lZWQgYSBieXBhc3MgaWYgb25lIGRvZXNuJ3QgZXhpc3RcbiAgICAgIHRoaXMuYXBwbHlCeXBhc3MoZWxlLCBuYW1lLCB2YWx1ZSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgb2xkVmFsdWUgPSBwcm9wLnBmVmFsdWUgIT0gbnVsbCA/IHByb3AucGZWYWx1ZSA6IHByb3AudmFsdWU7XG5cbiAgICBwcm9wLnZhbHVlID0gdmFsdWU7XG5cbiAgICBpZiAocHJvcC5wZlZhbHVlICE9IG51bGwpIHtcbiAgICAgIHByb3AucGZWYWx1ZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIGlmIChpc0NvbG9yKSB7XG4gICAgICBwcm9wLnN0clZhbHVlID0gJ3JnYignICsgdmFsdWUuam9pbignLCcpICsgJyknO1xuICAgIH0gZWxzZSBpZiAoaXNNdWx0aSkge1xuICAgICAgcHJvcC5zdHJWYWx1ZSA9IHZhbHVlLmpvaW4oJyAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvcC5zdHJWYWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgfVxuXG4gICAgdGhpcy5jaGVja1pPcmRlclRyaWdnZXIoZWxlLCBuYW1lLCBvbGRWYWx1ZSwgdmFsdWUpO1xuICB9XG59O1xuXG5zdHlmbi5yZW1vdmVBbGxCeXBhc3NlcyA9IGZ1bmN0aW9uIChlbGVzLCB1cGRhdGVUcmFuc2l0aW9ucykge1xuICByZXR1cm4gdGhpcy5yZW1vdmVCeXBhc3NlcyhlbGVzLCB0aGlzLnByb3BlcnR5TmFtZXMsIHVwZGF0ZVRyYW5zaXRpb25zKTtcbn07XG5cbnN0eWZuLnJlbW92ZUJ5cGFzc2VzID0gZnVuY3Rpb24gKGVsZXMsIHByb3BzLCB1cGRhdGVUcmFuc2l0aW9ucykge1xuICB2YXIgaXNCeXBhc3MgPSB0cnVlO1xuXG4gIGZvciAodmFyIGogPSAwOyBqIDwgZWxlcy5sZW5ndGg7IGorKykge1xuICAgIHZhciBlbGUgPSBlbGVzW2pdO1xuICAgIHZhciBkaWZmUHJvcHMgPSB7fTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuYW1lID0gcHJvcHNbaV07XG4gICAgICB2YXIgcHJvcCA9IHRoaXMucHJvcGVydGllc1tuYW1lXTtcbiAgICAgIHZhciBwcmV2UHJvcCA9IGVsZS5wc3R5bGUocHJvcC5uYW1lKTtcblxuICAgICAgaWYgKCFwcmV2UHJvcCB8fCAhcHJldlByb3AuYnlwYXNzKSB7XG4gICAgICAgIC8vIGlmIGEgYnlwYXNzIGRvZXNuJ3QgZXhpc3QgZm9yIHRoZSBwcm9wLCBub3RoaW5nIG5lZWRzIHRvIGJlIHJlbW92ZWRcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZSA9ICcnOyAvLyBlbXB0eSA9PiByZW1vdmUgYnlwYXNzXG4gICAgICB2YXIgcGFyc2VkUHJvcCA9IHRoaXMucGFyc2UobmFtZSwgdmFsdWUsIHRydWUpO1xuICAgICAgdmFyIGRpZmZQcm9wID0gZGlmZlByb3BzW3Byb3AubmFtZV0gPSB7IHByZXY6IHByZXZQcm9wIH07XG5cbiAgICAgIHRoaXMuYXBwbHlQYXJzZWRQcm9wZXJ0eShlbGUsIHBhcnNlZFByb3ApO1xuXG4gICAgICBkaWZmUHJvcC5uZXh0ID0gZWxlLnBzdHlsZShwcm9wLm5hbWUpO1xuICAgIH0gLy8gZm9yIHByb3BzXG5cbiAgICB0aGlzLnVwZGF0ZVN0eWxlSGludHMoZWxlKTtcblxuICAgIGlmICh1cGRhdGVUcmFuc2l0aW9ucykge1xuICAgICAgdGhpcy51cGRhdGVUcmFuc2l0aW9ucyhlbGUsIGRpZmZQcm9wcywgaXNCeXBhc3MpO1xuICAgIH1cbiAgfSAvLyBmb3IgZWxlc1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdHlmbjtcblxuLyoqKi8gfSksXG4vKiA4NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgd2luZG93ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIHN0eWZuID0ge307XG5cbi8vIGdldHMgd2hhdCBhbiBlbSBzaXplIGNvcnJlc3BvbmRzIHRvIGluIHBpeGVscyByZWxhdGl2ZSB0byBhIGRvbSBlbGVtZW50XG5zdHlmbi5nZXRFbVNpemVJblBpeGVscyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHB4ID0gdGhpcy5jb250YWluZXJDc3MoJ2ZvbnQtc2l6ZScpO1xuXG4gIGlmIChweCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQocHgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAxOyAvLyBmb3IgaGVhZGxlc3NcbiAgfVxufTtcblxuLy8gZ2V0cyBjc3MgcHJvcGVydHkgZnJvbSB0aGUgY29yZSBjb250YWluZXJcbnN0eWZuLmNvbnRhaW5lckNzcyA9IGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICB2YXIgZG9tRWxlbWVudCA9IGN5LmNvbnRhaW5lcigpO1xuXG4gIGlmICh3aW5kb3cgJiYgZG9tRWxlbWVudCAmJiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSkge1xuICAgIHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb21FbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BOYW1lKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdHlmbjtcblxuLyoqKi8gfSksXG4vKiA4OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG52YXIgaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgc3R5Zm4gPSB7fTtcblxuLy8gZ2V0cyB0aGUgcmVuZGVyZWQgc3R5bGUgZm9yIGFuIGVsZW1lbnRcbnN0eWZuLmdldFJlbmRlcmVkU3R5bGUgPSBmdW5jdGlvbiAoZWxlLCBwcm9wKSB7XG4gIGlmIChwcm9wKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U3R5bGVQcm9wZXJ0eVZhbHVlKGVsZSwgcHJvcCwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UmF3U3R5bGUoZWxlLCB0cnVlKTtcbiAgfVxufTtcblxuLy8gZ2V0cyB0aGUgcmF3IHN0eWxlIGZvciBhbiBlbGVtZW50XG5zdHlmbi5nZXRSYXdTdHlsZSA9IGZ1bmN0aW9uIChlbGUsIGlzUmVuZGVyZWRWYWwpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGVsZSA9IGVsZVswXTsgLy8gaW5zdXJlIGl0J3MgYW4gZWxlbWVudFxuXG4gIGlmIChlbGUpIHtcbiAgICB2YXIgcnN0eWxlID0ge307XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYucHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHByb3AgPSBzZWxmLnByb3BlcnRpZXNbaV07XG4gICAgICB2YXIgdmFsID0gc2VsZi5nZXRTdHlsZVByb3BlcnR5VmFsdWUoZWxlLCBwcm9wLm5hbWUsIGlzUmVuZGVyZWRWYWwpO1xuXG4gICAgICBpZiAodmFsICE9IG51bGwpIHtcbiAgICAgICAgcnN0eWxlW3Byb3AubmFtZV0gPSB2YWw7XG4gICAgICAgIHJzdHlsZVt1dGlsLmRhc2gyY2FtZWwocHJvcC5uYW1lKV0gPSB2YWw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJzdHlsZTtcbiAgfVxufTtcblxuc3R5Zm4uZ2V0SW5kZXhlZFN0eWxlID0gZnVuY3Rpb24gKGVsZSwgcHJvcGVydHksIHN1YnByb3BlcnR5LCBpbmRleCkge1xuICB2YXIgcHN0eWxlID0gZWxlLnBzdHlsZShwcm9wZXJ0eSlbc3VicHJvcGVydHldW2luZGV4XTtcbiAgcmV0dXJuIHBzdHlsZSAhPSBudWxsID8gcHN0eWxlIDogZWxlLmN5KCkuc3R5bGUoKS5nZXREZWZhdWx0UHJvcGVydHkocHJvcGVydHkpW3N1YnByb3BlcnR5XVswXTtcbn07XG5cbnN0eWZuLmdldFN0eWxlUHJvcGVydHlWYWx1ZSA9IGZ1bmN0aW9uIChlbGUsIHByb3BOYW1lLCBpc1JlbmRlcmVkVmFsKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBlbGUgPSBlbGVbMF07IC8vIGluc3VyZSBpdCdzIGFuIGVsZW1lbnRcblxuICBpZiAoZWxlKSB7XG4gICAgdmFyIHByb3AgPSBzZWxmLnByb3BlcnRpZXNbcHJvcE5hbWVdO1xuXG4gICAgaWYgKHByb3AuYWxpYXMpIHtcbiAgICAgIHByb3AgPSBwcm9wLnBvaW50c1RvO1xuICAgIH1cblxuICAgIHZhciB0eXBlID0gcHJvcC50eXBlO1xuICAgIHZhciBzdHlsZVByb3AgPSBlbGUucHN0eWxlKHByb3AubmFtZSk7XG4gICAgdmFyIHpvb20gPSBlbGUuY3koKS56b29tKCk7XG5cbiAgICBpZiAoc3R5bGVQcm9wKSB7XG4gICAgICB2YXIgdW5pdHMgPSBzdHlsZVByb3AudW5pdHMgPyB0eXBlLmltcGxpY2l0VW5pdHMgfHwgJ3B4JyA6IG51bGw7XG4gICAgICB2YXIgdmFsID0gdW5pdHMgPyBbXS5jb25jYXQoc3R5bGVQcm9wLnBmVmFsdWUpLm1hcChmdW5jdGlvbiAocGZWYWx1ZSkge1xuICAgICAgICByZXR1cm4gcGZWYWx1ZSAqIChpc1JlbmRlcmVkVmFsID8gem9vbSA6IDEpICsgdW5pdHM7XG4gICAgICB9KS5qb2luKCcgJykgOiBzdHlsZVByb3Auc3RyVmFsdWU7XG5cbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICB9XG59O1xuXG5zdHlmbi5nZXRBbmltYXRpb25TdGFydFN0eWxlID0gZnVuY3Rpb24gKGVsZSwgYW5pUHJvcHMpIHtcbiAgdmFyIHJzdHlsZSA9IHt9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYW5pUHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYW5pUHJvcCA9IGFuaVByb3BzW2ldO1xuICAgIHZhciBuYW1lID0gYW5pUHJvcC5uYW1lO1xuXG4gICAgdmFyIHN0eWxlUHJvcCA9IGVsZS5wc3R5bGUobmFtZSk7XG5cbiAgICBpZiAoc3R5bGVQcm9wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHRoZW4gbWFrZSBhIHByb3Agb2YgaXRcbiAgICAgIGlmIChpcy5wbGFpbk9iamVjdChzdHlsZVByb3ApKSB7XG4gICAgICAgIHN0eWxlUHJvcCA9IHRoaXMucGFyc2UobmFtZSwgc3R5bGVQcm9wLnN0clZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0eWxlUHJvcCA9IHRoaXMucGFyc2UobmFtZSwgc3R5bGVQcm9wKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3R5bGVQcm9wKSB7XG4gICAgICByc3R5bGVbbmFtZV0gPSBzdHlsZVByb3A7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJzdHlsZTtcbn07XG5cbnN0eWZuLmdldFByb3BzTGlzdCA9IGZ1bmN0aW9uIChwcm9wc09iaikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciByc3R5bGUgPSBbXTtcbiAgdmFyIHN0eWxlID0gcHJvcHNPYmo7XG4gIHZhciBwcm9wcyA9IHNlbGYucHJvcGVydGllcztcblxuICBpZiAoc3R5bGUpIHtcbiAgICB2YXIgbmFtZXMgPSBPYmplY3Qua2V5cyhzdHlsZSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbmFtZSA9IG5hbWVzW2ldO1xuICAgICAgdmFyIHZhbCA9IHN0eWxlW25hbWVdO1xuICAgICAgdmFyIHByb3AgPSBwcm9wc1tuYW1lXSB8fCBwcm9wc1t1dGlsLmNhbWVsMmRhc2gobmFtZSldO1xuICAgICAgdmFyIHN0eWxlUHJvcCA9IHRoaXMucGFyc2UocHJvcC5uYW1lLCB2YWwpO1xuXG4gICAgICBpZiAoc3R5bGVQcm9wKSB7XG4gICAgICAgIHJzdHlsZS5wdXNoKHN0eWxlUHJvcCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJzdHlsZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gc3R5Zm47XG5cbi8qKiovIH0pLFxuLyogODkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIHN0eWZuID0ge307XG5cbnN0eWZuLmFwcGVuZEZyb21Kc29uID0gZnVuY3Rpb24gKGpzb24pIHtcbiAgdmFyIHN0eWxlID0gdGhpcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGpzb24ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY29udGV4dCA9IGpzb25baV07XG4gICAgdmFyIHNlbGVjdG9yID0gY29udGV4dC5zZWxlY3RvcjtcbiAgICB2YXIgcHJvcHMgPSBjb250ZXh0LnN0eWxlIHx8IGNvbnRleHQuY3NzO1xuICAgIHZhciBuYW1lcyA9IE9iamVjdC5rZXlzKHByb3BzKTtcblxuICAgIHN0eWxlLnNlbGVjdG9yKHNlbGVjdG9yKTsgLy8gYXBwbHkgc2VsZWN0b3JcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbmFtZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBuYW1lID0gbmFtZXNbal07XG4gICAgICB2YXIgdmFsdWUgPSBwcm9wc1tuYW1lXTtcblxuICAgICAgc3R5bGUuY3NzKG5hbWUsIHZhbHVlKTsgLy8gYXBwbHkgcHJvcGVydHlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3R5bGU7XG59O1xuXG4vLyBhY2Nlc3NpYmxlIGN5LnN0eWxlKCkgZnVuY3Rpb25cbnN0eWZuLmZyb21Kc29uID0gZnVuY3Rpb24gKGpzb24pIHtcbiAgdmFyIHN0eWxlID0gdGhpcztcblxuICBzdHlsZS5yZXNldFRvRGVmYXVsdCgpO1xuICBzdHlsZS5hcHBlbmRGcm9tSnNvbihqc29uKTtcblxuICByZXR1cm4gc3R5bGU7XG59O1xuXG4vLyBnZXQganNvbiBmcm9tIGN5LnN0eWxlKCkgYXBpXG5zdHlmbi5qc29uID0gZnVuY3Rpb24gKCkge1xuICB2YXIganNvbiA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSB0aGlzLmRlZmF1bHRMZW5ndGg7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGN4dCA9IHRoaXNbaV07XG4gICAgdmFyIHNlbGVjdG9yID0gY3h0LnNlbGVjdG9yO1xuICAgIHZhciBwcm9wcyA9IGN4dC5wcm9wZXJ0aWVzO1xuICAgIHZhciBjc3MgPSB7fTtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgcHJvcHMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBwcm9wID0gcHJvcHNbal07XG4gICAgICBjc3NbcHJvcC5uYW1lXSA9IHByb3Auc3RyVmFsdWU7XG4gICAgfVxuXG4gICAganNvbi5wdXNoKHtcbiAgICAgIHNlbGVjdG9yOiAhc2VsZWN0b3IgPyAnY29yZScgOiBzZWxlY3Rvci50b1N0cmluZygpLFxuICAgICAgc3R5bGU6IGNzc1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGpzb247XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN0eWZuO1xuXG4vKioqLyB9KSxcbi8qIDkwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbnZhciBTZWxlY3RvciA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cbnZhciBzdHlmbiA9IHt9O1xuXG5zdHlmbi5hcHBlbmRGcm9tU3RyaW5nID0gZnVuY3Rpb24gKHN0cmluZykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzdHlsZSA9IHRoaXM7XG4gIHZhciByZW1haW5pbmcgPSAnJyArIHN0cmluZztcbiAgdmFyIHNlbEFuZEJsb2NrU3RyID0gdm9pZCAwO1xuICB2YXIgYmxvY2tSZW0gPSB2b2lkIDA7XG4gIHZhciBwcm9wQW5kVmFsU3RyID0gdm9pZCAwO1xuXG4gIC8vIHJlbW92ZSBjb21tZW50cyBmcm9tIHRoZSBzdHlsZSBzdHJpbmdcbiAgcmVtYWluaW5nID0gcmVtYWluaW5nLnJlcGxhY2UoL1svXVsqXShcXHN8LikrP1sqXVsvXS9nLCAnJyk7XG5cbiAgZnVuY3Rpb24gcmVtb3ZlU2VsQW5kQmxvY2tGcm9tUmVtYWluaW5nKCkge1xuICAgIC8vIHJlbW92ZSB0aGUgcGFyc2VkIHNlbGVjdG9yIGFuZCBibG9jayBmcm9tIHRoZSByZW1haW5pbmcgdGV4dCB0byBwYXJzZVxuICAgIGlmIChyZW1haW5pbmcubGVuZ3RoID4gc2VsQW5kQmxvY2tTdHIubGVuZ3RoKSB7XG4gICAgICByZW1haW5pbmcgPSByZW1haW5pbmcuc3Vic3RyKHNlbEFuZEJsb2NrU3RyLmxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbWFpbmluZyA9ICcnO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZVByb3BBbmRWYWxGcm9tUmVtKCkge1xuICAgIC8vIHJlbW92ZSB0aGUgcGFyc2VkIHByb3BlcnR5IGFuZCB2YWx1ZSBmcm9tIHRoZSByZW1haW5pbmcgYmxvY2sgdGV4dCB0byBwYXJzZVxuICAgIGlmIChibG9ja1JlbS5sZW5ndGggPiBwcm9wQW5kVmFsU3RyLmxlbmd0aCkge1xuICAgICAgYmxvY2tSZW0gPSBibG9ja1JlbS5zdWJzdHIocHJvcEFuZFZhbFN0ci5sZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBibG9ja1JlbSA9ICcnO1xuICAgIH1cbiAgfVxuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdmFyIG5vdGhpbmdMZWZ0VG9QYXJzZSA9IHJlbWFpbmluZy5tYXRjaCgvXlxccyokLyk7XG4gICAgaWYgKG5vdGhpbmdMZWZ0VG9QYXJzZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIHNlbEFuZEJsb2NrID0gcmVtYWluaW5nLm1hdGNoKC9eXFxzKigoPzoufFxccykrPylcXHMqXFx7KCg/Oi58XFxzKSs/KVxcfS8pO1xuXG4gICAgaWYgKCFzZWxBbmRCbG9jaykge1xuICAgICAgdXRpbC5lcnJvcignSGFsdGluZyBzdHlsZXNoZWV0IHBhcnNpbmc6IFN0cmluZyBzdHlsZXNoZWV0IGNvbnRhaW5zIG1vcmUgdG8gcGFyc2UgYnV0IG5vIHNlbGVjdG9yIGFuZCBibG9jayBmb3VuZCBpbjogJyArIHJlbWFpbmluZyk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBzZWxBbmRCbG9ja1N0ciA9IHNlbEFuZEJsb2NrWzBdO1xuXG4gICAgLy8gcGFyc2UgdGhlIHNlbGVjdG9yXG4gICAgdmFyIHNlbGVjdG9yU3RyID0gc2VsQW5kQmxvY2tbMV07XG4gICAgaWYgKHNlbGVjdG9yU3RyICE9PSAnY29yZScpIHtcbiAgICAgIHZhciBzZWxlY3RvciA9IG5ldyBTZWxlY3RvcihzZWxlY3RvclN0cik7XG4gICAgICBpZiAoc2VsZWN0b3IuX3ByaXZhdGUuaW52YWxpZCkge1xuICAgICAgICB1dGlsLmVycm9yKCdTa2lwcGluZyBwYXJzaW5nIG9mIGJsb2NrOiBJbnZhbGlkIHNlbGVjdG9yIGZvdW5kIGluIHN0cmluZyBzdHlsZXNoZWV0OiAnICsgc2VsZWN0b3JTdHIpO1xuXG4gICAgICAgIC8vIHNraXAgdGhpcyBzZWxlY3RvciBhbmQgYmxvY2tcbiAgICAgICAgcmVtb3ZlU2VsQW5kQmxvY2tGcm9tUmVtYWluaW5nKCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHBhcnNlIHRoZSBibG9jayBvZiBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXNcbiAgICB2YXIgYmxvY2tTdHIgPSBzZWxBbmRCbG9ja1syXTtcbiAgICB2YXIgaW52YWxpZEJsb2NrID0gZmFsc2U7XG4gICAgYmxvY2tSZW0gPSBibG9ja1N0cjtcbiAgICB2YXIgcHJvcHMgPSBbXTtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICB2YXIgX25vdGhpbmdMZWZ0VG9QYXJzZSA9IGJsb2NrUmVtLm1hdGNoKC9eXFxzKiQvKTtcbiAgICAgIGlmIChfbm90aGluZ0xlZnRUb1BhcnNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJvcEFuZFZhbCA9IGJsb2NrUmVtLm1hdGNoKC9eXFxzKiguKz8pXFxzKjpcXHMqKC4rPylcXHMqOy8pO1xuXG4gICAgICBpZiAoIXByb3BBbmRWYWwpIHtcbiAgICAgICAgdXRpbC5lcnJvcignU2tpcHBpbmcgcGFyc2luZyBvZiBibG9jazogSW52YWxpZCBmb3JtYXR0aW5nIG9mIHN0eWxlIHByb3BlcnR5IGFuZCB2YWx1ZSBkZWZpbml0aW9ucyBmb3VuZCBpbjonICsgYmxvY2tTdHIpO1xuICAgICAgICBpbnZhbGlkQmxvY2sgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcHJvcEFuZFZhbFN0ciA9IHByb3BBbmRWYWxbMF07XG4gICAgICB2YXIgcHJvcFN0ciA9IHByb3BBbmRWYWxbMV07XG4gICAgICB2YXIgdmFsU3RyID0gcHJvcEFuZFZhbFsyXTtcblxuICAgICAgdmFyIHByb3AgPSBzZWxmLnByb3BlcnRpZXNbcHJvcFN0cl07XG4gICAgICBpZiAoIXByb3ApIHtcbiAgICAgICAgdXRpbC5lcnJvcignU2tpcHBpbmcgcHJvcGVydHk6IEludmFsaWQgcHJvcGVydHkgbmFtZSBpbjogJyArIHByb3BBbmRWYWxTdHIpO1xuXG4gICAgICAgIC8vIHNraXAgdGhpcyBwcm9wZXJ0eSBpbiB0aGUgYmxvY2tcbiAgICAgICAgcmVtb3ZlUHJvcEFuZFZhbEZyb21SZW0oKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBwYXJzZWRQcm9wID0gc3R5bGUucGFyc2UocHJvcFN0ciwgdmFsU3RyKTtcblxuICAgICAgaWYgKCFwYXJzZWRQcm9wKSB7XG4gICAgICAgIHV0aWwuZXJyb3IoJ1NraXBwaW5nIHByb3BlcnR5OiBJbnZhbGlkIHByb3BlcnR5IGRlZmluaXRpb24gaW46ICcgKyBwcm9wQW5kVmFsU3RyKTtcblxuICAgICAgICAvLyBza2lwIHRoaXMgcHJvcGVydHkgaW4gdGhlIGJsb2NrXG4gICAgICAgIHJlbW92ZVByb3BBbmRWYWxGcm9tUmVtKCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBwcm9wcy5wdXNoKHtcbiAgICAgICAgbmFtZTogcHJvcFN0cixcbiAgICAgICAgdmFsOiB2YWxTdHJcbiAgICAgIH0pO1xuICAgICAgcmVtb3ZlUHJvcEFuZFZhbEZyb21SZW0oKTtcbiAgICB9XG5cbiAgICBpZiAoaW52YWxpZEJsb2NrKSB7XG4gICAgICByZW1vdmVTZWxBbmRCbG9ja0Zyb21SZW1haW5pbmcoKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIHB1dCB0aGUgcGFyc2VkIGJsb2NrIGluIHRoZSBzdHlsZVxuICAgIHN0eWxlLnNlbGVjdG9yKHNlbGVjdG9yU3RyKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgX3Byb3AgPSBwcm9wc1tpXTtcbiAgICAgIHN0eWxlLmNzcyhfcHJvcC5uYW1lLCBfcHJvcC52YWwpO1xuICAgIH1cblxuICAgIHJlbW92ZVNlbEFuZEJsb2NrRnJvbVJlbWFpbmluZygpO1xuICB9XG5cbiAgcmV0dXJuIHN0eWxlO1xufTtcblxuc3R5Zm4uZnJvbVN0cmluZyA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgdmFyIHN0eWxlID0gdGhpcztcblxuICBzdHlsZS5yZXNldFRvRGVmYXVsdCgpO1xuICBzdHlsZS5hcHBlbmRGcm9tU3RyaW5nKHN0cmluZyk7XG5cbiAgcmV0dXJuIHN0eWxlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdHlmbjtcblxuLyoqKi8gfSksXG4vKiA5MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG52YXIgaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgc3R5Zm4gPSB7fTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgdmFyIG51bWJlciA9IHV0aWwucmVnZXgubnVtYmVyO1xuICB2YXIgcmdiYSA9IHV0aWwucmVnZXgucmdiYU5vQmFja1JlZnM7XG4gIHZhciBoc2xhID0gdXRpbC5yZWdleC5oc2xhTm9CYWNrUmVmcztcbiAgdmFyIGhleDMgPSB1dGlsLnJlZ2V4LmhleDM7XG4gIHZhciBoZXg2ID0gdXRpbC5yZWdleC5oZXg2O1xuICB2YXIgZGF0YSA9IGZ1bmN0aW9uIGRhdGEocHJlZml4KSB7XG4gICAgcmV0dXJuICdeJyArIHByZWZpeCArICdcXFxccypcXFxcKFxcXFxzKihbXFxcXHdcXFxcLl0rKVxcXFxzKlxcXFwpJCc7XG4gIH07XG4gIHZhciBtYXBEYXRhID0gZnVuY3Rpb24gbWFwRGF0YShwcmVmaXgpIHtcbiAgICB2YXIgbWFwQXJnID0gbnVtYmVyICsgJ3xcXFxcdyt8JyArIHJnYmEgKyAnfCcgKyBoc2xhICsgJ3wnICsgaGV4MyArICd8JyArIGhleDY7XG4gICAgcmV0dXJuICdeJyArIHByZWZpeCArICdcXFxccypcXFxcKChbXFxcXHdcXFxcLl0rKVxcXFxzKlxcXFwsXFxcXHMqKCcgKyBudW1iZXIgKyAnKVxcXFxzKlxcXFwsXFxcXHMqKCcgKyBudW1iZXIgKyAnKVxcXFxzKixcXFxccyooJyArIG1hcEFyZyArICcpXFxcXHMqXFxcXCxcXFxccyooJyArIG1hcEFyZyArICcpXFxcXCkkJztcbiAgfTtcbiAgdmFyIHVybFJlZ2V4ZXMgPSBbJ151cmxcXFxccypcXFxcKFxcXFxzKltcXCdcIl0/KC4rPylbXFwnXCJdP1xcXFxzKlxcXFwpJCcsICdeKG5vbmUpJCcsICdeKC4rKSQnXTtcblxuICAvLyBlYWNoIHZpc3VhbCBzdHlsZSBwcm9wZXJ0eSBoYXMgYSB0eXBlIGFuZCBuZWVkcyB0byBiZSB2YWxpZGF0ZWQgYWNjb3JkaW5nIHRvIGl0XG4gIHN0eWZuLnR5cGVzID0ge1xuICAgIHRpbWU6IHsgbnVtYmVyOiB0cnVlLCBtaW46IDAsIHVuaXRzOiAnc3xtcycsIGltcGxpY2l0VW5pdHM6ICdtcycgfSxcbiAgICBwZXJjZW50OiB7IG51bWJlcjogdHJ1ZSwgbWluOiAwLCBtYXg6IDEwMCwgdW5pdHM6ICclJywgaW1wbGljaXRVbml0czogJyUnIH0sXG4gICAgemVyb09uZU51bWJlcjogeyBudW1iZXI6IHRydWUsIG1pbjogMCwgbWF4OiAxLCB1bml0bGVzczogdHJ1ZSB9LFxuICAgIHplcm9PbmVOdW1iZXJzOiB7IG51bWJlcjogdHJ1ZSwgbWluOiAwLCBtYXg6IDEsIHVuaXRsZXNzOiB0cnVlLCBtdWx0aXBsZTogdHJ1ZSB9LFxuICAgIG5PbmVPbmVOdW1iZXI6IHsgbnVtYmVyOiB0cnVlLCBtaW46IC0xLCBtYXg6IDEsIHVuaXRsZXNzOiB0cnVlIH0sXG4gICAgbm9uTmVnYXRpdmVJbnQ6IHsgbnVtYmVyOiB0cnVlLCBtaW46IDAsIGludGVnZXI6IHRydWUsIHVuaXRsZXNzOiB0cnVlIH0sXG4gICAgcG9zaXRpb246IHsgZW51bXM6IFsncGFyZW50JywgJ29yaWdpbiddIH0sXG4gICAgbm9kZVNpemU6IHsgbnVtYmVyOiB0cnVlLCBtaW46IDAsIGVudW1zOiBbJ2xhYmVsJ10gfSxcbiAgICBudW1iZXI6IHsgbnVtYmVyOiB0cnVlLCB1bml0bGVzczogdHJ1ZSB9LFxuICAgIG51bWJlcnM6IHsgbnVtYmVyOiB0cnVlLCB1bml0bGVzczogdHJ1ZSwgbXVsdGlwbGU6IHRydWUgfSxcbiAgICBwb3NpdGl2ZU51bWJlcjogeyBudW1iZXI6IHRydWUsIHVuaXRsZXNzOiB0cnVlLCBtaW46IDAsIHN0cmljdE1pbjogdHJ1ZSB9LFxuICAgIHNpemU6IHsgbnVtYmVyOiB0cnVlLCBtaW46IDAgfSxcbiAgICBiaWRpcmVjdGlvbmFsU2l6ZTogeyBudW1iZXI6IHRydWUgfSwgLy8gYWxsb3dzIG5lZ2F0aXZlXG4gICAgYmlkaXJlY3Rpb25hbFNpemVzOiB7IG51bWJlcjogdHJ1ZSwgbXVsdGlwbGU6IHRydWUgfSwgLy8gYWxsb3dzIG5lZ2F0aXZlXG4gICAgc2l6ZU1heWJlUGVyY2VudDogeyBudW1iZXI6IHRydWUsIG1pbjogMCwgYWxsb3dQZXJjZW50OiB0cnVlIH0sXG4gICAgcGFkZGluZ1JlbGF0aXZlVG86IHsgZW51bXM6IFsnd2lkdGgnLCAnaGVpZ2h0JywgJ2F2ZXJhZ2UnLCAnbWluJywgJ21heCddIH0sXG4gICAgYmdXSDogeyBudW1iZXI6IHRydWUsIG1pbjogMCwgYWxsb3dQZXJjZW50OiB0cnVlLCBlbnVtczogWydhdXRvJ10sIG11bHRpcGxlOiB0cnVlIH0sXG4gICAgYmdQb3M6IHsgbnVtYmVyOiB0cnVlLCBhbGxvd1BlcmNlbnQ6IHRydWUsIG11bHRpcGxlOiB0cnVlIH0sXG4gICAgYmdSZWxhdGl2ZVRvOiB7IGVudW1zOiBbJ2lubmVyJywgJ2luY2x1ZGUtcGFkZGluZyddLCBtdWx0aXBsZTogdHJ1ZSB9LFxuICAgIGJnUmVwZWF0OiB7IGVudW1zOiBbJ3JlcGVhdCcsICdyZXBlYXQteCcsICdyZXBlYXQteScsICduby1yZXBlYXQnXSwgbXVsdGlwbGU6IHRydWUgfSxcbiAgICBiZ0ZpdDogeyBlbnVtczogWydub25lJywgJ2NvbnRhaW4nLCAnY292ZXInXSwgbXVsdGlwbGU6IHRydWUgfSxcbiAgICBiZ0Nyb3NzT3JpZ2luOiB7IGVudW1zOiBbJ2Fub255bW91cycsICd1c2UtY3JlZGVudGlhbHMnXSwgbXVsdGlwbGU6IHRydWUgfSxcbiAgICBiZ0NsaXA6IHsgZW51bXM6IFsnbm9uZScsICdub2RlJ10gfSxcbiAgICBjb2xvcjogeyBjb2xvcjogdHJ1ZSB9LFxuICAgIGJvb2w6IHsgZW51bXM6IFsneWVzJywgJ25vJ10gfSxcbiAgICBsaW5lU3R5bGU6IHsgZW51bXM6IFsnc29saWQnLCAnZG90dGVkJywgJ2Rhc2hlZCddIH0sXG4gICAgYm9yZGVyU3R5bGU6IHsgZW51bXM6IFsnc29saWQnLCAnZG90dGVkJywgJ2Rhc2hlZCcsICdkb3VibGUnXSB9LFxuICAgIGN1cnZlU3R5bGU6IHsgZW51bXM6IFsnYmV6aWVyJywgJ3VuYnVuZGxlZC1iZXppZXInLCAnaGF5c3RhY2snLCAnc2VnbWVudHMnXSB9LFxuICAgIGZvbnRGYW1pbHk6IHsgcmVnZXg6ICdeKFtcXFxcdy0gXFxcXFwiXSsoPzpcXFxccyosXFxcXHMqW1xcXFx3LSBcXFxcXCJdKykqKSQnIH0sXG4gICAgZm9udGxldGlhbnQ6IHsgZW51bXM6IFsnc21hbGwtY2FwcycsICdub3JtYWwnXSB9LFxuICAgIGZvbnRTdHlsZTogeyBlbnVtczogWydpdGFsaWMnLCAnbm9ybWFsJywgJ29ibGlxdWUnXSB9LFxuICAgIGZvbnRXZWlnaHQ6IHsgZW51bXM6IFsnbm9ybWFsJywgJ2JvbGQnLCAnYm9sZGVyJywgJ2xpZ2h0ZXInLCAnMTAwJywgJzIwMCcsICczMDAnLCAnNDAwJywgJzUwMCcsICc2MDAnLCAnODAwJywgJzkwMCcsIDEwMCwgMjAwLCAzMDAsIDQwMCwgNTAwLCA2MDAsIDcwMCwgODAwLCA5MDBdIH0sXG4gICAgdGV4dERlY29yYXRpb246IHsgZW51bXM6IFsnbm9uZScsICd1bmRlcmxpbmUnLCAnb3ZlcmxpbmUnLCAnbGluZS10aHJvdWdoJ10gfSxcbiAgICB0ZXh0VHJhbnNmb3JtOiB7IGVudW1zOiBbJ25vbmUnLCAndXBwZXJjYXNlJywgJ2xvd2VyY2FzZSddIH0sXG4gICAgdGV4dFdyYXA6IHsgZW51bXM6IFsnbm9uZScsICd3cmFwJywgJ2VsbGlwc2lzJ10gfSxcbiAgICB0ZXh0QmFja2dyb3VuZFNoYXBlOiB7IGVudW1zOiBbJ3JlY3RhbmdsZScsICdyb3VuZHJlY3RhbmdsZSddIH0sXG4gICAgbm9kZVNoYXBlOiB7IGVudW1zOiBbJ3JlY3RhbmdsZScsICdyb3VuZHJlY3RhbmdsZScsICdjdXRyZWN0YW5nbGUnLCAnYm90dG9tcm91bmRyZWN0YW5nbGUnLCAnYmFycmVsJywgJ2VsbGlwc2UnLCAndHJpYW5nbGUnLCAnc3F1YXJlJywgJ3BlbnRhZ29uJywgJ2hleGFnb24nLCAnY29uY2F2ZWhleGFnb24nLCAnaGVwdGFnb24nLCAnb2N0YWdvbicsICd0YWcnLCAnc3RhcicsICdkaWFtb25kJywgJ3ZlZScsICdyaG9tYm9pZCcsICdwb2x5Z29uJ10gfSxcbiAgICBjb21wb3VuZEluY2x1ZGVMYWJlbHM6IHsgZW51bXM6IFsnaW5jbHVkZScsICdleGNsdWRlJ10gfSxcbiAgICBhcnJvd1NoYXBlOiB7IGVudW1zOiBbJ3RlZScsICd0cmlhbmdsZScsICd0cmlhbmdsZS10ZWUnLCAndHJpYW5nbGUtY3Jvc3MnLCAndHJpYW5nbGUtYmFja2N1cnZlJywgJ2hhbGYtdHJpYW5nbGUtb3ZlcnNob3QnLCAndmVlJywgJ3NxdWFyZScsICdjaXJjbGUnLCAnZGlhbW9uZCcsICdub25lJ10gfSxcbiAgICBhcnJvd0ZpbGw6IHsgZW51bXM6IFsnZmlsbGVkJywgJ2hvbGxvdyddIH0sXG4gICAgZGlzcGxheTogeyBlbnVtczogWydlbGVtZW50JywgJ25vbmUnXSB9LFxuICAgIHZpc2liaWxpdHk6IHsgZW51bXM6IFsnaGlkZGVuJywgJ3Zpc2libGUnXSB9LFxuICAgIHpDb21wb3VuZERlcHRoOiB7IGVudW1zOiBbJ2JvdHRvbScsICdvcnBoYW4nLCAnYXV0bycsICd0b3AnXSB9LFxuICAgIHpJbmRleENvbXBhcmU6IHsgZW51bXM6IFsnYXV0bycsICdtYW51YWwnXSB9LFxuICAgIHZhbGlnbjogeyBlbnVtczogWyd0b3AnLCAnY2VudGVyJywgJ2JvdHRvbSddIH0sXG4gICAgaGFsaWduOiB7IGVudW1zOiBbJ2xlZnQnLCAnY2VudGVyJywgJ3JpZ2h0J10gfSxcbiAgICB0ZXh0OiB7IHN0cmluZzogdHJ1ZSB9LFxuICAgIGRhdGE6IHsgbWFwcGluZzogdHJ1ZSwgcmVnZXg6IGRhdGEoJ2RhdGEnKSB9LFxuICAgIGxheW91dERhdGE6IHsgbWFwcGluZzogdHJ1ZSwgcmVnZXg6IGRhdGEoJ2xheW91dERhdGEnKSB9LFxuICAgIHNjcmF0Y2g6IHsgbWFwcGluZzogdHJ1ZSwgcmVnZXg6IGRhdGEoJ3NjcmF0Y2gnKSB9LFxuICAgIG1hcERhdGE6IHsgbWFwcGluZzogdHJ1ZSwgcmVnZXg6IG1hcERhdGEoJ21hcERhdGEnKSB9LFxuICAgIG1hcExheW91dERhdGE6IHsgbWFwcGluZzogdHJ1ZSwgcmVnZXg6IG1hcERhdGEoJ21hcExheW91dERhdGEnKSB9LFxuICAgIG1hcFNjcmF0Y2g6IHsgbWFwcGluZzogdHJ1ZSwgcmVnZXg6IG1hcERhdGEoJ21hcFNjcmF0Y2gnKSB9LFxuICAgIGZuOiB7IG1hcHBpbmc6IHRydWUsIGZuOiB0cnVlIH0sXG4gICAgdXJsOiB7IHJlZ2V4ZXM6IHVybFJlZ2V4ZXMsIHNpbmdsZVJlZ2V4TWF0Y2hWYWx1ZTogdHJ1ZSB9LFxuICAgIHVybHM6IHsgcmVnZXhlczogdXJsUmVnZXhlcywgc2luZ2xlUmVnZXhNYXRjaFZhbHVlOiB0cnVlLCBtdWx0aXBsZTogdHJ1ZSB9LFxuICAgIHByb3BMaXN0OiB7IHByb3BMaXN0OiB0cnVlIH0sXG4gICAgYW5nbGU6IHsgbnVtYmVyOiB0cnVlLCB1bml0czogJ2RlZ3xyYWQnLCBpbXBsaWNpdFVuaXRzOiAncmFkJyB9LFxuICAgIHRleHRSb3RhdGlvbjogeyBudW1iZXI6IHRydWUsIHVuaXRzOiAnZGVnfHJhZCcsIGltcGxpY2l0VW5pdHM6ICdyYWQnLCBlbnVtczogWydub25lJywgJ2F1dG9yb3RhdGUnXSB9LFxuICAgIHBvbHlnb25Qb2ludExpc3Q6IHsgbnVtYmVyOiB0cnVlLCBtdWx0aXBsZTogdHJ1ZSwgZXZlbk11bHRpcGxlOiB0cnVlLCBtaW46IC0xLCBtYXg6IDEsIHVuaXRsZXNzOiB0cnVlIH0sXG4gICAgZWRnZURpc3RhbmNlczogeyBlbnVtczogWydpbnRlcnNlY3Rpb24nLCAnbm9kZS1wb3NpdGlvbiddIH0sXG4gICAgZWRnZUVuZHBvaW50OiB7XG4gICAgICBudW1iZXI6IHRydWUsIG11bHRpcGxlOiB0cnVlLCB1bml0czogJyV8cHh8ZW18ZGVnfHJhZCcsIGltcGxpY2l0VW5pdHM6ICdweCcsXG4gICAgICBlbnVtczogWydpbnNpZGUtdG8tbm9kZScsICdvdXRzaWRlLXRvLW5vZGUnLCAnb3V0c2lkZS10by1saW5lJ10sIHNpbmdsZUVudW06IHRydWUsXG4gICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGUodmFsQXJyLCB1bml0c0Fycikge1xuICAgICAgICBzd2l0Y2ggKHZhbEFyci5sZW5ndGgpIHtcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAvLyBjYW4gYmUgJSBvciBweCBvbmx5XG4gICAgICAgICAgICByZXR1cm4gdW5pdHNBcnJbMF0gIT09ICdkZWcnICYmIHVuaXRzQXJyWzBdICE9PSAncmFkJyAmJiB1bml0c0FyclsxXSAhPT0gJ2RlZycgJiYgdW5pdHNBcnJbMV0gIT09ICdyYWQnO1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIC8vIGNhbiBiZSBlbnVtLCBkZWcsIG9yIHJhZCBvbmx5XG4gICAgICAgICAgICByZXR1cm4gaXMuc3RyaW5nKHZhbEFyclswXSkgfHwgdW5pdHNBcnJbMF0gPT09ICdkZWcnIHx8IHVuaXRzQXJyWzBdID09PSAncmFkJztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBlYXNpbmc6IHtcbiAgICAgIHJlZ2V4ZXM6IFsnXihzcHJpbmcpXFxcXHMqXFxcXChcXFxccyooJyArIG51bWJlciArICcpXFxcXHMqLFxcXFxzKignICsgbnVtYmVyICsgJylcXFxccypcXFxcKSQnLCAnXihjdWJpYy1iZXppZXIpXFxcXHMqXFxcXChcXFxccyooJyArIG51bWJlciArICcpXFxcXHMqLFxcXFxzKignICsgbnVtYmVyICsgJylcXFxccyosXFxcXHMqKCcgKyBudW1iZXIgKyAnKVxcXFxzKixcXFxccyooJyArIG51bWJlciArICcpXFxcXHMqXFxcXCkkJ10sXG4gICAgICBlbnVtczogWydsaW5lYXInLCAnZWFzZScsICdlYXNlLWluJywgJ2Vhc2Utb3V0JywgJ2Vhc2UtaW4tb3V0JywgJ2Vhc2UtaW4tc2luZScsICdlYXNlLW91dC1zaW5lJywgJ2Vhc2UtaW4tb3V0LXNpbmUnLCAnZWFzZS1pbi1xdWFkJywgJ2Vhc2Utb3V0LXF1YWQnLCAnZWFzZS1pbi1vdXQtcXVhZCcsICdlYXNlLWluLWN1YmljJywgJ2Vhc2Utb3V0LWN1YmljJywgJ2Vhc2UtaW4tb3V0LWN1YmljJywgJ2Vhc2UtaW4tcXVhcnQnLCAnZWFzZS1vdXQtcXVhcnQnLCAnZWFzZS1pbi1vdXQtcXVhcnQnLCAnZWFzZS1pbi1xdWludCcsICdlYXNlLW91dC1xdWludCcsICdlYXNlLWluLW91dC1xdWludCcsICdlYXNlLWluLWV4cG8nLCAnZWFzZS1vdXQtZXhwbycsICdlYXNlLWluLW91dC1leHBvJywgJ2Vhc2UtaW4tY2lyYycsICdlYXNlLW91dC1jaXJjJywgJ2Vhc2UtaW4tb3V0LWNpcmMnXVxuICAgIH1cbiAgfTtcblxuICB2YXIgek9yZGVyRGlmZiA9IHtcbiAgICB6ZXJvTm9uWmVybzogZnVuY3Rpb24gemVyb05vblplcm8odmFsMSwgdmFsMikge1xuICAgICAgaWYgKHZhbDEgPT09IDAgJiYgdmFsMiAhPT0gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodmFsMSAhPT0gMCAmJiB2YWwyID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG4gICAgYW55RGlmZjogZnVuY3Rpb24gYW55RGlmZih2YWwxLCB2YWwyKSB7XG4gICAgICByZXR1cm4gdmFsMSAhPT0gdmFsMjtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHpkID0gek9yZGVyRGlmZjtcblxuICAvLyBkZWZpbmUgdmlzdWFsIHN0eWxlIHByb3BlcnRpZXNcbiAgdmFyIHQgPSBzdHlmbi50eXBlcztcbiAgdmFyIHByb3BzID0gc3R5Zm4ucHJvcGVydGllcyA9IFtcbiAgLy8gbWFpbiBsYWJlbFxuICB7IG5hbWU6ICdsYWJlbCcsIHR5cGU6IHQudGV4dCB9LCB7IG5hbWU6ICd0ZXh0LXJvdGF0aW9uJywgdHlwZTogdC50ZXh0Um90YXRpb24gfSwgeyBuYW1lOiAndGV4dC1tYXJnaW4teCcsIHR5cGU6IHQuYmlkaXJlY3Rpb25hbFNpemUgfSwgeyBuYW1lOiAndGV4dC1tYXJnaW4teScsIHR5cGU6IHQuYmlkaXJlY3Rpb25hbFNpemUgfSxcblxuICAvLyBzb3VyY2UgbGFiZWxcbiAgeyBuYW1lOiAnc291cmNlLWxhYmVsJywgdHlwZTogdC50ZXh0IH0sIHsgbmFtZTogJ3NvdXJjZS10ZXh0LXJvdGF0aW9uJywgdHlwZTogdC50ZXh0Um90YXRpb24gfSwgeyBuYW1lOiAnc291cmNlLXRleHQtbWFyZ2luLXgnLCB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplIH0sIHsgbmFtZTogJ3NvdXJjZS10ZXh0LW1hcmdpbi15JywgdHlwZTogdC5iaWRpcmVjdGlvbmFsU2l6ZSB9LCB7IG5hbWU6ICdzb3VyY2UtdGV4dC1vZmZzZXQnLCB0eXBlOiB0LnNpemUgfSxcblxuICAvLyB0YXJnZXQgbGFiZWxcbiAgeyBuYW1lOiAndGFyZ2V0LWxhYmVsJywgdHlwZTogdC50ZXh0IH0sIHsgbmFtZTogJ3RhcmdldC10ZXh0LXJvdGF0aW9uJywgdHlwZTogdC50ZXh0Um90YXRpb24gfSwgeyBuYW1lOiAndGFyZ2V0LXRleHQtbWFyZ2luLXgnLCB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplIH0sIHsgbmFtZTogJ3RhcmdldC10ZXh0LW1hcmdpbi15JywgdHlwZTogdC5iaWRpcmVjdGlvbmFsU2l6ZSB9LCB7IG5hbWU6ICd0YXJnZXQtdGV4dC1vZmZzZXQnLCB0eXBlOiB0LnNpemUgfSxcblxuICAvLyBjb21tb24gbGFiZWwgc3R5bGVcbiAgeyBuYW1lOiAndGV4dC12YWxpZ24nLCB0eXBlOiB0LnZhbGlnbiB9LCB7IG5hbWU6ICd0ZXh0LWhhbGlnbicsIHR5cGU6IHQuaGFsaWduIH0sIHsgbmFtZTogJ2NvbG9yJywgdHlwZTogdC5jb2xvciB9LCB7IG5hbWU6ICd0ZXh0LW91dGxpbmUtY29sb3InLCB0eXBlOiB0LmNvbG9yIH0sIHsgbmFtZTogJ3RleHQtb3V0bGluZS13aWR0aCcsIHR5cGU6IHQuc2l6ZSB9LCB7IG5hbWU6ICd0ZXh0LW91dGxpbmUtb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9LCB7IG5hbWU6ICd0ZXh0LW9wYWNpdHknLCB0eXBlOiB0Lnplcm9PbmVOdW1iZXIgfSwgeyBuYW1lOiAndGV4dC1iYWNrZ3JvdW5kLWNvbG9yJywgdHlwZTogdC5jb2xvciB9LCB7IG5hbWU6ICd0ZXh0LWJhY2tncm91bmQtb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9LCB7IG5hbWU6ICd0ZXh0LWJhY2tncm91bmQtcGFkZGluZycsIHR5cGU6IHQuc2l6ZSB9LCB7IG5hbWU6ICd0ZXh0LWJvcmRlci1vcGFjaXR5JywgdHlwZTogdC56ZXJvT25lTnVtYmVyIH0sIHsgbmFtZTogJ3RleHQtYm9yZGVyLWNvbG9yJywgdHlwZTogdC5jb2xvciB9LCB7IG5hbWU6ICd0ZXh0LWJvcmRlci13aWR0aCcsIHR5cGU6IHQuc2l6ZSB9LCB7IG5hbWU6ICd0ZXh0LWJvcmRlci1zdHlsZScsIHR5cGU6IHQuYm9yZGVyU3R5bGUgfSwgeyBuYW1lOiAndGV4dC1iYWNrZ3JvdW5kLXNoYXBlJywgdHlwZTogdC50ZXh0QmFja2dyb3VuZFNoYXBlIH0sXG4gIC8vIHsgbmFtZTogJ3RleHQtZGVjb3JhdGlvbicsIHR5cGU6IHQudGV4dERlY29yYXRpb24gfSwgLy8gbm90IHN1cHBvcnRlZCBpbiBjYW52YXNcbiAgeyBuYW1lOiAndGV4dC10cmFuc2Zvcm0nLCB0eXBlOiB0LnRleHRUcmFuc2Zvcm0gfSwgeyBuYW1lOiAndGV4dC13cmFwJywgdHlwZTogdC50ZXh0V3JhcCB9LCB7IG5hbWU6ICd0ZXh0LW1heC13aWR0aCcsIHR5cGU6IHQuc2l6ZSB9LCB7IG5hbWU6ICd0ZXh0LWV2ZW50cycsIHR5cGU6IHQuYm9vbCB9LCB7IG5hbWU6ICdmb250LWZhbWlseScsIHR5cGU6IHQuZm9udEZhbWlseSB9LCB7IG5hbWU6ICdmb250LXN0eWxlJywgdHlwZTogdC5mb250U3R5bGUgfSxcbiAgLy8geyBuYW1lOiAnZm9udC1sZXRpYW50JywgdHlwZTogdC5mb250bGV0aWFudCB9LCAvLyBub3QgdXNlZnVsXG4gIHsgbmFtZTogJ2ZvbnQtd2VpZ2h0JywgdHlwZTogdC5mb250V2VpZ2h0IH0sIHsgbmFtZTogJ2ZvbnQtc2l6ZScsIHR5cGU6IHQuc2l6ZSB9LCB7IG5hbWU6ICdtaW4tem9vbWVkLWZvbnQtc2l6ZScsIHR5cGU6IHQuc2l6ZSB9LFxuXG4gIC8vIGJlaGF2aW91clxuICB7IG5hbWU6ICdldmVudHMnLCB0eXBlOiB0LmJvb2wgfSxcblxuICAvLyB2aXNpYmlsaXR5XG4gIHsgbmFtZTogJ2Rpc3BsYXknLCB0eXBlOiB0LmRpc3BsYXksIHRyaWdnZXJzWk9yZGVyOiB6ZC5hbnlEaWZmIH0sIHsgbmFtZTogJ3Zpc2liaWxpdHknLCB0eXBlOiB0LnZpc2liaWxpdHksIHRyaWdnZXJzWk9yZGVyOiB6ZC5hbnlEaWZmIH0sIHsgbmFtZTogJ29wYWNpdHknLCB0eXBlOiB0Lnplcm9PbmVOdW1iZXIsIHRyaWdnZXJzWk9yZGVyOiB6ZC56ZXJvTm9uWmVybyB9LCB7IG5hbWU6ICd6LWNvbXBvdW5kLWRlcHRoJywgdHlwZTogdC56Q29tcG91bmREZXB0aCwgdHJpZ2dlcnNaT3JkZXI6IHpkLmFueURpZmYgfSwgeyBuYW1lOiAnei1pbmRleC1jb21wYXJlJywgdHlwZTogdC56SW5kZXhDb21wYXJlLCB0cmlnZ2Vyc1pPcmRlcjogemQuYW55RGlmZiB9LCB7IG5hbWU6ICd6LWluZGV4JywgdHlwZTogdC5ub25OZWdhdGl2ZUludCwgdHJpZ2dlcnNaT3JkZXI6IHpkLmFueURpZmYgfSxcblxuICAvLyBvdmVybGF5c1xuICB7IG5hbWU6ICdvdmVybGF5LXBhZGRpbmcnLCB0eXBlOiB0LnNpemUgfSwgeyBuYW1lOiAnb3ZlcmxheS1jb2xvcicsIHR5cGU6IHQuY29sb3IgfSwgeyBuYW1lOiAnb3ZlcmxheS1vcGFjaXR5JywgdHlwZTogdC56ZXJvT25lTnVtYmVyIH0sXG5cbiAgLy8gdHJhbnNpdGlvbiBhbmlzXG4gIHsgbmFtZTogJ3RyYW5zaXRpb24tcHJvcGVydHknLCB0eXBlOiB0LnByb3BMaXN0IH0sIHsgbmFtZTogJ3RyYW5zaXRpb24tZHVyYXRpb24nLCB0eXBlOiB0LnRpbWUgfSwgeyBuYW1lOiAndHJhbnNpdGlvbi1kZWxheScsIHR5cGU6IHQudGltZSB9LCB7IG5hbWU6ICd0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbicsIHR5cGU6IHQuZWFzaW5nIH0sXG5cbiAgLy8gbm9kZSBib2R5XG4gIHsgbmFtZTogJ2hlaWdodCcsIHR5cGU6IHQubm9kZVNpemUgfSwgeyBuYW1lOiAnd2lkdGgnLCB0eXBlOiB0Lm5vZGVTaXplIH0sIHsgbmFtZTogJ3NoYXBlJywgdHlwZTogdC5ub2RlU2hhcGUgfSwgeyBuYW1lOiAnc2hhcGUtcG9seWdvbi1wb2ludHMnLCB0eXBlOiB0LnBvbHlnb25Qb2ludExpc3QgfSwgeyBuYW1lOiAnYmFja2dyb3VuZC1jb2xvcicsIHR5cGU6IHQuY29sb3IgfSwgeyBuYW1lOiAnYmFja2dyb3VuZC1vcGFjaXR5JywgdHlwZTogdC56ZXJvT25lTnVtYmVyIH0sIHsgbmFtZTogJ2JhY2tncm91bmQtYmxhY2tlbicsIHR5cGU6IHQubk9uZU9uZU51bWJlciB9LCB7IG5hbWU6ICdwYWRkaW5nJywgdHlwZTogdC5zaXplTWF5YmVQZXJjZW50IH0sIHsgbmFtZTogJ3BhZGRpbmctcmVsYXRpdmUtdG8nLCB0eXBlOiB0LnBhZGRpbmdSZWxhdGl2ZVRvIH0sXG5cbiAgLy8gbm9kZSBib3JkZXJcbiAgeyBuYW1lOiAnYm9yZGVyLWNvbG9yJywgdHlwZTogdC5jb2xvciB9LCB7IG5hbWU6ICdib3JkZXItb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9LCB7IG5hbWU6ICdib3JkZXItd2lkdGgnLCB0eXBlOiB0LnNpemUgfSwgeyBuYW1lOiAnYm9yZGVyLXN0eWxlJywgdHlwZTogdC5ib3JkZXJTdHlsZSB9LFxuXG4gIC8vIG5vZGUgYmFja2dyb3VuZCBpbWFnZXNcbiAgeyBuYW1lOiAnYmFja2dyb3VuZC1pbWFnZScsIHR5cGU6IHQudXJscyB9LCB7IG5hbWU6ICdiYWNrZ3JvdW5kLWltYWdlLWNyb3Nzb3JpZ2luJywgdHlwZTogdC5iZ0Nyb3NzT3JpZ2luIH0sIHsgbmFtZTogJ2JhY2tncm91bmQtaW1hZ2Utb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlcnMgfSwgeyBuYW1lOiAnYmFja2dyb3VuZC1wb3NpdGlvbi14JywgdHlwZTogdC5iZ1BvcyB9LCB7IG5hbWU6ICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXknLCB0eXBlOiB0LmJnUG9zIH0sIHsgbmFtZTogJ2JhY2tncm91bmQtd2lkdGgtcmVsYXRpdmUtdG8nLCB0eXBlOiB0LmJnUmVsYXRpdmVUbyB9LCB7IG5hbWU6ICdiYWNrZ3JvdW5kLWhlaWdodC1yZWxhdGl2ZS10bycsIHR5cGU6IHQuYmdSZWxhdGl2ZVRvIH0sIHsgbmFtZTogJ2JhY2tncm91bmQtcmVwZWF0JywgdHlwZTogdC5iZ1JlcGVhdCB9LCB7IG5hbWU6ICdiYWNrZ3JvdW5kLWZpdCcsIHR5cGU6IHQuYmdGaXQgfSwgeyBuYW1lOiAnYmFja2dyb3VuZC1jbGlwJywgdHlwZTogdC5iZ0NsaXAgfSwgeyBuYW1lOiAnYmFja2dyb3VuZC13aWR0aCcsIHR5cGU6IHQuYmdXSCB9LCB7IG5hbWU6ICdiYWNrZ3JvdW5kLWhlaWdodCcsIHR5cGU6IHQuYmdXSCB9LFxuXG4gIC8vIGNvbXBvdW5kIHByb3BzXG4gIHsgbmFtZTogJ3Bvc2l0aW9uJywgdHlwZTogdC5wb3NpdGlvbiB9LCB7IG5hbWU6ICdjb21wb3VuZC1zaXppbmctd3J0LWxhYmVscycsIHR5cGU6IHQuY29tcG91bmRJbmNsdWRlTGFiZWxzIH0sIHsgbmFtZTogJ21pbi13aWR0aCcsIHR5cGU6IHQuc2l6ZSB9LCB7IG5hbWU6ICdtaW4td2lkdGgtYmlhcy1sZWZ0JywgdHlwZTogdC5zaXplTWF5YmVQZXJjZW50IH0sIHsgbmFtZTogJ21pbi13aWR0aC1iaWFzLXJpZ2h0JywgdHlwZTogdC5zaXplTWF5YmVQZXJjZW50IH0sIHsgbmFtZTogJ21pbi1oZWlnaHQnLCB0eXBlOiB0LnNpemUgfSwgeyBuYW1lOiAnbWluLWhlaWdodC1iaWFzLXRvcCcsIHR5cGU6IHQuc2l6ZU1heWJlUGVyY2VudCB9LCB7IG5hbWU6ICdtaW4taGVpZ2h0LWJpYXMtYm90dG9tJywgdHlwZTogdC5zaXplTWF5YmVQZXJjZW50IH0sXG5cbiAgLy8gZWRnZSBsaW5lXG4gIHsgbmFtZTogJ2xpbmUtc3R5bGUnLCB0eXBlOiB0LmxpbmVTdHlsZSB9LCB7IG5hbWU6ICdsaW5lLWNvbG9yJywgdHlwZTogdC5jb2xvciB9LCB7IG5hbWU6ICdjdXJ2ZS1zdHlsZScsIHR5cGU6IHQuY3VydmVTdHlsZSB9LCB7IG5hbWU6ICdoYXlzdGFjay1yYWRpdXMnLCB0eXBlOiB0Lnplcm9PbmVOdW1iZXIgfSwgeyBuYW1lOiAnc291cmNlLWVuZHBvaW50JywgdHlwZTogdC5lZGdlRW5kcG9pbnQgfSwgeyBuYW1lOiAndGFyZ2V0LWVuZHBvaW50JywgdHlwZTogdC5lZGdlRW5kcG9pbnQgfSwgeyBuYW1lOiAnY29udHJvbC1wb2ludC1zdGVwLXNpemUnLCB0eXBlOiB0LnNpemUgfSwgeyBuYW1lOiAnY29udHJvbC1wb2ludC1kaXN0YW5jZXMnLCB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplcyB9LCB7IG5hbWU6ICdjb250cm9sLXBvaW50LXdlaWdodHMnLCB0eXBlOiB0Lm51bWJlcnMgfSwgeyBuYW1lOiAnc2VnbWVudC1kaXN0YW5jZXMnLCB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplcyB9LCB7IG5hbWU6ICdzZWdtZW50LXdlaWdodHMnLCB0eXBlOiB0Lm51bWJlcnMgfSwgeyBuYW1lOiAnZWRnZS1kaXN0YW5jZXMnLCB0eXBlOiB0LmVkZ2VEaXN0YW5jZXMgfSwgeyBuYW1lOiAnYXJyb3ctc2NhbGUnLCB0eXBlOiB0LnBvc2l0aXZlTnVtYmVyIH0sIHsgbmFtZTogJ2xvb3AtZGlyZWN0aW9uJywgdHlwZTogdC5hbmdsZSB9LCB7IG5hbWU6ICdsb29wLXN3ZWVwJywgdHlwZTogdC5hbmdsZSB9LCB7IG5hbWU6ICdzb3VyY2UtZGlzdGFuY2UtZnJvbS1ub2RlJywgdHlwZTogdC5zaXplIH0sIHsgbmFtZTogJ3RhcmdldC1kaXN0YW5jZS1mcm9tLW5vZGUnLCB0eXBlOiB0LnNpemUgfSxcblxuICAvLyBnaG9zdCBwcm9wZXJ0aWVzXG4gIHsgbmFtZTogJ2dob3N0JywgdHlwZTogdC5ib29sIH0sIHsgbmFtZTogJ2dob3N0LW9mZnNldC14JywgdHlwZTogdC5iaWRpcmVjdGlvbmFsU2l6ZSB9LCB7IG5hbWU6ICdnaG9zdC1vZmZzZXQteScsIHR5cGU6IHQuYmlkaXJlY3Rpb25hbFNpemUgfSwgeyBuYW1lOiAnZ2hvc3Qtb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9LFxuXG4gIC8vIHRoZXNlIGFyZSBqdXN0IGZvciB0aGUgY29yZVxuICB7IG5hbWU6ICdzZWxlY3Rpb24tYm94LWNvbG9yJywgdHlwZTogdC5jb2xvciB9LCB7IG5hbWU6ICdzZWxlY3Rpb24tYm94LW9wYWNpdHknLCB0eXBlOiB0Lnplcm9PbmVOdW1iZXIgfSwgeyBuYW1lOiAnc2VsZWN0aW9uLWJveC1ib3JkZXItY29sb3InLCB0eXBlOiB0LmNvbG9yIH0sIHsgbmFtZTogJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLXdpZHRoJywgdHlwZTogdC5zaXplIH0sIHsgbmFtZTogJ2FjdGl2ZS1iZy1jb2xvcicsIHR5cGU6IHQuY29sb3IgfSwgeyBuYW1lOiAnYWN0aXZlLWJnLW9wYWNpdHknLCB0eXBlOiB0Lnplcm9PbmVOdW1iZXIgfSwgeyBuYW1lOiAnYWN0aXZlLWJnLXNpemUnLCB0eXBlOiB0LnNpemUgfSwgeyBuYW1lOiAnb3V0c2lkZS10ZXh0dXJlLWJnLWNvbG9yJywgdHlwZTogdC5jb2xvciB9LCB7IG5hbWU6ICdvdXRzaWRlLXRleHR1cmUtYmctb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9XTtcblxuICAvLyBkZWZpbmUgYWxpYXNlc1xuICB2YXIgYWxpYXNlcyA9IHN0eWZuLmFsaWFzZXMgPSBbeyBuYW1lOiAnY29udGVudCcsIHBvaW50c1RvOiAnbGFiZWwnIH0sIHsgbmFtZTogJ2NvbnRyb2wtcG9pbnQtZGlzdGFuY2UnLCBwb2ludHNUbzogJ2NvbnRyb2wtcG9pbnQtZGlzdGFuY2VzJyB9LCB7IG5hbWU6ICdjb250cm9sLXBvaW50LXdlaWdodCcsIHBvaW50c1RvOiAnY29udHJvbC1wb2ludC13ZWlnaHRzJyB9LCB7IG5hbWU6ICdlZGdlLXRleHQtcm90YXRpb24nLCBwb2ludHNUbzogJ3RleHQtcm90YXRpb24nIH0sIHsgbmFtZTogJ3BhZGRpbmctbGVmdCcsIHBvaW50c1RvOiAncGFkZGluZycgfSwgeyBuYW1lOiAncGFkZGluZy1yaWdodCcsIHBvaW50c1RvOiAncGFkZGluZycgfSwgeyBuYW1lOiAncGFkZGluZy10b3AnLCBwb2ludHNUbzogJ3BhZGRpbmcnIH0sIHsgbmFtZTogJ3BhZGRpbmctYm90dG9tJywgcG9pbnRzVG86ICdwYWRkaW5nJyB9XTtcblxuICAvLyBwaWUgYmFja2dyb3VuZHMgZm9yIG5vZGVzXG4gIHN0eWZuLnBpZUJhY2tncm91bmROID0gMTY7IC8vIGJlY2F1c2UgdGhlIHBpZSBwcm9wZXJ0aWVzIGFyZSBudW1iZXJlZCwgZ2l2ZSBhY2Nlc3MgdG8gYSBjb25zdGFudCBOIChmb3IgcmVuZGVyZXIgdXNlKVxuICBwcm9wcy5wdXNoKHsgbmFtZTogJ3BpZS1zaXplJywgdHlwZTogdC5zaXplTWF5YmVQZXJjZW50IH0pO1xuICBmb3IgKHZhciBpID0gMTsgaSA8PSBzdHlmbi5waWVCYWNrZ3JvdW5kTjsgaSsrKSB7XG4gICAgcHJvcHMucHVzaCh7IG5hbWU6ICdwaWUtJyArIGkgKyAnLWJhY2tncm91bmQtY29sb3InLCB0eXBlOiB0LmNvbG9yIH0pO1xuICAgIHByb3BzLnB1c2goeyBuYW1lOiAncGllLScgKyBpICsgJy1iYWNrZ3JvdW5kLXNpemUnLCB0eXBlOiB0LnBlcmNlbnQgfSk7XG4gICAgcHJvcHMucHVzaCh7IG5hbWU6ICdwaWUtJyArIGkgKyAnLWJhY2tncm91bmQtb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9KTtcbiAgfVxuXG4gIC8vIGVkZ2UgYXJyb3dzXG4gIHZhciBhcnJvd1ByZWZpeGVzID0gc3R5Zm4uYXJyb3dQcmVmaXhlcyA9IFsnc291cmNlJywgJ21pZC1zb3VyY2UnLCAndGFyZ2V0JywgJ21pZC10YXJnZXQnXTtcbiAgW3sgbmFtZTogJ2Fycm93LXNoYXBlJywgdHlwZTogdC5hcnJvd1NoYXBlIH0sIHsgbmFtZTogJ2Fycm93LWNvbG9yJywgdHlwZTogdC5jb2xvciB9LCB7IG5hbWU6ICdhcnJvdy1maWxsJywgdHlwZTogdC5hcnJvd0ZpbGwgfV0uZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgIGFycm93UHJlZml4ZXMuZm9yRWFjaChmdW5jdGlvbiAocHJlZml4KSB7XG4gICAgICB2YXIgbmFtZSA9IHByZWZpeCArICctJyArIHByb3AubmFtZTtcbiAgICAgIHZhciB0eXBlID0gcHJvcC50eXBlO1xuXG4gICAgICBwcm9wcy5wdXNoKHsgbmFtZTogbmFtZSwgdHlwZTogdHlwZSB9KTtcbiAgICB9KTtcbiAgfSwge30pO1xuXG4gIC8vIGxpc3Qgb2YgcHJvcGVydHkgbmFtZXNcbiAgc3R5Zm4ucHJvcGVydHlOYW1lcyA9IHByb3BzLm1hcChmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiBwLm5hbWU7XG4gIH0pO1xuXG4gIC8vIGFsbG93IGFjY2VzcyBvZiBwcm9wZXJ0aWVzIGJ5IG5hbWUgKCBlLmcuIHN0eWxlLnByb3BlcnRpZXMuaGVpZ2h0IClcbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHByb3BzLmxlbmd0aDsgX2krKykge1xuICAgIHZhciBwcm9wID0gcHJvcHNbX2ldO1xuXG4gICAgcHJvcHNbcHJvcC5uYW1lXSA9IHByb3A7IC8vIGFsbG93IGxvb2t1cCBieSBuYW1lXG4gIH1cblxuICAvLyBtYXAgYWxpYXNlc1xuICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBhbGlhc2VzLmxlbmd0aDsgX2kyKyspIHtcbiAgICB2YXIgYWxpYXMgPSBhbGlhc2VzW19pMl07XG4gICAgdmFyIHBvaW50c1RvUHJvcCA9IHByb3BzW2FsaWFzLnBvaW50c1RvXTtcbiAgICB2YXIgYWxpYXNQcm9wID0ge1xuICAgICAgbmFtZTogYWxpYXMubmFtZSxcbiAgICAgIGFsaWFzOiB0cnVlLFxuICAgICAgcG9pbnRzVG86IHBvaW50c1RvUHJvcFxuICAgIH07XG5cbiAgICAvLyBhZGQgYWxpYXMgcHJvcCBmb3IgcGFyc2luZ1xuICAgIHByb3BzLnB1c2goYWxpYXNQcm9wKTtcblxuICAgIHByb3BzW2FsaWFzLm5hbWVdID0gYWxpYXNQcm9wOyAvLyBhbGxvdyBsb29rdXAgYnkgbmFtZVxuICB9XG59KSgpO1xuXG5zdHlmbi5nZXREZWZhdWx0UHJvcGVydHkgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gdGhpcy5nZXREZWZhdWx0UHJvcGVydGllcygpW25hbWVdO1xufTtcblxuc3R5Zm4uZ2V0RGVmYXVsdFByb3BlcnRpZXMgPSB1dGlsLm1lbW9pemUoZnVuY3Rpb24gKCkge1xuICB2YXIgcmF3UHJvcHMgPSB1dGlsLmV4dGVuZCh7XG4gICAgLy8gY29tbW9uIG5vZGUvZWRnZSBwcm9wc1xuICAgICdldmVudHMnOiAneWVzJyxcbiAgICAndGV4dC1ldmVudHMnOiAnbm8nLFxuICAgICd0ZXh0LXZhbGlnbic6ICd0b3AnLFxuICAgICd0ZXh0LWhhbGlnbic6ICdjZW50ZXInLFxuICAgICdjb2xvcic6ICcjMDAwJyxcbiAgICAndGV4dC1vdXRsaW5lLWNvbG9yJzogJyMwMDAnLFxuICAgICd0ZXh0LW91dGxpbmUtd2lkdGgnOiAwLFxuICAgICd0ZXh0LW91dGxpbmUtb3BhY2l0eSc6IDEsXG4gICAgJ3RleHQtb3BhY2l0eSc6IDEsXG4gICAgJ3RleHQtZGVjb3JhdGlvbic6ICdub25lJyxcbiAgICAndGV4dC10cmFuc2Zvcm0nOiAnbm9uZScsXG4gICAgJ3RleHQtd3JhcCc6ICdub25lJyxcbiAgICAndGV4dC1tYXgtd2lkdGgnOiA5OTk5LFxuICAgICd0ZXh0LWJhY2tncm91bmQtY29sb3InOiAnIzAwMCcsXG4gICAgJ3RleHQtYmFja2dyb3VuZC1vcGFjaXR5JzogMCxcbiAgICAndGV4dC1iYWNrZ3JvdW5kLXNoYXBlJzogJ3JlY3RhbmdsZScsXG4gICAgJ3RleHQtYmFja2dyb3VuZC1wYWRkaW5nJzogMCxcbiAgICAndGV4dC1ib3JkZXItb3BhY2l0eSc6IDAsXG4gICAgJ3RleHQtYm9yZGVyLXdpZHRoJzogMCxcbiAgICAndGV4dC1ib3JkZXItc3R5bGUnOiAnc29saWQnLFxuICAgICd0ZXh0LWJvcmRlci1jb2xvcic6ICcjMDAwJyxcbiAgICAnZm9udC1mYW1pbHknOiAnSGVsdmV0aWNhIE5ldWUsIEhlbHZldGljYSwgc2Fucy1zZXJpZicsXG4gICAgJ2ZvbnQtc3R5bGUnOiAnbm9ybWFsJyxcbiAgICAvLyAnZm9udC1sZXRpYW50JzogZm9udGxldGlhbnQsXG4gICAgJ2ZvbnQtd2VpZ2h0JzogJ25vcm1hbCcsXG4gICAgJ2ZvbnQtc2l6ZSc6IDE2LFxuICAgICdtaW4tem9vbWVkLWZvbnQtc2l6ZSc6IDAsXG4gICAgJ3RleHQtcm90YXRpb24nOiAnbm9uZScsXG4gICAgJ3NvdXJjZS10ZXh0LXJvdGF0aW9uJzogJ25vbmUnLFxuICAgICd0YXJnZXQtdGV4dC1yb3RhdGlvbic6ICdub25lJyxcbiAgICAndmlzaWJpbGl0eSc6ICd2aXNpYmxlJyxcbiAgICAnZGlzcGxheSc6ICdlbGVtZW50JyxcbiAgICAnb3BhY2l0eSc6IDEsXG4gICAgJ3otY29tcG91bmQtZGVwdGgnOiAnYXV0bycsXG4gICAgJ3otaW5kZXgtY29tcGFyZSc6ICdhdXRvJyxcbiAgICAnei1pbmRleCc6IDAsXG4gICAgJ2xhYmVsJzogJycsXG4gICAgJ3RleHQtbWFyZ2luLXgnOiAwLFxuICAgICd0ZXh0LW1hcmdpbi15JzogMCxcbiAgICAnc291cmNlLWxhYmVsJzogJycsXG4gICAgJ3NvdXJjZS10ZXh0LW9mZnNldCc6IDAsXG4gICAgJ3NvdXJjZS10ZXh0LW1hcmdpbi14JzogMCxcbiAgICAnc291cmNlLXRleHQtbWFyZ2luLXknOiAwLFxuICAgICd0YXJnZXQtbGFiZWwnOiAnJyxcbiAgICAndGFyZ2V0LXRleHQtb2Zmc2V0JzogMCxcbiAgICAndGFyZ2V0LXRleHQtbWFyZ2luLXgnOiAwLFxuICAgICd0YXJnZXQtdGV4dC1tYXJnaW4teSc6IDAsXG4gICAgJ292ZXJsYXktb3BhY2l0eSc6IDAsXG4gICAgJ292ZXJsYXktY29sb3InOiAnIzAwMCcsXG4gICAgJ292ZXJsYXktcGFkZGluZyc6IDEwLFxuICAgICd0cmFuc2l0aW9uLXByb3BlcnR5JzogJ25vbmUnLFxuICAgICd0cmFuc2l0aW9uLWR1cmF0aW9uJzogMCxcbiAgICAndHJhbnNpdGlvbi1kZWxheSc6IDAsXG4gICAgJ3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uJzogJ2xpbmVhcicsXG5cbiAgICAvLyBub2RlIHByb3BzXG4gICAgJ2JhY2tncm91bmQtYmxhY2tlbic6IDAsXG4gICAgJ2JhY2tncm91bmQtY29sb3InOiAnIzk5OScsXG4gICAgJ2JhY2tncm91bmQtb3BhY2l0eSc6IDEsXG4gICAgJ2JhY2tncm91bmQtaW1hZ2UnOiAnbm9uZScsXG4gICAgJ2JhY2tncm91bmQtaW1hZ2UtY3Jvc3NvcmlnaW4nOiAnYW5vbnltb3VzJyxcbiAgICAnYmFja2dyb3VuZC1pbWFnZS1vcGFjaXR5JzogMSxcbiAgICAnYmFja2dyb3VuZC1wb3NpdGlvbi14JzogJzUwJScsXG4gICAgJ2JhY2tncm91bmQtcG9zaXRpb24teSc6ICc1MCUnLFxuICAgICdiYWNrZ3JvdW5kLXdpZHRoLXJlbGF0aXZlLXRvJzogJ2luY2x1ZGUtcGFkZGluZycsXG4gICAgJ2JhY2tncm91bmQtaGVpZ2h0LXJlbGF0aXZlLXRvJzogJ2luY2x1ZGUtcGFkZGluZycsXG4gICAgJ2JhY2tncm91bmQtcmVwZWF0JzogJ25vLXJlcGVhdCcsXG4gICAgJ2JhY2tncm91bmQtZml0JzogJ25vbmUnLFxuICAgICdiYWNrZ3JvdW5kLWNsaXAnOiAnbm9kZScsXG4gICAgJ2JhY2tncm91bmQtd2lkdGgnOiAnYXV0bycsXG4gICAgJ2JhY2tncm91bmQtaGVpZ2h0JzogJ2F1dG8nLFxuICAgICdib3JkZXItY29sb3InOiAnIzAwMCcsXG4gICAgJ2JvcmRlci1vcGFjaXR5JzogMSxcbiAgICAnYm9yZGVyLXdpZHRoJzogMCxcbiAgICAnYm9yZGVyLXN0eWxlJzogJ3NvbGlkJyxcbiAgICAnaGVpZ2h0JzogMzAsXG4gICAgJ3dpZHRoJzogMzAsXG4gICAgJ3NoYXBlJzogJ2VsbGlwc2UnLFxuICAgICdzaGFwZS1wb2x5Z29uLXBvaW50cyc6ICctMSwgLTEsICAgMSwgLTEsICAgMSwgMSwgICAtMSwgMScsXG5cbiAgICAvLyBnaG9zdCBwcm9wc1xuICAgICdnaG9zdCc6ICdubycsXG4gICAgJ2dob3N0LW9mZnNldC15JzogMCxcbiAgICAnZ2hvc3Qtb2Zmc2V0LXgnOiAwLFxuICAgICdnaG9zdC1vcGFjaXR5JzogMCxcblxuICAgIC8vIGNvbXBvdW5kIHByb3BzXG4gICAgJ3BhZGRpbmcnOiAwLFxuICAgICdwYWRkaW5nLXJlbGF0aXZlLXRvJzogJ3dpZHRoJyxcbiAgICAncG9zaXRpb24nOiAnb3JpZ2luJyxcbiAgICAnY29tcG91bmQtc2l6aW5nLXdydC1sYWJlbHMnOiAnaW5jbHVkZScsXG4gICAgJ21pbi13aWR0aCc6IDAsXG4gICAgJ21pbi13aWR0aC1iaWFzLWxlZnQnOiAwLFxuICAgICdtaW4td2lkdGgtYmlhcy1yaWdodCc6IDAsXG4gICAgJ21pbi1oZWlnaHQnOiAwLFxuICAgICdtaW4taGVpZ2h0LWJpYXMtdG9wJzogMCxcbiAgICAnbWluLWhlaWdodC1iaWFzLWJvdHRvbSc6IDBcbiAgfSwge1xuICAgIC8vIG5vZGUgcGllIGJnXG4gICAgJ3BpZS1zaXplJzogJzEwMCUnXG4gIH0sIFt7IG5hbWU6ICdwaWUte3tpfX0tYmFja2dyb3VuZC1jb2xvcicsIHZhbHVlOiAnYmxhY2snIH0sIHsgbmFtZTogJ3BpZS17e2l9fS1iYWNrZ3JvdW5kLXNpemUnLCB2YWx1ZTogJzAlJyB9LCB7IG5hbWU6ICdwaWUte3tpfX0tYmFja2dyb3VuZC1vcGFjaXR5JywgdmFsdWU6IDEgfV0ucmVkdWNlKGZ1bmN0aW9uIChjc3MsIHByb3ApIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBzdHlmbi5waWVCYWNrZ3JvdW5kTjsgaSsrKSB7XG4gICAgICB2YXIgbmFtZSA9IHByb3AubmFtZS5yZXBsYWNlKCd7e2l9fScsIGkpO1xuICAgICAgdmFyIHZhbCA9IHByb3AudmFsdWU7XG5cbiAgICAgIGNzc1tuYW1lXSA9IHZhbDtcbiAgICB9XG5cbiAgICByZXR1cm4gY3NzO1xuICB9LCB7fSksIHtcbiAgICAvLyBlZGdlIHByb3BzXG4gICAgJ2xpbmUtc3R5bGUnOiAnc29saWQnLFxuICAgICdsaW5lLWNvbG9yJzogJyM5OTknLFxuICAgICdjb250cm9sLXBvaW50LXN0ZXAtc2l6ZSc6IDQwLFxuICAgICdjb250cm9sLXBvaW50LXdlaWdodHMnOiAwLjUsXG4gICAgJ3NlZ21lbnQtd2VpZ2h0cyc6IDAuNSxcbiAgICAnc2VnbWVudC1kaXN0YW5jZXMnOiAyMCxcbiAgICAnZWRnZS1kaXN0YW5jZXMnOiAnaW50ZXJzZWN0aW9uJyxcbiAgICAnY3VydmUtc3R5bGUnOiAnYmV6aWVyJyxcbiAgICAnaGF5c3RhY2stcmFkaXVzJzogMCxcbiAgICAnYXJyb3ctc2NhbGUnOiAxLFxuICAgICdsb29wLWRpcmVjdGlvbic6ICctNDVkZWcnLFxuICAgICdsb29wLXN3ZWVwJzogJy05MGRlZycsXG4gICAgJ3NvdXJjZS1kaXN0YW5jZS1mcm9tLW5vZGUnOiAwLFxuICAgICd0YXJnZXQtZGlzdGFuY2UtZnJvbS1ub2RlJzogMCxcbiAgICAnc291cmNlLWVuZHBvaW50JzogJ291dHNpZGUtdG8tbm9kZScsXG4gICAgJ3RhcmdldC1lbmRwb2ludCc6ICdvdXRzaWRlLXRvLW5vZGUnXG4gIH0sIFt7IG5hbWU6ICdhcnJvdy1zaGFwZScsIHZhbHVlOiAnbm9uZScgfSwgeyBuYW1lOiAnYXJyb3ctY29sb3InLCB2YWx1ZTogJyM5OTknIH0sIHsgbmFtZTogJ2Fycm93LWZpbGwnLCB2YWx1ZTogJ2ZpbGxlZCcgfV0ucmVkdWNlKGZ1bmN0aW9uIChjc3MsIHByb3ApIHtcbiAgICBzdHlmbi5hcnJvd1ByZWZpeGVzLmZvckVhY2goZnVuY3Rpb24gKHByZWZpeCkge1xuICAgICAgdmFyIG5hbWUgPSBwcmVmaXggKyAnLScgKyBwcm9wLm5hbWU7XG4gICAgICB2YXIgdmFsID0gcHJvcC52YWx1ZTtcblxuICAgICAgY3NzW25hbWVdID0gdmFsO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNzcztcbiAgfSwge30pKTtcblxuICB2YXIgcGFyc2VkUHJvcHMgPSB7fTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm9wID0gdGhpcy5wcm9wZXJ0aWVzW2ldO1xuXG4gICAgaWYgKHByb3AucG9pbnRzVG8pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBuYW1lID0gcHJvcC5uYW1lO1xuICAgIHZhciB2YWwgPSByYXdQcm9wc1tuYW1lXTtcbiAgICB2YXIgcGFyc2VkUHJvcCA9IHRoaXMucGFyc2UobmFtZSwgdmFsKTtcblxuICAgIHBhcnNlZFByb3BzW25hbWVdID0gcGFyc2VkUHJvcDtcbiAgfVxuXG4gIHJldHVybiBwYXJzZWRQcm9wcztcbn0pO1xuXG5zdHlmbi5hZGREZWZhdWx0U3R5bGVzaGVldCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZWxlY3RvcignJG5vZGUgPiBub2RlJykgLy8gY29tcG91bmQgKHBhcmVudCkgbm9kZSBwcm9wZXJ0aWVzXG4gIC5jc3Moe1xuICAgICdzaGFwZSc6ICdyZWN0YW5nbGUnLFxuICAgICdwYWRkaW5nJzogMTAsXG4gICAgJ2JhY2tncm91bmQtY29sb3InOiAnI2VlZScsXG4gICAgJ2JvcmRlci1jb2xvcic6ICcjY2NjJyxcbiAgICAnYm9yZGVyLXdpZHRoJzogMVxuICB9KS5zZWxlY3RvcignZWRnZScpIC8vIGp1c3QgZWRnZSBwcm9wZXJ0aWVzXG4gIC5jc3Moe1xuICAgICd3aWR0aCc6IDMsXG4gICAgJ2N1cnZlLXN0eWxlJzogJ2hheXN0YWNrJ1xuICB9KS5zZWxlY3RvcignOnBhcmVudCA8LT4gbm9kZScpLmNzcyh7XG4gICAgJ2N1cnZlLXN0eWxlJzogJ2JlemllcicsXG4gICAgJ3NvdXJjZS1lbmRwb2ludCc6ICdvdXRzaWRlLXRvLWxpbmUnLFxuICAgICd0YXJnZXQtZW5kcG9pbnQnOiAnb3V0c2lkZS10by1saW5lJ1xuICB9KS5zZWxlY3RvcignOnNlbGVjdGVkJykuY3NzKHtcbiAgICAnYmFja2dyb3VuZC1jb2xvcic6ICcjMDE2OUQ5JyxcbiAgICAnbGluZS1jb2xvcic6ICcjMDE2OUQ5JyxcbiAgICAnc291cmNlLWFycm93LWNvbG9yJzogJyMwMTY5RDknLFxuICAgICd0YXJnZXQtYXJyb3ctY29sb3InOiAnIzAxNjlEOScsXG4gICAgJ21pZC1zb3VyY2UtYXJyb3ctY29sb3InOiAnIzAxNjlEOScsXG4gICAgJ21pZC10YXJnZXQtYXJyb3ctY29sb3InOiAnIzAxNjlEOSdcbiAgfSkuc2VsZWN0b3IoJ25vZGU6cGFyZW50OnNlbGVjdGVkJykuY3NzKHtcbiAgICAnYmFja2dyb3VuZC1jb2xvcic6ICcjQ0NFMUY5JyxcbiAgICAnYm9yZGVyLWNvbG9yJzogJyNhZWM4ZTUnXG4gIH0pLnNlbGVjdG9yKCc6YWN0aXZlJykuY3NzKHtcbiAgICAnb3ZlcmxheS1jb2xvcic6ICdibGFjaycsXG4gICAgJ292ZXJsYXktcGFkZGluZyc6IDEwLFxuICAgICdvdmVybGF5LW9wYWNpdHknOiAwLjI1XG4gIH0pLnNlbGVjdG9yKCdjb3JlJykgLy8ganVzdCBjb3JlIHByb3BlcnRpZXNcbiAgLmNzcyh7XG4gICAgJ3NlbGVjdGlvbi1ib3gtY29sb3InOiAnI2RkZCcsXG4gICAgJ3NlbGVjdGlvbi1ib3gtb3BhY2l0eSc6IDAuNjUsXG4gICAgJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLWNvbG9yJzogJyNhYWEnLFxuICAgICdzZWxlY3Rpb24tYm94LWJvcmRlci13aWR0aCc6IDEsXG4gICAgJ2FjdGl2ZS1iZy1jb2xvcic6ICdibGFjaycsXG4gICAgJ2FjdGl2ZS1iZy1vcGFjaXR5JzogMC4xNSxcbiAgICAnYWN0aXZlLWJnLXNpemUnOiAzMCxcbiAgICAnb3V0c2lkZS10ZXh0dXJlLWJnLWNvbG9yJzogJyMwMDAnLFxuICAgICdvdXRzaWRlLXRleHR1cmUtYmctb3BhY2l0eSc6IDAuMTI1XG4gIH0pO1xuXG4gIHRoaXMuZGVmYXVsdExlbmd0aCA9IHRoaXMubGVuZ3RoO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdHlmbjtcblxuLyoqKi8gfSksXG4vKiA5MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG52YXIgaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIG1hdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgc3R5Zm4gPSB7fTtcblxuLy8gYSBjYWNoaW5nIGxheWVyIGZvciBwcm9wZXJ0eSBwYXJzaW5nXG5zdHlmbi5wYXJzZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgcHJvcElzQnlwYXNzLCBwcm9wSXNGbGF0KSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICAvLyBmdW5jdGlvbiB2YWx1ZXMgY2FuJ3QgYmUgY2FjaGVkIGluIGFsbCBjYXNlcywgYW5kIHRoZXJlIGlzbid0IG11Y2ggYmVuZWZpdCBvZiBjYWNoaW5nIHRoZW0gYW55d2F5XG4gIGlmIChpcy5mbih2YWx1ZSkpIHtcbiAgICByZXR1cm4gc2VsZi5wYXJzZUltcGxXYXJuKG5hbWUsIHZhbHVlLCBwcm9wSXNCeXBhc3MsIHByb3BJc0ZsYXQpO1xuICB9XG5cbiAgdmFyIGZsYXRLZXkgPSBwcm9wSXNGbGF0ID09PSAnbWFwcGluZycgfHwgcHJvcElzRmxhdCA9PT0gdHJ1ZSB8fCBwcm9wSXNGbGF0ID09PSBmYWxzZSB8fCBwcm9wSXNGbGF0ID09IG51bGwgPyAnZG9udGNhcmUnIDogcHJvcElzRmxhdDtcbiAgdmFyIGFyZ0hhc2ggPSBbbmFtZSwgdmFsdWUsIHByb3BJc0J5cGFzcywgZmxhdEtleV0uam9pbignJCcpO1xuICB2YXIgcHJvcENhY2hlID0gc2VsZi5wcm9wQ2FjaGUgPSBzZWxmLnByb3BDYWNoZSB8fCB7fTtcbiAgdmFyIHJldCA9IHZvaWQgMDtcblxuICBpZiAoIShyZXQgPSBwcm9wQ2FjaGVbYXJnSGFzaF0pKSB7XG4gICAgcmV0ID0gcHJvcENhY2hlW2FyZ0hhc2hdID0gc2VsZi5wYXJzZUltcGxXYXJuKG5hbWUsIHZhbHVlLCBwcm9wSXNCeXBhc3MsIHByb3BJc0ZsYXQpO1xuICB9XG5cbiAgLy8gLSBieXBhc3NlcyBjYW4ndCBiZSBzaGFyZWQgYi9jIHRoZSB2YWx1ZSBjYW4gYmUgY2hhbmdlZCBieSBhbmltYXRpb25zIG9yIG90aGVyd2lzZSBvdmVycmlkZGVuXG4gIC8vIC0gbWFwcGluZ3MgY2FuJ3QgYmUgc2hhcmVkIGIvYyBtYXBwaW5ncyBhcmUgcGVyLWVsZW1lbnRcbiAgaWYgKHByb3BJc0J5cGFzcyB8fCBwcm9wSXNGbGF0ID09PSAnbWFwcGluZycpIHtcbiAgICAvLyBuZWVkIGEgY29weSBzaW5jZSBwcm9wcyBhcmUgbXV0YXRlZCBsYXRlciBpbiB0aGVpciBsaWZlY3ljbGVzXG4gICAgcmV0ID0gdXRpbC5jb3B5KHJldCk7XG5cbiAgICBpZiAocmV0KSB7XG4gICAgICByZXQudmFsdWUgPSB1dGlsLmNvcHkocmV0LnZhbHVlKTsgLy8gYmVjYXVzZSBpdCBjb3VsZCBiZSBhbiBhcnJheSwgZS5nLiBjb2xvdXJcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuc3R5Zm4ucGFyc2VJbXBsV2FybiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgcHJvcElzQnlwYXNzLCBwcm9wSXNGbGF0KSB7XG4gIHZhciBwcm9wID0gdGhpcy5wYXJzZUltcGwobmFtZSwgdmFsdWUsIHByb3BJc0J5cGFzcywgcHJvcElzRmxhdCk7XG5cbiAgaWYgKCFwcm9wICYmIHZhbHVlICE9IG51bGwpIHtcbiAgICB1dGlsLmVycm9yKCdUaGUgc3R5bGUgcHJvcGVydHkgYCVzOiAlc2AgaXMgaW52YWxpZCcsIG5hbWUsIHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiBwcm9wO1xufTtcblxuLy8gcGFyc2UgYSBwcm9wZXJ0eTsgcmV0dXJuIG51bGwgb24gaW52YWxpZDsgcmV0dXJuIHBhcnNlZCBwcm9wZXJ0eSBvdGhlcndpc2Vcbi8vIGZpZWxkcyA6XG4vLyAtIG5hbWUgOiB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHlcbi8vIC0gdmFsdWUgOiB0aGUgcGFyc2VkLCBuYXRpdmUtdHlwZWQgdmFsdWUgb2YgdGhlIHByb3BlcnR5XG4vLyAtIHN0clZhbHVlIDogYSBzdHJpbmcgdmFsdWUgdGhhdCByZXByZXNlbnRzIHRoZSBwcm9wZXJ0eSB2YWx1ZSBpbiB2YWxpZCBjc3Ncbi8vIC0gYnlwYXNzIDogdHJ1ZSBpZmYgdGhlIHByb3BlcnR5IGlzIGEgYnlwYXNzIHByb3BlcnR5XG5zdHlmbi5wYXJzZUltcGwgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIHByb3BJc0J5cGFzcywgcHJvcElzRmxhdCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgbmFtZSA9IHV0aWwuY2FtZWwyZGFzaChuYW1lKTsgLy8gbWFrZSBzdXJlIHRoZSBwcm9wZXJ0eSBuYW1lIGlzIGluIGRhc2ggZm9ybSAoZS5nLiAncHJvcGVydHktbmFtZScgbm90ICdwcm9wZXJ0eU5hbWUnKVxuXG4gIHZhciBwcm9wZXJ0eSA9IHNlbGYucHJvcGVydGllc1tuYW1lXTtcbiAgdmFyIHBhc3NlZFZhbHVlID0gdmFsdWU7XG4gIHZhciB0eXBlcyA9IHNlbGYudHlwZXM7XG5cbiAgaWYgKCFwcm9wZXJ0eSkge1xuICAgIHJldHVybiBudWxsO1xuICB9IC8vIHJldHVybiBudWxsIG9uIHByb3BlcnR5IG9mIHVua25vd24gbmFtZVxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9IC8vIGNhbid0IGFzc2lnbiB1bmRlZmluZWRcblxuICAvLyB0aGUgcHJvcGVydHkgbWF5IGJlIGFuIGFsaWFzXG4gIGlmIChwcm9wZXJ0eS5hbGlhcykge1xuICAgIHByb3BlcnR5ID0gcHJvcGVydHkucG9pbnRzVG87XG4gICAgbmFtZSA9IHByb3BlcnR5Lm5hbWU7XG4gIH1cblxuICB2YXIgdmFsdWVJc1N0cmluZyA9IGlzLnN0cmluZyh2YWx1ZSk7XG4gIGlmICh2YWx1ZUlzU3RyaW5nKSB7XG4gICAgLy8gdHJpbSB0aGUgdmFsdWUgdG8gbWFrZSBwYXJzaW5nIGVhc2llclxuICAgIHZhbHVlID0gdmFsdWUudHJpbSgpO1xuICB9XG5cbiAgdmFyIHR5cGUgPSBwcm9wZXJ0eS50eXBlO1xuICBpZiAoIXR5cGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBubyB0eXBlLCBubyBsdWNrXG5cbiAgLy8gY2hlY2sgaWYgYnlwYXNzIGlzIG51bGwgb3IgZW1wdHkgc3RyaW5nIChpLmUuIGluZGljYXRpb24gdG8gZGVsZXRlIGJ5cGFzcyBwcm9wZXJ0eSlcbiAgaWYgKHByb3BJc0J5cGFzcyAmJiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSBudWxsKSkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgYnlwYXNzOiB0cnVlLFxuICAgICAgZGVsZXRlQnlwYXNzOiB0cnVlXG4gICAgfTtcbiAgfVxuXG4gIC8vIGNoZWNrIGlmIHZhbHVlIGlzIGEgZnVuY3Rpb24gdXNlZCBhcyBhIG1hcHBlclxuICBpZiAoaXMuZm4odmFsdWUpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBzdHJWYWx1ZTogJ2ZuJyxcbiAgICAgIG1hcHBlZDogdHlwZXMuZm4sXG4gICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgIH07XG4gIH1cblxuICAvLyBjaGVjayBpZiB2YWx1ZSBpcyBtYXBwZWRcbiAgdmFyIGRhdGEgPSB2b2lkIDAsXG4gICAgICBtYXBEYXRhID0gdm9pZCAwO1xuICBpZiAoIXZhbHVlSXNTdHJpbmcgfHwgcHJvcElzRmxhdCkge1xuICAgIC8vIHRoZW4gZG9uJ3QgYm90aGVyIHRvIGRvIHRoZSBleHBlbnNpdmUgcmVnZXggY2hlY2tzXG5cbiAgfSBlbHNlIGlmIChkYXRhID0gbmV3IFJlZ0V4cCh0eXBlcy5kYXRhLnJlZ2V4KS5leGVjKHZhbHVlKSkge1xuICAgIGlmIChwcm9wSXNCeXBhc3MpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIG1hcHBlcnMgbm90IGFsbG93ZWQgaW4gYnlwYXNzXG5cbiAgICB2YXIgbWFwcGVkID0gdHlwZXMuZGF0YTtcblxuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6IGRhdGEsXG4gICAgICBzdHJWYWx1ZTogJycgKyB2YWx1ZSxcbiAgICAgIG1hcHBlZDogbWFwcGVkLFxuICAgICAgZmllbGQ6IGRhdGFbMV0sXG4gICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgIH07XG4gIH0gZWxzZSBpZiAobWFwRGF0YSA9IG5ldyBSZWdFeHAodHlwZXMubWFwRGF0YS5yZWdleCkuZXhlYyh2YWx1ZSkpIHtcbiAgICBpZiAocHJvcElzQnlwYXNzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBtYXBwZXJzIG5vdCBhbGxvd2VkIGluIGJ5cGFzc1xuICAgIGlmICh0eXBlLm11bHRpcGxlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBpbXBvc3NpYmxlIHRvIG1hcCB0byBudW1cblxuICAgIHZhciBfbWFwcGVkID0gdHlwZXMubWFwRGF0YTtcblxuICAgIC8vIHdlIGNhbiBtYXAgb25seSBpZiB0aGUgdHlwZSBpcyBhIGNvbG91ciBvciBhIG51bWJlclxuICAgIGlmICghKHR5cGUuY29sb3IgfHwgdHlwZS5udW1iZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlTWluID0gdGhpcy5wYXJzZShuYW1lLCBtYXBEYXRhWzRdKTsgLy8gcGFyc2UgdG8gdmFsaWRhdGVcbiAgICBpZiAoIXZhbHVlTWluIHx8IHZhbHVlTWluLm1hcHBlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gY2FuJ3QgYmUgaW52YWxpZCBvciBtYXBwZWRcblxuICAgIHZhciB2YWx1ZU1heCA9IHRoaXMucGFyc2UobmFtZSwgbWFwRGF0YVs1XSk7IC8vIHBhcnNlIHRvIHZhbGlkYXRlXG4gICAgaWYgKCF2YWx1ZU1heCB8fCB2YWx1ZU1heC5tYXBwZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIGNhbid0IGJlIGludmFsaWQgb3IgbWFwcGVkXG5cbiAgICAvLyBjaGVjayBpZiB2YWx1ZU1pbiBhbmQgdmFsdWVNYXggYXJlIHRoZSBzYW1lXG4gICAgaWYgKHZhbHVlTWluLnZhbHVlID09PSB2YWx1ZU1heC52YWx1ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlOyAvLyBjYW4ndCBtYWtlIG11Y2ggb2YgYSBtYXBwZXIgd2l0aG91dCBhIHJhbmdlXG4gICAgfSBlbHNlIGlmICh0eXBlLmNvbG9yKSB7XG4gICAgICB2YXIgYzEgPSB2YWx1ZU1pbi52YWx1ZTtcbiAgICAgIHZhciBjMiA9IHZhbHVlTWF4LnZhbHVlO1xuXG4gICAgICB2YXIgc2FtZSA9IGMxWzBdID09PSBjMlswXSAvLyByZWRcbiAgICAgICYmIGMxWzFdID09PSBjMlsxXSAvLyBncmVlblxuICAgICAgJiYgYzFbMl0gPT09IGMyWzJdIC8vIGJsdWVcbiAgICAgICYmICggLy8gb3B0aW9uYWwgYWxwaGFcbiAgICAgIGMxWzNdID09PSBjMlszXSAvLyBzYW1lIGFscGhhIG91dHJpZ2h0XG4gICAgICB8fCAoYzFbM10gPT0gbnVsbCB8fCBjMVszXSA9PT0gMSkgJiYgKCAvLyBmdWxsIG9wYWNpdHkgZm9yIGNvbG91ciAxP1xuICAgICAgYzJbM10gPT0gbnVsbCB8fCBjMlszXSA9PT0gMSkgLy8gZnVsbCBvcGFjaXR5IGZvciBjb2xvdXIgMj9cbiAgICAgICk7XG5cbiAgICAgIGlmIChzYW1lKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gLy8gY2FuJ3QgbWFrZSBhIG1hcHBlciB3aXRob3V0IGEgcmFuZ2VcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHZhbHVlOiBtYXBEYXRhLFxuICAgICAgc3RyVmFsdWU6ICcnICsgdmFsdWUsXG4gICAgICBtYXBwZWQ6IF9tYXBwZWQsXG4gICAgICBmaWVsZDogbWFwRGF0YVsxXSxcbiAgICAgIGZpZWxkTWluOiBwYXJzZUZsb2F0KG1hcERhdGFbMl0pLCAvLyBtaW4gJiBtYXggYXJlIG51bWVyaWNcbiAgICAgIGZpZWxkTWF4OiBwYXJzZUZsb2F0KG1hcERhdGFbM10pLFxuICAgICAgdmFsdWVNaW46IHZhbHVlTWluLnZhbHVlLFxuICAgICAgdmFsdWVNYXg6IHZhbHVlTWF4LnZhbHVlLFxuICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICB9O1xuICB9XG5cbiAgaWYgKHR5cGUubXVsdGlwbGUgJiYgcHJvcElzRmxhdCAhPT0gJ211bHRpcGxlJykge1xuICAgIHZhciB2YWxzID0gdm9pZCAwO1xuXG4gICAgaWYgKHZhbHVlSXNTdHJpbmcpIHtcbiAgICAgIHZhbHMgPSB2YWx1ZS5zcGxpdCgvXFxzKy8pO1xuICAgIH0gZWxzZSBpZiAoaXMuYXJyYXkodmFsdWUpKSB7XG4gICAgICB2YWxzID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHMgPSBbdmFsdWVdO1xuICAgIH1cblxuICAgIGlmICh0eXBlLmV2ZW5NdWx0aXBsZSAmJiB2YWxzLmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciB2YWxBcnIgPSBbXTtcbiAgICB2YXIgdW5pdHNBcnIgPSBbXTtcbiAgICB2YXIgcGZWYWxBcnIgPSBbXTtcbiAgICB2YXIgaGFzRW51bSA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcCA9IHNlbGYucGFyc2UobmFtZSwgdmFsc1tpXSwgcHJvcElzQnlwYXNzLCAnbXVsdGlwbGUnKTtcblxuICAgICAgaGFzRW51bSA9IGhhc0VudW0gfHwgaXMuc3RyaW5nKHAudmFsdWUpO1xuXG4gICAgICB2YWxBcnIucHVzaChwLnZhbHVlKTtcbiAgICAgIHBmVmFsQXJyLnB1c2gocC5wZlZhbHVlICE9IG51bGwgPyBwLnBmVmFsdWUgOiBwLnZhbHVlKTtcbiAgICAgIHVuaXRzQXJyLnB1c2gocC51bml0cyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUudmFsaWRhdGUgJiYgIXR5cGUudmFsaWRhdGUodmFsQXJyLCB1bml0c0FycikpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICh0eXBlLnNpbmdsZUVudW0gJiYgaGFzRW51bSkge1xuICAgICAgaWYgKHZhbEFyci5sZW5ndGggPT09IDEgJiYgaXMuc3RyaW5nKHZhbEFyclswXSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgIHZhbHVlOiB2YWxBcnJbMF0sXG4gICAgICAgICAgc3RyVmFsdWU6IHZhbEFyclswXSxcbiAgICAgICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogdmFsQXJyLFxuICAgICAgcGZWYWx1ZTogcGZWYWxBcnIsXG4gICAgICBzdHJWYWx1ZTogdmFsQXJyLm1hcChmdW5jdGlvbiAodmFsLCBpKSB7XG4gICAgICAgIHJldHVybiB2YWwgKyAodW5pdHNBcnJbaV0gfHwgJycpO1xuICAgICAgfSkuam9pbignICcpLFxuICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3MsXG4gICAgICB1bml0czogdW5pdHNBcnJcbiAgICB9O1xuICB9XG5cbiAgLy8gc2V2ZXJhbCB0eXBlcyBhbHNvIGFsbG93IGVudW1zXG4gIHZhciBjaGVja0VudW1zID0gZnVuY3Rpb24gY2hlY2tFbnVtcygpIHtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdHlwZS5lbnVtcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBlbiA9IHR5cGUuZW51bXNbX2ldO1xuXG4gICAgICBpZiAoZW4gPT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgc3RyVmFsdWU6ICcnICsgdmFsdWUsXG4gICAgICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvLyBjaGVjayB0aGUgdHlwZSBhbmQgcmV0dXJuIHRoZSBhcHByb3ByaWF0ZSBvYmplY3RcbiAgaWYgKHR5cGUubnVtYmVyKSB7XG4gICAgdmFyIHVuaXRzID0gdm9pZCAwO1xuICAgIHZhciBpbXBsaWNpdFVuaXRzID0gJ3B4JzsgLy8gbm90IHNldCA9PiBweFxuXG4gICAgaWYgKHR5cGUudW5pdHMpIHtcbiAgICAgIC8vIHVzZSBzcGVjaWZpZWQgdW5pdHMgaWYgc2V0XG4gICAgICB1bml0cyA9IHR5cGUudW5pdHM7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUuaW1wbGljaXRVbml0cykge1xuICAgICAgaW1wbGljaXRVbml0cyA9IHR5cGUuaW1wbGljaXRVbml0cztcbiAgICB9XG5cbiAgICBpZiAoIXR5cGUudW5pdGxlc3MpIHtcbiAgICAgIGlmICh2YWx1ZUlzU3RyaW5nKSB7XG4gICAgICAgIHZhciB1bml0c1JlZ2V4ID0gJ3B4fGVtJyArICh0eXBlLmFsbG93UGVyY2VudCA/ICd8XFxcXCUnIDogJycpO1xuICAgICAgICBpZiAodW5pdHMpIHtcbiAgICAgICAgICB1bml0c1JlZ2V4ID0gdW5pdHM7XG4gICAgICAgIH0gLy8gb25seSBhbGxvdyBleHBsaWNpdCB1bml0cyBpZiBzbyBzZXRcbiAgICAgICAgdmFyIG1hdGNoID0gdmFsdWUubWF0Y2goJ14oJyArIHV0aWwucmVnZXgubnVtYmVyICsgJykoJyArIHVuaXRzUmVnZXggKyAnKT8nICsgJyQnKTtcblxuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICB2YWx1ZSA9IG1hdGNoWzFdO1xuICAgICAgICAgIHVuaXRzID0gbWF0Y2hbMl0gfHwgaW1wbGljaXRVbml0cztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghdW5pdHMgfHwgdHlwZS5pbXBsaWNpdFVuaXRzKSB7XG4gICAgICAgIHVuaXRzID0gaW1wbGljaXRVbml0czsgLy8gaW1wbGljaXRseSBweCBpZiB1bnNwZWNpZmllZFxuICAgICAgfVxuICAgIH1cblxuICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG5cbiAgICAvLyBpZiBub3QgYSBudW1iZXIgYW5kIGVudW1zIG5vdCBhbGxvd2VkLCB0aGVuIHRoZSB2YWx1ZSBpcyBpbnZhbGlkXG4gICAgaWYgKGlzTmFOKHZhbHVlKSAmJiB0eXBlLmVudW1zID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGlmIHRoaXMgbnVtYmVyIHR5cGUgYWxzbyBhY2NlcHRzIHNwZWNpYWwga2V5d29yZHMgaW4gcGxhY2Ugb2YgbnVtYmVyc1xuICAgIC8vIChpLmUuIGBsZWZ0YCwgYGF1dG9gLCBldGMpXG4gICAgaWYgKGlzTmFOKHZhbHVlKSAmJiB0eXBlLmVudW1zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhbHVlID0gcGFzc2VkVmFsdWU7XG5cbiAgICAgIHJldHVybiBjaGVja0VudW1zKCk7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgaWYgdmFsdWUgbXVzdCBiZSBhbiBpbnRlZ2VyXG4gICAgaWYgKHR5cGUuaW50ZWdlciAmJiAhaXMuaW50ZWdlcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIHZhbHVlIGlzIHdpdGhpbiByYW5nZVxuICAgIGlmICh0eXBlLm1pbiAhPT0gdW5kZWZpbmVkICYmICh2YWx1ZSA8IHR5cGUubWluIHx8IHR5cGUuc3RyaWN0TWluICYmIHZhbHVlID09PSB0eXBlLm1pbikgfHwgdHlwZS5tYXggIT09IHVuZGVmaW5lZCAmJiAodmFsdWUgPiB0eXBlLm1heCB8fCB0eXBlLnN0cmljdE1heCAmJiB2YWx1ZSA9PT0gdHlwZS5tYXgpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgcmV0ID0ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIHN0clZhbHVlOiAnJyArIHZhbHVlICsgKHVuaXRzID8gdW5pdHMgOiAnJyksXG4gICAgICB1bml0czogdW5pdHMsXG4gICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgIH07XG5cbiAgICAvLyBub3JtYWxpc2UgdmFsdWUgaW4gcGl4ZWxzXG4gICAgaWYgKHR5cGUudW5pdGxlc3MgfHwgdW5pdHMgIT09ICdweCcgJiYgdW5pdHMgIT09ICdlbScpIHtcbiAgICAgIHJldC5wZlZhbHVlID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldC5wZlZhbHVlID0gdW5pdHMgPT09ICdweCcgfHwgIXVuaXRzID8gdmFsdWUgOiB0aGlzLmdldEVtU2l6ZUluUGl4ZWxzKCkgKiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvLyBub3JtYWxpc2UgdmFsdWUgaW4gbXNcbiAgICBpZiAodW5pdHMgPT09ICdtcycgfHwgdW5pdHMgPT09ICdzJykge1xuICAgICAgcmV0LnBmVmFsdWUgPSB1bml0cyA9PT0gJ21zJyA/IHZhbHVlIDogMTAwMCAqIHZhbHVlO1xuICAgIH1cblxuICAgIC8vIG5vcm1hbGlzZSB2YWx1ZSBpbiByYWRcbiAgICBpZiAodW5pdHMgPT09ICdkZWcnIHx8IHVuaXRzID09PSAncmFkJykge1xuICAgICAgcmV0LnBmVmFsdWUgPSB1bml0cyA9PT0gJ3JhZCcgPyB2YWx1ZSA6IG1hdGguZGVnMnJhZCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLy8gbm9ybWFsaXplIHZhbHVlIGluICVcbiAgICBpZiAodW5pdHMgPT09ICclJykge1xuICAgICAgcmV0LnBmVmFsdWUgPSB2YWx1ZSAvIDEwMDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9IGVsc2UgaWYgKHR5cGUucHJvcExpc3QpIHtcblxuICAgIHZhciBwcm9wcyA9IFtdO1xuICAgIHZhciBwcm9wc1N0ciA9ICcnICsgdmFsdWU7XG5cbiAgICBpZiAocHJvcHNTdHIgPT09ICdub25lJykge1xuICAgICAgLy8gbGVhdmUgZW1wdHlcblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBnbyBvdmVyIGVhY2ggcHJvcFxuXG4gICAgICB2YXIgcHJvcHNTcGxpdCA9IHByb3BzU3RyLnNwbGl0KCcsJyk7XG4gICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBwcm9wc1NwbGl0Lmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgdmFyIHByb3BOYW1lID0gcHJvcHNTcGxpdFtfaTJdLnRyaW0oKTtcblxuICAgICAgICBpZiAoc2VsZi5wcm9wZXJ0aWVzW3Byb3BOYW1lXSkge1xuICAgICAgICAgIHByb3BzLnB1c2gocHJvcE5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9wcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogcHJvcHMsXG4gICAgICBzdHJWYWx1ZTogcHJvcHMubGVuZ3RoID09PSAwID8gJ25vbmUnIDogcHJvcHMuam9pbignLCAnKSxcbiAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgfTtcbiAgfSBlbHNlIGlmICh0eXBlLmNvbG9yKSB7XG4gICAgdmFyIHR1cGxlID0gdXRpbC5jb2xvcjJ0dXBsZSh2YWx1ZSk7XG5cbiAgICBpZiAoIXR1cGxlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHZhbHVlOiB0dXBsZSxcbiAgICAgIHBmVmFsdWU6IHR1cGxlLFxuICAgICAgc3RyVmFsdWU6ICcnICsgdmFsdWUsXG4gICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgIH07XG4gIH0gZWxzZSBpZiAodHlwZS5yZWdleCB8fCB0eXBlLnJlZ2V4ZXMpIHtcblxuICAgIC8vIGZpcnN0IGNoZWNrIGVudW1zXG4gICAgaWYgKHR5cGUuZW51bXMpIHtcbiAgICAgIHZhciBlbnVtUHJvcCA9IGNoZWNrRW51bXMoKTtcblxuICAgICAgaWYgKGVudW1Qcm9wKSB7XG4gICAgICAgIHJldHVybiBlbnVtUHJvcDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVnZXhlcyA9IHR5cGUucmVnZXhlcyA/IHR5cGUucmVnZXhlcyA6IFt0eXBlLnJlZ2V4XTtcblxuICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IHJlZ2V4ZXMubGVuZ3RoOyBfaTMrKykge1xuICAgICAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cChyZWdleGVzW19pM10pOyAvLyBtYWtlIGEgcmVnZXggZnJvbSB0aGUgdHlwZSBzdHJpbmdcbiAgICAgIHZhciBtID0gcmVnZXguZXhlYyh2YWx1ZSk7XG5cbiAgICAgIGlmIChtKSB7XG4gICAgICAgIC8vIHJlZ2V4IG1hdGNoZXNcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgIHZhbHVlOiB0eXBlLnNpbmdsZVJlZ2V4TWF0Y2hWYWx1ZSA/IG1bMV0gOiBtLFxuICAgICAgICAgIHN0clZhbHVlOiAnJyArIHZhbHVlLFxuICAgICAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7IC8vIGRpZG4ndCBtYXRjaCBhbnlcbiAgfSBlbHNlIGlmICh0eXBlLnN0cmluZykge1xuICAgIC8vIGp1c3QgcmV0dXJuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogJycgKyB2YWx1ZSxcbiAgICAgIHN0clZhbHVlOiAnJyArIHZhbHVlLFxuICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICB9O1xuICB9IGVsc2UgaWYgKHR5cGUuZW51bXMpIHtcbiAgICAvLyBjaGVjayBlbnVtcyBsYXN0IGJlY2F1c2UgaXQncyBhIGNvbWJvIHR5cGUgaW4gb3RoZXJzXG4gICAgcmV0dXJuIGNoZWNrRW51bXMoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDsgLy8gbm90IGEgdHlwZSB3ZSBjYW4gaGFuZGxlXG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gc3R5Zm47XG5cbi8qKiovIH0pLFxuLyogOTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciB3aW5kb3cgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xudmFyIG1hdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgY29yZWZuID0ge1xuXG4gIGF1dG9sb2NrOiBmdW5jdGlvbiBhdXRvbG9jayhib29sKSB7XG4gICAgaWYgKGJvb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fcHJpdmF0ZS5hdXRvbG9jayA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmF1dG9sb2NrO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIGF1dG91bmdyYWJpZnk6IGZ1bmN0aW9uIGF1dG91bmdyYWJpZnkoYm9vbCkge1xuICAgIGlmIChib29sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX3ByaXZhdGUuYXV0b3VuZ3JhYmlmeSA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmF1dG91bmdyYWJpZnk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgYXV0b3Vuc2VsZWN0aWZ5OiBmdW5jdGlvbiBhdXRvdW5zZWxlY3RpZnkoYm9vbCkge1xuICAgIGlmIChib29sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX3ByaXZhdGUuYXV0b3Vuc2VsZWN0aWZ5ID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuYXV0b3Vuc2VsZWN0aWZ5O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIHBhbm5pbmdFbmFibGVkOiBmdW5jdGlvbiBwYW5uaW5nRW5hYmxlZChib29sKSB7XG4gICAgaWYgKGJvb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIHVzZXJQYW5uaW5nRW5hYmxlZDogZnVuY3Rpb24gdXNlclBhbm5pbmdFbmFibGVkKGJvb2wpIHtcbiAgICBpZiAoYm9vbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9wcml2YXRlLnVzZXJQYW5uaW5nRW5hYmxlZCA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnVzZXJQYW5uaW5nRW5hYmxlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICB6b29taW5nRW5hYmxlZDogZnVuY3Rpb24gem9vbWluZ0VuYWJsZWQoYm9vbCkge1xuICAgIGlmIChib29sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX3ByaXZhdGUuem9vbWluZ0VuYWJsZWQgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS56b29taW5nRW5hYmxlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICB1c2VyWm9vbWluZ0VuYWJsZWQ6IGZ1bmN0aW9uIHVzZXJab29taW5nRW5hYmxlZChib29sKSB7XG4gICAgaWYgKGJvb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fcHJpdmF0ZS51c2VyWm9vbWluZ0VuYWJsZWQgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS51c2VyWm9vbWluZ0VuYWJsZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgYm94U2VsZWN0aW9uRW5hYmxlZDogZnVuY3Rpb24gYm94U2VsZWN0aW9uRW5hYmxlZChib29sKSB7XG4gICAgaWYgKGJvb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fcHJpdmF0ZS5ib3hTZWxlY3Rpb25FbmFibGVkID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuYm94U2VsZWN0aW9uRW5hYmxlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICBwYW46IGZ1bmN0aW9uIHBhbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICB2YXIgcGFuID0gdGhpcy5fcHJpdmF0ZS5wYW47XG4gICAgdmFyIGRpbSA9IHZvaWQgMCxcbiAgICAgICAgdmFsID0gdm9pZCAwLFxuICAgICAgICBkaW1zID0gdm9pZCAwLFxuICAgICAgICB4ID0gdm9pZCAwLFxuICAgICAgICB5ID0gdm9pZCAwO1xuXG4gICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICAvLyAucGFuKClcbiAgICAgICAgcmV0dXJuIHBhbjtcblxuICAgICAgY2FzZSAxOlxuXG4gICAgICAgIGlmIChpcy5zdHJpbmcoYXJnc1swXSkpIHtcbiAgICAgICAgICAvLyAucGFuKCd4JylcbiAgICAgICAgICBkaW0gPSBhcmdzWzBdO1xuICAgICAgICAgIHJldHVybiBwYW5bZGltXTtcbiAgICAgICAgfSBlbHNlIGlmIChpcy5wbGFpbk9iamVjdChhcmdzWzBdKSkge1xuICAgICAgICAgIC8vIC5wYW4oeyB4OiAwLCB5OiAxMDAgfSlcbiAgICAgICAgICBpZiAoIXRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRpbXMgPSBhcmdzWzBdO1xuICAgICAgICAgIHggPSBkaW1zLng7XG4gICAgICAgICAgeSA9IGRpbXMueTtcblxuICAgICAgICAgIGlmIChpcy5udW1iZXIoeCkpIHtcbiAgICAgICAgICAgIHBhbi54ID0geDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXMubnVtYmVyKHkpKSB7XG4gICAgICAgICAgICBwYW4ueSA9IHk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5lbWl0KCdwYW4gdmlld3BvcnQnKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAyOlxuICAgICAgICAvLyAucGFuKCd4JywgMTAwKVxuICAgICAgICBpZiAoIXRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGRpbSA9IGFyZ3NbMF07XG4gICAgICAgIHZhbCA9IGFyZ3NbMV07XG5cbiAgICAgICAgaWYgKChkaW0gPT09ICd4JyB8fCBkaW0gPT09ICd5JykgJiYgaXMubnVtYmVyKHZhbCkpIHtcbiAgICAgICAgICBwYW5bZGltXSA9IHZhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZW1pdCgncGFuIHZpZXdwb3J0Jyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhazsgLy8gaW52YWxpZFxuICAgIH1cblxuICAgIHRoaXMubm90aWZ5KHsgLy8gbm90aWZ5IHRoZSByZW5kZXJlciB0aGF0IHRoZSB2aWV3cG9ydCBjaGFuZ2VkXG4gICAgICB0eXBlOiAndmlld3BvcnQnXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICBwYW5CeTogZnVuY3Rpb24gcGFuQnkoYXJnMCwgYXJnMSkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHZhciBwYW4gPSB0aGlzLl9wcml2YXRlLnBhbjtcbiAgICB2YXIgZGltID0gdm9pZCAwLFxuICAgICAgICB2YWwgPSB2b2lkIDAsXG4gICAgICAgIGRpbXMgPSB2b2lkIDAsXG4gICAgICAgIHggPSB2b2lkIDAsXG4gICAgICAgIHkgPSB2b2lkIDA7XG5cbiAgICBpZiAoIXRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMTpcblxuICAgICAgICBpZiAoaXMucGxhaW5PYmplY3QoYXJnMCkpIHtcbiAgICAgICAgICAvLyAucGFuQnkoeyB4OiAwLCB5OiAxMDAgfSlcbiAgICAgICAgICBkaW1zID0gYXJnc1swXTtcbiAgICAgICAgICB4ID0gZGltcy54O1xuICAgICAgICAgIHkgPSBkaW1zLnk7XG5cbiAgICAgICAgICBpZiAoaXMubnVtYmVyKHgpKSB7XG4gICAgICAgICAgICBwYW4ueCArPSB4O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpcy5udW1iZXIoeSkpIHtcbiAgICAgICAgICAgIHBhbi55ICs9IHk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5lbWl0KCdwYW4gdmlld3BvcnQnKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAyOlxuICAgICAgICAvLyAucGFuQnkoJ3gnLCAxMDApXG4gICAgICAgIGRpbSA9IGFyZzA7XG4gICAgICAgIHZhbCA9IGFyZzE7XG5cbiAgICAgICAgaWYgKChkaW0gPT09ICd4JyB8fCBkaW0gPT09ICd5JykgJiYgaXMubnVtYmVyKHZhbCkpIHtcbiAgICAgICAgICBwYW5bZGltXSArPSB2YWw7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVtaXQoJ3BhbiB2aWV3cG9ydCcpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7IC8vIGludmFsaWRcbiAgICB9XG5cbiAgICB0aGlzLm5vdGlmeSh7IC8vIG5vdGlmeSB0aGUgcmVuZGVyZXIgdGhhdCB0aGUgdmlld3BvcnQgY2hhbmdlZFxuICAgICAgdHlwZTogJ3ZpZXdwb3J0J1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgZml0OiBmdW5jdGlvbiBmaXQoZWxlbWVudHMsIHBhZGRpbmcpIHtcbiAgICB2YXIgdmlld3BvcnRTdGF0ZSA9IHRoaXMuZ2V0Rml0Vmlld3BvcnQoZWxlbWVudHMsIHBhZGRpbmcpO1xuXG4gICAgaWYgKHZpZXdwb3J0U3RhdGUpIHtcbiAgICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgICBfcC56b29tID0gdmlld3BvcnRTdGF0ZS56b29tO1xuICAgICAgX3AucGFuID0gdmlld3BvcnRTdGF0ZS5wYW47XG5cbiAgICAgIHRoaXMuZW1pdCgncGFuIHpvb20gdmlld3BvcnQnKTtcblxuICAgICAgdGhpcy5ub3RpZnkoeyAvLyBub3RpZnkgdGhlIHJlbmRlcmVyIHRoYXQgdGhlIHZpZXdwb3J0IGNoYW5nZWRcbiAgICAgICAgdHlwZTogJ3ZpZXdwb3J0J1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgZ2V0Rml0Vmlld3BvcnQ6IGZ1bmN0aW9uIGdldEZpdFZpZXdwb3J0KGVsZW1lbnRzLCBwYWRkaW5nKSB7XG4gICAgaWYgKGlzLm51bWJlcihlbGVtZW50cykgJiYgcGFkZGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBlbGVtZW50cyBpcyBvcHRpb25hbFxuICAgICAgcGFkZGluZyA9IGVsZW1lbnRzO1xuICAgICAgZWxlbWVudHMgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkIHx8ICF0aGlzLl9wcml2YXRlLnpvb21pbmdFbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGJiID0gdm9pZCAwO1xuXG4gICAgaWYgKGlzLnN0cmluZyhlbGVtZW50cykpIHtcbiAgICAgIHZhciBzZWwgPSBlbGVtZW50cztcbiAgICAgIGVsZW1lbnRzID0gdGhpcy4kKHNlbCk7XG4gICAgfSBlbHNlIGlmIChpcy5ib3VuZGluZ0JveChlbGVtZW50cykpIHtcbiAgICAgIC8vIGFzc3VtZSBiYlxuICAgICAgdmFyIGJiZSA9IGVsZW1lbnRzO1xuICAgICAgYmIgPSB7XG4gICAgICAgIHgxOiBiYmUueDEsXG4gICAgICAgIHkxOiBiYmUueTEsXG4gICAgICAgIHgyOiBiYmUueDIsXG4gICAgICAgIHkyOiBiYmUueTJcbiAgICAgIH07XG5cbiAgICAgIGJiLncgPSBiYi54MiAtIGJiLngxO1xuICAgICAgYmIuaCA9IGJiLnkyIC0gYmIueTE7XG4gICAgfSBlbHNlIGlmICghaXMuZWxlbWVudE9yQ29sbGVjdGlvbihlbGVtZW50cykpIHtcbiAgICAgIGVsZW1lbnRzID0gdGhpcy5tdXRhYmxlRWxlbWVudHMoKTtcbiAgICB9XG5cbiAgICBpZiAoaXMuZWxlbWVudE9yQ29sbGVjdGlvbihlbGVtZW50cykgJiYgZWxlbWVudHMuZW1wdHkoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gY2FuJ3QgZml0IHRvIG5vdGhpbmdcblxuICAgIGJiID0gYmIgfHwgZWxlbWVudHMuYm91bmRpbmdCb3goKTtcblxuICAgIHZhciB3ID0gdGhpcy53aWR0aCgpO1xuICAgIHZhciBoID0gdGhpcy5oZWlnaHQoKTtcbiAgICB2YXIgem9vbSA9IHZvaWQgMDtcbiAgICBwYWRkaW5nID0gaXMubnVtYmVyKHBhZGRpbmcpID8gcGFkZGluZyA6IDA7XG5cbiAgICBpZiAoIWlzTmFOKHcpICYmICFpc05hTihoKSAmJiB3ID4gMCAmJiBoID4gMCAmJiAhaXNOYU4oYmIudykgJiYgIWlzTmFOKGJiLmgpICYmIGJiLncgPiAwICYmIGJiLmggPiAwKSB7XG4gICAgICB6b29tID0gTWF0aC5taW4oKHcgLSAyICogcGFkZGluZykgLyBiYi53LCAoaCAtIDIgKiBwYWRkaW5nKSAvIGJiLmgpO1xuXG4gICAgICAvLyBjcm9wIHpvb21cbiAgICAgIHpvb20gPSB6b29tID4gdGhpcy5fcHJpdmF0ZS5tYXhab29tID8gdGhpcy5fcHJpdmF0ZS5tYXhab29tIDogem9vbTtcbiAgICAgIHpvb20gPSB6b29tIDwgdGhpcy5fcHJpdmF0ZS5taW5ab29tID8gdGhpcy5fcHJpdmF0ZS5taW5ab29tIDogem9vbTtcblxuICAgICAgdmFyIHBhbiA9IHsgLy8gbm93IHBhbiB0byBtaWRkbGVcbiAgICAgICAgeDogKHcgLSB6b29tICogKGJiLngxICsgYmIueDIpKSAvIDIsXG4gICAgICAgIHk6IChoIC0gem9vbSAqIChiYi55MSArIGJiLnkyKSkgLyAyXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB6b29tOiB6b29tLFxuICAgICAgICBwYW46IHBhblxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH0sXG5cbiAgbWluWm9vbTogZnVuY3Rpb24gbWluWm9vbSh6b29tKSB7XG4gICAgaWYgKHpvb20gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUubWluWm9vbTtcbiAgICB9IGVsc2UgaWYgKGlzLm51bWJlcih6b29tKSkge1xuICAgICAgdGhpcy5fcHJpdmF0ZS5taW5ab29tID0gem9vbTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBtYXhab29tOiBmdW5jdGlvbiBtYXhab29tKHpvb20pIHtcbiAgICBpZiAoem9vbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5tYXhab29tO1xuICAgIH0gZWxzZSBpZiAoaXMubnVtYmVyKHpvb20pKSB7XG4gICAgICB0aGlzLl9wcml2YXRlLm1heFpvb20gPSB6b29tO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGdldFpvb21lZFZpZXdwb3J0OiBmdW5jdGlvbiBnZXRab29tZWRWaWV3cG9ydChwYXJhbXMpIHtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIHZhciBjdXJyZW50UGFuID0gX3AucGFuO1xuICAgIHZhciBjdXJyZW50Wm9vbSA9IF9wLnpvb207XG4gICAgdmFyIHBvcyA9IHZvaWQgMDsgLy8gaW4gcmVuZGVyZWQgcHhcbiAgICB2YXIgem9vbSA9IHZvaWQgMDtcbiAgICB2YXIgYmFpbCA9IGZhbHNlO1xuXG4gICAgaWYgKCFfcC56b29taW5nRW5hYmxlZCkge1xuICAgICAgLy8gem9vbWluZyBkaXNhYmxlZFxuICAgICAgYmFpbCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGlzLm51bWJlcihwYXJhbXMpKSB7XG4gICAgICAvLyB0aGVuIHNldCB0aGUgem9vbVxuICAgICAgem9vbSA9IHBhcmFtcztcbiAgICB9IGVsc2UgaWYgKGlzLnBsYWluT2JqZWN0KHBhcmFtcykpIHtcbiAgICAgIC8vIHRoZW4gem9vbSBhYm91dCBhIHBvaW50XG4gICAgICB6b29tID0gcGFyYW1zLmxldmVsO1xuXG4gICAgICBpZiAocGFyYW1zLnBvc2l0aW9uICE9IG51bGwpIHtcbiAgICAgICAgcG9zID0gbWF0aC5tb2RlbFRvUmVuZGVyZWRQb3NpdGlvbihwYXJhbXMucG9zaXRpb24sIGN1cnJlbnRab29tLCBjdXJyZW50UGFuKTtcbiAgICAgIH0gZWxzZSBpZiAocGFyYW1zLnJlbmRlcmVkUG9zaXRpb24gIT0gbnVsbCkge1xuICAgICAgICBwb3MgPSBwYXJhbXMucmVuZGVyZWRQb3NpdGlvbjtcbiAgICAgIH1cblxuICAgICAgaWYgKHBvcyAhPSBudWxsICYmICFfcC5wYW5uaW5nRW5hYmxlZCkge1xuICAgICAgICAvLyBwYW5uaW5nIGRpc2FibGVkXG4gICAgICAgIGJhaWwgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNyb3Agem9vbVxuICAgIHpvb20gPSB6b29tID4gX3AubWF4Wm9vbSA/IF9wLm1heFpvb20gOiB6b29tO1xuICAgIHpvb20gPSB6b29tIDwgX3AubWluWm9vbSA/IF9wLm1pblpvb20gOiB6b29tO1xuXG4gICAgLy8gY2FuJ3Qgem9vbSB3aXRoIGludmFsaWQgcGFyYW1zXG4gICAgaWYgKGJhaWwgfHwgIWlzLm51bWJlcih6b29tKSB8fCB6b29tID09PSBjdXJyZW50Wm9vbSB8fCBwb3MgIT0gbnVsbCAmJiAoIWlzLm51bWJlcihwb3MueCkgfHwgIWlzLm51bWJlcihwb3MueSkpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAocG9zICE9IG51bGwpIHtcbiAgICAgIC8vIHNldCB6b29tIGFib3V0IHBvc2l0aW9uXG4gICAgICB2YXIgcGFuMSA9IGN1cnJlbnRQYW47XG4gICAgICB2YXIgem9vbTEgPSBjdXJyZW50Wm9vbTtcbiAgICAgIHZhciB6b29tMiA9IHpvb207XG5cbiAgICAgIHZhciBwYW4yID0ge1xuICAgICAgICB4OiAtem9vbTIgLyB6b29tMSAqIChwb3MueCAtIHBhbjEueCkgKyBwb3MueCxcbiAgICAgICAgeTogLXpvb20yIC8gem9vbTEgKiAocG9zLnkgLSBwYW4xLnkpICsgcG9zLnlcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHpvb21lZDogdHJ1ZSxcbiAgICAgICAgcGFubmVkOiB0cnVlLFxuICAgICAgICB6b29tOiB6b29tMixcbiAgICAgICAgcGFuOiBwYW4yXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBqdXN0IHNldCB0aGUgem9vbVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgem9vbWVkOiB0cnVlLFxuICAgICAgICBwYW5uZWQ6IGZhbHNlLFxuICAgICAgICB6b29tOiB6b29tLFxuICAgICAgICBwYW46IGN1cnJlbnRQYW5cbiAgICAgIH07XG4gICAgfVxuICB9LFxuXG4gIHpvb206IGZ1bmN0aW9uIHpvb20ocGFyYW1zKSB7XG4gICAgaWYgKHBhcmFtcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBnZXRcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnpvb207XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHNldFxuICAgICAgdmFyIHZwID0gdGhpcy5nZXRab29tZWRWaWV3cG9ydChwYXJhbXMpO1xuICAgICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcblxuICAgICAgaWYgKHZwID09IG51bGwgfHwgIXZwLnpvb21lZCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgX3Auem9vbSA9IHZwLnpvb207XG5cbiAgICAgIGlmICh2cC5wYW5uZWQpIHtcbiAgICAgICAgX3AucGFuLnggPSB2cC5wYW4ueDtcbiAgICAgICAgX3AucGFuLnkgPSB2cC5wYW4ueTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5lbWl0KCd6b29tJyArICh2cC5wYW5uZWQgPyAnIHBhbicgOiAnJykgKyAnIHZpZXdwb3J0Jyk7XG5cbiAgICAgIHRoaXMubm90aWZ5KHsgLy8gbm90aWZ5IHRoZSByZW5kZXJlciB0aGF0IHRoZSB2aWV3cG9ydCBjaGFuZ2VkXG4gICAgICAgIHR5cGU6ICd2aWV3cG9ydCdcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9XG4gIH0sXG5cbiAgdmlld3BvcnQ6IGZ1bmN0aW9uIHZpZXdwb3J0KG9wdHMpIHtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIHZhciB6b29tRGVmZCA9IHRydWU7XG4gICAgdmFyIHBhbkRlZmQgPSB0cnVlO1xuICAgIHZhciBldmVudHMgPSBbXTsgLy8gdG8gdHJpZ2dlclxuICAgIHZhciB6b29tRmFpbGVkID0gZmFsc2U7XG4gICAgdmFyIHBhbkZhaWxlZCA9IGZhbHNlO1xuXG4gICAgaWYgKCFvcHRzKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKCFpcy5udW1iZXIob3B0cy56b29tKSkge1xuICAgICAgem9vbURlZmQgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFpcy5wbGFpbk9iamVjdChvcHRzLnBhbikpIHtcbiAgICAgIHBhbkRlZmQgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCF6b29tRGVmZCAmJiAhcGFuRGVmZCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKHpvb21EZWZkKSB7XG4gICAgICB2YXIgeiA9IG9wdHMuem9vbTtcblxuICAgICAgaWYgKHogPCBfcC5taW5ab29tIHx8IHogPiBfcC5tYXhab29tIHx8ICFfcC56b29taW5nRW5hYmxlZCkge1xuICAgICAgICB6b29tRmFpbGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9wLnpvb20gPSB6O1xuXG4gICAgICAgIGV2ZW50cy5wdXNoKCd6b29tJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBhbkRlZmQgJiYgKCF6b29tRmFpbGVkIHx8ICFvcHRzLmNhbmNlbE9uRmFpbGVkWm9vbSkgJiYgX3AucGFubmluZ0VuYWJsZWQpIHtcbiAgICAgIHZhciBwID0gb3B0cy5wYW47XG5cbiAgICAgIGlmIChpcy5udW1iZXIocC54KSkge1xuICAgICAgICBfcC5wYW4ueCA9IHAueDtcbiAgICAgICAgcGFuRmFpbGVkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChpcy5udW1iZXIocC55KSkge1xuICAgICAgICBfcC5wYW4ueSA9IHAueTtcbiAgICAgICAgcGFuRmFpbGVkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICghcGFuRmFpbGVkKSB7XG4gICAgICAgIGV2ZW50cy5wdXNoKCdwYW4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZXZlbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIGV2ZW50cy5wdXNoKCd2aWV3cG9ydCcpO1xuICAgICAgdGhpcy5lbWl0KGV2ZW50cy5qb2luKCcgJykpO1xuXG4gICAgICB0aGlzLm5vdGlmeSh7XG4gICAgICAgIHR5cGU6ICd2aWV3cG9ydCdcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIGNlbnRlcjogZnVuY3Rpb24gY2VudGVyKGVsZW1lbnRzKSB7XG4gICAgdmFyIHBhbiA9IHRoaXMuZ2V0Q2VudGVyUGFuKGVsZW1lbnRzKTtcblxuICAgIGlmIChwYW4pIHtcbiAgICAgIHRoaXMuX3ByaXZhdGUucGFuID0gcGFuO1xuXG4gICAgICB0aGlzLmVtaXQoJ3BhbiB2aWV3cG9ydCcpO1xuXG4gICAgICB0aGlzLm5vdGlmeSh7IC8vIG5vdGlmeSB0aGUgcmVuZGVyZXIgdGhhdCB0aGUgdmlld3BvcnQgY2hhbmdlZFxuICAgICAgICB0eXBlOiAndmlld3BvcnQnXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICBnZXRDZW50ZXJQYW46IGZ1bmN0aW9uIGdldENlbnRlclBhbihlbGVtZW50cywgem9vbSkge1xuICAgIGlmICghdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpcy5zdHJpbmcoZWxlbWVudHMpKSB7XG4gICAgICB2YXIgc2VsZWN0b3IgPSBlbGVtZW50cztcbiAgICAgIGVsZW1lbnRzID0gdGhpcy5tdXRhYmxlRWxlbWVudHMoKS5maWx0ZXIoc2VsZWN0b3IpO1xuICAgIH0gZWxzZSBpZiAoIWlzLmVsZW1lbnRPckNvbGxlY3Rpb24oZWxlbWVudHMpKSB7XG4gICAgICBlbGVtZW50cyA9IHRoaXMubXV0YWJsZUVsZW1lbnRzKCk7XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gY2FuJ3QgY2VudHJlIHBhbiB0byBub3RoaW5nXG5cbiAgICB2YXIgYmIgPSBlbGVtZW50cy5ib3VuZGluZ0JveCgpO1xuICAgIHZhciB3ID0gdGhpcy53aWR0aCgpO1xuICAgIHZhciBoID0gdGhpcy5oZWlnaHQoKTtcbiAgICB6b29tID0gem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fcHJpdmF0ZS56b29tIDogem9vbTtcblxuICAgIHZhciBwYW4gPSB7IC8vIG1pZGRsZVxuICAgICAgeDogKHcgLSB6b29tICogKGJiLngxICsgYmIueDIpKSAvIDIsXG4gICAgICB5OiAoaCAtIHpvb20gKiAoYmIueTEgKyBiYi55MikpIC8gMlxuICAgIH07XG5cbiAgICByZXR1cm4gcGFuO1xuICB9LFxuXG4gIHJlc2V0OiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBpZiAoIXRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQgfHwgIXRoaXMuX3ByaXZhdGUuem9vbWluZ0VuYWJsZWQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMudmlld3BvcnQoe1xuICAgICAgcGFuOiB7IHg6IDAsIHk6IDAgfSxcbiAgICAgIHpvb206IDFcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIGludmFsaWRhdGVTaXplOiBmdW5jdGlvbiBpbnZhbGlkYXRlU2l6ZSgpIHtcbiAgICB0aGlzLl9wcml2YXRlLnNpemVDYWNoZSA9IG51bGw7XG4gIH0sXG5cbiAgc2l6ZTogZnVuY3Rpb24gc2l6ZSgpIHtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIHZhciBjb250YWluZXIgPSBfcC5jb250YWluZXI7XG5cbiAgICByZXR1cm4gX3Auc2l6ZUNhY2hlID0gX3Auc2l6ZUNhY2hlIHx8IChjb250YWluZXIgPyBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShjb250YWluZXIpO1xuICAgICAgdmFyIHZhbCA9IGZ1bmN0aW9uIHZhbChuYW1lKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHN0eWxlLmdldFByb3BlcnR5VmFsdWUobmFtZSkpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IGNvbnRhaW5lci5jbGllbnRXaWR0aCAtIHZhbCgncGFkZGluZy1sZWZ0JykgLSB2YWwoJ3BhZGRpbmctcmlnaHQnKSxcbiAgICAgICAgaGVpZ2h0OiBjb250YWluZXIuY2xpZW50SGVpZ2h0IC0gdmFsKCdwYWRkaW5nLXRvcCcpIC0gdmFsKCdwYWRkaW5nLWJvdHRvbScpXG4gICAgICB9O1xuICAgIH0oKSA6IHsgLy8gZmFsbGJhY2sgaWYgbm8gY29udGFpbmVyIChub3QgMCBiL2MgY2FuIGJlIHVzZWQgZm9yIGRpdmlkaW5nIGV0YylcbiAgICAgIHdpZHRoOiAxLFxuICAgICAgaGVpZ2h0OiAxXG4gICAgfSk7XG4gIH0sXG5cbiAgd2lkdGg6IGZ1bmN0aW9uIHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLnNpemUoKS53aWR0aDtcbiAgfSxcblxuICBoZWlnaHQ6IGZ1bmN0aW9uIGhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5zaXplKCkuaGVpZ2h0O1xuICB9LFxuXG4gIGV4dGVudDogZnVuY3Rpb24gZXh0ZW50KCkge1xuICAgIHZhciBwYW4gPSB0aGlzLl9wcml2YXRlLnBhbjtcbiAgICB2YXIgem9vbSA9IHRoaXMuX3ByaXZhdGUuem9vbTtcbiAgICB2YXIgcmIgPSB0aGlzLnJlbmRlcmVkRXh0ZW50KCk7XG5cbiAgICB2YXIgYiA9IHtcbiAgICAgIHgxOiAocmIueDEgLSBwYW4ueCkgLyB6b29tLFxuICAgICAgeDI6IChyYi54MiAtIHBhbi54KSAvIHpvb20sXG4gICAgICB5MTogKHJiLnkxIC0gcGFuLnkpIC8gem9vbSxcbiAgICAgIHkyOiAocmIueTIgLSBwYW4ueSkgLyB6b29tXG4gICAgfTtcblxuICAgIGIudyA9IGIueDIgLSBiLngxO1xuICAgIGIuaCA9IGIueTIgLSBiLnkxO1xuXG4gICAgcmV0dXJuIGI7XG4gIH0sXG5cbiAgcmVuZGVyZWRFeHRlbnQ6IGZ1bmN0aW9uIHJlbmRlcmVkRXh0ZW50KCkge1xuICAgIHZhciB3aWR0aCA9IHRoaXMud2lkdGgoKTtcbiAgICB2YXIgaGVpZ2h0ID0gdGhpcy5oZWlnaHQoKTtcblxuICAgIHJldHVybiB7XG4gICAgICB4MTogMCxcbiAgICAgIHkxOiAwLFxuICAgICAgeDI6IHdpZHRoLFxuICAgICAgeTI6IGhlaWdodCxcbiAgICAgIHc6IHdpZHRoLFxuICAgICAgaDogaGVpZ2h0XG4gICAgfTtcbiAgfVxufTtcblxuLy8gYWxpYXNlc1xuY29yZWZuLmNlbnRyZSA9IGNvcmVmbi5jZW50ZXI7XG5cbi8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5jb3JlZm4uYXV0b2xvY2tOb2RlcyA9IGNvcmVmbi5hdXRvbG9jaztcbmNvcmVmbi5hdXRvdW5ncmFiaWZ5Tm9kZXMgPSBjb3JlZm4uYXV0b3VuZ3JhYmlmeTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb3JlZm47XG5cbi8qKiovIH0pLFxuLyogOTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xudmFyIGRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG52YXIgQ29sbGVjdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG52YXIgQ29yZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xudmFyIGluY0V4dHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1KTtcbnZhciBpcyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgRW1pdHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXG4vLyByZWdpc3RlcmVkIGV4dGVuc2lvbnMgdG8gY3l0b3NjYXBlLCBpbmRleGVkIGJ5IG5hbWVcbnZhciBleHRlbnNpb25zID0ge307XG5cbi8vIHJlZ2lzdGVyZWQgbW9kdWxlcyBmb3IgZXh0ZW5zaW9ucywgaW5kZXhlZCBieSBuYW1lXG52YXIgbW9kdWxlcyA9IHt9O1xuXG5mdW5jdGlvbiBzZXRFeHRlbnNpb24odHlwZSwgbmFtZSwgcmVnaXN0cmFudCkge1xuXG4gIHZhciBleHQgPSByZWdpc3RyYW50O1xuXG4gIHZhciBvdmVycmlkZUVyciA9IGZ1bmN0aW9uIG92ZXJyaWRlRXJyKGZpZWxkKSB7XG4gICAgdXRpbC5lcnJvcignQ2FuIG5vdCByZWdpc3RlciBgJyArIG5hbWUgKyAnYCBmb3IgYCcgKyB0eXBlICsgJ2Agc2luY2UgYCcgKyBmaWVsZCArICdgIGFscmVhZHkgZXhpc3RzIGluIHRoZSBwcm90b3R5cGUgYW5kIGNhbiBub3QgYmUgb3ZlcnJpZGRlbicpO1xuICB9O1xuXG4gIGlmICh0eXBlID09PSAnY29yZScpIHtcbiAgICBpZiAoQ29yZS5wcm90b3R5cGVbbmFtZV0pIHtcbiAgICAgIHJldHVybiBvdmVycmlkZUVycihuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgQ29yZS5wcm90b3R5cGVbbmFtZV0gPSByZWdpc3RyYW50O1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlID09PSAnY29sbGVjdGlvbicpIHtcbiAgICBpZiAoQ29sbGVjdGlvbi5wcm90b3R5cGVbbmFtZV0pIHtcbiAgICAgIHJldHVybiBvdmVycmlkZUVycihuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGVbbmFtZV0gPSByZWdpc3RyYW50O1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbGF5b3V0Jykge1xuICAgIC8vIGZpbGwgaW4gbWlzc2luZyBsYXlvdXQgZnVuY3Rpb25zIGluIHRoZSBwcm90b3R5cGVcblxuICAgIHZhciBMYXlvdXQgPSBmdW5jdGlvbiBMYXlvdXQob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuICAgICAgcmVnaXN0cmFudC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgICAvLyBtYWtlIHN1cmUgbGF5b3V0IGhhcyBfcHJpdmF0ZSBmb3IgdXNlIHcvIHN0ZCBhcGlzIGxpa2UgLm9uKClcbiAgICAgIGlmICghaXMucGxhaW5PYmplY3QodGhpcy5fcHJpdmF0ZSkpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZSA9IHt9O1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9wcml2YXRlLmN5ID0gb3B0aW9ucy5jeTtcbiAgICAgIHRoaXMuX3ByaXZhdGUubGlzdGVuZXJzID0gW107XG5cbiAgICAgIHRoaXMuY3JlYXRlRW1pdHRlcigpO1xuICAgIH07XG5cbiAgICB2YXIgbGF5b3V0UHJvdG8gPSBMYXlvdXQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShyZWdpc3RyYW50LnByb3RvdHlwZSk7XG5cbiAgICB2YXIgb3B0TGF5b3V0Rm5zID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdExheW91dEZucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGZuTmFtZSA9IG9wdExheW91dEZuc1tpXTtcblxuICAgICAgbGF5b3V0UHJvdG9bZm5OYW1lXSA9IGxheW91dFByb3RvW2ZuTmFtZV0gfHwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gZWl0aGVyIC5zdGFydCgpIG9yIC5ydW4oKSBpcyBkZWZpbmVkLCBzbyBhdXRvZ2VuIHRoZSBvdGhlclxuICAgIGlmIChsYXlvdXRQcm90by5zdGFydCAmJiAhbGF5b3V0UHJvdG8ucnVuKSB7XG4gICAgICBsYXlvdXRQcm90by5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc3RhcnQoKTtyZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICghbGF5b3V0UHJvdG8uc3RhcnQgJiYgbGF5b3V0UHJvdG8ucnVuKSB7XG4gICAgICBsYXlvdXRQcm90by5zdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5ydW4oKTtyZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIHJlZ1N0b3AgPSByZWdpc3RyYW50LnByb3RvdHlwZS5zdG9wO1xuICAgIGxheW91dFByb3RvLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgb3B0cyA9IHRoaXMub3B0aW9ucztcblxuICAgICAgaWYgKG9wdHMgJiYgb3B0cy5hbmltYXRlKSB7XG4gICAgICAgIHZhciBhbmlzID0gdGhpcy5hbmltYXRpb25zO1xuXG4gICAgICAgIGlmIChhbmlzKSB7XG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFuaXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhbmlzW19pXS5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWdTdG9wKSB7XG4gICAgICAgIHJlZ1N0b3AuY2FsbCh0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZW1pdCgnbGF5b3V0c3RvcCcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgaWYgKCFsYXlvdXRQcm90by5kZXN0cm95KSB7XG4gICAgICBsYXlvdXRQcm90by5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgfVxuXG4gICAgbGF5b3V0UHJvdG8uY3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICB9O1xuXG4gICAgdmFyIGdldEN5ID0gZnVuY3Rpb24gZ2V0Q3kobGF5b3V0KSB7XG4gICAgICByZXR1cm4gbGF5b3V0Ll9wcml2YXRlLmN5O1xuICAgIH07XG5cbiAgICB1dGlsLmFzc2lnbihsYXlvdXRQcm90bywge1xuICAgICAgY3JlYXRlRW1pdHRlcjogZnVuY3Rpb24gY3JlYXRlRW1pdHRlcigpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZS5lbWl0dGVyID0gbmV3IEVtaXR0ZXIoe1xuICAgICAgICAgIGV2ZW50RmllbGRzOiBmdW5jdGlvbiBldmVudEZpZWxkcyhsYXlvdXQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGxheW91dDogbGF5b3V0LFxuICAgICAgICAgICAgICBjeTogZ2V0Q3kobGF5b3V0KSxcbiAgICAgICAgICAgICAgdGFyZ2V0OiBsYXlvdXRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBidWJibGU6IGZ1bmN0aW9uIGJ1YmJsZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcGFyZW50OiBmdW5jdGlvbiBwYXJlbnQobGF5b3V0KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q3kobGF5b3V0KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNvbnRleHQ6IHRoaXNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgZW1pdHRlcjogZnVuY3Rpb24gZW1pdHRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuZW1pdHRlcjtcbiAgICAgIH0sXG4gICAgICBvbjogZnVuY3Rpb24gb24oZXZ0LCBjYikge1xuICAgICAgICB0aGlzLmVtaXR0ZXIoKS5vbihldnQsIGNiKTtyZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBvbmU6IGZ1bmN0aW9uIG9uZShldnQsIGNiKSB7XG4gICAgICAgIHRoaXMuZW1pdHRlcigpLm9uZShldnQsIGNiKTtyZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBvbmNlOiBmdW5jdGlvbiBvbmNlKGV2dCwgY2IpIHtcbiAgICAgICAgdGhpcy5lbWl0dGVyKCkub25lKGV2dCwgY2IpO3JldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIHJlbW92ZUxpc3RlbmVyOiBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihldnQsIGNiKSB7XG4gICAgICAgIHRoaXMuZW1pdHRlcigpLnJlbW92ZUxpc3RlbmVyKGV2dCwgY2IpO3JldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIGVtaXQ6IGZ1bmN0aW9uIGVtaXQoZXZ0LCBwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5lbWl0dGVyKCkuZW1pdChldnQsIHBhcmFtcyk7cmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBkZWZpbmUuZXZlbnRBbGlhc2VzT24obGF5b3V0UHJvdG8pO1xuXG4gICAgZXh0ID0gTGF5b3V0OyAvLyByZXBsYWNlIHdpdGggb3VyIHdyYXBwZWQgbGF5b3V0XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3JlbmRlcmVyJyAmJiBuYW1lICE9PSAnbnVsbCcgJiYgbmFtZSAhPT0gJ2Jhc2UnKSB7XG4gICAgLy8gdXNlciByZWdpc3RlcmVkIHJlbmRlcmVycyBpbmhlcml0IGZyb20gYmFzZVxuXG4gICAgdmFyIEJhc2VSZW5kZXJlciA9IGdldEV4dGVuc2lvbigncmVuZGVyZXInLCAnYmFzZScpO1xuICAgIHZhciBiUHJvdG8gPSBCYXNlUmVuZGVyZXIucHJvdG90eXBlO1xuICAgIHZhciBSZWdpc3RyYW50UmVuZGVyZXIgPSByZWdpc3RyYW50O1xuICAgIHZhciByUHJvdG8gPSByZWdpc3RyYW50LnByb3RvdHlwZTtcblxuICAgIHZhciBSZW5kZXJlciA9IGZ1bmN0aW9uIFJlbmRlcmVyKCkge1xuICAgICAgQmFzZVJlbmRlcmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBSZWdpc3RyYW50UmVuZGVyZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgdmFyIHByb3RvID0gUmVuZGVyZXIucHJvdG90eXBlO1xuXG4gICAgZm9yICh2YXIgcE5hbWUgaW4gYlByb3RvKSB7XG4gICAgICB2YXIgcFZhbCA9IGJQcm90b1twTmFtZV07XG4gICAgICB2YXIgZXhpc3RzSW5SID0gclByb3RvW3BOYW1lXSAhPSBudWxsO1xuXG4gICAgICBpZiAoZXhpc3RzSW5SKSB7XG4gICAgICAgIHJldHVybiBvdmVycmlkZUVycihwTmFtZSk7XG4gICAgICB9XG5cbiAgICAgIHByb3RvW3BOYW1lXSA9IHBWYWw7IC8vIHRha2UgaW1wbCBmcm9tIGJhc2VcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfcE5hbWUgaW4gclByb3RvKSB7XG4gICAgICBwcm90b1tfcE5hbWVdID0gclByb3RvW19wTmFtZV07IC8vIHRha2UgaW1wbCBmcm9tIHJlZ2lzdHJhbnRcbiAgICB9XG5cbiAgICBiUHJvdG8uY2xpZW50RnVuY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHByb3RvW25hbWVdID0gcHJvdG9bbmFtZV0gfHwgZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlsLmVycm9yKCdSZW5kZXJlciBkb2VzIG5vdCBpbXBsZW1lbnQgYHJlbmRlcmVyLicgKyBuYW1lICsgJygpYCBvbiBpdHMgcHJvdG90eXBlJyk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgZXh0ID0gUmVuZGVyZXI7XG4gIH1cblxuICByZXR1cm4gdXRpbC5zZXRNYXAoe1xuICAgIG1hcDogZXh0ZW5zaW9ucyxcbiAgICBrZXlzOiBbdHlwZSwgbmFtZV0sXG4gICAgdmFsdWU6IGV4dFxuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0RXh0ZW5zaW9uKHR5cGUsIG5hbWUpIHtcbiAgcmV0dXJuIHV0aWwuZ2V0TWFwKHtcbiAgICBtYXA6IGV4dGVuc2lvbnMsXG4gICAga2V5czogW3R5cGUsIG5hbWVdXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzZXRNb2R1bGUodHlwZSwgbmFtZSwgbW9kdWxlVHlwZSwgbW9kdWxlTmFtZSwgcmVnaXN0cmFudCkge1xuICByZXR1cm4gdXRpbC5zZXRNYXAoe1xuICAgIG1hcDogbW9kdWxlcyxcbiAgICBrZXlzOiBbdHlwZSwgbmFtZSwgbW9kdWxlVHlwZSwgbW9kdWxlTmFtZV0sXG4gICAgdmFsdWU6IHJlZ2lzdHJhbnRcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldE1vZHVsZSh0eXBlLCBuYW1lLCBtb2R1bGVUeXBlLCBtb2R1bGVOYW1lKSB7XG4gIHJldHVybiB1dGlsLmdldE1hcCh7XG4gICAgbWFwOiBtb2R1bGVzLFxuICAgIGtleXM6IFt0eXBlLCBuYW1lLCBtb2R1bGVUeXBlLCBtb2R1bGVOYW1lXVxuICB9KTtcbn1cblxudmFyIGV4dGVuc2lvbiA9IGZ1bmN0aW9uIGV4dGVuc2lvbigpIHtcbiAgLy8gZS5nLiBleHRlbnNpb24oJ3JlbmRlcmVyJywgJ3N2ZycpXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgcmV0dXJuIGdldEV4dGVuc2lvbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgLy8gZS5nLiBleHRlbnNpb24oJ3JlbmRlcmVyJywgJ3N2ZycsIHsgLi4uIH0pXG4gIGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgIHJldHVybiBzZXRFeHRlbnNpb24uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICAvLyBlLmcuIGV4dGVuc2lvbigncmVuZGVyZXInLCAnc3ZnJywgJ25vZGVTaGFwZScsICdlbGxpcHNlJylcbiAgICBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIHJldHVybiBnZXRNb2R1bGUuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgLy8gZS5nLiBleHRlbnNpb24oJ3JlbmRlcmVyJywgJ3N2ZycsICdub2RlU2hhcGUnLCAnZWxsaXBzZScsIHsgLi4uIH0pXG4gICAgICBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA1KSB7XG4gICAgICAgICAgcmV0dXJuIHNldE1vZHVsZS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHV0aWwuZXJyb3IoJ0ludmFsaWQgZXh0ZW5zaW9uIGFjY2VzcyBzeW50YXgnKTtcbiAgICAgICAgfVxufTtcblxuLy8gYWxsb3dzIGEgY29yZSBpbnN0YW5jZSB0byBhY2Nlc3MgZXh0ZW5zaW9ucyBpbnRlcm5hbGx5XG5Db3JlLnByb3RvdHlwZS5leHRlbnNpb24gPSBleHRlbnNpb247XG5cbi8vIGluY2x1ZGVkIGV4dGVuc2lvbnNcbmluY0V4dHMuZm9yRWFjaChmdW5jdGlvbiAoZ3JvdXApIHtcbiAgZ3JvdXAuZXh0ZW5zaW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChleHQpIHtcbiAgICBzZXRFeHRlbnNpb24oZ3JvdXAudHlwZSwgZXh0Lm5hbWUsIGV4dC5pbXBsKTtcbiAgfSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHRlbnNpb247XG5cbi8qKiovIH0pLFxuLyogOTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBbe1xuICB0eXBlOiAnbGF5b3V0JyxcbiAgZXh0ZW5zaW9uczogX193ZWJwYWNrX3JlcXVpcmVfXyg5Nilcbn0sIHtcbiAgdHlwZTogJ3JlbmRlcmVyJyxcbiAgZXh0ZW5zaW9uczogX193ZWJwYWNrX3JlcXVpcmVfXygxMDUpXG59XTtcblxuLyoqKi8gfSksXG4vKiA5NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFt7IG5hbWU6ICdicmVhZHRoZmlyc3QnLCBpbXBsOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDk3KSB9LCB7IG5hbWU6ICdjaXJjbGUnLCBpbXBsOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDk4KSB9LCB7IG5hbWU6ICdjb25jZW50cmljJywgaW1wbDogX193ZWJwYWNrX3JlcXVpcmVfXyg5OSkgfSwgeyBuYW1lOiAnY29zZScsIGltcGw6IF9fd2VicGFja19yZXF1aXJlX18oMTAwKSB9LCB7IG5hbWU6ICdncmlkJywgaW1wbDogX193ZWJwYWNrX3JlcXVpcmVfXygxMDEpIH0sIHsgbmFtZTogJ251bGwnLCBpbXBsOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwMikgfSwgeyBuYW1lOiAncHJlc2V0JywgaW1wbDogX193ZWJwYWNrX3JlcXVpcmVfXygxMDMpIH0sIHsgbmFtZTogJ3JhbmRvbScsIGltcGw6IF9fd2VicGFja19yZXF1aXJlX18oMTA0KSB9XTtcblxuLyoqKi8gfSksXG4vKiA5NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG52YXIgbWF0aCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG52YXIgaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgZGVmYXVsdHMgPSB7XG4gIGZpdDogdHJ1ZSwgLy8gd2hldGhlciB0byBmaXQgdGhlIHZpZXdwb3J0IHRvIHRoZSBncmFwaFxuICBkaXJlY3RlZDogZmFsc2UsIC8vIHdoZXRoZXIgdGhlIHRyZWUgaXMgZGlyZWN0ZWQgZG93bndhcmRzIChvciBlZGdlcyBjYW4gcG9pbnQgaW4gYW55IGRpcmVjdGlvbiBpZiBmYWxzZSlcbiAgcGFkZGluZzogMzAsIC8vIHBhZGRpbmcgb24gZml0XG4gIGNpcmNsZTogZmFsc2UsIC8vIHB1dCBkZXB0aHMgaW4gY29uY2VudHJpYyBjaXJjbGVzIGlmIHRydWUsIHB1dCBkZXB0aHMgdG9wIGRvd24gaWYgZmFsc2VcbiAgc3BhY2luZ0ZhY3RvcjogMS43NSwgLy8gcG9zaXRpdmUgc3BhY2luZyBmYWN0b3IsIGxhcmdlciA9PiBtb3JlIHNwYWNlIGJldHdlZW4gbm9kZXMgKE4uQi4gbi9hIGlmIGNhdXNlcyBvdmVybGFwKVxuICBib3VuZGluZ0JveDogdW5kZWZpbmVkLCAvLyBjb25zdHJhaW4gbGF5b3V0IGJvdW5kczsgeyB4MSwgeTEsIHgyLCB5MiB9IG9yIHsgeDEsIHkxLCB3LCBoIH1cbiAgYXZvaWRPdmVybGFwOiB0cnVlLCAvLyBwcmV2ZW50cyBub2RlIG92ZXJsYXAsIG1heSBvdmVyZmxvdyBib3VuZGluZ0JveCBpZiBub3QgZW5vdWdoIHNwYWNlXG4gIG5vZGVEaW1lbnNpb25zSW5jbHVkZUxhYmVsczogZmFsc2UsIC8vIEV4Y2x1ZGVzIHRoZSBsYWJlbCB3aGVuIGNhbGN1bGF0aW5nIG5vZGUgYm91bmRpbmcgYm94ZXMgZm9yIHRoZSBsYXlvdXQgYWxnb3JpdGhtXG4gIHJvb3RzOiB1bmRlZmluZWQsIC8vIHRoZSByb290cyBvZiB0aGUgdHJlZXNcbiAgbWF4aW1hbEFkanVzdG1lbnRzOiAwLCAvLyBob3cgbWFueSB0aW1lcyB0byB0cnkgdG8gcG9zaXRpb24gdGhlIG5vZGVzIGluIGEgbWF4aW1hbCB3YXkgKGkuZS4gbm8gYmFja3RyYWNraW5nKVxuICBhbmltYXRlOiBmYWxzZSwgLy8gd2hldGhlciB0byB0cmFuc2l0aW9uIHRoZSBub2RlIHBvc2l0aW9uc1xuICBhbmltYXRpb25EdXJhdGlvbjogNTAwLCAvLyBkdXJhdGlvbiBvZiBhbmltYXRpb24gaW4gbXMgaWYgZW5hYmxlZFxuICBhbmltYXRpb25FYXNpbmc6IHVuZGVmaW5lZCwgLy8gZWFzaW5nIG9mIGFuaW1hdGlvbiBpZiBlbmFibGVkLFxuICBhbmltYXRlRmlsdGVyOiBmdW5jdGlvbiBhbmltYXRlRmlsdGVyKG5vZGUsIGkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgLy8gYSBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgd2hldGhlciB0aGUgbm9kZSBzaG91bGQgYmUgYW5pbWF0ZWQuICBBbGwgbm9kZXMgYW5pbWF0ZWQgYnkgZGVmYXVsdCBvbiBhbmltYXRlIGVuYWJsZWQuICBOb24tYW5pbWF0ZWQgbm9kZXMgYXJlIHBvc2l0aW9uZWQgaW1tZWRpYXRlbHkgd2hlbiB0aGUgbGF5b3V0IHN0YXJ0c1xuICByZWFkeTogdW5kZWZpbmVkLCAvLyBjYWxsYmFjayBvbiBsYXlvdXRyZWFkeVxuICBzdG9wOiB1bmRlZmluZWQsIC8vIGNhbGxiYWNrIG9uIGxheW91dHN0b3BcbiAgdHJhbnNmb3JtOiBmdW5jdGlvbiB0cmFuc2Zvcm0obm9kZSwgcG9zaXRpb24pIHtcbiAgICByZXR1cm4gcG9zaXRpb247XG4gIH0gLy8gdHJhbnNmb3JtIGEgZ2l2ZW4gbm9kZSBwb3NpdGlvbi4gVXNlZnVsIGZvciBjaGFuZ2luZyBmbG93IGRpcmVjdGlvbiBpbiBkaXNjcmV0ZSBsYXlvdXRzXG59O1xuXG5mdW5jdGlvbiBCcmVhZHRoRmlyc3RMYXlvdXQob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7fSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xufVxuXG5CcmVhZHRoRmlyc3RMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHBhcmFtcyA9IHRoaXMub3B0aW9ucztcbiAgdmFyIG9wdGlvbnMgPSBwYXJhbXM7XG5cbiAgdmFyIGN5ID0gcGFyYW1zLmN5O1xuICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlcztcbiAgdmFyIG5vZGVzID0gZWxlcy5ub2RlcygpLm5vdCgnOnBhcmVudCcpO1xuICB2YXIgZ3JhcGggPSBlbGVzO1xuXG4gIHZhciBiYiA9IG1hdGgubWFrZUJvdW5kaW5nQm94KG9wdGlvbnMuYm91bmRpbmdCb3ggPyBvcHRpb25zLmJvdW5kaW5nQm94IDoge1xuICAgIHgxOiAwLCB5MTogMCwgdzogY3kud2lkdGgoKSwgaDogY3kuaGVpZ2h0KClcbiAgfSk7XG5cbiAgdmFyIHJvb3RzID0gdm9pZCAwO1xuICBpZiAoaXMuZWxlbWVudE9yQ29sbGVjdGlvbihvcHRpb25zLnJvb3RzKSkge1xuICAgIHJvb3RzID0gb3B0aW9ucy5yb290cztcbiAgfSBlbHNlIGlmIChpcy5hcnJheShvcHRpb25zLnJvb3RzKSkge1xuICAgIHZhciByb290c0FycmF5ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdGlvbnMucm9vdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpZCA9IG9wdGlvbnMucm9vdHNbaV07XG4gICAgICB2YXIgZWxlID0gY3kuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICAgICAgcm9vdHNBcnJheS5wdXNoKGVsZSk7XG4gICAgfVxuXG4gICAgcm9vdHMgPSBjeS5jb2xsZWN0aW9uKHJvb3RzQXJyYXkpO1xuICB9IGVsc2UgaWYgKGlzLnN0cmluZyhvcHRpb25zLnJvb3RzKSkge1xuICAgIHJvb3RzID0gY3kuJChvcHRpb25zLnJvb3RzKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAob3B0aW9ucy5kaXJlY3RlZCkge1xuICAgICAgcm9vdHMgPSBub2Rlcy5yb290cygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY29tcG9uZW50cyA9IFtdO1xuICAgICAgdmFyIHVuaGFuZGxlZE5vZGVzID0gbm9kZXM7XG5cbiAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKCkge1xuICAgICAgICB2YXIgY3VyckNvbXAgPSBjeS5jb2xsZWN0aW9uKCk7XG5cbiAgICAgICAgZWxlcy5iZnMoe1xuICAgICAgICAgIHJvb3RzOiB1bmhhbmRsZWROb2Rlc1swXSxcbiAgICAgICAgICB2aXNpdDogZnVuY3Rpb24gdmlzaXQobm9kZSwgZWRnZSwgcE5vZGUsIGksIGRlcHRoKSB7XG4gICAgICAgICAgICBjdXJyQ29tcCA9IGN1cnJDb21wLmFkZChub2RlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRpcmVjdGVkOiBmYWxzZVxuICAgICAgICB9KTtcblxuICAgICAgICB1bmhhbmRsZWROb2RlcyA9IHVuaGFuZGxlZE5vZGVzLm5vdChjdXJyQ29tcCk7XG4gICAgICAgIGNvbXBvbmVudHMucHVzaChjdXJyQ29tcCk7XG4gICAgICB9O1xuXG4gICAgICB3aGlsZSAodW5oYW5kbGVkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBfbG9vcCgpO1xuICAgICAgfVxuXG4gICAgICByb290cyA9IGN5LmNvbGxlY3Rpb24oKTtcblxuICAgICAgdmFyIF9sb29wMiA9IGZ1bmN0aW9uIF9sb29wMihfaSkge1xuICAgICAgICB2YXIgY29tcCA9IGNvbXBvbmVudHNbX2ldO1xuICAgICAgICB2YXIgbWF4RGVncmVlID0gY29tcC5tYXhEZWdyZWUoZmFsc2UpO1xuICAgICAgICB2YXIgY29tcFJvb3RzID0gY29tcC5maWx0ZXIoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICAgIHJldHVybiBlbGUuZGVncmVlKGZhbHNlKSA9PT0gbWF4RGVncmVlO1xuICAgICAgICB9KTtcblxuICAgICAgICByb290cyA9IHJvb3RzLmFkZChjb21wUm9vdHMpO1xuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGNvbXBvbmVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIF9sb29wMihfaSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGRlcHRocyA9IFtdO1xuICB2YXIgZm91bmRCeUJmcyA9IHt9O1xuICB2YXIgaWQyZGVwdGggPSB7fTtcbiAgdmFyIHByZXZOb2RlID0ge307XG4gIHZhciBwcmV2RWRnZSA9IHt9O1xuICB2YXIgc3VjY2Vzc29ycyA9IHt9O1xuXG4gIC8vIGZpbmQgdGhlIGRlcHRocyBvZiB0aGUgbm9kZXNcbiAgZ3JhcGguYmZzKHtcbiAgICByb290czogcm9vdHMsXG4gICAgZGlyZWN0ZWQ6IG9wdGlvbnMuZGlyZWN0ZWQsXG4gICAgdmlzaXQ6IGZ1bmN0aW9uIHZpc2l0KG5vZGUsIGVkZ2UsIHBOb2RlLCBpLCBkZXB0aCkge1xuICAgICAgdmFyIGVsZSA9IG5vZGVbMF07XG4gICAgICB2YXIgaWQgPSBlbGUuaWQoKTtcblxuICAgICAgaWYgKCFkZXB0aHNbZGVwdGhdKSB7XG4gICAgICAgIGRlcHRoc1tkZXB0aF0gPSBbXTtcbiAgICAgIH1cblxuICAgICAgZGVwdGhzW2RlcHRoXS5wdXNoKGVsZSk7XG4gICAgICBmb3VuZEJ5QmZzW2lkXSA9IHRydWU7XG4gICAgICBpZDJkZXB0aFtpZF0gPSBkZXB0aDtcbiAgICAgIHByZXZOb2RlW2lkXSA9IHBOb2RlO1xuICAgICAgcHJldkVkZ2VbaWRdID0gZWRnZTtcblxuICAgICAgaWYgKHBOb2RlKSB7XG4gICAgICAgIHZhciBwcmV2SWQgPSBwTm9kZS5pZCgpO1xuICAgICAgICB2YXIgc3VjYyA9IHN1Y2Nlc3NvcnNbcHJldklkXSA9IHN1Y2Nlc3NvcnNbcHJldklkXSB8fCBbXTtcblxuICAgICAgICBzdWNjLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvLyBjaGVjayBmb3Igbm9kZXMgbm90IGZvdW5kIGJ5IGJmc1xuICB2YXIgb3JwaGFuTm9kZXMgPSBbXTtcbiAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbm9kZXMubGVuZ3RoOyBfaTIrKykge1xuICAgIHZhciBfZWxlID0gbm9kZXNbX2kyXTtcblxuICAgIGlmIChmb3VuZEJ5QmZzW19lbGUuaWQoKV0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcnBoYW5Ob2Rlcy5wdXNoKF9lbGUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGFzc2lnbiBvcnBoYW4gbm9kZXMgYSBkZXB0aCBmcm9tIHRoZWlyIG5laWdoYm9yaG9vZFxuICB2YXIgbWF4Q2hlY2tzID0gb3JwaGFuTm9kZXMubGVuZ3RoICogMztcbiAgdmFyIGNoZWNrcyA9IDA7XG4gIHdoaWxlIChvcnBoYW5Ob2Rlcy5sZW5ndGggIT09IDAgJiYgY2hlY2tzIDwgbWF4Q2hlY2tzKSB7XG4gICAgdmFyIG5vZGUgPSBvcnBoYW5Ob2Rlcy5zaGlmdCgpO1xuICAgIHZhciBuZWlnaGJvcnMgPSBub2RlLm5laWdoYm9yaG9vZCgpLm5vZGVzKCk7XG4gICAgdmFyIGFzc2lnbmVkRGVwdGggPSBmYWxzZTtcblxuICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IG5laWdoYm9ycy5sZW5ndGg7IF9pMysrKSB7XG4gICAgICB2YXIgZGVwdGggPSBpZDJkZXB0aFtuZWlnaGJvcnNbX2kzXS5pZCgpXTtcblxuICAgICAgaWYgKGRlcHRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVwdGhzW2RlcHRoXS5wdXNoKG5vZGUpO1xuICAgICAgICBhc3NpZ25lZERlcHRoID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFhc3NpZ25lZERlcHRoKSB7XG4gICAgICBvcnBoYW5Ob2Rlcy5wdXNoKG5vZGUpO1xuICAgIH1cblxuICAgIGNoZWNrcysrO1xuICB9XG5cbiAgLy8gYXNzaWduIG9ycGhhbiBub2RlcyB0aGF0IGFyZSBzdGlsbCBsZWZ0IHRvIHRoZSBkZXB0aCBvZiB0aGVpciBzdWJncmFwaFxuICB3aGlsZSAob3JwaGFuTm9kZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgdmFyIF9ub2RlID0gb3JwaGFuTm9kZXMuc2hpZnQoKTtcbiAgICAvL2xldCBzdWJncmFwaCA9IGdyYXBoLmJmcyggbm9kZSApLnBhdGg7XG4gICAgdmFyIF9hc3NpZ25lZERlcHRoID0gZmFsc2U7XG5cbiAgICAvLyBmb3IoIGxldCBpID0gMDsgaSA8IHN1YmdyYXBoLmxlbmd0aDsgaSsrICl7XG4gICAgLy8gICBsZXQgZGVwdGggPSBpZDJkZXB0aFsgc3ViZ3JhcGhbaV0uaWQoKSBdO1xuXG4gICAgLy8gICBpZiggZGVwdGggIT09IHVuZGVmaW5lZCApe1xuICAgIC8vICAgICBkZXB0aHNbZGVwdGhdLnB1c2goIG5vZGUgKTtcbiAgICAvLyAgICAgYXNzaWduZWREZXB0aCA9IHRydWU7XG4gICAgLy8gICAgIGJyZWFrO1xuICAgIC8vICAgfVxuICAgIC8vIH1cblxuICAgIGlmICghX2Fzc2lnbmVkRGVwdGgpIHtcbiAgICAgIC8vIHdvcnN0IGNhc2UgaWYgdGhlIGdyYXBoIHJlYWxseSBpc24ndCB0cmVlIGZyaWVuZGx5LCB0aGVuIGp1c3QgZHVtcCBpdCBpbiAwXG4gICAgICBpZiAoZGVwdGhzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBkZXB0aHMucHVzaChbXSk7XG4gICAgICB9XG5cbiAgICAgIGRlcHRoc1swXS5wdXNoKF9ub2RlKTtcbiAgICB9XG4gIH1cblxuICAvLyBhc3NpZ24gdGhlIG5vZGVzIGEgZGVwdGggYW5kIGluZGV4XG4gIHZhciBhc3NpZ25EZXB0aHNUb0VsZXMgPSBmdW5jdGlvbiBhc3NpZ25EZXB0aHNUb0VsZXMoKSB7XG4gICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgZGVwdGhzLmxlbmd0aDsgX2k0KyspIHtcbiAgICAgIHZhciBfZWxlcyA9IGRlcHRoc1tfaTRdO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IF9lbGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBfZWxlMiA9IF9lbGVzW2pdO1xuXG4gICAgICAgIGlmIChfZWxlMiA9PSBudWxsKSB7XG4gICAgICAgICAgX2VsZXMuc3BsaWNlKGosIDEpO1xuICAgICAgICAgIGotLTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9lbGUyLl9wcml2YXRlLnNjcmF0Y2guYnJlYWR0aGZpcnN0ID0ge1xuICAgICAgICAgIGRlcHRoOiBfaTQsXG4gICAgICAgICAgaW5kZXg6IGpcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGFzc2lnbkRlcHRoc1RvRWxlcygpO1xuXG4gIHZhciBpbnRlcnNlY3RzRGVwdGggPSBmdW5jdGlvbiBpbnRlcnNlY3RzRGVwdGgobm9kZSkge1xuICAgIC8vIHJldHVybnMgdHJ1ZSBpZiBoYXMgZWRnZXMgcG9pbnRpbmcgaW4gZnJvbSBhIGhpZ2hlciBkZXB0aFxuICAgIHZhciBlZGdlcyA9IG5vZGUuY29ubmVjdGVkRWRnZXMoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5kYXRhKCd0YXJnZXQnKSA9PT0gbm9kZS5pZCgpO1xuICAgIH0pO1xuICAgIHZhciB0aGlzSW5mbyA9IG5vZGUuX3ByaXZhdGUuc2NyYXRjaC5icmVhZHRoZmlyc3Q7XG4gICAgdmFyIGhpZ2hlc3REZXB0aE9mT3RoZXIgPSAwO1xuICAgIHZhciBoaWdoZXN0T3RoZXIgPSB2b2lkIDA7XG4gICAgZm9yICh2YXIgX2k1ID0gMDsgX2k1IDwgZWRnZXMubGVuZ3RoOyBfaTUrKykge1xuICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tfaTVdO1xuICAgICAgdmFyIG90aGVyTm9kZSA9IGVkZ2Uuc291cmNlKClbMF07XG4gICAgICB2YXIgb3RoZXJJbmZvID0gb3RoZXJOb2RlLl9wcml2YXRlLnNjcmF0Y2guYnJlYWR0aGZpcnN0O1xuXG4gICAgICBpZiAodGhpc0luZm8uZGVwdGggPD0gb3RoZXJJbmZvLmRlcHRoICYmIGhpZ2hlc3REZXB0aE9mT3RoZXIgPCBvdGhlckluZm8uZGVwdGgpIHtcbiAgICAgICAgaGlnaGVzdERlcHRoT2ZPdGhlciA9IG90aGVySW5mby5kZXB0aDtcbiAgICAgICAgaGlnaGVzdE90aGVyID0gb3RoZXJOb2RlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBoaWdoZXN0T3RoZXI7XG4gIH07XG5cbiAgLy8gbWFrZSBtYXhpbWFsIGlmIHNvIHNldCBieSBhZGp1c3RpbmcgZGVwdGhzXG4gIGZvciAodmFyIGFkaiA9IDA7IGFkaiA8IG9wdGlvbnMubWF4aW1hbEFkanVzdG1lbnRzOyBhZGorKykge1xuXG4gICAgdmFyIG5EZXB0aHMgPSBkZXB0aHMubGVuZ3RoO1xuICAgIHZhciBlbGVzVG9Nb3ZlID0gW107XG4gICAgZm9yICh2YXIgX2k2ID0gMDsgX2k2IDwgbkRlcHRoczsgX2k2KyspIHtcbiAgICAgIHZhciBfZGVwdGggPSBkZXB0aHNbX2k2XTtcblxuICAgICAgdmFyIG5EZXB0aCA9IF9kZXB0aC5sZW5ndGg7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5EZXB0aDsgaisrKSB7XG4gICAgICAgIHZhciBfZWxlMyA9IF9kZXB0aFtqXTtcbiAgICAgICAgdmFyIGluZm8gPSBfZWxlMy5fcHJpdmF0ZS5zY3JhdGNoLmJyZWFkdGhmaXJzdDtcbiAgICAgICAgdmFyIGludEVsZSA9IGludGVyc2VjdHNEZXB0aChfZWxlMyk7XG5cbiAgICAgICAgaWYgKGludEVsZSkge1xuICAgICAgICAgIGluZm8uaW50RWxlID0gaW50RWxlO1xuICAgICAgICAgIGVsZXNUb01vdmUucHVzaChfZWxlMyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaTcgPSAwOyBfaTcgPCBlbGVzVG9Nb3ZlLmxlbmd0aDsgX2k3KyspIHtcbiAgICAgIHZhciBfZWxlNCA9IGVsZXNUb01vdmVbX2k3XTtcbiAgICAgIHZhciBfaW5mbyA9IF9lbGU0Ll9wcml2YXRlLnNjcmF0Y2guYnJlYWR0aGZpcnN0O1xuICAgICAgdmFyIF9pbnRFbGUgPSBfaW5mby5pbnRFbGU7XG4gICAgICB2YXIgaW50SW5mbyA9IF9pbnRFbGUuX3ByaXZhdGUuc2NyYXRjaC5icmVhZHRoZmlyc3Q7XG5cbiAgICAgIGRlcHRoc1tfaW5mby5kZXB0aF1bX2luZm8uaW5kZXhdID0gbnVsbDsgLy8gcmVtb3ZlIGZyb20gb2xkIGRlcHRoICYgaW5kZXggKGNyZWF0ZSBob2xlIHRvIGJlIGNsZWFuZWQpXG5cbiAgICAgIC8vIGFkZCB0byBlbmQgb2YgbmV3IGRlcHRoXG4gICAgICB2YXIgbmV3RGVwdGggPSBpbnRJbmZvLmRlcHRoICsgMTtcbiAgICAgIHdoaWxlIChuZXdEZXB0aCA+IGRlcHRocy5sZW5ndGggLSAxKSB7XG4gICAgICAgIGRlcHRocy5wdXNoKFtdKTtcbiAgICAgIH1cbiAgICAgIGRlcHRoc1tuZXdEZXB0aF0ucHVzaChfZWxlNCk7XG5cbiAgICAgIF9pbmZvLmRlcHRoID0gbmV3RGVwdGg7XG4gICAgICBfaW5mby5pbmRleCA9IGRlcHRoc1tuZXdEZXB0aF0ubGVuZ3RoIC0gMTtcbiAgICB9XG5cbiAgICBhc3NpZ25EZXB0aHNUb0VsZXMoKTtcbiAgfVxuXG4gIC8vIGZpbmQgbWluIGRpc3RhbmNlIHdlIG5lZWQgdG8gbGVhdmUgYmV0d2VlbiBub2Rlc1xuICB2YXIgbWluRGlzdGFuY2UgPSAwO1xuICBpZiAob3B0aW9ucy5hdm9pZE92ZXJsYXApIHtcbiAgICBmb3IgKHZhciBfaTggPSAwOyBfaTggPCBub2Rlcy5sZW5ndGg7IF9pOCsrKSB7XG4gICAgICB2YXIgbiA9IG5vZGVzW19pOF07XG4gICAgICB2YXIgbmJiID0gbi5sYXlvdXREaW1lbnNpb25zKG9wdGlvbnMpO1xuICAgICAgdmFyIHcgPSBuYmIudztcbiAgICAgIHZhciBoID0gbmJiLmg7XG5cbiAgICAgIG1pbkRpc3RhbmNlID0gTWF0aC5tYXgobWluRGlzdGFuY2UsIHcsIGgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGdldCB0aGUgd2VpZ2h0ZWQgcGVyY2VudCBmb3IgYW4gZWxlbWVudCBiYXNlZCBvbiBpdHMgY29ubmVjdGl2aXR5IHRvIG90aGVyIGxldmVsc1xuICB2YXIgY2FjaGVkV2VpZ2h0ZWRQZXJjZW50ID0ge307XG4gIHZhciBnZXRXZWlnaHRlZFBlcmNlbnQgPSBmdW5jdGlvbiBnZXRXZWlnaHRlZFBlcmNlbnQoZWxlKSB7XG4gICAgaWYgKGNhY2hlZFdlaWdodGVkUGVyY2VudFtlbGUuaWQoKV0pIHtcbiAgICAgIHJldHVybiBjYWNoZWRXZWlnaHRlZFBlcmNlbnRbZWxlLmlkKCldO1xuICAgIH1cblxuICAgIHZhciBlbGVEZXB0aCA9IGVsZS5fcHJpdmF0ZS5zY3JhdGNoLmJyZWFkdGhmaXJzdC5kZXB0aDtcbiAgICB2YXIgbmVpZ2hib3JzID0gZWxlLm5laWdoYm9yaG9vZCgpLm5vZGVzKCkubm90KCc6cGFyZW50JykuaW50ZXJzZWN0aW9uKG5vZGVzKTtcbiAgICB2YXIgcGVyY2VudCA9IDA7XG4gICAgdmFyIHNhbXBsZXMgPSAwO1xuXG4gICAgZm9yICh2YXIgX2k5ID0gMDsgX2k5IDwgbmVpZ2hib3JzLmxlbmd0aDsgX2k5KyspIHtcbiAgICAgIHZhciBuZWlnaGJvciA9IG5laWdoYm9yc1tfaTldO1xuICAgICAgdmFyIGJmID0gbmVpZ2hib3IuX3ByaXZhdGUuc2NyYXRjaC5icmVhZHRoZmlyc3Q7XG4gICAgICB2YXIgaW5kZXggPSBiZi5pbmRleDtcbiAgICAgIHZhciBfZGVwdGgyID0gYmYuZGVwdGg7XG4gICAgICB2YXIgX25EZXB0aCA9IGRlcHRoc1tfZGVwdGgyXS5sZW5ndGg7XG5cbiAgICAgIGlmIChlbGVEZXB0aCA+IF9kZXB0aDIgfHwgZWxlRGVwdGggPT09IDApIHtcbiAgICAgICAgLy8gb25seSBnZXQgaW5mbHVlbmNlZCBieSBlbGVtZW50cyBhYm92ZVxuICAgICAgICBwZXJjZW50ICs9IGluZGV4IC8gX25EZXB0aDtcbiAgICAgICAgc2FtcGxlcysrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNhbXBsZXMgPSBNYXRoLm1heCgxLCBzYW1wbGVzKTtcbiAgICBwZXJjZW50ID0gcGVyY2VudCAvIHNhbXBsZXM7XG5cbiAgICBpZiAoc2FtcGxlcyA9PT0gMCkge1xuICAgICAgLy8gc28gbG9uZSBub2RlcyBoYXZlIGEgXCJkb24ndCBjYXJlXCIgc3RhdGUgaW4gc29ydGluZ1xuICAgICAgcGVyY2VudCA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBjYWNoZWRXZWlnaHRlZFBlcmNlbnRbZWxlLmlkKCldID0gcGVyY2VudDtcbiAgICByZXR1cm4gcGVyY2VudDtcbiAgfTtcblxuICAvLyByZWFycmFuZ2UgdGhlIGluZGljZXMgaW4gZWFjaCBkZXB0aCBsZXZlbCBiYXNlZCBvbiBjb25uZWN0aXZpdHlcblxuICB2YXIgc29ydEZuID0gZnVuY3Rpb24gc29ydEZuKGEsIGIpIHtcbiAgICB2YXIgYXBjdCA9IGdldFdlaWdodGVkUGVyY2VudChhKTtcbiAgICB2YXIgYnBjdCA9IGdldFdlaWdodGVkUGVyY2VudChiKTtcblxuICAgIHJldHVybiBhcGN0IC0gYnBjdDtcbiAgfTtcblxuICBmb3IgKHZhciB0aW1lcyA9IDA7IHRpbWVzIDwgMzsgdGltZXMrKykge1xuICAgIC8vIGRvIGl0IGEgZmV3IHRpbWVzIGIvYyB0aGUgZGVwdGhzIGFyZSBkeW5hbWljIGFuZCB3ZSB3YW50IGEgbW9yZSBzdGFibGUgcmVzdWx0XG5cbiAgICBmb3IgKHZhciBfaTEwID0gMDsgX2kxMCA8IGRlcHRocy5sZW5ndGg7IF9pMTArKykge1xuICAgICAgZGVwdGhzW19pMTBdID0gZGVwdGhzW19pMTBdLnNvcnQoc29ydEZuKTtcbiAgICB9XG4gICAgYXNzaWduRGVwdGhzVG9FbGVzKCk7IC8vIGFuZCB1cGRhdGVcbiAgfVxuXG4gIHZhciBiaWdnZXN0RGVwdGhTaXplID0gMDtcbiAgZm9yICh2YXIgX2kxMSA9IDA7IF9pMTEgPCBkZXB0aHMubGVuZ3RoOyBfaTExKyspIHtcbiAgICBiaWdnZXN0RGVwdGhTaXplID0gTWF0aC5tYXgoZGVwdGhzW19pMTFdLmxlbmd0aCwgYmlnZ2VzdERlcHRoU2l6ZSk7XG4gIH1cblxuICB2YXIgY2VudGVyID0ge1xuICAgIHg6IGJiLngxICsgYmIudyAvIDIsXG4gICAgeTogYmIueDEgKyBiYi5oIC8gMlxuICB9O1xuXG4gIHZhciBnZXRQb3NpdGlvbiA9IGZ1bmN0aW9uIGdldFBvc2l0aW9uKGVsZSwgaXNCb3R0b21EZXB0aCkge1xuICAgIHZhciBpbmZvID0gZWxlLl9wcml2YXRlLnNjcmF0Y2guYnJlYWR0aGZpcnN0O1xuICAgIHZhciBkZXB0aCA9IGluZm8uZGVwdGg7XG4gICAgdmFyIGluZGV4ID0gaW5mby5pbmRleDtcbiAgICB2YXIgZGVwdGhTaXplID0gZGVwdGhzW2RlcHRoXS5sZW5ndGg7XG5cbiAgICB2YXIgZGlzdGFuY2VYID0gTWF0aC5tYXgoYmIudyAvIChkZXB0aFNpemUgKyAxKSwgbWluRGlzdGFuY2UpO1xuICAgIHZhciBkaXN0YW5jZVkgPSBNYXRoLm1heChiYi5oIC8gKGRlcHRocy5sZW5ndGggKyAxKSwgbWluRGlzdGFuY2UpO1xuICAgIHZhciByYWRpdXNTdGVwU2l6ZSA9IE1hdGgubWluKGJiLncgLyAyIC8gZGVwdGhzLmxlbmd0aCwgYmIuaCAvIDIgLyBkZXB0aHMubGVuZ3RoKTtcbiAgICByYWRpdXNTdGVwU2l6ZSA9IE1hdGgubWF4KHJhZGl1c1N0ZXBTaXplLCBtaW5EaXN0YW5jZSk7XG5cbiAgICBpZiAoIW9wdGlvbnMuY2lyY2xlKSB7XG5cbiAgICAgIHZhciBlcG9zID0ge1xuICAgICAgICB4OiBjZW50ZXIueCArIChpbmRleCArIDEgLSAoZGVwdGhTaXplICsgMSkgLyAyKSAqIGRpc3RhbmNlWCxcbiAgICAgICAgeTogKGRlcHRoICsgMSkgKiBkaXN0YW5jZVlcbiAgICAgIH07XG5cbiAgICAgIGlmIChpc0JvdHRvbURlcHRoKSB7XG4gICAgICAgIHJldHVybiBlcG9zO1xuICAgICAgfVxuXG4gICAgICAvLyBsZXQgc3VjY3MgPSBzdWNjZXNzb3JzWyBlbGUuaWQoKSBdO1xuICAgICAgLy8gaWYoIHN1Y2NzICl7XG4gICAgICAvLyAgIGVwb3MueCA9IDA7XG4gICAgICAvL1xuICAgICAgLy8gICBmb3IoIGxldCBpID0gMCA7IGkgPCBzdWNjcy5sZW5ndGg7IGkrKyApe1xuICAgICAgLy8gICAgIGxldCBzcG9zID0gcG9zWyBzdWNjc1tpXS5pZCgpIF07XG4gICAgICAvL1xuICAgICAgLy8gICAgIGVwb3MueCArPSBzcG9zLng7XG4gICAgICAvLyAgIH1cbiAgICAgIC8vXG4gICAgICAvLyAgIGVwb3MueCAvPSBzdWNjcy5sZW5ndGg7XG4gICAgICAvLyB9IGVsc2Uge1xuICAgICAgLy8gICAvL2RlYnVnZ2VyO1xuICAgICAgLy8gfVxuXG4gICAgICByZXR1cm4gZXBvcztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG9wdGlvbnMuY2lyY2xlKSB7XG4gICAgICAgIHZhciByYWRpdXMgPSByYWRpdXNTdGVwU2l6ZSAqIGRlcHRoICsgcmFkaXVzU3RlcFNpemUgLSAoZGVwdGhzLmxlbmd0aCA+IDAgJiYgZGVwdGhzWzBdLmxlbmd0aCA8PSAzID8gcmFkaXVzU3RlcFNpemUgLyAyIDogMCk7XG4gICAgICAgIHZhciB0aGV0YSA9IDIgKiBNYXRoLlBJIC8gZGVwdGhzW2RlcHRoXS5sZW5ndGggKiBpbmRleDtcblxuICAgICAgICBpZiAoZGVwdGggPT09IDAgJiYgZGVwdGhzWzBdLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHJhZGl1cyA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IGNlbnRlci54ICsgcmFkaXVzICogTWF0aC5jb3ModGhldGEpLFxuICAgICAgICAgIHk6IGNlbnRlci55ICsgcmFkaXVzICogTWF0aC5zaW4odGhldGEpXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IGNlbnRlci54ICsgKGluZGV4ICsgMSAtIChkZXB0aFNpemUgKyAxKSAvIDIpICogZGlzdGFuY2VYLFxuICAgICAgICAgIHk6IChkZXB0aCArIDEpICogZGlzdGFuY2VZXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIGdldCBwb3NpdGlvbnMgaW4gcmV2ZXJzZSBkZXB0aCBvcmRlclxuICB2YXIgcG9zID0ge307XG4gIGZvciAodmFyIF9pMTIgPSBkZXB0aHMubGVuZ3RoIC0gMTsgX2kxMiA+PSAwOyBfaTEyLS0pIHtcbiAgICB2YXIgX2RlcHRoMyA9IGRlcHRoc1tfaTEyXTtcblxuICAgIGZvciAodmFyIF9qID0gMDsgX2ogPCBfZGVwdGgzLmxlbmd0aDsgX2orKykge1xuICAgICAgdmFyIF9ub2RlMiA9IF9kZXB0aDNbX2pdO1xuXG4gICAgICBwb3NbX25vZGUyLmlkKCldID0gZ2V0UG9zaXRpb24oX25vZGUyLCBfaTEyID09PSBkZXB0aHMubGVuZ3RoIC0gMSk7XG4gICAgfVxuICB9XG5cbiAgbm9kZXMubGF5b3V0UG9zaXRpb25zKHRoaXMsIG9wdGlvbnMsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuIHBvc1tub2RlLmlkKCldO1xuICB9KTtcblxuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQnJlYWR0aEZpcnN0TGF5b3V0O1xuXG4vKioqLyB9KSxcbi8qIDk4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbnZhciBtYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbnZhciBpcyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgZml0OiB0cnVlLCAvLyB3aGV0aGVyIHRvIGZpdCB0aGUgdmlld3BvcnQgdG8gdGhlIGdyYXBoXG4gIHBhZGRpbmc6IDMwLCAvLyB0aGUgcGFkZGluZyBvbiBmaXRcbiAgYm91bmRpbmdCb3g6IHVuZGVmaW5lZCwgLy8gY29uc3RyYWluIGxheW91dCBib3VuZHM7IHsgeDEsIHkxLCB4MiwgeTIgfSBvciB7IHgxLCB5MSwgdywgaCB9XG4gIGF2b2lkT3ZlcmxhcDogdHJ1ZSwgLy8gcHJldmVudHMgbm9kZSBvdmVybGFwLCBtYXkgb3ZlcmZsb3cgYm91bmRpbmdCb3ggYW5kIHJhZGl1cyBpZiBub3QgZW5vdWdoIHNwYWNlXG4gIG5vZGVEaW1lbnNpb25zSW5jbHVkZUxhYmVsczogZmFsc2UsIC8vIEV4Y2x1ZGVzIHRoZSBsYWJlbCB3aGVuIGNhbGN1bGF0aW5nIG5vZGUgYm91bmRpbmcgYm94ZXMgZm9yIHRoZSBsYXlvdXQgYWxnb3JpdGhtXG4gIHNwYWNpbmdGYWN0b3I6IHVuZGVmaW5lZCwgLy8gQXBwbGllcyBhIG11bHRpcGxpY2F0aXZlIGZhY3RvciAoPjApIHRvIGV4cGFuZCBvciBjb21wcmVzcyB0aGUgb3ZlcmFsbCBhcmVhIHRoYXQgdGhlIG5vZGVzIHRha2UgdXBcbiAgcmFkaXVzOiB1bmRlZmluZWQsIC8vIHRoZSByYWRpdXMgb2YgdGhlIGNpcmNsZVxuICBzdGFydEFuZ2xlOiAzIC8gMiAqIE1hdGguUEksIC8vIHdoZXJlIG5vZGVzIHN0YXJ0IGluIHJhZGlhbnNcbiAgc3dlZXA6IHVuZGVmaW5lZCwgLy8gaG93IG1hbnkgcmFkaWFucyBzaG91bGQgYmUgYmV0d2VlbiB0aGUgZmlyc3QgYW5kIGxhc3Qgbm9kZSAoZGVmYXVsdHMgdG8gZnVsbCBjaXJjbGUpXG4gIGNsb2Nrd2lzZTogdHJ1ZSwgLy8gd2hldGhlciB0aGUgbGF5b3V0IHNob3VsZCBnbyBjbG9ja3dpc2UgKHRydWUpIG9yIGNvdW50ZXJjbG9ja3dpc2UvYW50aWNsb2Nrd2lzZSAoZmFsc2UpXG4gIHNvcnQ6IHVuZGVmaW5lZCwgLy8gYSBzb3J0aW5nIGZ1bmN0aW9uIHRvIG9yZGVyIHRoZSBub2RlczsgZS5nLiBmdW5jdGlvbihhLCBiKXsgcmV0dXJuIGEuZGF0YSgnd2VpZ2h0JykgLSBiLmRhdGEoJ3dlaWdodCcpIH1cbiAgYW5pbWF0ZTogZmFsc2UsIC8vIHdoZXRoZXIgdG8gdHJhbnNpdGlvbiB0aGUgbm9kZSBwb3NpdGlvbnNcbiAgYW5pbWF0aW9uRHVyYXRpb246IDUwMCwgLy8gZHVyYXRpb24gb2YgYW5pbWF0aW9uIGluIG1zIGlmIGVuYWJsZWRcbiAgYW5pbWF0aW9uRWFzaW5nOiB1bmRlZmluZWQsIC8vIGVhc2luZyBvZiBhbmltYXRpb24gaWYgZW5hYmxlZFxuICBhbmltYXRlRmlsdGVyOiBmdW5jdGlvbiBhbmltYXRlRmlsdGVyKG5vZGUsIGkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgLy8gYSBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgd2hldGhlciB0aGUgbm9kZSBzaG91bGQgYmUgYW5pbWF0ZWQuICBBbGwgbm9kZXMgYW5pbWF0ZWQgYnkgZGVmYXVsdCBvbiBhbmltYXRlIGVuYWJsZWQuICBOb24tYW5pbWF0ZWQgbm9kZXMgYXJlIHBvc2l0aW9uZWQgaW1tZWRpYXRlbHkgd2hlbiB0aGUgbGF5b3V0IHN0YXJ0c1xuICByZWFkeTogdW5kZWZpbmVkLCAvLyBjYWxsYmFjayBvbiBsYXlvdXRyZWFkeVxuICBzdG9wOiB1bmRlZmluZWQsIC8vIGNhbGxiYWNrIG9uIGxheW91dHN0b3BcbiAgdHJhbnNmb3JtOiBmdW5jdGlvbiB0cmFuc2Zvcm0obm9kZSwgcG9zaXRpb24pIHtcbiAgICByZXR1cm4gcG9zaXRpb247XG4gIH0gLy8gdHJhbnNmb3JtIGEgZ2l2ZW4gbm9kZSBwb3NpdGlvbi4gVXNlZnVsIGZvciBjaGFuZ2luZyBmbG93IGRpcmVjdGlvbiBpbiBkaXNjcmV0ZSBsYXlvdXRzIFxuXG59O1xuXG5mdW5jdGlvbiBDaXJjbGVMYXlvdXQob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7fSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xufVxuXG5DaXJjbGVMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHBhcmFtcyA9IHRoaXMub3B0aW9ucztcbiAgdmFyIG9wdGlvbnMgPSBwYXJhbXM7XG5cbiAgdmFyIGN5ID0gcGFyYW1zLmN5O1xuICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlcztcblxuICB2YXIgY2xvY2t3aXNlID0gb3B0aW9ucy5jb3VudGVyY2xvY2t3aXNlICE9PSB1bmRlZmluZWQgPyAhb3B0aW9ucy5jb3VudGVyY2xvY2t3aXNlIDogb3B0aW9ucy5jbG9ja3dpc2U7XG5cbiAgdmFyIG5vZGVzID0gZWxlcy5ub2RlcygpLm5vdCgnOnBhcmVudCcpO1xuXG4gIGlmIChvcHRpb25zLnNvcnQpIHtcbiAgICBub2RlcyA9IG5vZGVzLnNvcnQob3B0aW9ucy5zb3J0KTtcbiAgfVxuXG4gIHZhciBiYiA9IG1hdGgubWFrZUJvdW5kaW5nQm94KG9wdGlvbnMuYm91bmRpbmdCb3ggPyBvcHRpb25zLmJvdW5kaW5nQm94IDoge1xuICAgIHgxOiAwLCB5MTogMCwgdzogY3kud2lkdGgoKSwgaDogY3kuaGVpZ2h0KClcbiAgfSk7XG5cbiAgdmFyIGNlbnRlciA9IHtcbiAgICB4OiBiYi54MSArIGJiLncgLyAyLFxuICAgIHk6IGJiLnkxICsgYmIuaCAvIDJcbiAgfTtcblxuICB2YXIgc3dlZXAgPSBvcHRpb25zLnN3ZWVwID09PSB1bmRlZmluZWQgPyAyICogTWF0aC5QSSAtIDIgKiBNYXRoLlBJIC8gbm9kZXMubGVuZ3RoIDogb3B0aW9ucy5zd2VlcDtcbiAgdmFyIGRUaGV0YSA9IHN3ZWVwIC8gTWF0aC5tYXgoMSwgbm9kZXMubGVuZ3RoIC0gMSk7XG4gIHZhciByID0gdm9pZCAwO1xuXG4gIHZhciBtaW5EaXN0YW5jZSA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbiA9IG5vZGVzW2ldO1xuICAgIHZhciBuYmIgPSBuLmxheW91dERpbWVuc2lvbnMob3B0aW9ucyk7XG4gICAgdmFyIHcgPSBuYmIudztcbiAgICB2YXIgaCA9IG5iYi5oO1xuXG4gICAgbWluRGlzdGFuY2UgPSBNYXRoLm1heChtaW5EaXN0YW5jZSwgdywgaCk7XG4gIH1cblxuICBpZiAoaXMubnVtYmVyKG9wdGlvbnMucmFkaXVzKSkge1xuICAgIHIgPSBvcHRpb25zLnJhZGl1cztcbiAgfSBlbHNlIGlmIChub2Rlcy5sZW5ndGggPD0gMSkge1xuICAgIHIgPSAwO1xuICB9IGVsc2Uge1xuICAgIHIgPSBNYXRoLm1pbihiYi5oLCBiYi53KSAvIDIgLSBtaW5EaXN0YW5jZTtcbiAgfVxuXG4gIC8vIGNhbGN1bGF0ZSB0aGUgcmFkaXVzXG4gIGlmIChub2Rlcy5sZW5ndGggPiAxICYmIG9wdGlvbnMuYXZvaWRPdmVybGFwKSB7XG4gICAgLy8gYnV0IG9ubHkgaWYgbW9yZSB0aGFuIG9uZSBub2RlIChjYW4ndCBvdmVybGFwKVxuICAgIG1pbkRpc3RhbmNlICo9IDEuNzU7IC8vIGp1c3QgdG8gaGF2ZSBzb21lIG5pY2Ugc3BhY2luZ1xuXG4gICAgdmFyIGRjb3MgPSBNYXRoLmNvcyhkVGhldGEpIC0gTWF0aC5jb3MoMCk7XG4gICAgdmFyIGRzaW4gPSBNYXRoLnNpbihkVGhldGEpIC0gTWF0aC5zaW4oMCk7XG4gICAgdmFyIHJNaW4gPSBNYXRoLnNxcnQobWluRGlzdGFuY2UgKiBtaW5EaXN0YW5jZSAvIChkY29zICogZGNvcyArIGRzaW4gKiBkc2luKSk7IC8vIHMudC4gbm8gbm9kZXMgb3ZlcmxhcHBpbmdcbiAgICByID0gTWF0aC5tYXgock1pbiwgcik7XG4gIH1cblxuICB2YXIgZ2V0UG9zID0gZnVuY3Rpb24gZ2V0UG9zKGVsZSwgaSkge1xuICAgIHZhciB0aGV0YSA9IG9wdGlvbnMuc3RhcnRBbmdsZSArIGkgKiBkVGhldGEgKiAoY2xvY2t3aXNlID8gMSA6IC0xKTtcblxuICAgIHZhciByeCA9IHIgKiBNYXRoLmNvcyh0aGV0YSk7XG4gICAgdmFyIHJ5ID0gciAqIE1hdGguc2luKHRoZXRhKTtcbiAgICB2YXIgcG9zID0ge1xuICAgICAgeDogY2VudGVyLnggKyByeCxcbiAgICAgIHk6IGNlbnRlci55ICsgcnlcbiAgICB9O1xuXG4gICAgcmV0dXJuIHBvcztcbiAgfTtcblxuICBub2Rlcy5sYXlvdXRQb3NpdGlvbnModGhpcywgb3B0aW9ucywgZ2V0UG9zKTtcblxuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2lyY2xlTGF5b3V0O1xuXG4vKioqLyB9KSxcbi8qIDk5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbnZhciBtYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIGRlZmF1bHRzID0ge1xuICBmaXQ6IHRydWUsIC8vIHdoZXRoZXIgdG8gZml0IHRoZSB2aWV3cG9ydCB0byB0aGUgZ3JhcGhcbiAgcGFkZGluZzogMzAsIC8vIHRoZSBwYWRkaW5nIG9uIGZpdFxuICBzdGFydEFuZ2xlOiAzIC8gMiAqIE1hdGguUEksIC8vIHdoZXJlIG5vZGVzIHN0YXJ0IGluIHJhZGlhbnNcbiAgc3dlZXA6IHVuZGVmaW5lZCwgLy8gaG93IG1hbnkgcmFkaWFucyBzaG91bGQgYmUgYmV0d2VlbiB0aGUgZmlyc3QgYW5kIGxhc3Qgbm9kZSAoZGVmYXVsdHMgdG8gZnVsbCBjaXJjbGUpXG4gIGNsb2Nrd2lzZTogdHJ1ZSwgLy8gd2hldGhlciB0aGUgbGF5b3V0IHNob3VsZCBnbyBjbG9ja3dpc2UgKHRydWUpIG9yIGNvdW50ZXJjbG9ja3dpc2UvYW50aWNsb2Nrd2lzZSAoZmFsc2UpXG4gIGVxdWlkaXN0YW50OiBmYWxzZSwgLy8gd2hldGhlciBsZXZlbHMgaGF2ZSBhbiBlcXVhbCByYWRpYWwgZGlzdGFuY2UgYmV0d2VuIHRoZW0sIG1heSBjYXVzZSBib3VuZGluZyBib3ggb3ZlcmZsb3dcbiAgbWluTm9kZVNwYWNpbmc6IDEwLCAvLyBtaW4gc3BhY2luZyBiZXR3ZWVuIG91dHNpZGUgb2Ygbm9kZXMgKHVzZWQgZm9yIHJhZGl1cyBhZGp1c3RtZW50KVxuICBib3VuZGluZ0JveDogdW5kZWZpbmVkLCAvLyBjb25zdHJhaW4gbGF5b3V0IGJvdW5kczsgeyB4MSwgeTEsIHgyLCB5MiB9IG9yIHsgeDEsIHkxLCB3LCBoIH1cbiAgYXZvaWRPdmVybGFwOiB0cnVlLCAvLyBwcmV2ZW50cyBub2RlIG92ZXJsYXAsIG1heSBvdmVyZmxvdyBib3VuZGluZ0JveCBpZiBub3QgZW5vdWdoIHNwYWNlXG4gIG5vZGVEaW1lbnNpb25zSW5jbHVkZUxhYmVsczogZmFsc2UsIC8vIEV4Y2x1ZGVzIHRoZSBsYWJlbCB3aGVuIGNhbGN1bGF0aW5nIG5vZGUgYm91bmRpbmcgYm94ZXMgZm9yIHRoZSBsYXlvdXQgYWxnb3JpdGhtXG4gIGhlaWdodDogdW5kZWZpbmVkLCAvLyBoZWlnaHQgb2YgbGF5b3V0IGFyZWEgKG92ZXJyaWRlcyBjb250YWluZXIgaGVpZ2h0KVxuICB3aWR0aDogdW5kZWZpbmVkLCAvLyB3aWR0aCBvZiBsYXlvdXQgYXJlYSAob3ZlcnJpZGVzIGNvbnRhaW5lciB3aWR0aClcbiAgc3BhY2luZ0ZhY3RvcjogdW5kZWZpbmVkLCAvLyBBcHBsaWVzIGEgbXVsdGlwbGljYXRpdmUgZmFjdG9yICg+MCkgdG8gZXhwYW5kIG9yIGNvbXByZXNzIHRoZSBvdmVyYWxsIGFyZWEgdGhhdCB0aGUgbm9kZXMgdGFrZSB1cFxuICBjb25jZW50cmljOiBmdW5jdGlvbiBjb25jZW50cmljKG5vZGUpIHtcbiAgICAvLyByZXR1cm5zIG51bWVyaWMgdmFsdWUgZm9yIGVhY2ggbm9kZSwgcGxhY2luZyBoaWdoZXIgbm9kZXMgaW4gbGV2ZWxzIHRvd2FyZHMgdGhlIGNlbnRyZVxuICAgIHJldHVybiBub2RlLmRlZ3JlZSgpO1xuICB9LFxuICBsZXZlbFdpZHRoOiBmdW5jdGlvbiBsZXZlbFdpZHRoKG5vZGVzKSB7XG4gICAgLy8gdGhlIGxldGlhdGlvbiBvZiBjb25jZW50cmljIHZhbHVlcyBpbiBlYWNoIGxldmVsXG4gICAgcmV0dXJuIG5vZGVzLm1heERlZ3JlZSgpIC8gNDtcbiAgfSxcbiAgYW5pbWF0ZTogZmFsc2UsIC8vIHdoZXRoZXIgdG8gdHJhbnNpdGlvbiB0aGUgbm9kZSBwb3NpdGlvbnNcbiAgYW5pbWF0aW9uRHVyYXRpb246IDUwMCwgLy8gZHVyYXRpb24gb2YgYW5pbWF0aW9uIGluIG1zIGlmIGVuYWJsZWRcbiAgYW5pbWF0aW9uRWFzaW5nOiB1bmRlZmluZWQsIC8vIGVhc2luZyBvZiBhbmltYXRpb24gaWYgZW5hYmxlZFxuICBhbmltYXRlRmlsdGVyOiBmdW5jdGlvbiBhbmltYXRlRmlsdGVyKG5vZGUsIGkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgLy8gYSBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgd2hldGhlciB0aGUgbm9kZSBzaG91bGQgYmUgYW5pbWF0ZWQuICBBbGwgbm9kZXMgYW5pbWF0ZWQgYnkgZGVmYXVsdCBvbiBhbmltYXRlIGVuYWJsZWQuICBOb24tYW5pbWF0ZWQgbm9kZXMgYXJlIHBvc2l0aW9uZWQgaW1tZWRpYXRlbHkgd2hlbiB0aGUgbGF5b3V0IHN0YXJ0c1xuICByZWFkeTogdW5kZWZpbmVkLCAvLyBjYWxsYmFjayBvbiBsYXlvdXRyZWFkeVxuICBzdG9wOiB1bmRlZmluZWQsIC8vIGNhbGxiYWNrIG9uIGxheW91dHN0b3BcbiAgdHJhbnNmb3JtOiBmdW5jdGlvbiB0cmFuc2Zvcm0obm9kZSwgcG9zaXRpb24pIHtcbiAgICByZXR1cm4gcG9zaXRpb247XG4gIH0gLy8gdHJhbnNmb3JtIGEgZ2l2ZW4gbm9kZSBwb3NpdGlvbi4gVXNlZnVsIGZvciBjaGFuZ2luZyBmbG93IGRpcmVjdGlvbiBpbiBkaXNjcmV0ZSBsYXlvdXRzIFxufTtcblxuZnVuY3Rpb24gQ29uY2VudHJpY0xheW91dChvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG59XG5cbkNvbmNlbnRyaWNMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHBhcmFtcyA9IHRoaXMub3B0aW9ucztcbiAgdmFyIG9wdGlvbnMgPSBwYXJhbXM7XG5cbiAgdmFyIGNsb2Nrd2lzZSA9IG9wdGlvbnMuY291bnRlcmNsb2Nrd2lzZSAhPT0gdW5kZWZpbmVkID8gIW9wdGlvbnMuY291bnRlcmNsb2Nrd2lzZSA6IG9wdGlvbnMuY2xvY2t3aXNlO1xuXG4gIHZhciBjeSA9IHBhcmFtcy5jeTtcblxuICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlcztcbiAgdmFyIG5vZGVzID0gZWxlcy5ub2RlcygpLm5vdCgnOnBhcmVudCcpO1xuXG4gIHZhciBiYiA9IG1hdGgubWFrZUJvdW5kaW5nQm94KG9wdGlvbnMuYm91bmRpbmdCb3ggPyBvcHRpb25zLmJvdW5kaW5nQm94IDoge1xuICAgIHgxOiAwLCB5MTogMCwgdzogY3kud2lkdGgoKSwgaDogY3kuaGVpZ2h0KClcbiAgfSk7XG5cbiAgdmFyIGNlbnRlciA9IHtcbiAgICB4OiBiYi54MSArIGJiLncgLyAyLFxuICAgIHk6IGJiLnkxICsgYmIuaCAvIDJcbiAgfTtcblxuICB2YXIgbm9kZVZhbHVlcyA9IFtdOyAvLyB7IG5vZGUsIHZhbHVlIH1cbiAgdmFyIHRoZXRhID0gb3B0aW9ucy5zdGFydEFuZ2xlO1xuICB2YXIgbWF4Tm9kZVNpemUgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgIHZhciB2YWx1ZSA9IHZvaWQgMDtcblxuICAgIC8vIGNhbGN1bGF0ZSB0aGUgbm9kZSB2YWx1ZVxuICAgIHZhbHVlID0gb3B0aW9ucy5jb25jZW50cmljKG5vZGUpO1xuICAgIG5vZGVWYWx1ZXMucHVzaCh7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBub2RlOiBub2RlXG4gICAgfSk7XG5cbiAgICAvLyBmb3Igc3R5bGUgbWFwcGluZ1xuICAgIG5vZGUuX3ByaXZhdGUuc2NyYXRjaC5jb25jZW50cmljID0gdmFsdWU7XG4gIH1cblxuICAvLyBpbiBjYXNlIHdlIHVzZWQgdGhlIGBjb25jZW50cmljYCBpbiBzdHlsZVxuICBub2Rlcy51cGRhdGVTdHlsZSgpO1xuXG4gIC8vIGNhbGN1bGF0ZSBtYXggc2l6ZSBub3cgYmFzZWQgb24gcG90ZW50aWFsbHkgdXBkYXRlZCBtYXBwZXJzXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBub2Rlcy5sZW5ndGg7IF9pKyspIHtcbiAgICB2YXIgX25vZGUgPSBub2Rlc1tfaV07XG4gICAgdmFyIG5iYiA9IF9ub2RlLmxheW91dERpbWVuc2lvbnMob3B0aW9ucyk7XG5cbiAgICBtYXhOb2RlU2l6ZSA9IE1hdGgubWF4KG1heE5vZGVTaXplLCBuYmIudywgbmJiLmgpO1xuICB9XG5cbiAgLy8gc29ydCBub2RlIHZhbHVlcyBpbiBkZXNjcmVhc2luZyBvcmRlclxuICBub2RlVmFsdWVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYi52YWx1ZSAtIGEudmFsdWU7XG4gIH0pO1xuXG4gIHZhciBsZXZlbFdpZHRoID0gb3B0aW9ucy5sZXZlbFdpZHRoKG5vZGVzKTtcblxuICAvLyBwdXQgdGhlIHZhbHVlcyBpbnRvIGxldmVsc1xuICB2YXIgbGV2ZWxzID0gW1tdXTtcbiAgdmFyIGN1cnJlbnRMZXZlbCA9IGxldmVsc1swXTtcbiAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbm9kZVZhbHVlcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgdmFyIHZhbCA9IG5vZGVWYWx1ZXNbX2kyXTtcblxuICAgIGlmIChjdXJyZW50TGV2ZWwubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIGRpZmYgPSBNYXRoLmFicyhjdXJyZW50TGV2ZWxbMF0udmFsdWUgLSB2YWwudmFsdWUpO1xuXG4gICAgICBpZiAoZGlmZiA+PSBsZXZlbFdpZHRoKSB7XG4gICAgICAgIGN1cnJlbnRMZXZlbCA9IFtdO1xuICAgICAgICBsZXZlbHMucHVzaChjdXJyZW50TGV2ZWwpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGN1cnJlbnRMZXZlbC5wdXNoKHZhbCk7XG4gIH1cblxuICAvLyBjcmVhdGUgcG9zaXRpb25zIGZyb20gbGV2ZWxzXG5cbiAgdmFyIG1pbkRpc3QgPSBtYXhOb2RlU2l6ZSArIG9wdGlvbnMubWluTm9kZVNwYWNpbmc7IC8vIG1pbiBkaXN0IGJldHdlZW4gbm9kZXNcblxuICBpZiAoIW9wdGlvbnMuYXZvaWRPdmVybGFwKSB7XG4gICAgLy8gdGhlbiBzdHJpY3RseSBjb25zdHJhaW4gdG8gYmJcbiAgICB2YXIgZmlyc3RMdmxIYXNNdWx0aSA9IGxldmVscy5sZW5ndGggPiAwICYmIGxldmVsc1swXS5sZW5ndGggPiAxO1xuICAgIHZhciBtYXhSID0gTWF0aC5taW4oYmIudywgYmIuaCkgLyAyIC0gbWluRGlzdDtcbiAgICB2YXIgclN0ZXAgPSBtYXhSIC8gKGxldmVscy5sZW5ndGggKyBmaXJzdEx2bEhhc011bHRpID8gMSA6IDApO1xuXG4gICAgbWluRGlzdCA9IE1hdGgubWluKG1pbkRpc3QsIHJTdGVwKTtcbiAgfVxuXG4gIC8vIGZpbmQgdGhlIG1ldHJpY3MgZm9yIGVhY2ggbGV2ZWxcbiAgdmFyIHIgPSAwO1xuICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBsZXZlbHMubGVuZ3RoOyBfaTMrKykge1xuICAgIHZhciBsZXZlbCA9IGxldmVsc1tfaTNdO1xuICAgIHZhciBzd2VlcCA9IG9wdGlvbnMuc3dlZXAgPT09IHVuZGVmaW5lZCA/IDIgKiBNYXRoLlBJIC0gMiAqIE1hdGguUEkgLyBsZXZlbC5sZW5ndGggOiBvcHRpb25zLnN3ZWVwO1xuICAgIHZhciBkVGhldGEgPSBsZXZlbC5kVGhldGEgPSBzd2VlcCAvIE1hdGgubWF4KDEsIGxldmVsLmxlbmd0aCAtIDEpO1xuXG4gICAgLy8gY2FsY3VsYXRlIHRoZSByYWRpdXNcbiAgICBpZiAobGV2ZWwubGVuZ3RoID4gMSAmJiBvcHRpb25zLmF2b2lkT3ZlcmxhcCkge1xuICAgICAgLy8gYnV0IG9ubHkgaWYgbW9yZSB0aGFuIG9uZSBub2RlIChjYW4ndCBvdmVybGFwKVxuICAgICAgdmFyIGRjb3MgPSBNYXRoLmNvcyhkVGhldGEpIC0gTWF0aC5jb3MoMCk7XG4gICAgICB2YXIgZHNpbiA9IE1hdGguc2luKGRUaGV0YSkgLSBNYXRoLnNpbigwKTtcbiAgICAgIHZhciByTWluID0gTWF0aC5zcXJ0KG1pbkRpc3QgKiBtaW5EaXN0IC8gKGRjb3MgKiBkY29zICsgZHNpbiAqIGRzaW4pKTsgLy8gcy50LiBubyBub2RlcyBvdmVybGFwcGluZ1xuXG4gICAgICByID0gTWF0aC5tYXgock1pbiwgcik7XG4gICAgfVxuXG4gICAgbGV2ZWwuciA9IHI7XG5cbiAgICByICs9IG1pbkRpc3Q7XG4gIH1cblxuICBpZiAob3B0aW9ucy5lcXVpZGlzdGFudCkge1xuICAgIHZhciByRGVsdGFNYXggPSAwO1xuICAgIHZhciBfciA9IDA7XG5cbiAgICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBsZXZlbHMubGVuZ3RoOyBfaTQrKykge1xuICAgICAgdmFyIF9sZXZlbCA9IGxldmVsc1tfaTRdO1xuICAgICAgdmFyIHJEZWx0YSA9IF9sZXZlbC5yIC0gX3I7XG5cbiAgICAgIHJEZWx0YU1heCA9IE1hdGgubWF4KHJEZWx0YU1heCwgckRlbHRhKTtcbiAgICB9XG5cbiAgICBfciA9IDA7XG4gICAgZm9yICh2YXIgX2k1ID0gMDsgX2k1IDwgbGV2ZWxzLmxlbmd0aDsgX2k1KyspIHtcbiAgICAgIHZhciBfbGV2ZWwyID0gbGV2ZWxzW19pNV07XG5cbiAgICAgIGlmIChfaTUgPT09IDApIHtcbiAgICAgICAgX3IgPSBfbGV2ZWwyLnI7XG4gICAgICB9XG5cbiAgICAgIF9sZXZlbDIuciA9IF9yO1xuXG4gICAgICBfciArPSByRGVsdGFNYXg7XG4gICAgfVxuICB9XG5cbiAgLy8gY2FsY3VsYXRlIHRoZSBub2RlIHBvc2l0aW9uc1xuICB2YXIgcG9zID0ge307IC8vIGlkID0+IHBvc2l0aW9uXG4gIGZvciAodmFyIF9pNiA9IDA7IF9pNiA8IGxldmVscy5sZW5ndGg7IF9pNisrKSB7XG4gICAgdmFyIF9sZXZlbDMgPSBsZXZlbHNbX2k2XTtcbiAgICB2YXIgX2RUaGV0YSA9IF9sZXZlbDMuZFRoZXRhO1xuICAgIHZhciBfcjIgPSBfbGV2ZWwzLnI7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IF9sZXZlbDMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBfdmFsID0gX2xldmVsM1tqXTtcbiAgICAgIHZhciBfdGhldGEgPSBvcHRpb25zLnN0YXJ0QW5nbGUgKyAoY2xvY2t3aXNlID8gMSA6IC0xKSAqIF9kVGhldGEgKiBqO1xuXG4gICAgICB2YXIgcCA9IHtcbiAgICAgICAgeDogY2VudGVyLnggKyBfcjIgKiBNYXRoLmNvcyhfdGhldGEpLFxuICAgICAgICB5OiBjZW50ZXIueSArIF9yMiAqIE1hdGguc2luKF90aGV0YSlcbiAgICAgIH07XG5cbiAgICAgIHBvc1tfdmFsLm5vZGUuaWQoKV0gPSBwO1xuICAgIH1cbiAgfVxuXG4gIC8vIHBvc2l0aW9uIHRoZSBub2Rlc1xuICBub2Rlcy5sYXlvdXRQb3NpdGlvbnModGhpcywgb3B0aW9ucywgZnVuY3Rpb24gKGVsZSkge1xuICAgIHZhciBpZCA9IGVsZS5pZCgpO1xuXG4gICAgcmV0dXJuIHBvc1tpZF07XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb25jZW50cmljTGF5b3V0O1xuXG4vKioqLyB9KSxcbi8qIDEwMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKlxuVGhlIENvU0UgbGF5b3V0IHdhcyB3cml0dGVuIGJ5IEdlcmFyZG8gSHVjay5cbmh0dHBzOi8vd3d3LmxpbmtlZGluLmNvbS9pbi9nZXJhcmRvaHVjay9cblxuQmFzZWQgb24gdGhlIGZvbGxvd2luZyBhcnRpY2xlOlxuaHR0cDovL2RsLmFjbS5vcmcvY2l0YXRpb24uY2ZtP2lkPTE0OTgwNDdcblxuTW9kaWZpY2F0aW9ucyB0cmFja2VkIG9uIEdpdGh1Yi5cbiovXG5cbnZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbnZhciBtYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbnZhciBpcyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgUHJvbWlzZSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbnZhciBERUJVRztcblxuLyoqXG4gKiBAYnJpZWYgOiAgZGVmYXVsdCBsYXlvdXQgb3B0aW9uc1xuICovXG52YXIgZGVmYXVsdHMgPSB7XG4gIC8vIENhbGxlZCBvbiBgbGF5b3V0cmVhZHlgXG4gIHJlYWR5OiBmdW5jdGlvbiByZWFkeSgpIHt9LFxuXG4gIC8vIENhbGxlZCBvbiBgbGF5b3V0c3RvcGBcbiAgc3RvcDogZnVuY3Rpb24gc3RvcCgpIHt9LFxuXG4gIC8vIFdoZXRoZXIgdG8gYW5pbWF0ZSB3aGlsZSBydW5uaW5nIHRoZSBsYXlvdXRcbiAgLy8gdHJ1ZSA6IEFuaW1hdGUgY29udGludW91c2x5IGFzIHRoZSBsYXlvdXQgaXMgcnVubmluZ1xuICAvLyBmYWxzZSA6IEp1c3Qgc2hvdyB0aGUgZW5kIHJlc3VsdFxuICAvLyAnZW5kJyA6IEFuaW1hdGUgd2l0aCB0aGUgZW5kIHJlc3VsdCwgZnJvbSB0aGUgaW5pdGlhbCBwb3NpdGlvbnMgdG8gdGhlIGVuZCBwb3NpdGlvbnNcbiAgYW5pbWF0ZTogdHJ1ZSxcblxuICAvLyBFYXNpbmcgb2YgdGhlIGFuaW1hdGlvbiBmb3IgYW5pbWF0ZTonZW5kJ1xuICBhbmltYXRpb25FYXNpbmc6IHVuZGVmaW5lZCxcblxuICAvLyBUaGUgZHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbiBmb3IgYW5pbWF0ZTonZW5kJ1xuICBhbmltYXRpb25EdXJhdGlvbjogdW5kZWZpbmVkLFxuXG4gIC8vIEEgZnVuY3Rpb24gdGhhdCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG5vZGUgc2hvdWxkIGJlIGFuaW1hdGVkXG4gIC8vIEFsbCBub2RlcyBhbmltYXRlZCBieSBkZWZhdWx0IG9uIGFuaW1hdGUgZW5hYmxlZFxuICAvLyBOb24tYW5pbWF0ZWQgbm9kZXMgYXJlIHBvc2l0aW9uZWQgaW1tZWRpYXRlbHkgd2hlbiB0aGUgbGF5b3V0IHN0YXJ0c1xuICBhbmltYXRlRmlsdGVyOiBmdW5jdGlvbiBhbmltYXRlRmlsdGVyKG5vZGUsIGkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICAvLyBUaGUgbGF5b3V0IGFuaW1hdGVzIG9ubHkgYWZ0ZXIgdGhpcyBtYW55IG1pbGxpc2Vjb25kcyBmb3IgYW5pbWF0ZTp0cnVlXG4gIC8vIChwcmV2ZW50cyBmbGFzaGluZyBvbiBmYXN0IHJ1bnMpXG4gIGFuaW1hdGlvblRocmVzaG9sZDogMjUwLFxuXG4gIC8vIE51bWJlciBvZiBpdGVyYXRpb25zIGJldHdlZW4gY29uc2VjdXRpdmUgc2NyZWVuIHBvc2l0aW9ucyB1cGRhdGVcbiAgLy8gKDAgLT4gb25seSB1cGRhdGVkIG9uIHRoZSBlbmQpXG4gIHJlZnJlc2g6IDIwLFxuXG4gIC8vIFdoZXRoZXIgdG8gZml0IHRoZSBuZXR3b3JrIHZpZXcgYWZ0ZXIgd2hlbiBkb25lXG4gIGZpdDogdHJ1ZSxcblxuICAvLyBQYWRkaW5nIG9uIGZpdFxuICBwYWRkaW5nOiAzMCxcblxuICAvLyBDb25zdHJhaW4gbGF5b3V0IGJvdW5kczsgeyB4MSwgeTEsIHgyLCB5MiB9IG9yIHsgeDEsIHkxLCB3LCBoIH1cbiAgYm91bmRpbmdCb3g6IHVuZGVmaW5lZCxcblxuICAvLyBFeGNsdWRlcyB0aGUgbGFiZWwgd2hlbiBjYWxjdWxhdGluZyBub2RlIGJvdW5kaW5nIGJveGVzIGZvciB0aGUgbGF5b3V0IGFsZ29yaXRobVxuICBub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHM6IGZhbHNlLFxuXG4gIC8vIFJhbmRvbWl6ZSB0aGUgaW5pdGlhbCBwb3NpdGlvbnMgb2YgdGhlIG5vZGVzICh0cnVlKSBvciB1c2UgZXhpc3RpbmcgcG9zaXRpb25zIChmYWxzZSlcbiAgcmFuZG9taXplOiBmYWxzZSxcblxuICAvLyBFeHRyYSBzcGFjaW5nIGJldHdlZW4gY29tcG9uZW50cyBpbiBub24tY29tcG91bmQgZ3JhcGhzXG4gIGNvbXBvbmVudFNwYWNpbmc6IDQwLFxuXG4gIC8vIE5vZGUgcmVwdWxzaW9uIChub24gb3ZlcmxhcHBpbmcpIG11bHRpcGxpZXJcbiAgbm9kZVJlcHVsc2lvbjogZnVuY3Rpb24gbm9kZVJlcHVsc2lvbihub2RlKSB7XG4gICAgcmV0dXJuIDIwNDg7XG4gIH0sXG5cbiAgLy8gTm9kZSByZXB1bHNpb24gKG92ZXJsYXBwaW5nKSBtdWx0aXBsaWVyXG4gIG5vZGVPdmVybGFwOiA0LFxuXG4gIC8vIElkZWFsIGVkZ2UgKG5vbiBuZXN0ZWQpIGxlbmd0aFxuICBpZGVhbEVkZ2VMZW5ndGg6IGZ1bmN0aW9uIGlkZWFsRWRnZUxlbmd0aChlZGdlKSB7XG4gICAgcmV0dXJuIDMyO1xuICB9LFxuXG4gIC8vIERpdmlzb3IgdG8gY29tcHV0ZSBlZGdlIGZvcmNlc1xuICBlZGdlRWxhc3RpY2l0eTogZnVuY3Rpb24gZWRnZUVsYXN0aWNpdHkoZWRnZSkge1xuICAgIHJldHVybiAzMjtcbiAgfSxcblxuICAvLyBOZXN0aW5nIGZhY3RvciAobXVsdGlwbGllcikgdG8gY29tcHV0ZSBpZGVhbCBlZGdlIGxlbmd0aCBmb3IgbmVzdGVkIGVkZ2VzXG4gIG5lc3RpbmdGYWN0b3I6IDEuMixcblxuICAvLyBHcmF2aXR5IGZvcmNlIChjb25zdGFudClcbiAgZ3Jhdml0eTogMSxcblxuICAvLyBNYXhpbXVtIG51bWJlciBvZiBpdGVyYXRpb25zIHRvIHBlcmZvcm1cbiAgbnVtSXRlcjogMTAwMCxcblxuICAvLyBJbml0aWFsIHRlbXBlcmF0dXJlIChtYXhpbXVtIG5vZGUgZGlzcGxhY2VtZW50KVxuICBpbml0aWFsVGVtcDogMTAwMCxcblxuICAvLyBDb29saW5nIGZhY3RvciAoaG93IHRoZSB0ZW1wZXJhdHVyZSBpcyByZWR1Y2VkIGJldHdlZW4gY29uc2VjdXRpdmUgaXRlcmF0aW9uc1xuICBjb29saW5nRmFjdG9yOiAwLjk5LFxuXG4gIC8vIExvd2VyIHRlbXBlcmF0dXJlIHRocmVzaG9sZCAoYmVsb3cgdGhpcyBwb2ludCB0aGUgbGF5b3V0IHdpbGwgZW5kKVxuICBtaW5UZW1wOiAxLjAsXG5cbiAgLy8gUGFzcyBhIHJlZmVyZW5jZSB0byB3ZWF2ZXIgdG8gdXNlIHRocmVhZHMgZm9yIGNhbGN1bGF0aW9uc1xuICB3ZWF2ZXI6IGZhbHNlXG59O1xuXG4vKipcbiAqIEBicmllZiAgICAgICA6IGNvbnN0cnVjdG9yXG4gKiBAYXJnIG9wdGlvbnMgOiBvYmplY3QgY29udGFpbmluZyBsYXlvdXQgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBDb3NlTGF5b3V0KG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gdXRpbC5leHRlbmQoe30sIGRlZmF1bHRzLCBvcHRpb25zKTtcblxuICB0aGlzLm9wdGlvbnMubGF5b3V0ID0gdGhpcztcbn1cblxuLyoqXG4gKiBAYnJpZWYgOiBydW5zIHRoZSBsYXlvdXRcbiAqL1xuQ29zZUxheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgdmFyIGN5ID0gb3B0aW9ucy5jeTtcbiAgdmFyIGxheW91dCA9IHRoaXM7XG4gIHZhciB0aHJlYWQgPSB0aGlzLnRocmVhZDtcbiAgdmFyIFRocmVhZCA9IG9wdGlvbnMud2VhdmVyID8gb3B0aW9ucy53ZWF2ZXIuVGhyZWFkIDogbnVsbDtcblxuICB2YXIgZmFsc2VUaHJlYWQgPSB7IC8vIHVzZSBmYWxzZSB0aHJlYWQgYXMgcG9seWZpbGxcbiAgICBsaXN0ZW5lcnM6IFtdLFxuICAgIG9uOiBmdW5jdGlvbiBvbihlLCBjYikge1xuICAgICAgdGhpcy5saXN0ZW5lcnMucHVzaCh7IGV2ZW50OiBlLCBjYWxsYmFjazogY2IgfSk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgdHJpZ2dlcjogZnVuY3Rpb24gdHJpZ2dlcihlKSB7XG4gICAgICBpZiAoaXMuc3RyaW5nKGUpKSB7XG4gICAgICAgIGUgPSB7IHR5cGU6IGUgfTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1hdGNoZXNFdmVudCA9IGZ1bmN0aW9uIG1hdGNoZXNFdmVudChsKSB7XG4gICAgICAgIHJldHVybiBsLmV2ZW50ID09PSBlLnR5cGU7XG4gICAgICB9O1xuICAgICAgdmFyIHRyaWdnZXIgPSBmdW5jdGlvbiB0cmlnZ2VyKGwpIHtcbiAgICAgICAgbC5jYWxsYmFjayhlKTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMubGlzdGVuZXJzLmZpbHRlcihtYXRjaGVzRXZlbnQpLmZvckVhY2godHJpZ2dlcik7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgcGFzczogZnVuY3Rpb24gcGFzcyhkYXRhKSB7XG4gICAgICB0aGlzLnBhc3MgPSBkYXRhO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHJ1bjogZnVuY3Rpb24gcnVuKGNiKSB7XG4gICAgICB2YXIgcGFzcyA9IHRoaXMucGFzcztcblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIHJlc29sdmUoY2IocGFzcykpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBzdG9wOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBzdG9wcGVkOiBmdW5jdGlvbiBzdG9wcGVkKCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGJyb2FkY2FzdChtZXNzYWdlKSB7XG4gICAgLy8gZm9yIGZhbHNlIHRocmVhZFxuICAgIHZhciBlID0geyB0eXBlOiAnbWVzc2FnZScsIG1lc3NhZ2U6IG1lc3NhZ2UgfTtcblxuICAgIGZhbHNlVGhyZWFkLnRyaWdnZXIoZSk7XG4gIH1cblxuICBpZiAoIXRocmVhZCB8fCB0aHJlYWQuc3RvcHBlZCgpKSB7XG4gICAgdGhyZWFkID0gdGhpcy50aHJlYWQgPSBUaHJlYWQgPyBuZXcgVGhyZWFkKCkgOiBmYWxzZVRocmVhZDtcbiAgfVxuXG4gIGxheW91dC5zdG9wcGVkID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMuYW5pbWF0ZSA9PT0gdHJ1ZSB8fCBvcHRpb25zLmFuaW1hdGUgPT09IGZhbHNlKSB7XG4gICAgbGF5b3V0LmVtaXQoeyB0eXBlOiAnbGF5b3V0c3RhcnQnLCBsYXlvdXQ6IGxheW91dCB9KTtcbiAgfVxuXG4gIC8vIFNldCBERUJVRyAtIEdsb2JhbCB2YXJpYWJsZVxuICBpZiAodHJ1ZSA9PT0gb3B0aW9ucy5kZWJ1Zykge1xuICAgIERFQlVHID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBERUJVRyA9IGZhbHNlO1xuICB9XG5cbiAgLy8gSW5pdGlhbGl6ZSBsYXlvdXQgaW5mb1xuICB2YXIgbGF5b3V0SW5mbyA9IGNyZWF0ZUxheW91dEluZm8oY3ksIGxheW91dCwgb3B0aW9ucyk7XG5cbiAgLy8gU2hvdyBMYXlvdXRJbmZvIGNvbnRlbnRzIGlmIGRlYnVnZ2luZ1xuICBpZiAoREVCVUcpIHtcbiAgICBwcmludExheW91dEluZm8obGF5b3V0SW5mbyk7XG4gIH1cblxuICAvLyBJZiByZXF1aXJlZCwgcmFuZG9taXplIG5vZGUgcG9zaXRpb25zXG4gIGlmIChvcHRpb25zLnJhbmRvbWl6ZSkge1xuICAgIHJhbmRvbWl6ZVBvc2l0aW9ucyhsYXlvdXRJbmZvLCBjeSk7XG4gIH1cblxuICB2YXIgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgdmFyIHJlZnJlc2hSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgdmFyIHJlZnJlc2ggPSBmdW5jdGlvbiByZWZyZXNoKHJPcHRzKSB7XG4gICAgck9wdHMgPSByT3B0cyB8fCB7fTtcblxuICAgIGlmIChyZWZyZXNoUmVxdWVzdGVkICYmICFyT3B0cy5uZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFyT3B0cy5mb3JjZSAmJiBEYXRlLm5vdygpIC0gc3RhcnRUaW1lIDwgb3B0aW9ucy5hbmltYXRpb25UaHJlc2hvbGQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZWZyZXNoUmVxdWVzdGVkID0gdHJ1ZTtcblxuICAgIHV0aWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlZnJlc2hQb3NpdGlvbnMobGF5b3V0SW5mbywgY3ksIG9wdGlvbnMpO1xuXG4gICAgICAvLyBGaXQgdGhlIGdyYXBoIGlmIG5lY2Vzc2FyeVxuICAgICAgaWYgKHRydWUgPT09IG9wdGlvbnMuZml0KSB7XG4gICAgICAgIGN5LmZpdChvcHRpb25zLnBhZGRpbmcpO1xuICAgICAgfVxuXG4gICAgICByZWZyZXNoUmVxdWVzdGVkID0gZmFsc2U7XG5cbiAgICAgIGlmIChyT3B0cy5uZXh0KSB7XG4gICAgICAgIHJPcHRzLm5leHQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICB0aHJlYWQub24oJ21lc3NhZ2UnLCBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBsYXlvdXROb2RlcyA9IGUubWVzc2FnZTtcblxuICAgIGxheW91dEluZm8ubGF5b3V0Tm9kZXMgPSBsYXlvdXROb2RlcztcbiAgICByZWZyZXNoKCk7XG4gIH0pO1xuXG4gIHRocmVhZC5wYXNzKHtcbiAgICBsYXlvdXRJbmZvOiBsYXlvdXRJbmZvLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIGFuaW1hdGU6IG9wdGlvbnMuYW5pbWF0ZSxcbiAgICAgIHJlZnJlc2g6IG9wdGlvbnMucmVmcmVzaCxcbiAgICAgIGNvbXBvbmVudFNwYWNpbmc6IG9wdGlvbnMuY29tcG9uZW50U3BhY2luZyxcbiAgICAgIG5vZGVPdmVybGFwOiBvcHRpb25zLm5vZGVPdmVybGFwLFxuICAgICAgbmVzdGluZ0ZhY3Rvcjogb3B0aW9ucy5uZXN0aW5nRmFjdG9yLFxuICAgICAgZ3Jhdml0eTogb3B0aW9ucy5ncmF2aXR5LFxuICAgICAgbnVtSXRlcjogb3B0aW9ucy5udW1JdGVyLFxuICAgICAgaW5pdGlhbFRlbXA6IG9wdGlvbnMuaW5pdGlhbFRlbXAsXG4gICAgICBjb29saW5nRmFjdG9yOiBvcHRpb25zLmNvb2xpbmdGYWN0b3IsXG4gICAgICBtaW5UZW1wOiBvcHRpb25zLm1pblRlbXBcbiAgICB9XG4gIH0pLnJ1bihmdW5jdGlvbiAocGFzcykge1xuICAgIHZhciBsYXlvdXRJbmZvID0gcGFzcy5sYXlvdXRJbmZvO1xuICAgIHZhciBvcHRpb25zID0gcGFzcy5vcHRpb25zO1xuICAgIHZhciBzdG9wcGVkID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAYnJpZWYgICAgICAgICAgOiBQZXJmb3JtcyBvbmUgaXRlcmF0aW9uIG9mIHRoZSBwaHlzaWNhbCBzaW11bGF0aW9uXG4gICAgICogQGFyZyBsYXlvdXRJbmZvIDogTGF5b3V0SW5mbyBvYmplY3QgYWxyZWFkeSBpbml0aWFsaXplZFxuICAgICAqIEBhcmcgY3kgICAgICAgICA6IEN5dG9zY2FwZSBvYmplY3RcbiAgICAgKiBAYXJnIG9wdGlvbnMgICAgOiBMYXlvdXQgb3B0aW9uc1xuICAgICAqL1xuICAgIHZhciBzdGVwID0gZnVuY3Rpb24gc3RlcChsYXlvdXRJbmZvLCBvcHRpb25zLCBfc3RlcCkge1xuICAgICAgLy8gdmFyIHMgPSBcIlxcblxcbiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcIjtcbiAgICAgIC8vIHMgKz0gXCJcXG5TVEVQOiBcIiArIHN0ZXA7XG4gICAgICAvLyBzICs9IFwiXFxuIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xcblwiO1xuICAgICAgLy8gbG9nRGVidWcocyk7XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBub2RlIHJlcHVsc2lvbnNcbiAgICAgIGNhbGN1bGF0ZU5vZGVGb3JjZXMobGF5b3V0SW5mbywgb3B0aW9ucyk7XG4gICAgICAvLyBDYWxjdWxhdGUgZWRnZSBmb3JjZXNcbiAgICAgIGNhbGN1bGF0ZUVkZ2VGb3JjZXMobGF5b3V0SW5mbywgb3B0aW9ucyk7XG4gICAgICAvLyBDYWxjdWxhdGUgZ3Jhdml0eSBmb3JjZXNcbiAgICAgIGNhbGN1bGF0ZUdyYXZpdHlGb3JjZXMobGF5b3V0SW5mbywgb3B0aW9ucyk7XG4gICAgICAvLyBQcm9wYWdhdGUgZm9yY2VzIGZyb20gcGFyZW50IHRvIGNoaWxkXG4gICAgICBwcm9wYWdhdGVGb3JjZXMobGF5b3V0SW5mbywgb3B0aW9ucyk7XG4gICAgICAvLyBVcGRhdGUgcG9zaXRpb25zIGJhc2VkIG9uIGNhbGN1bGF0ZWQgZm9yY2VzXG4gICAgICB1cGRhdGVQb3NpdGlvbnMobGF5b3V0SW5mbywgb3B0aW9ucyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBicmllZiA6IENvbXB1dGVzIHRoZSBub2RlIHJlcHVsc2lvbiBmb3JjZXNcbiAgICAgKi9cbiAgICB2YXIgY2FsY3VsYXRlTm9kZUZvcmNlcyA9IGZ1bmN0aW9uIGNhbGN1bGF0ZU5vZGVGb3JjZXMobGF5b3V0SW5mbywgb3B0aW9ucykge1xuICAgICAgLy8gR28gdGhyb3VnaCBlYWNoIG9mIHRoZSBncmFwaHMgaW4gZ3JhcGhTZXRcbiAgICAgIC8vIE5vZGVzIG9ubHkgcmVwZWwgZWFjaCBvdGhlciBpZiB0aGV5IGJlbG9uZyB0byB0aGUgc2FtZSBncmFwaFxuICAgICAgLy8gdmFyIHMgPSAnY2FsY3VsYXRlTm9kZUZvcmNlcyc7XG4gICAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ncmFwaFNldC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZ3JhcGggPSBsYXlvdXRJbmZvLmdyYXBoU2V0W2ldO1xuICAgICAgICB2YXIgbnVtTm9kZXMgPSBncmFwaC5sZW5ndGg7XG5cbiAgICAgICAgLy8gcyA9IFwiU2V0OiBcIiArIGdyYXBoLnRvU3RyaW5nKCk7XG4gICAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuXG4gICAgICAgIC8vIE5vdyBnZXQgYWxsIHRoZSBwYWlycyBvZiBub2Rlc1xuICAgICAgICAvLyBPbmx5IGdldCBlYWNoIHBhaXIgb25jZSwgKEEsIEIpID0gKEIsIEEpXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtTm9kZXM7IGorKykge1xuICAgICAgICAgIHZhciBub2RlMSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbZ3JhcGhbal1dXTtcblxuICAgICAgICAgIGZvciAodmFyIGsgPSBqICsgMTsgayA8IG51bU5vZGVzOyBrKyspIHtcbiAgICAgICAgICAgIHZhciBub2RlMiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbZ3JhcGhba11dXTtcblxuICAgICAgICAgICAgbm9kZVJlcHVsc2lvbihub2RlMSwgbm9kZTIsIGxheW91dEluZm8sIG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgcmFuZG9tRGlzdGFuY2UgPSBmdW5jdGlvbiByYW5kb21EaXN0YW5jZShtYXgpIHtcbiAgICAgIHJldHVybiAtbWF4ICsgMiAqIG1heCAqIE1hdGgucmFuZG9tKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBicmllZiA6IENvbXB1dGUgdGhlIG5vZGUgcmVwdWxzaW9uIGZvcmNlcyBiZXR3ZWVuIGEgcGFpciBvZiBub2Rlc1xuICAgICAqL1xuICAgIHZhciBub2RlUmVwdWxzaW9uID0gZnVuY3Rpb24gbm9kZVJlcHVsc2lvbihub2RlMSwgbm9kZTIsIGxheW91dEluZm8sIG9wdGlvbnMpIHtcbiAgICAgIC8vIHZhciBzID0gXCJOb2RlIHJlcHVsc2lvbi4gTm9kZTE6IFwiICsgbm9kZTEuaWQgKyBcIiBOb2RlMjogXCIgKyBub2RlMi5pZDtcblxuICAgICAgdmFyIGNtcHRJZDEgPSBub2RlMS5jbXB0SWQ7XG4gICAgICB2YXIgY21wdElkMiA9IG5vZGUyLmNtcHRJZDtcblxuICAgICAgaWYgKGNtcHRJZDEgIT09IGNtcHRJZDIgJiYgIWxheW91dEluZm8uaXNDb21wb3VuZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIEdldCBkaXJlY3Rpb24gb2YgbGluZSBjb25uZWN0aW5nIGJvdGggbm9kZSBjZW50ZXJzXG4gICAgICB2YXIgZGlyZWN0aW9uWCA9IG5vZGUyLnBvc2l0aW9uWCAtIG5vZGUxLnBvc2l0aW9uWDtcbiAgICAgIHZhciBkaXJlY3Rpb25ZID0gbm9kZTIucG9zaXRpb25ZIC0gbm9kZTEucG9zaXRpb25ZO1xuICAgICAgdmFyIG1heFJhbmREaXN0ID0gMTtcbiAgICAgIC8vIHMgKz0gXCJcXG5kaXJlY3Rpb25YOiBcIiArIGRpcmVjdGlvblggKyBcIiwgZGlyZWN0aW9uWTogXCIgKyBkaXJlY3Rpb25ZO1xuXG4gICAgICAvLyBJZiBib3RoIGNlbnRlcnMgYXJlIHRoZSBzYW1lLCBhcHBseSBhIHJhbmRvbSBmb3JjZVxuICAgICAgaWYgKDAgPT09IGRpcmVjdGlvblggJiYgMCA9PT0gZGlyZWN0aW9uWSkge1xuICAgICAgICBkaXJlY3Rpb25YID0gcmFuZG9tRGlzdGFuY2UobWF4UmFuZERpc3QpO1xuICAgICAgICBkaXJlY3Rpb25ZID0gcmFuZG9tRGlzdGFuY2UobWF4UmFuZERpc3QpO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3ZlcmxhcCA9IG5vZGVzT3ZlcmxhcChub2RlMSwgbm9kZTIsIGRpcmVjdGlvblgsIGRpcmVjdGlvblkpO1xuXG4gICAgICBpZiAob3ZlcmxhcCA+IDApIHtcbiAgICAgICAgLy8gcyArPSBcIlxcbk5vZGVzIERPIG92ZXJsYXAuXCI7XG4gICAgICAgIC8vIHMgKz0gXCJcXG5PdmVybGFwOiBcIiArIG92ZXJsYXA7XG4gICAgICAgIC8vIElmIG5vZGVzIG92ZXJsYXAsIHJlcHVsc2lvbiBmb3JjZSBpcyBwcm9wb3J0aW9uYWxcbiAgICAgICAgLy8gdG8gdGhlIG92ZXJsYXBcbiAgICAgICAgdmFyIGZvcmNlID0gb3B0aW9ucy5ub2RlT3ZlcmxhcCAqIG92ZXJsYXA7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgbW9kdWxlIGFuZCBjb21wb25lbnRzIG9mIHRoZSBmb3JjZSB2ZWN0b3JcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gTWF0aC5zcXJ0KGRpcmVjdGlvblggKiBkaXJlY3Rpb25YICsgZGlyZWN0aW9uWSAqIGRpcmVjdGlvblkpO1xuICAgICAgICAvLyBzICs9IFwiXFxuRGlzdGFuY2U6IFwiICsgZGlzdGFuY2U7XG4gICAgICAgIHZhciBmb3JjZVggPSBmb3JjZSAqIGRpcmVjdGlvblggLyBkaXN0YW5jZTtcbiAgICAgICAgdmFyIGZvcmNlWSA9IGZvcmNlICogZGlyZWN0aW9uWSAvIGRpc3RhbmNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcyArPSBcIlxcbk5vZGVzIGRvIE5PVCBvdmVybGFwLlwiO1xuICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIG92ZXJsYXAsIGZvcmNlIGlzIGludmVyc2VseSBwcm9wb3J0aW9uYWxcbiAgICAgICAgLy8gdG8gc3F1YXJlZCBkaXN0YW5jZVxuXG4gICAgICAgIC8vIEdldCBjbGlwcGluZyBwb2ludHMgZm9yIGJvdGggbm9kZXNcbiAgICAgICAgdmFyIHBvaW50MSA9IGZpbmRDbGlwcGluZ1BvaW50KG5vZGUxLCBkaXJlY3Rpb25YLCBkaXJlY3Rpb25ZKTtcbiAgICAgICAgdmFyIHBvaW50MiA9IGZpbmRDbGlwcGluZ1BvaW50KG5vZGUyLCAtMSAqIGRpcmVjdGlvblgsIC0xICogZGlyZWN0aW9uWSk7XG5cbiAgICAgICAgLy8gVXNlIGNsaXBwaW5nIHBvaW50cyB0byBjb21wdXRlIGRpc3RhbmNlXG4gICAgICAgIHZhciBkaXN0YW5jZVggPSBwb2ludDIueCAtIHBvaW50MS54O1xuICAgICAgICB2YXIgZGlzdGFuY2VZID0gcG9pbnQyLnkgLSBwb2ludDEueTtcbiAgICAgICAgdmFyIGRpc3RhbmNlU3FyID0gZGlzdGFuY2VYICogZGlzdGFuY2VYICsgZGlzdGFuY2VZICogZGlzdGFuY2VZO1xuICAgICAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZGlzdGFuY2VTcXIpO1xuICAgICAgICAvLyBzICs9IFwiXFxuRGlzdGFuY2U6IFwiICsgZGlzdGFuY2U7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgbW9kdWxlIGFuZCBjb21wb25lbnRzIG9mIHRoZSBmb3JjZSB2ZWN0b3JcbiAgICAgICAgdmFyIGZvcmNlID0gKG5vZGUxLm5vZGVSZXB1bHNpb24gKyBub2RlMi5ub2RlUmVwdWxzaW9uKSAvIGRpc3RhbmNlU3FyO1xuICAgICAgICB2YXIgZm9yY2VYID0gZm9yY2UgKiBkaXN0YW5jZVggLyBkaXN0YW5jZTtcbiAgICAgICAgdmFyIGZvcmNlWSA9IGZvcmNlICogZGlzdGFuY2VZIC8gZGlzdGFuY2U7XG4gICAgICB9XG5cbiAgICAgIC8vIEFwcGx5IGZvcmNlXG4gICAgICBpZiAoIW5vZGUxLmlzTG9ja2VkKSB7XG4gICAgICAgIG5vZGUxLm9mZnNldFggLT0gZm9yY2VYO1xuICAgICAgICBub2RlMS5vZmZzZXRZIC09IGZvcmNlWTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFub2RlMi5pc0xvY2tlZCkge1xuICAgICAgICBub2RlMi5vZmZzZXRYICs9IGZvcmNlWDtcbiAgICAgICAgbm9kZTIub2Zmc2V0WSArPSBmb3JjZVk7XG4gICAgICB9XG5cbiAgICAgIC8vIHMgKz0gXCJcXG5Gb3JjZVg6IFwiICsgZm9yY2VYICsgXCIgRm9yY2VZOiBcIiArIGZvcmNlWTtcbiAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuXG4gICAgICByZXR1cm47XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBicmllZiAgOiBEZXRlcm1pbmVzIHdoZXRoZXIgdHdvIG5vZGVzIG92ZXJsYXAgb3Igbm90XG4gICAgICogQHJldHVybiA6IEFtb3VudCBvZiBvdmVybGFwcGluZyAoMCA9PiBubyBvdmVybGFwKVxuICAgICAqL1xuICAgIHZhciBub2Rlc092ZXJsYXAgPSBmdW5jdGlvbiBub2Rlc092ZXJsYXAobm9kZTEsIG5vZGUyLCBkWCwgZFkpIHtcblxuICAgICAgaWYgKGRYID4gMCkge1xuICAgICAgICB2YXIgb3ZlcmxhcFggPSBub2RlMS5tYXhYIC0gbm9kZTIubWluWDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBvdmVybGFwWCA9IG5vZGUyLm1heFggLSBub2RlMS5taW5YO1xuICAgICAgfVxuXG4gICAgICBpZiAoZFkgPiAwKSB7XG4gICAgICAgIHZhciBvdmVybGFwWSA9IG5vZGUxLm1heFkgLSBub2RlMi5taW5ZO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG92ZXJsYXBZID0gbm9kZTIubWF4WSAtIG5vZGUxLm1pblk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvdmVybGFwWCA+PSAwICYmIG92ZXJsYXBZID49IDApIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChvdmVybGFwWCAqIG92ZXJsYXBYICsgb3ZlcmxhcFkgKiBvdmVybGFwWSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGJyaWVmIDogRmluZHMgdGhlIHBvaW50IGluIHdoaWNoIGFuIGVkZ2UgKGRpcmVjdGlvbiBkWCwgZFkpIGludGVyc2VjdHNcbiAgICAgKiAgICAgICAgICB0aGUgcmVjdGFuZ3VsYXIgYm91bmRpbmcgYm94IG9mIGl0J3Mgc291cmNlL3RhcmdldCBub2RlXG4gICAgICovXG4gICAgdmFyIGZpbmRDbGlwcGluZ1BvaW50ID0gZnVuY3Rpb24gZmluZENsaXBwaW5nUG9pbnQobm9kZSwgZFgsIGRZKSB7XG5cbiAgICAgIC8vIFNob3JjdXRzXG4gICAgICB2YXIgWCA9IG5vZGUucG9zaXRpb25YO1xuICAgICAgdmFyIFkgPSBub2RlLnBvc2l0aW9uWTtcbiAgICAgIHZhciBIID0gbm9kZS5oZWlnaHQgfHwgMTtcbiAgICAgIHZhciBXID0gbm9kZS53aWR0aCB8fCAxO1xuICAgICAgdmFyIGRpclNsb3BlID0gZFkgLyBkWDtcbiAgICAgIHZhciBub2RlU2xvcGUgPSBIIC8gVztcblxuICAgICAgLy8gdmFyIHMgPSAnQ29tcHV0aW5nIGNsaXBwaW5nIHBvaW50IG9mIG5vZGUgJyArIG5vZGUuaWQgK1xuICAgICAgLy8gICBcIiAuIEhlaWdodDogIFwiICsgSCArIFwiLCBXaWR0aDogXCIgKyBXICtcbiAgICAgIC8vICAgXCJcXG5EaXJlY3Rpb24gXCIgKyBkWCArIFwiLCBcIiArIGRZO1xuICAgICAgLy9cbiAgICAgIC8vIENvbXB1dGUgaW50ZXJzZWN0aW9uXG4gICAgICB2YXIgcmVzID0ge307XG5cbiAgICAgIC8vIENhc2U6IFZlcnRpY2FsIGRpcmVjdGlvbiAodXApXG4gICAgICBpZiAoMCA9PT0gZFggJiYgMCA8IGRZKSB7XG4gICAgICAgIHJlcy54ID0gWDtcbiAgICAgICAgLy8gcyArPSBcIlxcblVwIGRpcmVjdGlvblwiO1xuICAgICAgICByZXMueSA9IFkgKyBIIC8gMjtcblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfVxuXG4gICAgICAvLyBDYXNlOiBWZXJ0aWNhbCBkaXJlY3Rpb24gKGRvd24pXG4gICAgICBpZiAoMCA9PT0gZFggJiYgMCA+IGRZKSB7XG4gICAgICAgIHJlcy54ID0gWDtcbiAgICAgICAgcmVzLnkgPSBZICsgSCAvIDI7XG4gICAgICAgIC8vIHMgKz0gXCJcXG5Eb3duIGRpcmVjdGlvblwiO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG5cbiAgICAgIC8vIENhc2U6IEludGVyc2VjdHMgdGhlIHJpZ2h0IGJvcmRlclxuICAgICAgaWYgKDAgPCBkWCAmJiAtMSAqIG5vZGVTbG9wZSA8PSBkaXJTbG9wZSAmJiBkaXJTbG9wZSA8PSBub2RlU2xvcGUpIHtcbiAgICAgICAgcmVzLnggPSBYICsgVyAvIDI7XG4gICAgICAgIHJlcy55ID0gWSArIFcgKiBkWSAvIDIgLyBkWDtcbiAgICAgICAgLy8gcyArPSBcIlxcblJpZ2h0Ym9yZGVyXCI7XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cblxuICAgICAgLy8gQ2FzZTogSW50ZXJzZWN0cyB0aGUgbGVmdCBib3JkZXJcbiAgICAgIGlmICgwID4gZFggJiYgLTEgKiBub2RlU2xvcGUgPD0gZGlyU2xvcGUgJiYgZGlyU2xvcGUgPD0gbm9kZVNsb3BlKSB7XG4gICAgICAgIHJlcy54ID0gWCAtIFcgLyAyO1xuICAgICAgICByZXMueSA9IFkgLSBXICogZFkgLyAyIC8gZFg7XG4gICAgICAgIC8vIHMgKz0gXCJcXG5MZWZ0Ym9yZGVyXCI7XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cblxuICAgICAgLy8gQ2FzZTogSW50ZXJzZWN0cyB0aGUgdG9wIGJvcmRlclxuICAgICAgaWYgKDAgPCBkWSAmJiAoZGlyU2xvcGUgPD0gLTEgKiBub2RlU2xvcGUgfHwgZGlyU2xvcGUgPj0gbm9kZVNsb3BlKSkge1xuICAgICAgICByZXMueCA9IFggKyBIICogZFggLyAyIC8gZFk7XG4gICAgICAgIHJlcy55ID0gWSArIEggLyAyO1xuICAgICAgICAvLyBzICs9IFwiXFxuVG9wIGJvcmRlclwiO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG5cbiAgICAgIC8vIENhc2U6IEludGVyc2VjdHMgdGhlIGJvdHRvbSBib3JkZXJcbiAgICAgIGlmICgwID4gZFkgJiYgKGRpclNsb3BlIDw9IC0xICogbm9kZVNsb3BlIHx8IGRpclNsb3BlID49IG5vZGVTbG9wZSkpIHtcbiAgICAgICAgcmVzLnggPSBYIC0gSCAqIGRYIC8gMiAvIGRZO1xuICAgICAgICByZXMueSA9IFkgLSBIIC8gMjtcbiAgICAgICAgLy8gcyArPSBcIlxcbkJvdHRvbSBib3JkZXJcIjtcblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfVxuXG4gICAgICAvLyBzICs9IFwiXFxuQ2xpcHBpbmcgcG9pbnQgZm91bmQgYXQgXCIgKyByZXMueCArIFwiLCBcIiArIHJlcy55O1xuICAgICAgLy8gbG9nRGVidWcocyk7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYnJpZWYgOiBDYWxjdWxhdGVzIGFsbCBlZGdlIGZvcmNlc1xuICAgICAqL1xuICAgIHZhciBjYWxjdWxhdGVFZGdlRm9yY2VzID0gZnVuY3Rpb24gY2FsY3VsYXRlRWRnZUZvcmNlcyhsYXlvdXRJbmZvLCBvcHRpb25zKSB7XG4gICAgICAvLyBJdGVyYXRlIG92ZXIgYWxsIGVkZ2VzXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8uZWRnZVNpemU7IGkrKykge1xuICAgICAgICAvLyBHZXQgZWRnZSwgc291cmNlICYgdGFyZ2V0IG5vZGVzXG4gICAgICAgIHZhciBlZGdlID0gbGF5b3V0SW5mby5sYXlvdXRFZGdlc1tpXTtcbiAgICAgICAgdmFyIHNvdXJjZUl4ID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbZWRnZS5zb3VyY2VJZF07XG4gICAgICAgIHZhciBzb3VyY2UgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW3NvdXJjZUl4XTtcbiAgICAgICAgdmFyIHRhcmdldEl4ID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbZWRnZS50YXJnZXRJZF07XG4gICAgICAgIHZhciB0YXJnZXQgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW3RhcmdldEl4XTtcblxuICAgICAgICAvLyBHZXQgZGlyZWN0aW9uIG9mIGxpbmUgY29ubmVjdGluZyBib3RoIG5vZGUgY2VudGVyc1xuICAgICAgICB2YXIgZGlyZWN0aW9uWCA9IHRhcmdldC5wb3NpdGlvblggLSBzb3VyY2UucG9zaXRpb25YO1xuICAgICAgICB2YXIgZGlyZWN0aW9uWSA9IHRhcmdldC5wb3NpdGlvblkgLSBzb3VyY2UucG9zaXRpb25ZO1xuXG4gICAgICAgIC8vIElmIGJvdGggY2VudGVycyBhcmUgdGhlIHNhbWUsIGRvIG5vdGhpbmcuXG4gICAgICAgIC8vIEEgcmFuZG9tIGZvcmNlIGhhcyBhbHJlYWR5IGJlZW4gYXBwbGllZCBhcyBub2RlIHJlcHVsc2lvblxuICAgICAgICBpZiAoMCA9PT0gZGlyZWN0aW9uWCAmJiAwID09PSBkaXJlY3Rpb25ZKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXQgY2xpcHBpbmcgcG9pbnRzIGZvciBib3RoIG5vZGVzXG4gICAgICAgIHZhciBwb2ludDEgPSBmaW5kQ2xpcHBpbmdQb2ludChzb3VyY2UsIGRpcmVjdGlvblgsIGRpcmVjdGlvblkpO1xuICAgICAgICB2YXIgcG9pbnQyID0gZmluZENsaXBwaW5nUG9pbnQodGFyZ2V0LCAtMSAqIGRpcmVjdGlvblgsIC0xICogZGlyZWN0aW9uWSk7XG5cbiAgICAgICAgdmFyIGx4ID0gcG9pbnQyLnggLSBwb2ludDEueDtcbiAgICAgICAgdmFyIGx5ID0gcG9pbnQyLnkgLSBwb2ludDEueTtcbiAgICAgICAgdmFyIGwgPSBNYXRoLnNxcnQobHggKiBseCArIGx5ICogbHkpO1xuXG4gICAgICAgIHZhciBmb3JjZSA9IE1hdGgucG93KGVkZ2UuaWRlYWxMZW5ndGggLSBsLCAyKSAvIGVkZ2UuZWxhc3RpY2l0eTtcblxuICAgICAgICBpZiAoMCAhPT0gbCkge1xuICAgICAgICAgIHZhciBmb3JjZVggPSBmb3JjZSAqIGx4IC8gbDtcbiAgICAgICAgICB2YXIgZm9yY2VZID0gZm9yY2UgKiBseSAvIGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGZvcmNlWCA9IDA7XG4gICAgICAgICAgdmFyIGZvcmNlWSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgdGhpcyBmb3JjZSB0byB0YXJnZXQgYW5kIHNvdXJjZSBub2Rlc1xuICAgICAgICBpZiAoIXNvdXJjZS5pc0xvY2tlZCkge1xuICAgICAgICAgIHNvdXJjZS5vZmZzZXRYICs9IGZvcmNlWDtcbiAgICAgICAgICBzb3VyY2Uub2Zmc2V0WSArPSBmb3JjZVk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRhcmdldC5pc0xvY2tlZCkge1xuICAgICAgICAgIHRhcmdldC5vZmZzZXRYIC09IGZvcmNlWDtcbiAgICAgICAgICB0YXJnZXQub2Zmc2V0WSAtPSBmb3JjZVk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YXIgcyA9ICdFZGdlIGZvcmNlIGJldHdlZW4gbm9kZXMgJyArIHNvdXJjZS5pZCArICcgYW5kICcgKyB0YXJnZXQuaWQ7XG4gICAgICAgIC8vIHMgKz0gXCJcXG5EaXN0YW5jZTogXCIgKyBsICsgXCIgRm9yY2U6IChcIiArIGZvcmNlWCArIFwiLCBcIiArIGZvcmNlWSArIFwiKVwiO1xuICAgICAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGJyaWVmIDogQ29tcHV0ZXMgZ3Jhdml0eSBmb3JjZXMgZm9yIGFsbCBub2Rlc1xuICAgICAqL1xuICAgIHZhciBjYWxjdWxhdGVHcmF2aXR5Rm9yY2VzID0gZnVuY3Rpb24gY2FsY3VsYXRlR3Jhdml0eUZvcmNlcyhsYXlvdXRJbmZvLCBvcHRpb25zKSB7XG4gICAgICB2YXIgZGlzdFRocmVzaG9sZCA9IDE7XG5cbiAgICAgIC8vIHZhciBzID0gJ2NhbGN1bGF0ZUdyYXZpdHlGb3JjZXMnO1xuICAgICAgLy8gbG9nRGVidWcocyk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8uZ3JhcGhTZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGdyYXBoID0gbGF5b3V0SW5mby5ncmFwaFNldFtpXTtcbiAgICAgICAgdmFyIG51bU5vZGVzID0gZ3JhcGgubGVuZ3RoO1xuXG4gICAgICAgIC8vIHMgPSBcIlNldDogXCIgKyBncmFwaC50b1N0cmluZygpO1xuICAgICAgICAvLyBsb2dEZWJ1ZyhzKTtcblxuICAgICAgICAvLyBDb21wdXRlIGdyYXBoIGNlbnRlclxuICAgICAgICBpZiAoMCA9PT0gaSkge1xuICAgICAgICAgIHZhciBjZW50ZXJYID0gbGF5b3V0SW5mby5jbGllbnRIZWlnaHQgLyAyO1xuICAgICAgICAgIHZhciBjZW50ZXJZID0gbGF5b3V0SW5mby5jbGllbnRXaWR0aCAvIDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gR2V0IFBhcmVudCBub2RlIGZvciB0aGlzIGdyYXBoLCBhbmQgdXNlIGl0cyBwb3NpdGlvbiBhcyBjZW50ZXJcbiAgICAgICAgICB2YXIgdGVtcCA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbZ3JhcGhbMF1dXTtcbiAgICAgICAgICB2YXIgcGFyZW50ID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFt0ZW1wLnBhcmVudElkXV07XG4gICAgICAgICAgdmFyIGNlbnRlclggPSBwYXJlbnQucG9zaXRpb25YO1xuICAgICAgICAgIHZhciBjZW50ZXJZID0gcGFyZW50LnBvc2l0aW9uWTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzID0gXCJDZW50ZXIgZm91bmQgYXQ6IFwiICsgY2VudGVyWCArIFwiLCBcIiArIGNlbnRlclk7XG4gICAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuXG4gICAgICAgIC8vIEFwcGx5IGZvcmNlIHRvIGFsbCBub2RlcyBpbiBncmFwaFxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bU5vZGVzOyBqKyspIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbZ3JhcGhbal1dXTtcbiAgICAgICAgICAvLyBzID0gXCJOb2RlOiBcIiArIG5vZGUuaWQ7XG5cbiAgICAgICAgICBpZiAobm9kZS5pc0xvY2tlZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGR4ID0gY2VudGVyWCAtIG5vZGUucG9zaXRpb25YO1xuICAgICAgICAgIHZhciBkeSA9IGNlbnRlclkgLSBub2RlLnBvc2l0aW9uWTtcbiAgICAgICAgICB2YXIgZCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgICAgaWYgKGQgPiBkaXN0VGhyZXNob2xkKSB7XG4gICAgICAgICAgICB2YXIgZnggPSBvcHRpb25zLmdyYXZpdHkgKiBkeCAvIGQ7XG4gICAgICAgICAgICB2YXIgZnkgPSBvcHRpb25zLmdyYXZpdHkgKiBkeSAvIGQ7XG4gICAgICAgICAgICBub2RlLm9mZnNldFggKz0gZng7XG4gICAgICAgICAgICBub2RlLm9mZnNldFkgKz0gZnk7XG4gICAgICAgICAgICAvLyBzICs9IFwiOiBBcHBsaWVkIGZvcmNlOiBcIiArIGZ4ICsgXCIsIFwiICsgZnk7XG4gICAgICAgICAgfSBlbHNlIHt9XG4gICAgICAgICAgICAvLyBzICs9IFwiOiBza3lwcGVkIHNpbmNlIGl0J3MgdG9vIGNsb3NlIHRvIGNlbnRlclwiO1xuXG4gICAgICAgICAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYnJpZWYgICAgICAgICAgOiBUaGlzIGZ1bmN0aW9uIHByb3BhZ2F0ZXMgdGhlIGV4aXN0aW5nIG9mZnNldHMgZnJvbVxuICAgICAqICAgICAgICAgICAgICAgICAgIHBhcmVudCBub2RlcyB0byBpdHMgZGVzY2VuZGVudHMuXG4gICAgICogQGFyZyBsYXlvdXRJbmZvIDogbGF5b3V0SW5mbyBPYmplY3RcbiAgICAgKiBAYXJnIGN5ICAgICAgICAgOiBjeXRvc2NhcGUgT2JqZWN0XG4gICAgICogQGFyZyBvcHRpb25zICAgIDogTGF5b3V0IG9wdGlvbnNcbiAgICAgKi9cbiAgICB2YXIgcHJvcGFnYXRlRm9yY2VzID0gZnVuY3Rpb24gcHJvcGFnYXRlRm9yY2VzKGxheW91dEluZm8sIG9wdGlvbnMpIHtcbiAgICAgIC8vIElubGluZSBpbXBsZW1lbnRhdGlvbiBvZiBhIHF1ZXVlLCB1c2VkIGZvciB0cmF2ZXJzaW5nIHRoZSBncmFwaCBpbiBCRlMgb3JkZXJcbiAgICAgIHZhciBxdWV1ZSA9IFtdO1xuICAgICAgdmFyIHN0YXJ0ID0gMDsgLy8gUG9pbnRzIHRvIHRoZSBzdGFydCB0aGUgcXVldWVcbiAgICAgIHZhciBlbmQgPSAtMTsgLy8gUG9pbnRzIHRvIHRoZSBlbmQgb2YgdGhlIHF1ZXVlXG5cbiAgICAgIC8vIGxvZ0RlYnVnKCdwcm9wYWdhdGVGb3JjZXMnKTtcblxuICAgICAgLy8gU3RhcnQgYnkgdmlzaXRpbmcgdGhlIG5vZGVzIGluIHRoZSByb290IGdyYXBoXG4gICAgICBxdWV1ZS5wdXNoLmFwcGx5KHF1ZXVlLCBsYXlvdXRJbmZvLmdyYXBoU2V0WzBdKTtcbiAgICAgIGVuZCArPSBsYXlvdXRJbmZvLmdyYXBoU2V0WzBdLmxlbmd0aDtcblxuICAgICAgLy8gVHJhdmVyc2UgdGhlIGdyYXBoLCBsZXZlbCBieSBsZXZlbCxcbiAgICAgIHdoaWxlIChzdGFydCA8PSBlbmQpIHtcbiAgICAgICAgLy8gR2V0IHRoZSBub2RlIHRvIHZpc2l0IGFuZCByZW1vdmUgaXQgZnJvbSBxdWV1ZVxuICAgICAgICB2YXIgbm9kZUlkID0gcXVldWVbc3RhcnQrK107XG4gICAgICAgIHZhciBub2RlSW5kZXggPSBsYXlvdXRJbmZvLmlkVG9JbmRleFtub2RlSWRdO1xuICAgICAgICB2YXIgbm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbm9kZUluZGV4XTtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcblxuICAgICAgICAvLyBXZSBvbmx5IG5lZWQgdG8gcHJvY2VzcyB0aGUgbm9kZSBpZiBpdCdzIGNvbXBvdW5kXG4gICAgICAgIGlmICgwIDwgY2hpbGRyZW4ubGVuZ3RoICYmICFub2RlLmlzTG9ja2VkKSB7XG4gICAgICAgICAgdmFyIG9mZlggPSBub2RlLm9mZnNldFg7XG4gICAgICAgICAgdmFyIG9mZlkgPSBub2RlLm9mZnNldFk7XG5cbiAgICAgICAgICAvLyB2YXIgcyA9IFwiUHJvcGFnYXRpbmcgb2Zmc2V0IGZyb20gcGFyZW50IG5vZGUgOiBcIiArIG5vZGUuaWQgK1xuICAgICAgICAgIC8vICAgXCIuIE9mZnNldFg6IFwiICsgb2ZmWCArIFwiLiBPZmZzZXRZOiBcIiArIG9mZlk7XG4gICAgICAgICAgLy8gcyArPSBcIlxcbiBDaGlsZHJlbjogXCIgKyBjaGlsZHJlbi50b1N0cmluZygpO1xuICAgICAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbY2hpbGRyZW5baV1dXTtcbiAgICAgICAgICAgIC8vIFByb3BhZ2F0ZSBvZmZzZXRcbiAgICAgICAgICAgIGNoaWxkTm9kZS5vZmZzZXRYICs9IG9mZlg7XG4gICAgICAgICAgICBjaGlsZE5vZGUub2Zmc2V0WSArPSBvZmZZO1xuICAgICAgICAgICAgLy8gQWRkIGNoaWxkcmVuIHRvIHF1ZXVlIHRvIGJlIHZpc2l0ZWRcbiAgICAgICAgICAgIHF1ZXVlWysrZW5kXSA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFJlc2V0IHBhcmVudCBvZmZzZXRzXG4gICAgICAgICAgbm9kZS5vZmZzZXRYID0gMDtcbiAgICAgICAgICBub2RlLm9mZnNldFkgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBicmllZiA6IFVwZGF0ZXMgdGhlIGxheW91dCBtb2RlbCBwb3NpdGlvbnMsIGJhc2VkIG9uXG4gICAgICogICAgICAgICAgdGhlIGFjY3VtdWxhdGVkIGZvcmNlc1xuICAgICAqL1xuICAgIHZhciB1cGRhdGVQb3NpdGlvbnMgPSBmdW5jdGlvbiB1cGRhdGVQb3NpdGlvbnMobGF5b3V0SW5mbywgb3B0aW9ucykge1xuICAgICAgLy8gdmFyIHMgPSAnVXBkYXRpbmcgcG9zaXRpb25zJztcbiAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuXG4gICAgICAvLyBSZXNldCBib3VuZGFyaWVzIGZvciBjb21wb3VuZCBub2Rlc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLm5vZGVTaXplOyBpKyspIHtcbiAgICAgICAgdmFyIG4gPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2ldO1xuICAgICAgICBpZiAoMCA8IG4uY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gbG9nRGVidWcoXCJSZXNldHRpbmcgYm91bmRhcmllcyBvZiBjb21wb3VuZCBub2RlOiBcIiArIG4uaWQpO1xuICAgICAgICAgIG4ubWF4WCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuLm1pblggPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbi5tYXhZID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG4ubWluWSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubm9kZVNpemU7IGkrKykge1xuICAgICAgICB2YXIgbiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbaV07XG4gICAgICAgIGlmICgwIDwgbi5jaGlsZHJlbi5sZW5ndGggfHwgbi5pc0xvY2tlZCkge1xuICAgICAgICAgIC8vIE5vIG5lZWQgdG8gc2V0IGNvbXBvdW5kIG9yIGxvY2tlZCBub2RlIHBvc2l0aW9uXG4gICAgICAgICAgLy8gbG9nRGVidWcoXCJTa2lwcGluZyBwb3NpdGlvbiB1cGRhdGUgb2Ygbm9kZTogXCIgKyBuLmlkKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzID0gXCJOb2RlOiBcIiArIG4uaWQgKyBcIiBQcmV2aW91cyBwb3NpdGlvbjogKFwiICtcbiAgICAgICAgLy8gbi5wb3NpdGlvblggKyBcIiwgXCIgKyBuLnBvc2l0aW9uWSArIFwiKS5cIjtcblxuICAgICAgICAvLyBMaW1pdCBkaXNwbGFjZW1lbnQgaW4gb3JkZXIgdG8gaW1wcm92ZSBzdGFiaWxpdHlcbiAgICAgICAgdmFyIHRlbXBGb3JjZSA9IGxpbWl0Rm9yY2Uobi5vZmZzZXRYLCBuLm9mZnNldFksIGxheW91dEluZm8udGVtcGVyYXR1cmUpO1xuICAgICAgICBuLnBvc2l0aW9uWCArPSB0ZW1wRm9yY2UueDtcbiAgICAgICAgbi5wb3NpdGlvblkgKz0gdGVtcEZvcmNlLnk7XG4gICAgICAgIG4ub2Zmc2V0WCA9IDA7XG4gICAgICAgIG4ub2Zmc2V0WSA9IDA7XG4gICAgICAgIG4ubWluWCA9IG4ucG9zaXRpb25YIC0gbi53aWR0aDtcbiAgICAgICAgbi5tYXhYID0gbi5wb3NpdGlvblggKyBuLndpZHRoO1xuICAgICAgICBuLm1pblkgPSBuLnBvc2l0aW9uWSAtIG4uaGVpZ2h0O1xuICAgICAgICBuLm1heFkgPSBuLnBvc2l0aW9uWSArIG4uaGVpZ2h0O1xuICAgICAgICAvLyBzICs9IFwiIE5ldyBQb3NpdGlvbjogKFwiICsgbi5wb3NpdGlvblggKyBcIiwgXCIgKyBuLnBvc2l0aW9uWSArIFwiKS5cIjtcbiAgICAgICAgLy8gbG9nRGVidWcocyk7XG5cbiAgICAgICAgLy8gVXBkYXRlIGFuY2VzdHJ5IGJvdWRhcmllc1xuICAgICAgICB1cGRhdGVBbmNlc3RyeUJvdW5kYXJpZXMobiwgbGF5b3V0SW5mbyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSBzaXplLCBwb3NpdGlvbiBvZiBjb21wdW5kIG5vZGVzXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubm9kZVNpemU7IGkrKykge1xuICAgICAgICB2YXIgbiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbaV07XG4gICAgICAgIGlmICgwIDwgbi5jaGlsZHJlbi5sZW5ndGggJiYgIW4uaXNMb2NrZWQpIHtcbiAgICAgICAgICBuLnBvc2l0aW9uWCA9IChuLm1heFggKyBuLm1pblgpIC8gMjtcbiAgICAgICAgICBuLnBvc2l0aW9uWSA9IChuLm1heFkgKyBuLm1pblkpIC8gMjtcbiAgICAgICAgICBuLndpZHRoID0gbi5tYXhYIC0gbi5taW5YO1xuICAgICAgICAgIG4uaGVpZ2h0ID0gbi5tYXhZIC0gbi5taW5ZO1xuICAgICAgICAgIC8vIHMgPSBcIlVwZGF0aW5nIHBvc2l0aW9uLCBzaXplIG9mIGNvbXBvdW5kIG5vZGUgXCIgKyBuLmlkO1xuICAgICAgICAgIC8vIHMgKz0gXCJcXG5Qb3NpdGlvblg6IFwiICsgbi5wb3NpdGlvblggKyBcIiwgUG9zaXRpb25ZOiBcIiArIG4ucG9zaXRpb25ZO1xuICAgICAgICAgIC8vIHMgKz0gXCJcXG5XaWR0aDogXCIgKyBuLndpZHRoICsgXCIsIEhlaWdodDogXCIgKyBuLmhlaWdodDtcbiAgICAgICAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYnJpZWYgOiBMaW1pdHMgYSBmb3JjZSAoZm9yY2VYLCBmb3JjZVkpIHRvIGJlIG5vdFxuICAgICAqICAgICAgICAgIGdyZWF0ZXIgKGluIG1vZHVsbykgdGhhbiBtYXguXG4gICAgIDggICAgICAgICAgUHJlc2VydmVzIGZvcmNlIGRpcmVjdGlvbi5cbiAgICAgKi9cbiAgICB2YXIgbGltaXRGb3JjZSA9IGZ1bmN0aW9uIGxpbWl0Rm9yY2UoZm9yY2VYLCBmb3JjZVksIG1heCkge1xuICAgICAgLy8gdmFyIHMgPSBcIkxpbWl0aW5nIGZvcmNlOiAoXCIgKyBmb3JjZVggKyBcIiwgXCIgKyBmb3JjZVkgKyBcIikuIE1heDogXCIgKyBtYXg7XG4gICAgICB2YXIgZm9yY2UgPSBNYXRoLnNxcnQoZm9yY2VYICogZm9yY2VYICsgZm9yY2VZICogZm9yY2VZKTtcblxuICAgICAgaWYgKGZvcmNlID4gbWF4KSB7XG4gICAgICAgIHZhciByZXMgPSB7XG4gICAgICAgICAgeDogbWF4ICogZm9yY2VYIC8gZm9yY2UsXG4gICAgICAgICAgeTogbWF4ICogZm9yY2VZIC8gZm9yY2VcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXMgPSB7XG4gICAgICAgICAgeDogZm9yY2VYLFxuICAgICAgICAgIHk6IGZvcmNlWVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBzICs9IFwiLlxcblJlc3VsdDogKFwiICsgcmVzLnggKyBcIiwgXCIgKyByZXMueSArIFwiKVwiO1xuICAgICAgLy8gbG9nRGVidWcocyk7XG5cbiAgICAgIHJldHVybiByZXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBicmllZiA6IEZ1bmN0aW9uIHVzZWQgZm9yIGtlZXBpbmcgdHJhY2sgb2YgY29tcG91bmQgbm9kZVxuICAgICAqICAgICAgICAgIHNpemVzLCBzaW5jZSB0aGV5IHNob3VsZCBib3VuZCBhbGwgdGhlaXIgc3Vibm9kZXMuXG4gICAgICovXG4gICAgdmFyIHVwZGF0ZUFuY2VzdHJ5Qm91bmRhcmllcyA9IGZ1bmN0aW9uIHVwZGF0ZUFuY2VzdHJ5Qm91bmRhcmllcyhub2RlLCBsYXlvdXRJbmZvKSB7XG4gICAgICAvLyB2YXIgcyA9IFwiUHJvcGFnYXRpbmcgbmV3IHBvc2l0aW9uL3NpemUgb2Ygbm9kZSBcIiArIG5vZGUuaWQ7XG4gICAgICB2YXIgcGFyZW50SWQgPSBub2RlLnBhcmVudElkO1xuICAgICAgaWYgKG51bGwgPT0gcGFyZW50SWQpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUncyBubyBwYXJlbnQsIHdlIGFyZSBkb25lXG4gICAgICAgIC8vIHMgKz0gXCIuIE5vIHBhcmVudCBub2RlLlwiO1xuICAgICAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBHZXQgUGFyZW50IE5vZGVcbiAgICAgIHZhciBwID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFtwYXJlbnRJZF1dO1xuICAgICAgdmFyIGZsYWcgPSBmYWxzZTtcblxuICAgICAgLy8gTWF4WFxuICAgICAgaWYgKG51bGwgPT0gcC5tYXhYIHx8IG5vZGUubWF4WCArIHAucGFkUmlnaHQgPiBwLm1heFgpIHtcbiAgICAgICAgcC5tYXhYID0gbm9kZS5tYXhYICsgcC5wYWRSaWdodDtcbiAgICAgICAgZmxhZyA9IHRydWU7XG4gICAgICAgIC8vIHMgKz0gXCJcXG5OZXcgbWF4WCBmb3IgcGFyZW50IG5vZGUgXCIgKyBwLmlkICsgXCI6IFwiICsgcC5tYXhYO1xuICAgICAgfVxuXG4gICAgICAvLyBNaW5YXG4gICAgICBpZiAobnVsbCA9PSBwLm1pblggfHwgbm9kZS5taW5YIC0gcC5wYWRMZWZ0IDwgcC5taW5YKSB7XG4gICAgICAgIHAubWluWCA9IG5vZGUubWluWCAtIHAucGFkTGVmdDtcbiAgICAgICAgZmxhZyA9IHRydWU7XG4gICAgICAgIC8vIHMgKz0gXCJcXG5OZXcgbWluWCBmb3IgcGFyZW50IG5vZGUgXCIgKyBwLmlkICsgXCI6IFwiICsgcC5taW5YO1xuICAgICAgfVxuXG4gICAgICAvLyBNYXhZXG4gICAgICBpZiAobnVsbCA9PSBwLm1heFkgfHwgbm9kZS5tYXhZICsgcC5wYWRCb3R0b20gPiBwLm1heFkpIHtcbiAgICAgICAgcC5tYXhZID0gbm9kZS5tYXhZICsgcC5wYWRCb3R0b207XG4gICAgICAgIGZsYWcgPSB0cnVlO1xuICAgICAgICAvLyBzICs9IFwiXFxuTmV3IG1heFkgZm9yIHBhcmVudCBub2RlIFwiICsgcC5pZCArIFwiOiBcIiArIHAubWF4WTtcbiAgICAgIH1cblxuICAgICAgLy8gTWluWVxuICAgICAgaWYgKG51bGwgPT0gcC5taW5ZIHx8IG5vZGUubWluWSAtIHAucGFkVG9wIDwgcC5taW5ZKSB7XG4gICAgICAgIHAubWluWSA9IG5vZGUubWluWSAtIHAucGFkVG9wO1xuICAgICAgICBmbGFnID0gdHJ1ZTtcbiAgICAgICAgLy8gcyArPSBcIlxcbk5ldyBtaW5ZIGZvciBwYXJlbnQgbm9kZSBcIiArIHAuaWQgKyBcIjogXCIgKyBwLm1pblk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHVwZGF0ZWQgYm91bmRhcmllcywgcHJvcGFnYXRlIGNoYW5nZXMgdXB3YXJkXG4gICAgICBpZiAoZmxhZykge1xuICAgICAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUFuY2VzdHJ5Qm91bmRhcmllcyhwLCBsYXlvdXRJbmZvKTtcbiAgICAgIH1cblxuICAgICAgLy8gcyArPSBcIi4gTm8gY2hhbmdlcyBpbiBib3VuZGFyaWVzL3Bvc2l0aW9uIG9mIHBhcmVudCBub2RlIFwiICsgcC5pZDtcbiAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuICAgICAgcmV0dXJuO1xuICAgIH07XG5cbiAgICB2YXIgc2VwYXJhdGVDb21wb25lbnRzID0gZnVuY3Rpb24gc2VwYXJhdGVDb21wb25lbnRzKGxheXV0SW5mbywgb3B0aW9ucykge1xuICAgICAgdmFyIG5vZGVzID0gbGF5b3V0SW5mby5sYXlvdXROb2RlcztcbiAgICAgIHZhciBjb21wb25lbnRzID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgdmFyIGNpZCA9IG5vZGUuY21wdElkO1xuICAgICAgICB2YXIgY29tcG9uZW50ID0gY29tcG9uZW50c1tjaWRdID0gY29tcG9uZW50c1tjaWRdIHx8IFtdO1xuXG4gICAgICAgIGNvbXBvbmVudC5wdXNoKG5vZGUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdG90YWxBID0gMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21wb25lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjID0gY29tcG9uZW50c1tpXTtcblxuICAgICAgICBpZiAoIWMpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGMueDEgPSBJbmZpbml0eTtcbiAgICAgICAgYy54MiA9IC1JbmZpbml0eTtcbiAgICAgICAgYy55MSA9IEluZmluaXR5O1xuICAgICAgICBjLnkyID0gLUluZmluaXR5O1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHZhciBuID0gY1tqXTtcblxuICAgICAgICAgIGMueDEgPSBNYXRoLm1pbihjLngxLCBuLnBvc2l0aW9uWCAtIG4ud2lkdGggLyAyKTtcbiAgICAgICAgICBjLngyID0gTWF0aC5tYXgoYy54Miwgbi5wb3NpdGlvblggKyBuLndpZHRoIC8gMik7XG4gICAgICAgICAgYy55MSA9IE1hdGgubWluKGMueTEsIG4ucG9zaXRpb25ZIC0gbi5oZWlnaHQgLyAyKTtcbiAgICAgICAgICBjLnkyID0gTWF0aC5tYXgoYy55Miwgbi5wb3NpdGlvblkgKyBuLmhlaWdodCAvIDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgYy53ID0gYy54MiAtIGMueDE7XG4gICAgICAgIGMuaCA9IGMueTIgLSBjLnkxO1xuXG4gICAgICAgIHRvdGFsQSArPSBjLncgKiBjLmg7XG4gICAgICB9XG5cbiAgICAgIGNvbXBvbmVudHMuc29ydChmdW5jdGlvbiAoYzEsIGMyKSB7XG4gICAgICAgIHJldHVybiBjMi53ICogYzIuaCAtIGMxLncgKiBjMS5oO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciB4ID0gMDtcbiAgICAgIHZhciB5ID0gMDtcbiAgICAgIHZhciB1c2VkVyA9IDA7XG4gICAgICB2YXIgcm93SCA9IDA7XG4gICAgICB2YXIgbWF4Um93VyA9IE1hdGguc3FydCh0b3RhbEEpICogbGF5b3V0SW5mby5jbGllbnRXaWR0aCAvIGxheW91dEluZm8uY2xpZW50SGVpZ2h0O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbXBvbmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGMgPSBjb21wb25lbnRzW2ldO1xuXG4gICAgICAgIGlmICghYykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdmFyIG4gPSBjW2pdO1xuXG4gICAgICAgICAgaWYgKCFuLmlzTG9ja2VkKSB7XG4gICAgICAgICAgICBuLnBvc2l0aW9uWCArPSB4O1xuICAgICAgICAgICAgbi5wb3NpdGlvblkgKz0geTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB4ICs9IGMudyArIG9wdGlvbnMuY29tcG9uZW50U3BhY2luZztcbiAgICAgICAgdXNlZFcgKz0gYy53ICsgb3B0aW9ucy5jb21wb25lbnRTcGFjaW5nO1xuICAgICAgICByb3dIID0gTWF0aC5tYXgocm93SCwgYy5oKTtcblxuICAgICAgICBpZiAodXNlZFcgPiBtYXhSb3dXKSB7XG4gICAgICAgICAgeSArPSByb3dIICsgb3B0aW9ucy5jb21wb25lbnRTcGFjaW5nO1xuICAgICAgICAgIHggPSAwO1xuICAgICAgICAgIHVzZWRXID0gMDtcbiAgICAgICAgICByb3dIID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgbWFpbkxvb3AgPSBmdW5jdGlvbiBtYWluTG9vcChpKSB7XG4gICAgICBpZiAoc3RvcHBlZCkge1xuICAgICAgICAvLyBsb2dEZWJ1ZyhcIkxheW91dCBtYW51YWxseSBzdG9wcGVkLiBTdG9wcGluZyBjb21wdXRhdGlvbiBpbiBzdGVwIFwiICsgaSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gRG8gb25lIHN0ZXAgaW4gdGhlIHBoaXNpY2FsIHNpbXVsYXRpb25cbiAgICAgIHN0ZXAobGF5b3V0SW5mbywgb3B0aW9ucywgaSk7XG5cbiAgICAgIC8vIFVwZGF0ZSB0ZW1wZXJhdHVyZVxuICAgICAgbGF5b3V0SW5mby50ZW1wZXJhdHVyZSA9IGxheW91dEluZm8udGVtcGVyYXR1cmUgKiBvcHRpb25zLmNvb2xpbmdGYWN0b3I7XG4gICAgICAvLyBsb2dEZWJ1ZyhcIk5ldyB0ZW1wZXJhdHVyZTogXCIgKyBsYXlvdXRJbmZvLnRlbXBlcmF0dXJlKTtcblxuICAgICAgaWYgKGxheW91dEluZm8udGVtcGVyYXR1cmUgPCBvcHRpb25zLm1pblRlbXApIHtcbiAgICAgICAgLy8gbG9nRGVidWcoXCJUZW1wZXJhdHVyZSBkcm9wIGJlbG93IG1pbmltdW0gdGhyZXNob2xkLiBTdG9wcGluZyBjb21wdXRhdGlvbiBpbiBzdGVwIFwiICsgaSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbG9vcFJldDtcblxuICAgIGRvIHtcbiAgICAgIHZhciBmID0gMDtcblxuICAgICAgd2hpbGUgKGYgPCBvcHRpb25zLnJlZnJlc2ggJiYgaSA8IG9wdGlvbnMubnVtSXRlcikge1xuICAgICAgICB2YXIgbG9vcFJldCA9IG1haW5Mb29wKGkpO1xuICAgICAgICBpZiAoIWxvb3BSZXQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGYrKztcbiAgICAgICAgaSsrO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5hbmltYXRlID09PSB0cnVlKSB7XG4gICAgICAgIGJyb2FkY2FzdChsYXlvdXRJbmZvLmxheW91dE5vZGVzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgICAgfVxuICAgIH0gd2hpbGUgKGxvb3BSZXQgJiYgaSArIDEgPCBvcHRpb25zLm51bUl0ZXIpO1xuXG4gICAgc2VwYXJhdGVDb21wb25lbnRzKGxheW91dEluZm8sIG9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIGxheW91dEluZm87XG4gIH0pLnRoZW4oZnVuY3Rpb24gKGxheW91dEluZm9VcGRhdGVkKSB7XG4gICAgbGF5b3V0SW5mby5sYXlvdXROb2RlcyA9IGxheW91dEluZm9VcGRhdGVkLmxheW91dE5vZGVzOyAvLyBnZXQgdGhlIHBvc2l0aW9uc1xuXG4gICAgdGhyZWFkLnN0b3AoKTtcbiAgICBkb25lKCk7XG4gIH0pO1xuXG4gIHZhciBkb25lID0gZnVuY3Rpb24gZG9uZSgpIHtcbiAgICBpZiAob3B0aW9ucy5hbmltYXRlID09PSB0cnVlIHx8IG9wdGlvbnMuYW5pbWF0ZSA9PT0gZmFsc2UpIHtcbiAgICAgIHJlZnJlc2goe1xuICAgICAgICBmb3JjZTogdHJ1ZSxcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICAvLyBMYXlvdXQgaGFzIGZpbmlzaGVkXG4gICAgICAgICAgbGF5b3V0Lm9uZSgnbGF5b3V0c3RvcCcsIG9wdGlvbnMuc3RvcCk7XG4gICAgICAgICAgbGF5b3V0LmVtaXQoeyB0eXBlOiAnbGF5b3V0c3RvcCcsIGxheW91dDogbGF5b3V0IH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucy5lbGVzLm5vZGVzKCkubGF5b3V0UG9zaXRpb25zKGxheW91dCwgb3B0aW9ucywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIGxub2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFtub2RlLmRhdGEoJ2lkJyldXTtcblxuICAgICAgICByZXR1cm4geyB4OiBsbm9kZS5wb3NpdGlvblgsIHk6IGxub2RlLnBvc2l0aW9uWSB9O1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxuLyoqXG4gKiBAYnJpZWYgOiBjYWxsZWQgb24gY29udGludW91cyBsYXlvdXRzIHRvIHN0b3AgdGhlbSBiZWZvcmUgdGhleSBmaW5pc2hcbiAqL1xuQ29zZUxheW91dC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zdG9wcGVkID0gdHJ1ZTtcblxuICBpZiAodGhpcy50aHJlYWQpIHtcbiAgICB0aGlzLnRocmVhZC5zdG9wKCk7XG4gIH1cblxuICB0aGlzLmVtaXQoJ2xheW91dHN0b3AnKTtcblxuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbkNvc2VMYXlvdXQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnRocmVhZCkge1xuICAgIHRoaXMudGhyZWFkLnN0b3AoKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxuLyoqXG4gKiBAYnJpZWYgICAgIDogQ3JlYXRlcyBhbiBvYmplY3Qgd2hpY2ggaXMgY29udGFpbnMgYWxsIHRoZSBkYXRhXG4gKiAgICAgICAgICAgICAgdXNlZCBpbiB0aGUgbGF5b3V0IHByb2Nlc3NcbiAqIEBhcmcgY3kgICAgOiBjeXRvc2NhcGUuanMgb2JqZWN0XG4gKiBAcmV0dXJuICAgIDogbGF5b3V0SW5mbyBvYmplY3QgaW5pdGlhbGl6ZWRcbiAqL1xudmFyIGNyZWF0ZUxheW91dEluZm8gPSBmdW5jdGlvbiBjcmVhdGVMYXlvdXRJbmZvKGN5LCBsYXlvdXQsIG9wdGlvbnMpIHtcbiAgLy8gU2hvcnRjdXRcbiAgdmFyIGVkZ2VzID0gb3B0aW9ucy5lbGVzLmVkZ2VzKCk7XG4gIHZhciBub2RlcyA9IG9wdGlvbnMuZWxlcy5ub2RlcygpO1xuXG4gIHZhciBsYXlvdXRJbmZvID0ge1xuICAgIGlzQ29tcG91bmQ6IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKSxcbiAgICBsYXlvdXROb2RlczogW10sXG4gICAgaWRUb0luZGV4OiB7fSxcbiAgICBub2RlU2l6ZTogbm9kZXMuc2l6ZSgpLFxuICAgIGdyYXBoU2V0OiBbXSxcbiAgICBpbmRleFRvR3JhcGg6IFtdLFxuICAgIGxheW91dEVkZ2VzOiBbXSxcbiAgICBlZGdlU2l6ZTogZWRnZXMuc2l6ZSgpLFxuICAgIHRlbXBlcmF0dXJlOiBvcHRpb25zLmluaXRpYWxUZW1wLFxuICAgIGNsaWVudFdpZHRoOiBjeS53aWR0aCgpLFxuICAgIGNsaWVudEhlaWdodDogY3kud2lkdGgoKSxcbiAgICBib3VuZGluZ0JveDogbWF0aC5tYWtlQm91bmRpbmdCb3gob3B0aW9ucy5ib3VuZGluZ0JveCA/IG9wdGlvbnMuYm91bmRpbmdCb3ggOiB7XG4gICAgICB4MTogMCwgeTE6IDAsIHc6IGN5LndpZHRoKCksIGg6IGN5LmhlaWdodCgpXG4gICAgfSlcbiAgfTtcblxuICB2YXIgY29tcG9uZW50cyA9IG9wdGlvbnMuZWxlcy5jb21wb25lbnRzKCk7XG4gIHZhciBpZDJjbXB0SWQgPSB7fTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbXBvbmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY29tcG9uZW50ID0gY29tcG9uZW50c1tpXTtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29tcG9uZW50Lmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgbm9kZSA9IGNvbXBvbmVudFtqXTtcblxuICAgICAgaWQyY21wdElkW25vZGUuaWQoKV0gPSBpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEl0ZXJhdGUgb3ZlciBhbGwgbm9kZXMsIGNyZWF0aW5nIGxheW91dCBub2Rlc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubm9kZVNpemU7IGkrKykge1xuICAgIHZhciBuID0gbm9kZXNbaV07XG4gICAgdmFyIG5iYiA9IG4ubGF5b3V0RGltZW5zaW9ucyhvcHRpb25zKTtcblxuICAgIHZhciB0ZW1wTm9kZSA9IHt9O1xuICAgIHRlbXBOb2RlLmlzTG9ja2VkID0gbi5sb2NrZWQoKTtcbiAgICB0ZW1wTm9kZS5pZCA9IG4uZGF0YSgnaWQnKTtcbiAgICB0ZW1wTm9kZS5wYXJlbnRJZCA9IG4uZGF0YSgncGFyZW50Jyk7XG4gICAgdGVtcE5vZGUuY21wdElkID0gaWQyY21wdElkW24uaWQoKV07XG4gICAgdGVtcE5vZGUuY2hpbGRyZW4gPSBbXTtcbiAgICB0ZW1wTm9kZS5wb3NpdGlvblggPSBuLnBvc2l0aW9uKCd4Jyk7XG4gICAgdGVtcE5vZGUucG9zaXRpb25ZID0gbi5wb3NpdGlvbigneScpO1xuICAgIHRlbXBOb2RlLm9mZnNldFggPSAwO1xuICAgIHRlbXBOb2RlLm9mZnNldFkgPSAwO1xuICAgIHRlbXBOb2RlLmhlaWdodCA9IG5iYi53O1xuICAgIHRlbXBOb2RlLndpZHRoID0gbmJiLmg7XG4gICAgdGVtcE5vZGUubWF4WCA9IHRlbXBOb2RlLnBvc2l0aW9uWCArIHRlbXBOb2RlLndpZHRoIC8gMjtcbiAgICB0ZW1wTm9kZS5taW5YID0gdGVtcE5vZGUucG9zaXRpb25YIC0gdGVtcE5vZGUud2lkdGggLyAyO1xuICAgIHRlbXBOb2RlLm1heFkgPSB0ZW1wTm9kZS5wb3NpdGlvblkgKyB0ZW1wTm9kZS5oZWlnaHQgLyAyO1xuICAgIHRlbXBOb2RlLm1pblkgPSB0ZW1wTm9kZS5wb3NpdGlvblkgLSB0ZW1wTm9kZS5oZWlnaHQgLyAyO1xuICAgIHRlbXBOb2RlLnBhZExlZnQgPSBwYXJzZUZsb2F0KG4uc3R5bGUoJ3BhZGRpbmcnKSk7XG4gICAgdGVtcE5vZGUucGFkUmlnaHQgPSBwYXJzZUZsb2F0KG4uc3R5bGUoJ3BhZGRpbmcnKSk7XG4gICAgdGVtcE5vZGUucGFkVG9wID0gcGFyc2VGbG9hdChuLnN0eWxlKCdwYWRkaW5nJykpO1xuICAgIHRlbXBOb2RlLnBhZEJvdHRvbSA9IHBhcnNlRmxvYXQobi5zdHlsZSgncGFkZGluZycpKTtcblxuICAgIC8vIGZvcmNlc1xuICAgIHRlbXBOb2RlLm5vZGVSZXB1bHNpb24gPSBpcy5mbihvcHRpb25zLm5vZGVSZXB1bHNpb24pID8gb3B0aW9ucy5ub2RlUmVwdWxzaW9uKG4pIDogb3B0aW9ucy5ub2RlUmVwdWxzaW9uO1xuXG4gICAgLy8gQWRkIG5ldyBub2RlXG4gICAgbGF5b3V0SW5mby5sYXlvdXROb2Rlcy5wdXNoKHRlbXBOb2RlKTtcbiAgICAvLyBBZGQgZW50cnkgdG8gaWQtaW5kZXggbWFwXG4gICAgbGF5b3V0SW5mby5pZFRvSW5kZXhbdGVtcE5vZGUuaWRdID0gaTtcbiAgfVxuXG4gIC8vIElubGluZSBpbXBsZW1lbnRhdGlvbiBvZiBhIHF1ZXVlLCB1c2VkIGZvciB0cmF2ZXJzaW5nIHRoZSBncmFwaCBpbiBCRlMgb3JkZXJcbiAgdmFyIHF1ZXVlID0gW107XG4gIHZhciBzdGFydCA9IDA7IC8vIFBvaW50cyB0byB0aGUgc3RhcnQgdGhlIHF1ZXVlXG4gIHZhciBlbmQgPSAtMTsgLy8gUG9pbnRzIHRvIHRoZSBlbmQgb2YgdGhlIHF1ZXVlXG5cbiAgdmFyIHRlbXBHcmFwaCA9IFtdO1xuXG4gIC8vIFNlY29uZCBwYXNzIHRvIGFkZCBjaGlsZCBpbmZvcm1hdGlvbiBhbmRcbiAgLy8gaW5pdGlhbGl6ZSBxdWV1ZSBmb3IgaGllcmFyY2hpY2FsIHRyYXZlcnNhbFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubm9kZVNpemU7IGkrKykge1xuICAgIHZhciBuID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tpXTtcbiAgICB2YXIgcF9pZCA9IG4ucGFyZW50SWQ7XG4gICAgLy8gQ2hlY2sgaWYgbm9kZSBuIGhhcyBhIHBhcmVudCBub2RlXG4gICAgaWYgKG51bGwgIT0gcF9pZCkge1xuICAgICAgLy8gQWRkIG5vZGUgSWQgdG8gcGFyZW50J3MgbGlzdCBvZiBjaGlsZHJlblxuICAgICAgbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFtwX2lkXV0uY2hpbGRyZW4ucHVzaChuLmlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgYSBub2RlIGRvZXNuJ3QgaGF2ZSBhIHBhcmVudCwgdGhlbiBpdCdzIGluIHRoZSByb290IGdyYXBoXG4gICAgICBxdWV1ZVsrK2VuZF0gPSBuLmlkO1xuICAgICAgdGVtcEdyYXBoLnB1c2gobi5pZCk7XG4gICAgfVxuICB9XG5cbiAgLy8gQWRkIHJvb3QgZ3JhcGggdG8gZ3JhcGhTZXRcbiAgbGF5b3V0SW5mby5ncmFwaFNldC5wdXNoKHRlbXBHcmFwaCk7XG5cbiAgLy8gVHJhdmVyc2UgdGhlIGdyYXBoLCBsZXZlbCBieSBsZXZlbCxcbiAgd2hpbGUgKHN0YXJ0IDw9IGVuZCkge1xuICAgIC8vIEdldCB0aGUgbm9kZSB0byB2aXNpdCBhbmQgcmVtb3ZlIGl0IGZyb20gcXVldWVcbiAgICB2YXIgbm9kZV9pZCA9IHF1ZXVlW3N0YXJ0KytdO1xuICAgIHZhciBub2RlX2l4ID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbbm9kZV9pZF07XG4gICAgdmFyIG5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW25vZGVfaXhdO1xuICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIEFkZCBjaGlsZHJlbiBub2RlcyBhcyBhIG5ldyBncmFwaCB0byBncmFwaCBzZXRcbiAgICAgIGxheW91dEluZm8uZ3JhcGhTZXQucHVzaChjaGlsZHJlbik7XG4gICAgICAvLyBBZGQgY2hpbGRyZW4gdG8gcXVlIHF1ZXVlIHRvIGJlIHZpc2l0ZWRcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcXVldWVbKytlbmRdID0gY2hpbGRyZW5baV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ3JlYXRlIGluZGV4VG9HcmFwaCBtYXBcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLmdyYXBoU2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGdyYXBoID0gbGF5b3V0SW5mby5ncmFwaFNldFtpXTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGdyYXBoLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgaW5kZXggPSBsYXlvdXRJbmZvLmlkVG9JbmRleFtncmFwaFtqXV07XG4gICAgICBsYXlvdXRJbmZvLmluZGV4VG9HcmFwaFtpbmRleF0gPSBpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEl0ZXJhdGUgb3ZlciBhbGwgZWRnZXMsIGNyZWF0aW5nIExheW91dCBFZGdlc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8uZWRnZVNpemU7IGkrKykge1xuICAgIHZhciBlID0gZWRnZXNbaV07XG4gICAgdmFyIHRlbXBFZGdlID0ge307XG4gICAgdGVtcEVkZ2UuaWQgPSBlLmRhdGEoJ2lkJyk7XG4gICAgdGVtcEVkZ2Uuc291cmNlSWQgPSBlLmRhdGEoJ3NvdXJjZScpO1xuICAgIHRlbXBFZGdlLnRhcmdldElkID0gZS5kYXRhKCd0YXJnZXQnKTtcblxuICAgIC8vIENvbXB1dGUgaWRlYWwgbGVuZ3RoXG4gICAgdmFyIGlkZWFsTGVuZ3RoID0gaXMuZm4ob3B0aW9ucy5pZGVhbEVkZ2VMZW5ndGgpID8gb3B0aW9ucy5pZGVhbEVkZ2VMZW5ndGgoZSkgOiBvcHRpb25zLmlkZWFsRWRnZUxlbmd0aDtcbiAgICB2YXIgZWxhc3RpY2l0eSA9IGlzLmZuKG9wdGlvbnMuZWRnZUVsYXN0aWNpdHkpID8gb3B0aW9ucy5lZGdlRWxhc3RpY2l0eShlKSA6IG9wdGlvbnMuZWRnZUVsYXN0aWNpdHk7XG5cbiAgICAvLyBDaGVjayBpZiBpdCdzIGFuIGludGVyIGdyYXBoIGVkZ2VcbiAgICB2YXIgc291cmNlSXggPSBsYXlvdXRJbmZvLmlkVG9JbmRleFt0ZW1wRWRnZS5zb3VyY2VJZF07XG4gICAgdmFyIHRhcmdldEl4ID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbdGVtcEVkZ2UudGFyZ2V0SWRdO1xuICAgIHZhciBzb3VyY2VHcmFwaCA9IGxheW91dEluZm8uaW5kZXhUb0dyYXBoW3NvdXJjZUl4XTtcbiAgICB2YXIgdGFyZ2V0R3JhcGggPSBsYXlvdXRJbmZvLmluZGV4VG9HcmFwaFt0YXJnZXRJeF07XG5cbiAgICBpZiAoc291cmNlR3JhcGggIT0gdGFyZ2V0R3JhcGgpIHtcbiAgICAgIC8vIEZpbmQgbG93ZXN0IGNvbW1vbiBncmFwaCBhbmNlc3RvclxuICAgICAgdmFyIGxjYSA9IGZpbmRMQ0EodGVtcEVkZ2Uuc291cmNlSWQsIHRlbXBFZGdlLnRhcmdldElkLCBsYXlvdXRJbmZvKTtcblxuICAgICAgLy8gQ29tcHV0ZSBzdW0gb2Ygbm9kZSBkZXB0aHMsIHJlbGF0aXZlIHRvIGxjYSBncmFwaFxuICAgICAgdmFyIGxjYUdyYXBoID0gbGF5b3V0SW5mby5ncmFwaFNldFtsY2FdO1xuICAgICAgdmFyIGRlcHRoID0gMDtcblxuICAgICAgLy8gU291cmNlIGRlcHRoXG4gICAgICB2YXIgdGVtcE5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW3NvdXJjZUl4XTtcbiAgICAgIHdoaWxlICgtMSA9PT0gbGNhR3JhcGguaW5kZXhPZih0ZW1wTm9kZS5pZCkpIHtcbiAgICAgICAgdGVtcE5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W3RlbXBOb2RlLnBhcmVudElkXV07XG4gICAgICAgIGRlcHRoKys7XG4gICAgICB9XG5cbiAgICAgIC8vIFRhcmdldCBkZXB0aFxuICAgICAgdGVtcE5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW3RhcmdldEl4XTtcbiAgICAgIHdoaWxlICgtMSA9PT0gbGNhR3JhcGguaW5kZXhPZih0ZW1wTm9kZS5pZCkpIHtcbiAgICAgICAgdGVtcE5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W3RlbXBOb2RlLnBhcmVudElkXV07XG4gICAgICAgIGRlcHRoKys7XG4gICAgICB9XG5cbiAgICAgIC8vIGxvZ0RlYnVnKCdMQ0Egb2Ygbm9kZXMgJyArIHRlbXBFZGdlLnNvdXJjZUlkICsgJyBhbmQgJyArIHRlbXBFZGdlLnRhcmdldElkICtcbiAgICAgIC8vICBcIi4gSW5kZXg6IFwiICsgbGNhICsgXCIgQ29udGVudHM6IFwiICsgbGNhR3JhcGgudG9TdHJpbmcoKSArXG4gICAgICAvLyAgXCIuIERlcHRoOiBcIiArIGRlcHRoKTtcblxuICAgICAgLy8gVXBkYXRlIGlkZWFsTGVuZ3RoXG4gICAgICBpZGVhbExlbmd0aCAqPSBkZXB0aCAqIG9wdGlvbnMubmVzdGluZ0ZhY3RvcjtcbiAgICB9XG5cbiAgICB0ZW1wRWRnZS5pZGVhbExlbmd0aCA9IGlkZWFsTGVuZ3RoO1xuICAgIHRlbXBFZGdlLmVsYXN0aWNpdHkgPSBlbGFzdGljaXR5O1xuXG4gICAgbGF5b3V0SW5mby5sYXlvdXRFZGdlcy5wdXNoKHRlbXBFZGdlKTtcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHJldHVybiBsYXlvdXRJbmZvIG9iamVjdFxuICByZXR1cm4gbGF5b3V0SW5mbztcbn07XG5cbi8qKlxuICogQGJyaWVmIDogVGhpcyBmdW5jdGlvbiBmaW5kcyB0aGUgaW5kZXggb2YgdGhlIGxvd2VzdCBjb21tb25cbiAqICAgICAgICAgIGdyYXBoIGFuY2VzdG9yIGJldHdlZW4gMiBub2RlcyBpbiB0aGUgc3VidHJlZVxuICogICAgICAgICAgKGZyb20gdGhlIGdyYXBoIGhpZXJhcmNoeSBpbmR1Y2VkIHRyZWUpIHdob3NlXG4gKiAgICAgICAgICByb290IGlzIGdyYXBoSXhcbiAqXG4gKiBAYXJnIG5vZGUxOiBub2RlMSdzIElEXG4gKiBAYXJnIG5vZGUyOiBub2RlMidzIElEXG4gKiBAYXJnIGxheW91dEluZm86IGxheW91dEluZm8gb2JqZWN0XG4gKlxuICovXG52YXIgZmluZExDQSA9IGZ1bmN0aW9uIGZpbmRMQ0Eobm9kZTEsIG5vZGUyLCBsYXlvdXRJbmZvKSB7XG4gIC8vIEZpbmQgdGhlaXIgY29tbW9uIGFuY2VzdGVyLCBzdGFydGluZyBmcm9tIHRoZSByb290IGdyYXBoXG4gIHZhciByZXMgPSBmaW5kTENBX2F1eChub2RlMSwgbm9kZTIsIDAsIGxheW91dEluZm8pO1xuICBpZiAoMiA+IHJlcy5jb3VudCkge1xuICAgIC8vIElmIGF1eCBmdW5jdGlvbiBjb3VsZG4ndCBmaW5kIHRoZSBjb21tb24gYW5jZXN0ZXIsXG4gICAgLy8gdGhlbiBpdCBpcyB0aGUgcm9vdCBncmFwaFxuICAgIHJldHVybiAwO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiByZXMuZ3JhcGg7XG4gIH1cbn07XG5cbi8qKlxuICogQGJyaWVmICAgICAgICAgIDogQXV4aWxpYXJ5IGZ1bmN0aW9uIHVzZWQgZm9yIExDQSBjb21wdXRhdGlvblxuICpcbiAqIEBhcmcgbm9kZTEgICAgICA6IG5vZGUxJ3MgSURcbiAqIEBhcmcgbm9kZTIgICAgICA6IG5vZGUyJ3MgSURcbiAqIEBhcmcgZ3JhcGhJeCAgICA6IHN1YmdyYXBoIGluZGV4XG4gKiBAYXJnIGxheW91dEluZm8gOiBsYXlvdXRJbmZvIG9iamVjdFxuICpcbiAqIEByZXR1cm4gICAgICAgICA6IG9iamVjdCBvZiB0aGUgZm9ybSB7Y291bnQ6IFgsIGdyYXBoOiBZfSwgd2hlcmU6XG4gKiAgICAgICAgICAgICAgICAgICBYIGlzIHRoZSBudW1iZXIgb2YgYW5jZXN0ZXJzIChtYXg6IDIpIGZvdW5kIGluXG4gKiAgICAgICAgICAgICAgICAgICBncmFwaEl4IChhbmQgaXQncyBzdWJncmFwaHMpLFxuICogICAgICAgICAgICAgICAgICAgWSBpcyB0aGUgZ3JhcGggaW5kZXggb2YgdGhlIGxvd2VzdCBncmFwaCBjb250YWluaW5nXG4gKiAgICAgICAgICAgICAgICAgICBhbGwgWCBub2Rlc1xuICovXG52YXIgZmluZExDQV9hdXggPSBmdW5jdGlvbiBmaW5kTENBX2F1eChub2RlMSwgbm9kZTIsIGdyYXBoSXgsIGxheW91dEluZm8pIHtcbiAgdmFyIGdyYXBoID0gbGF5b3V0SW5mby5ncmFwaFNldFtncmFwaEl4XTtcbiAgLy8gSWYgYm90aCBub2RlcyBiZWxvbmdzIHRvIGdyYXBoSXhcbiAgaWYgKC0xIDwgZ3JhcGguaW5kZXhPZihub2RlMSkgJiYgLTEgPCBncmFwaC5pbmRleE9mKG5vZGUyKSkge1xuICAgIHJldHVybiB7IGNvdW50OiAyLCBncmFwaDogZ3JhcGhJeCB9O1xuICB9XG5cbiAgLy8gTWFrZSByZWN1cnNpdmUgY2FsbHMgZm9yIGFsbCBzdWJncmFwaHNcbiAgdmFyIGMgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGdyYXBoLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5vZGVJZCA9IGdyYXBoW2ldO1xuICAgIHZhciBub2RlSXggPSBsYXlvdXRJbmZvLmlkVG9JbmRleFtub2RlSWRdO1xuICAgIHZhciBjaGlsZHJlbiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbm9kZUl4XS5jaGlsZHJlbjtcblxuICAgIC8vIElmIHRoZSBub2RlIGhhcyBubyBjaGlsZCwgc2tpcCBpdFxuICAgIGlmICgwID09PSBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBjaGlsZEdyYXBoSXggPSBsYXlvdXRJbmZvLmluZGV4VG9HcmFwaFtsYXlvdXRJbmZvLmlkVG9JbmRleFtjaGlsZHJlblswXV1dO1xuICAgIHZhciByZXN1bHQgPSBmaW5kTENBX2F1eChub2RlMSwgbm9kZTIsIGNoaWxkR3JhcGhJeCwgbGF5b3V0SW5mbyk7XG4gICAgaWYgKDAgPT09IHJlc3VsdC5jb3VudCkge1xuICAgICAgLy8gTmVpdGhlciBub2RlMSBub3Igbm9kZTIgYXJlIHByZXNlbnQgaW4gdGhpcyBzdWJncmFwaFxuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIGlmICgxID09PSByZXN1bHQuY291bnQpIHtcbiAgICAgIC8vIE9uZSBvZiAobm9kZTEsIG5vZGUyKSBpcyBwcmVzZW50IGluIHRoaXMgc3ViZ3JhcGhcbiAgICAgIGMrKztcbiAgICAgIGlmICgyID09PSBjKSB7XG4gICAgICAgIC8vIFdlJ3ZlIGFscmVhZHkgZm91bmQgYm90aCBub2Rlcywgbm8gbmVlZCB0byBrZWVwIHNlYXJjaGluZ1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQm90aCBub2RlcyBhcmUgcHJlc2VudCBpbiB0aGlzIHN1YmdyYXBoXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7IGNvdW50OiBjLCBncmFwaDogZ3JhcGhJeCB9O1xufTtcblxuLyoqXG4gKiBAYnJpZWY6IHByaW50c0xheW91dEluZm8gaW50byBqcyBjb25zb2xlXG4gKiAgICAgICAgIE9ubHkgdXNlZCBmb3IgZGViYnVnaW5nXG4gKi9cbnZhciBwcmludExheW91dEluZm8gPSBmdW5jdGlvbiBwcmludExheW91dEluZm8obGF5b3V0SW5mbykge1xuICAvKiBlc2xpbnQtZGlzYWJsZSAqL1xuXG4gIGlmICghREVCVUcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc29sZS5kZWJ1ZygnbGF5b3V0Tm9kZXM6Jyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ub2RlU2l6ZTsgaSsrKSB7XG4gICAgdmFyIG4gPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2ldO1xuICAgIHZhciBzID0gJ1xcbmluZGV4OiAnICsgaSArICdcXG5JZDogJyArIG4uaWQgKyAnXFxuQ2hpbGRyZW46ICcgKyBuLmNoaWxkcmVuLnRvU3RyaW5nKCkgKyAnXFxucGFyZW50SWQ6ICcgKyBuLnBhcmVudElkICsgJ1xcbnBvc2l0aW9uWDogJyArIG4ucG9zaXRpb25YICsgJ1xcbnBvc2l0aW9uWTogJyArIG4ucG9zaXRpb25ZICsgJ1xcbk9mZnNldFg6ICcgKyBuLm9mZnNldFggKyAnXFxuT2Zmc2V0WTogJyArIG4ub2Zmc2V0WSArICdcXG5wYWRMZWZ0OiAnICsgbi5wYWRMZWZ0ICsgJ1xcbnBhZFJpZ2h0OiAnICsgbi5wYWRSaWdodCArICdcXG5wYWRUb3A6ICcgKyBuLnBhZFRvcCArICdcXG5wYWRCb3R0b206ICcgKyBuLnBhZEJvdHRvbTtcblxuICAgIGNvbnNvbGUuZGVidWcocyk7XG4gIH1cblxuICBjb25zb2xlLmRlYnVnKCdpZFRvSW5kZXgnKTtcbiAgZm9yICh2YXIgaSBpbiBsYXlvdXRJbmZvLmlkVG9JbmRleCkge1xuICAgIGNvbnNvbGUuZGVidWcoJ0lkOiAnICsgaSArICdcXG5JbmRleDogJyArIGxheW91dEluZm8uaWRUb0luZGV4W2ldKTtcbiAgfVxuXG4gIGNvbnNvbGUuZGVidWcoJ0dyYXBoIFNldCcpO1xuICB2YXIgc2V0ID0gbGF5b3V0SW5mby5ncmFwaFNldDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zb2xlLmRlYnVnKCdTZXQgOiAnICsgaSArICc6ICcgKyBzZXRbaV0udG9TdHJpbmcoKSk7XG4gIH1cblxuICB2YXIgcyA9ICdJbmRleFRvR3JhcGgnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8uaW5kZXhUb0dyYXBoLmxlbmd0aDsgaSsrKSB7XG4gICAgcyArPSAnXFxuSW5kZXggOiAnICsgaSArICcgR3JhcGg6ICcgKyBsYXlvdXRJbmZvLmluZGV4VG9HcmFwaFtpXTtcbiAgfVxuICBjb25zb2xlLmRlYnVnKHMpO1xuXG4gIHMgPSAnTGF5b3V0IEVkZ2VzJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLmxheW91dEVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGUgPSBsYXlvdXRJbmZvLmxheW91dEVkZ2VzW2ldO1xuICAgIHMgKz0gJ1xcbkVkZ2UgSW5kZXg6ICcgKyBpICsgJyBJRDogJyArIGUuaWQgKyAnIFNvdWNlSUQ6ICcgKyBlLnNvdXJjZUlkICsgJyBUYXJnZXRJZDogJyArIGUudGFyZ2V0SWQgKyAnIElkZWFsIExlbmd0aDogJyArIGUuaWRlYWxMZW5ndGg7XG4gIH1cbiAgY29uc29sZS5kZWJ1ZyhzKTtcblxuICBzID0gJ25vZGVTaXplOiAnICsgbGF5b3V0SW5mby5ub2RlU2l6ZTtcbiAgcyArPSAnXFxuZWRnZVNpemU6ICcgKyBsYXlvdXRJbmZvLmVkZ2VTaXplO1xuICBzICs9ICdcXG50ZW1wZXJhdHVyZTogJyArIGxheW91dEluZm8udGVtcGVyYXR1cmU7XG4gIGNvbnNvbGUuZGVidWcocyk7XG5cbiAgcmV0dXJuO1xuICAvKiBlc2xpbnQtZW5hYmxlICovXG59O1xuXG4vKipcbiAqIEBicmllZiA6IFJhbmRvbWl6ZXMgdGhlIHBvc2l0aW9uIG9mIGFsbCBub2Rlc1xuICovXG52YXIgcmFuZG9taXplUG9zaXRpb25zID0gZnVuY3Rpb24gcmFuZG9taXplUG9zaXRpb25zKGxheW91dEluZm8sIGN5KSB7XG4gIHZhciB3aWR0aCA9IGxheW91dEluZm8uY2xpZW50V2lkdGg7XG4gIHZhciBoZWlnaHQgPSBsYXlvdXRJbmZvLmNsaWVudEhlaWdodDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubm9kZVNpemU7IGkrKykge1xuICAgIHZhciBuID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tpXTtcblxuICAgIC8vIE5vIG5lZWQgdG8gcmFuZG9taXplIGNvbXBvdW5kIG5vZGVzIG9yIGxvY2tlZCBub2Rlc1xuICAgIGlmICgwID09PSBuLmNoaWxkcmVuLmxlbmd0aCAmJiAhbi5pc0xvY2tlZCkge1xuICAgICAgbi5wb3NpdGlvblggPSBNYXRoLnJhbmRvbSgpICogd2lkdGg7XG4gICAgICBuLnBvc2l0aW9uWSA9IE1hdGgucmFuZG9tKCkgKiBoZWlnaHQ7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEBicmllZiAgICAgICAgICA6IFVwZGF0ZXMgdGhlIHBvc2l0aW9ucyBvZiBub2RlcyBpbiB0aGUgbmV0d29ya1xuICogQGFyZyBsYXlvdXRJbmZvIDogTGF5b3V0SW5mbyBvYmplY3RcbiAqIEBhcmcgY3kgICAgICAgICA6IEN5dG9zY2FwZSBvYmplY3RcbiAqIEBhcmcgb3B0aW9ucyAgICA6IExheW91dCBvcHRpb25zXG4gKi9cbnZhciByZWZyZXNoUG9zaXRpb25zID0gZnVuY3Rpb24gcmVmcmVzaFBvc2l0aW9ucyhsYXlvdXRJbmZvLCBjeSwgb3B0aW9ucykge1xuICAvLyB2YXIgcyA9ICdSZWZyZXNoaW5nIHBvc2l0aW9ucyc7XG4gIC8vIGxvZ0RlYnVnKHMpO1xuXG4gIHZhciBsYXlvdXQgPSBvcHRpb25zLmxheW91dDtcbiAgdmFyIG5vZGVzID0gb3B0aW9ucy5lbGVzLm5vZGVzKCk7XG4gIHZhciBiYiA9IGxheW91dEluZm8uYm91bmRpbmdCb3g7XG4gIHZhciBjb3NlQkIgPSB7IHgxOiBJbmZpbml0eSwgeDI6IC1JbmZpbml0eSwgeTE6IEluZmluaXR5LCB5MjogLUluZmluaXR5IH07XG5cbiAgaWYgKG9wdGlvbnMuYm91bmRpbmdCb3gpIHtcbiAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICB2YXIgbG5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W25vZGUuZGF0YSgnaWQnKV1dO1xuXG4gICAgICBjb3NlQkIueDEgPSBNYXRoLm1pbihjb3NlQkIueDEsIGxub2RlLnBvc2l0aW9uWCk7XG4gICAgICBjb3NlQkIueDIgPSBNYXRoLm1heChjb3NlQkIueDIsIGxub2RlLnBvc2l0aW9uWCk7XG5cbiAgICAgIGNvc2VCQi55MSA9IE1hdGgubWluKGNvc2VCQi55MSwgbG5vZGUucG9zaXRpb25ZKTtcbiAgICAgIGNvc2VCQi55MiA9IE1hdGgubWF4KGNvc2VCQi55MiwgbG5vZGUucG9zaXRpb25ZKTtcbiAgICB9KTtcblxuICAgIGNvc2VCQi53ID0gY29zZUJCLngyIC0gY29zZUJCLngxO1xuICAgIGNvc2VCQi5oID0gY29zZUJCLnkyIC0gY29zZUJCLnkxO1xuICB9XG5cbiAgbm9kZXMucG9zaXRpb25zKGZ1bmN0aW9uIChlbGUsIGkpIHtcbiAgICB2YXIgbG5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W2VsZS5kYXRhKCdpZCcpXV07XG4gICAgLy8gcyA9IFwiTm9kZTogXCIgKyBsbm9kZS5pZCArIFwiLiBSZWZyZXNoZWQgcG9zaXRpb246IChcIiArXG4gICAgLy8gbG5vZGUucG9zaXRpb25YICsgXCIsIFwiICsgbG5vZGUucG9zaXRpb25ZICsgXCIpLlwiO1xuICAgIC8vIGxvZ0RlYnVnKHMpO1xuXG4gICAgaWYgKG9wdGlvbnMuYm91bmRpbmdCb3gpIHtcbiAgICAgIC8vIHRoZW4gYWRkIGV4dHJhIGJvdW5kaW5nIGJveCBjb25zdHJhaW50XG4gICAgICB2YXIgcGN0WCA9IChsbm9kZS5wb3NpdGlvblggLSBjb3NlQkIueDEpIC8gY29zZUJCLnc7XG4gICAgICB2YXIgcGN0WSA9IChsbm9kZS5wb3NpdGlvblkgLSBjb3NlQkIueTEpIC8gY29zZUJCLmg7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGJiLngxICsgcGN0WCAqIGJiLncsXG4gICAgICAgIHk6IGJiLnkxICsgcGN0WSAqIGJiLmhcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGxub2RlLnBvc2l0aW9uWCxcbiAgICAgICAgeTogbG5vZGUucG9zaXRpb25ZXG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gVHJpZ2dlciBsYXlvdXRSZWFkeSBvbmx5IG9uIGZpcnN0IGNhbGxcbiAgaWYgKHRydWUgIT09IGxheW91dEluZm8ucmVhZHkpIHtcbiAgICAvLyBzID0gJ1RyaWdnZXJpbmcgbGF5b3V0cmVhZHknO1xuICAgIC8vIGxvZ0RlYnVnKHMpO1xuICAgIGxheW91dEluZm8ucmVhZHkgPSB0cnVlO1xuICAgIGxheW91dC5vbmUoJ2xheW91dHJlYWR5Jywgb3B0aW9ucy5yZWFkeSk7XG4gICAgbGF5b3V0LmVtaXQoeyB0eXBlOiAnbGF5b3V0cmVhZHknLCBsYXlvdXQ6IHRoaXMgfSk7XG4gIH1cbn07XG5cbi8qKlxuICogQGJyaWVmIDogTG9ncyBhIGRlYnVnIG1lc3NhZ2UgaW4gSlMgY29uc29sZSwgaWYgREVCVUcgaXMgT05cbiAqL1xuLy8gdmFyIGxvZ0RlYnVnID0gZnVuY3Rpb24odGV4dCkge1xuLy8gICBpZiAoREVCVUcpIHtcbi8vICAgICBjb25zb2xlLmRlYnVnKHRleHQpO1xuLy8gICB9XG4vLyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvc2VMYXlvdXQ7XG5cbi8qKiovIH0pLFxuLyogMTAxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbnZhciBtYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIGRlZmF1bHRzID0ge1xuICBmaXQ6IHRydWUsIC8vIHdoZXRoZXIgdG8gZml0IHRoZSB2aWV3cG9ydCB0byB0aGUgZ3JhcGhcbiAgcGFkZGluZzogMzAsIC8vIHBhZGRpbmcgdXNlZCBvbiBmaXRcbiAgYm91bmRpbmdCb3g6IHVuZGVmaW5lZCwgLy8gY29uc3RyYWluIGxheW91dCBib3VuZHM7IHsgeDEsIHkxLCB4MiwgeTIgfSBvciB7IHgxLCB5MSwgdywgaCB9XG4gIGF2b2lkT3ZlcmxhcDogdHJ1ZSwgLy8gcHJldmVudHMgbm9kZSBvdmVybGFwLCBtYXkgb3ZlcmZsb3cgYm91bmRpbmdCb3ggaWYgbm90IGVub3VnaCBzcGFjZVxuICBhdm9pZE92ZXJsYXBQYWRkaW5nOiAxMCwgLy8gZXh0cmEgc3BhY2luZyBhcm91bmQgbm9kZXMgd2hlbiBhdm9pZE92ZXJsYXA6IHRydWVcbiAgbm9kZURpbWVuc2lvbnNJbmNsdWRlTGFiZWxzOiBmYWxzZSwgLy8gRXhjbHVkZXMgdGhlIGxhYmVsIHdoZW4gY2FsY3VsYXRpbmcgbm9kZSBib3VuZGluZyBib3hlcyBmb3IgdGhlIGxheW91dCBhbGdvcml0aG1cbiAgc3BhY2luZ0ZhY3RvcjogdW5kZWZpbmVkLCAvLyBBcHBsaWVzIGEgbXVsdGlwbGljYXRpdmUgZmFjdG9yICg+MCkgdG8gZXhwYW5kIG9yIGNvbXByZXNzIHRoZSBvdmVyYWxsIGFyZWEgdGhhdCB0aGUgbm9kZXMgdGFrZSB1cFxuICBjb25kZW5zZTogZmFsc2UsIC8vIHVzZXMgYWxsIGF2YWlsYWJsZSBzcGFjZSBvbiBmYWxzZSwgdXNlcyBtaW5pbWFsIHNwYWNlIG9uIHRydWVcbiAgcm93czogdW5kZWZpbmVkLCAvLyBmb3JjZSBudW0gb2Ygcm93cyBpbiB0aGUgZ3JpZFxuICBjb2xzOiB1bmRlZmluZWQsIC8vIGZvcmNlIG51bSBvZiBjb2x1bW5zIGluIHRoZSBncmlkXG4gIHBvc2l0aW9uOiBmdW5jdGlvbiBwb3NpdGlvbihub2RlKSB7fSwgLy8gcmV0dXJucyB7IHJvdywgY29sIH0gZm9yIGVsZW1lbnRcbiAgc29ydDogdW5kZWZpbmVkLCAvLyBhIHNvcnRpbmcgZnVuY3Rpb24gdG8gb3JkZXIgdGhlIG5vZGVzOyBlLmcuIGZ1bmN0aW9uKGEsIGIpeyByZXR1cm4gYS5kYXRhKCd3ZWlnaHQnKSAtIGIuZGF0YSgnd2VpZ2h0JykgfVxuICBhbmltYXRlOiBmYWxzZSwgLy8gd2hldGhlciB0byB0cmFuc2l0aW9uIHRoZSBub2RlIHBvc2l0aW9uc1xuICBhbmltYXRpb25EdXJhdGlvbjogNTAwLCAvLyBkdXJhdGlvbiBvZiBhbmltYXRpb24gaW4gbXMgaWYgZW5hYmxlZFxuICBhbmltYXRpb25FYXNpbmc6IHVuZGVmaW5lZCwgLy8gZWFzaW5nIG9mIGFuaW1hdGlvbiBpZiBlbmFibGVkXG4gIGFuaW1hdGVGaWx0ZXI6IGZ1bmN0aW9uIGFuaW1hdGVGaWx0ZXIobm9kZSwgaSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9LCAvLyBhIGZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBub2RlIHNob3VsZCBiZSBhbmltYXRlZC4gIEFsbCBub2RlcyBhbmltYXRlZCBieSBkZWZhdWx0IG9uIGFuaW1hdGUgZW5hYmxlZC4gIE5vbi1hbmltYXRlZCBub2RlcyBhcmUgcG9zaXRpb25lZCBpbW1lZGlhdGVseSB3aGVuIHRoZSBsYXlvdXQgc3RhcnRzXG4gIHJlYWR5OiB1bmRlZmluZWQsIC8vIGNhbGxiYWNrIG9uIGxheW91dHJlYWR5XG4gIHN0b3A6IHVuZGVmaW5lZCwgLy8gY2FsbGJhY2sgb24gbGF5b3V0c3RvcFxuICB0cmFuc2Zvcm06IGZ1bmN0aW9uIHRyYW5zZm9ybShub2RlLCBwb3NpdGlvbikge1xuICAgIHJldHVybiBwb3NpdGlvbjtcbiAgfSAvLyB0cmFuc2Zvcm0gYSBnaXZlbiBub2RlIHBvc2l0aW9uLiBVc2VmdWwgZm9yIGNoYW5naW5nIGZsb3cgZGlyZWN0aW9uIGluIGRpc2NyZXRlIGxheW91dHMgXG59O1xuXG5mdW5jdGlvbiBHcmlkTGF5b3V0KG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gdXRpbC5leHRlbmQoe30sIGRlZmF1bHRzLCBvcHRpb25zKTtcbn1cblxuR3JpZExheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcGFyYW1zID0gdGhpcy5vcHRpb25zO1xuICB2YXIgb3B0aW9ucyA9IHBhcmFtcztcblxuICB2YXIgY3kgPSBwYXJhbXMuY3k7XG4gIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCkubm90KCc6cGFyZW50Jyk7XG5cbiAgaWYgKG9wdGlvbnMuc29ydCkge1xuICAgIG5vZGVzID0gbm9kZXMuc29ydChvcHRpb25zLnNvcnQpO1xuICB9XG5cbiAgdmFyIGJiID0gbWF0aC5tYWtlQm91bmRpbmdCb3gob3B0aW9ucy5ib3VuZGluZ0JveCA/IG9wdGlvbnMuYm91bmRpbmdCb3ggOiB7XG4gICAgeDE6IDAsIHkxOiAwLCB3OiBjeS53aWR0aCgpLCBoOiBjeS5oZWlnaHQoKVxuICB9KTtcblxuICBpZiAoYmIuaCA9PT0gMCB8fCBiYi53ID09PSAwKSB7XG4gICAgbm9kZXMubGF5b3V0UG9zaXRpb25zKHRoaXMsIG9wdGlvbnMsIGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIHJldHVybiB7IHg6IGJiLngxLCB5OiBiYi55MSB9O1xuICAgIH0pO1xuICB9IGVsc2Uge1xuXG4gICAgLy8gd2lkdGgvaGVpZ2h0ICogc3BsaXRzXjIgPSBjZWxscyB3aGVyZSBzcGxpdHMgaXMgbnVtYmVyIG9mIHRpbWVzIHRvIHNwbGl0IHdpZHRoXG4gICAgdmFyIGNlbGxzID0gbm9kZXMuc2l6ZSgpO1xuICAgIHZhciBzcGxpdHMgPSBNYXRoLnNxcnQoY2VsbHMgKiBiYi5oIC8gYmIudyk7XG4gICAgdmFyIHJvd3MgPSBNYXRoLnJvdW5kKHNwbGl0cyk7XG4gICAgdmFyIGNvbHMgPSBNYXRoLnJvdW5kKGJiLncgLyBiYi5oICogc3BsaXRzKTtcblxuICAgIHZhciBzbWFsbCA9IGZ1bmN0aW9uIHNtYWxsKHZhbCkge1xuICAgICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1pbihyb3dzLCBjb2xzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBtaW4gPSBNYXRoLm1pbihyb3dzLCBjb2xzKTtcbiAgICAgICAgaWYgKG1pbiA9PSByb3dzKSB7XG4gICAgICAgICAgcm93cyA9IHZhbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb2xzID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBsYXJnZSA9IGZ1bmN0aW9uIGxhcmdlKHZhbCkge1xuICAgICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heChyb3dzLCBjb2xzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBtYXggPSBNYXRoLm1heChyb3dzLCBjb2xzKTtcbiAgICAgICAgaWYgKG1heCA9PSByb3dzKSB7XG4gICAgICAgICAgcm93cyA9IHZhbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb2xzID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBvUm93cyA9IG9wdGlvbnMucm93cztcbiAgICB2YXIgb0NvbHMgPSBvcHRpb25zLmNvbHMgIT0gbnVsbCA/IG9wdGlvbnMuY29scyA6IG9wdGlvbnMuY29sdW1ucztcblxuICAgIC8vIGlmIHJvd3Mgb3IgY29sdW1ucyB3ZXJlIHNldCBpbiBvcHRpb25zLCB1c2UgdGhvc2UgdmFsdWVzXG4gICAgaWYgKG9Sb3dzICE9IG51bGwgJiYgb0NvbHMgIT0gbnVsbCkge1xuICAgICAgcm93cyA9IG9Sb3dzO1xuICAgICAgY29scyA9IG9Db2xzO1xuICAgIH0gZWxzZSBpZiAob1Jvd3MgIT0gbnVsbCAmJiBvQ29scyA9PSBudWxsKSB7XG4gICAgICByb3dzID0gb1Jvd3M7XG4gICAgICBjb2xzID0gTWF0aC5jZWlsKGNlbGxzIC8gcm93cyk7XG4gICAgfSBlbHNlIGlmIChvUm93cyA9PSBudWxsICYmIG9Db2xzICE9IG51bGwpIHtcbiAgICAgIGNvbHMgPSBvQ29scztcbiAgICAgIHJvd3MgPSBNYXRoLmNlaWwoY2VsbHMgLyBjb2xzKTtcbiAgICB9XG5cbiAgICAvLyBvdGhlcndpc2UgdXNlIHRoZSBhdXRvbWF0aWMgdmFsdWVzIGFuZCBhZGp1c3QgYWNjb3JkaW5nbHlcblxuICAgIC8vIGlmIHJvdW5kaW5nIHdhcyB1cCwgc2VlIGlmIHdlIGNhbiByZWR1Y2Ugcm93cyBvciBjb2x1bW5zXG4gICAgZWxzZSBpZiAoY29scyAqIHJvd3MgPiBjZWxscykge1xuICAgICAgICB2YXIgc20gPSBzbWFsbCgpO1xuICAgICAgICB2YXIgbGcgPSBsYXJnZSgpO1xuXG4gICAgICAgIC8vIHJlZHVjaW5nIHRoZSBzbWFsbCBzaWRlIHRha2VzIGF3YXkgdGhlIG1vc3QgY2VsbHMsIHNvIHRyeSBpdCBmaXJzdFxuICAgICAgICBpZiAoKHNtIC0gMSkgKiBsZyA+PSBjZWxscykge1xuICAgICAgICAgIHNtYWxsKHNtIC0gMSk7XG4gICAgICAgIH0gZWxzZSBpZiAoKGxnIC0gMSkgKiBzbSA+PSBjZWxscykge1xuICAgICAgICAgIGxhcmdlKGxnIC0gMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gaWYgcm91bmRpbmcgd2FzIHRvbyBsb3csIGFkZCByb3dzIG9yIGNvbHVtbnNcbiAgICAgICAgd2hpbGUgKGNvbHMgKiByb3dzIDwgY2VsbHMpIHtcbiAgICAgICAgICB2YXIgX3NtID0gc21hbGwoKTtcbiAgICAgICAgICB2YXIgX2xnID0gbGFyZ2UoKTtcblxuICAgICAgICAgIC8vIHRyeSB0byBhZGQgdG8gbGFyZ2VyIHNpZGUgZmlyc3QgKGFkZHMgbGVzcyBpbiBtdWx0aXBsaWNhdGlvbilcbiAgICAgICAgICBpZiAoKF9sZyArIDEpICogX3NtID49IGNlbGxzKSB7XG4gICAgICAgICAgICBsYXJnZShfbGcgKyAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc21hbGwoX3NtICsgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB2YXIgY2VsbFdpZHRoID0gYmIudyAvIGNvbHM7XG4gICAgdmFyIGNlbGxIZWlnaHQgPSBiYi5oIC8gcm93cztcblxuICAgIGlmIChvcHRpb25zLmNvbmRlbnNlKSB7XG4gICAgICBjZWxsV2lkdGggPSAwO1xuICAgICAgY2VsbEhlaWdodCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuYXZvaWRPdmVybGFwKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIHZhciBwb3MgPSBub2RlLl9wcml2YXRlLnBvc2l0aW9uO1xuXG4gICAgICAgIGlmIChwb3MueCA9PSBudWxsIHx8IHBvcy55ID09IG51bGwpIHtcbiAgICAgICAgICAvLyBmb3IgYmJcbiAgICAgICAgICBwb3MueCA9IDA7XG4gICAgICAgICAgcG9zLnkgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5iYiA9IG5vZGUubGF5b3V0RGltZW5zaW9ucyhvcHRpb25zKTtcbiAgICAgICAgdmFyIHAgPSBvcHRpb25zLmF2b2lkT3ZlcmxhcFBhZGRpbmc7XG5cbiAgICAgICAgdmFyIHcgPSBuYmIudyArIHA7XG4gICAgICAgIHZhciBoID0gbmJiLmggKyBwO1xuXG4gICAgICAgIGNlbGxXaWR0aCA9IE1hdGgubWF4KGNlbGxXaWR0aCwgdyk7XG4gICAgICAgIGNlbGxIZWlnaHQgPSBNYXRoLm1heChjZWxsSGVpZ2h0LCBoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2VsbFVzZWQgPSB7fTsgLy8gZS5nLiAnYy0wLTInID0+IHRydWVcblxuICAgIHZhciB1c2VkID0gZnVuY3Rpb24gdXNlZChyb3csIGNvbCkge1xuICAgICAgcmV0dXJuIGNlbGxVc2VkWydjLScgKyByb3cgKyAnLScgKyBjb2xdID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH07XG5cbiAgICB2YXIgdXNlID0gZnVuY3Rpb24gdXNlKHJvdywgY29sKSB7XG4gICAgICBjZWxsVXNlZFsnYy0nICsgcm93ICsgJy0nICsgY29sXSA9IHRydWU7XG4gICAgfTtcblxuICAgIC8vIHRvIGtlZXAgdHJhY2sgb2YgY3VycmVudCBjZWxsIHBvc2l0aW9uXG4gICAgdmFyIHJvdyA9IDA7XG4gICAgdmFyIGNvbCA9IDA7XG4gICAgdmFyIG1vdmVUb05leHRDZWxsID0gZnVuY3Rpb24gbW92ZVRvTmV4dENlbGwoKSB7XG4gICAgICBjb2wrKztcbiAgICAgIGlmIChjb2wgPj0gY29scykge1xuICAgICAgICBjb2wgPSAwO1xuICAgICAgICByb3crKztcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gZ2V0IGEgY2FjaGUgb2YgYWxsIHRoZSBtYW51YWwgcG9zaXRpb25zXG4gICAgdmFyIGlkMm1hblBvcyA9IHt9O1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBub2Rlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfbm9kZSA9IG5vZGVzW19pXTtcbiAgICAgIHZhciByY1BvcyA9IG9wdGlvbnMucG9zaXRpb24oX25vZGUpO1xuXG4gICAgICBpZiAocmNQb3MgJiYgKHJjUG9zLnJvdyAhPT0gdW5kZWZpbmVkIHx8IHJjUG9zLmNvbCAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAvLyBtdXN0IGhhdmUgYXQgbGVhc3Qgcm93IG9yIGNvbCBkZWYnZFxuICAgICAgICB2YXIgX3BvcyA9IHtcbiAgICAgICAgICByb3c6IHJjUG9zLnJvdyxcbiAgICAgICAgICBjb2w6IHJjUG9zLmNvbFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChfcG9zLmNvbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gZmluZCB1bnVzZWQgY29sXG4gICAgICAgICAgX3Bvcy5jb2wgPSAwO1xuXG4gICAgICAgICAgd2hpbGUgKHVzZWQoX3Bvcy5yb3csIF9wb3MuY29sKSkge1xuICAgICAgICAgICAgX3Bvcy5jb2wrKztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoX3Bvcy5yb3cgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIGZpbmQgdW51c2VkIHJvd1xuICAgICAgICAgIF9wb3Mucm93ID0gMDtcblxuICAgICAgICAgIHdoaWxlICh1c2VkKF9wb3Mucm93LCBfcG9zLmNvbCkpIHtcbiAgICAgICAgICAgIF9wb3Mucm93Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWQybWFuUG9zW19ub2RlLmlkKCldID0gX3BvcztcbiAgICAgICAgdXNlKF9wb3Mucm93LCBfcG9zLmNvbCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGdldFBvcyA9IGZ1bmN0aW9uIGdldFBvcyhlbGVtZW50LCBpKSB7XG4gICAgICB2YXIgeCA9IHZvaWQgMCxcbiAgICAgICAgICB5ID0gdm9pZCAwO1xuXG4gICAgICBpZiAoZWxlbWVudC5sb2NrZWQoKSB8fCBlbGVtZW50LmlzUGFyZW50KCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBzZWUgaWYgd2UgaGF2ZSBhIG1hbnVhbCBwb3NpdGlvbiBzZXRcbiAgICAgIHZhciByY1BvcyA9IGlkMm1hblBvc1tlbGVtZW50LmlkKCldO1xuICAgICAgaWYgKHJjUG9zKSB7XG4gICAgICAgIHggPSByY1Bvcy5jb2wgKiBjZWxsV2lkdGggKyBjZWxsV2lkdGggLyAyICsgYmIueDE7XG4gICAgICAgIHkgPSByY1Bvcy5yb3cgKiBjZWxsSGVpZ2h0ICsgY2VsbEhlaWdodCAvIDIgKyBiYi55MTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG90aGVyd2lzZSBzZXQgYXV0b21hdGljYWxseVxuXG4gICAgICAgIHdoaWxlICh1c2VkKHJvdywgY29sKSkge1xuICAgICAgICAgIG1vdmVUb05leHRDZWxsKCk7XG4gICAgICAgIH1cblxuICAgICAgICB4ID0gY29sICogY2VsbFdpZHRoICsgY2VsbFdpZHRoIC8gMiArIGJiLngxO1xuICAgICAgICB5ID0gcm93ICogY2VsbEhlaWdodCArIGNlbGxIZWlnaHQgLyAyICsgYmIueTE7XG4gICAgICAgIHVzZShyb3csIGNvbCk7XG5cbiAgICAgICAgbW92ZVRvTmV4dENlbGwoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgeDogeCwgeTogeSB9O1xuICAgIH07XG5cbiAgICBub2Rlcy5sYXlvdXRQb3NpdGlvbnModGhpcywgb3B0aW9ucywgZ2V0UG9zKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHcmlkTGF5b3V0O1xuXG4vKioqLyB9KSxcbi8qIDEwMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbi8vIGRlZmF1bHQgbGF5b3V0IG9wdGlvbnNcbnZhciBkZWZhdWx0cyA9IHtcbiAgcmVhZHk6IGZ1bmN0aW9uIHJlYWR5KCkge30sIC8vIG9uIGxheW91dHJlYWR5XG4gIHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7fSAvLyBvbiBsYXlvdXRzdG9wXG59O1xuXG4vLyBjb25zdHJ1Y3RvclxuLy8gb3B0aW9ucyA6IG9iamVjdCBjb250YWluaW5nIGxheW91dCBvcHRpb25zXG5mdW5jdGlvbiBOdWxsTGF5b3V0KG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gdXRpbC5leHRlbmQoe30sIGRlZmF1bHRzLCBvcHRpb25zKTtcbn1cblxuLy8gcnVucyB0aGUgbGF5b3V0XG5OdWxsTGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlczsgLy8gZWxlbWVudHMgdG8gY29uc2lkZXIgaW4gdGhlIGxheW91dFxuICB2YXIgbGF5b3V0ID0gdGhpcztcblxuICAvLyBjeSBpcyBhdXRvbWF0aWNhbGx5IHBvcHVsYXRlZCBmb3IgdXMgaW4gdGhlIGNvbnN0cnVjdG9yXG4gIHZhciBjeSA9IG9wdGlvbnMuY3k7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuXG4gIGxheW91dC5lbWl0KCdsYXlvdXRzdGFydCcpO1xuXG4gIC8vIHB1dHMgYWxsIG5vZGVzIGF0ICgwLCAwKVxuICBlbGVzLm5vZGVzKCkucG9zaXRpb25zKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9O1xuICB9KTtcblxuICAvLyB0cmlnZ2VyIGxheW91dHJlYWR5IHdoZW4gZWFjaCBub2RlIGhhcyBoYWQgaXRzIHBvc2l0aW9uIHNldCBhdCBsZWFzdCBvbmNlXG4gIGxheW91dC5vbmUoJ2xheW91dHJlYWR5Jywgb3B0aW9ucy5yZWFkeSk7XG4gIGxheW91dC5lbWl0KCdsYXlvdXRyZWFkeScpO1xuXG4gIC8vIHRyaWdnZXIgbGF5b3V0c3RvcCB3aGVuIHRoZSBsYXlvdXQgc3RvcHMgKGUuZy4gZmluaXNoZXMpXG4gIGxheW91dC5vbmUoJ2xheW91dHN0b3AnLCBvcHRpb25zLnN0b3ApO1xuICBsYXlvdXQuZW1pdCgnbGF5b3V0c3RvcCcpO1xuXG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxuLy8gY2FsbGVkIG9uIGNvbnRpbnVvdXMgbGF5b3V0cyB0byBzdG9wIHRoZW0gYmVmb3JlIHRoZXkgZmluaXNoXG5OdWxsTGF5b3V0LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTnVsbExheW91dDtcblxuLyoqKi8gfSksXG4vKiAxMDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xudmFyIGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIGRlZmF1bHRzID0ge1xuICBwb3NpdGlvbnM6IHVuZGVmaW5lZCwgLy8gbWFwIG9mIChub2RlIGlkKSA9PiAocG9zaXRpb24gb2JqKTsgb3IgZnVuY3Rpb24obm9kZSl7IHJldHVybiBzb21Qb3M7IH1cbiAgem9vbTogdW5kZWZpbmVkLCAvLyB0aGUgem9vbSBsZXZlbCB0byBzZXQgKHByb2Igd2FudCBmaXQgPSBmYWxzZSBpZiBzZXQpXG4gIHBhbjogdW5kZWZpbmVkLCAvLyB0aGUgcGFuIGxldmVsIHRvIHNldCAocHJvYiB3YW50IGZpdCA9IGZhbHNlIGlmIHNldClcbiAgZml0OiB0cnVlLCAvLyB3aGV0aGVyIHRvIGZpdCB0byB2aWV3cG9ydFxuICBwYWRkaW5nOiAzMCwgLy8gcGFkZGluZyBvbiBmaXRcbiAgYW5pbWF0ZTogZmFsc2UsIC8vIHdoZXRoZXIgdG8gdHJhbnNpdGlvbiB0aGUgbm9kZSBwb3NpdGlvbnNcbiAgYW5pbWF0aW9uRHVyYXRpb246IDUwMCwgLy8gZHVyYXRpb24gb2YgYW5pbWF0aW9uIGluIG1zIGlmIGVuYWJsZWRcbiAgYW5pbWF0aW9uRWFzaW5nOiB1bmRlZmluZWQsIC8vIGVhc2luZyBvZiBhbmltYXRpb24gaWYgZW5hYmxlZFxuICBhbmltYXRlRmlsdGVyOiBmdW5jdGlvbiBhbmltYXRlRmlsdGVyKG5vZGUsIGkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgLy8gYSBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgd2hldGhlciB0aGUgbm9kZSBzaG91bGQgYmUgYW5pbWF0ZWQuICBBbGwgbm9kZXMgYW5pbWF0ZWQgYnkgZGVmYXVsdCBvbiBhbmltYXRlIGVuYWJsZWQuICBOb24tYW5pbWF0ZWQgbm9kZXMgYXJlIHBvc2l0aW9uZWQgaW1tZWRpYXRlbHkgd2hlbiB0aGUgbGF5b3V0IHN0YXJ0c1xuICByZWFkeTogdW5kZWZpbmVkLCAvLyBjYWxsYmFjayBvbiBsYXlvdXRyZWFkeVxuICBzdG9wOiB1bmRlZmluZWQsIC8vIGNhbGxiYWNrIG9uIGxheW91dHN0b3BcbiAgdHJhbnNmb3JtOiBmdW5jdGlvbiB0cmFuc2Zvcm0obm9kZSwgcG9zaXRpb24pIHtcbiAgICByZXR1cm4gcG9zaXRpb247XG4gIH0gLy8gdHJhbnNmb3JtIGEgZ2l2ZW4gbm9kZSBwb3NpdGlvbi4gVXNlZnVsIGZvciBjaGFuZ2luZyBmbG93IGRpcmVjdGlvbiBpbiBkaXNjcmV0ZSBsYXlvdXRzIFxufTtcblxuZnVuY3Rpb24gUHJlc2V0TGF5b3V0KG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gdXRpbC5leHRlbmQoe30sIGRlZmF1bHRzLCBvcHRpb25zKTtcbn1cblxuUHJlc2V0TGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlcztcblxuICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCk7XG4gIHZhciBwb3NJc0ZuID0gaXMuZm4ob3B0aW9ucy5wb3NpdGlvbnMpO1xuXG4gIGZ1bmN0aW9uIGdldFBvc2l0aW9uKG5vZGUpIHtcbiAgICBpZiAob3B0aW9ucy5wb3NpdGlvbnMgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHBvc0lzRm4pIHtcbiAgICAgIHJldHVybiBvcHRpb25zLnBvc2l0aW9ucyhub2RlKTtcbiAgICB9XG5cbiAgICB2YXIgcG9zID0gb3B0aW9ucy5wb3NpdGlvbnNbbm9kZS5fcHJpdmF0ZS5kYXRhLmlkXTtcblxuICAgIGlmIChwb3MgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvcztcbiAgfVxuXG4gIG5vZGVzLmxheW91dFBvc2l0aW9ucyh0aGlzLCBvcHRpb25zLCBmdW5jdGlvbiAobm9kZSwgaSkge1xuICAgIHZhciBwb3NpdGlvbiA9IGdldFBvc2l0aW9uKG5vZGUpO1xuXG4gICAgaWYgKG5vZGUubG9ja2VkKCkgfHwgcG9zaXRpb24gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBwb3NpdGlvbjtcbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByZXNldExheW91dDtcblxuLyoqKi8gfSksXG4vKiAxMDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xudmFyIG1hdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgZGVmYXVsdHMgPSB7XG4gIGZpdDogdHJ1ZSwgLy8gd2hldGhlciB0byBmaXQgdG8gdmlld3BvcnRcbiAgcGFkZGluZzogMzAsIC8vIGZpdCBwYWRkaW5nXG4gIGJvdW5kaW5nQm94OiB1bmRlZmluZWQsIC8vIGNvbnN0cmFpbiBsYXlvdXQgYm91bmRzOyB7IHgxLCB5MSwgeDIsIHkyIH0gb3IgeyB4MSwgeTEsIHcsIGggfVxuICBhbmltYXRlOiBmYWxzZSwgLy8gd2hldGhlciB0byB0cmFuc2l0aW9uIHRoZSBub2RlIHBvc2l0aW9uc1xuICBhbmltYXRpb25EdXJhdGlvbjogNTAwLCAvLyBkdXJhdGlvbiBvZiBhbmltYXRpb24gaW4gbXMgaWYgZW5hYmxlZFxuICBhbmltYXRpb25FYXNpbmc6IHVuZGVmaW5lZCwgLy8gZWFzaW5nIG9mIGFuaW1hdGlvbiBpZiBlbmFibGVkXG4gIGFuaW1hdGVGaWx0ZXI6IGZ1bmN0aW9uIGFuaW1hdGVGaWx0ZXIobm9kZSwgaSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9LCAvLyBhIGZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBub2RlIHNob3VsZCBiZSBhbmltYXRlZC4gIEFsbCBub2RlcyBhbmltYXRlZCBieSBkZWZhdWx0IG9uIGFuaW1hdGUgZW5hYmxlZC4gIE5vbi1hbmltYXRlZCBub2RlcyBhcmUgcG9zaXRpb25lZCBpbW1lZGlhdGVseSB3aGVuIHRoZSBsYXlvdXQgc3RhcnRzXG4gIHJlYWR5OiB1bmRlZmluZWQsIC8vIGNhbGxiYWNrIG9uIGxheW91dHJlYWR5XG4gIHN0b3A6IHVuZGVmaW5lZCwgLy8gY2FsbGJhY2sgb24gbGF5b3V0c3RvcFxuICB0cmFuc2Zvcm06IGZ1bmN0aW9uIHRyYW5zZm9ybShub2RlLCBwb3NpdGlvbikge1xuICAgIHJldHVybiBwb3NpdGlvbjtcbiAgfSAvLyB0cmFuc2Zvcm0gYSBnaXZlbiBub2RlIHBvc2l0aW9uLiBVc2VmdWwgZm9yIGNoYW5naW5nIGZsb3cgZGlyZWN0aW9uIGluIGRpc2NyZXRlIGxheW91dHMgXG59O1xuXG5mdW5jdGlvbiBSYW5kb21MYXlvdXQob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7fSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xufVxuXG5SYW5kb21MYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gIHZhciBjeSA9IG9wdGlvbnMuY3k7XG4gIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCkubm90KCc6cGFyZW50Jyk7XG5cbiAgdmFyIGJiID0gbWF0aC5tYWtlQm91bmRpbmdCb3gob3B0aW9ucy5ib3VuZGluZ0JveCA/IG9wdGlvbnMuYm91bmRpbmdCb3ggOiB7XG4gICAgeDE6IDAsIHkxOiAwLCB3OiBjeS53aWR0aCgpLCBoOiBjeS5oZWlnaHQoKVxuICB9KTtcblxuICB2YXIgZ2V0UG9zID0gZnVuY3Rpb24gZ2V0UG9zKG5vZGUsIGkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogYmIueDEgKyBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiBiYi53KSxcbiAgICAgIHk6IGJiLnkxICsgTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogYmIuaClcbiAgICB9O1xuICB9O1xuXG4gIG5vZGVzLmxheW91dFBvc2l0aW9ucyh0aGlzLCBvcHRpb25zLCBnZXRQb3MpO1xuXG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSYW5kb21MYXlvdXQ7XG5cbi8qKiovIH0pLFxuLyogMTA1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gW3sgbmFtZTogJ251bGwnLCBpbXBsOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwNikgfSwgeyBuYW1lOiAnYmFzZScsIGltcGw6IF9fd2VicGFja19yZXF1aXJlX18oMTA3KSB9LCB7IG5hbWU6ICdjYW52YXMnLCBpbXBsOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyMykgfV07XG5cbi8qKiovIH0pLFxuLyogMTA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIE51bGxSZW5kZXJlcihvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIHRoaXMubm90aWZpY2F0aW9ucyA9IDA7IC8vIGZvciB0ZXN0aW5nXG59XG5cbnZhciBub29wID0gZnVuY3Rpb24gbm9vcCgpIHt9O1xuXG5OdWxsUmVuZGVyZXIucHJvdG90eXBlID0ge1xuICByZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGU6IG5vb3AsXG4gIG5vdGlmeTogZnVuY3Rpb24gbm90aWZ5KCkge1xuICAgIHRoaXMubm90aWZpY2F0aW9ucysrO1xuICB9LFxuICBpbml0OiBub29wXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE51bGxSZW5kZXJlcjtcblxuLyoqKi8gfSksXG4vKiAxMDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbnZhciB3aW5kb3cgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgQmFzZVJlbmRlcmVyID0gZnVuY3Rpb24gQmFzZVJlbmRlcmVyKG9wdGlvbnMpIHtcbiAgdGhpcy5pbml0KG9wdGlvbnMpO1xufTtcbnZhciBCUiA9IEJhc2VSZW5kZXJlcjtcbnZhciBCUnAgPSBCUi5wcm90b3R5cGU7XG5cbkJScC5jbGllbnRGdW5jdGlvbnMgPSBbJ3JlZHJhd0hpbnQnLCAncmVuZGVyJywgJ3JlbmRlclRvJywgJ21hdGNoQ2FudmFzU2l6ZScsICdub2RlU2hhcGVJbXBsJywgJ2Fycm93U2hhcGVJbXBsJ107XG5cbkJScC5pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIHIgPSB0aGlzO1xuXG4gIHIub3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgci5jeSA9IG9wdGlvbnMuY3k7XG5cbiAgdmFyIGN0ciA9IHIuY29udGFpbmVyID0gb3B0aW9ucy5jeS5jb250YWluZXIoKTtcblxuICAvLyBwcmVwZW5kIGEgc3R5bGVzaGVldCBpbiB0aGUgaGVhZCBzdWNoIHRoYXRcbiAgaWYgKHdpbmRvdykge1xuICAgIHZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcbiAgICB2YXIgaGVhZCA9IGRvY3VtZW50LmhlYWQ7XG4gICAgdmFyIHN0eWxlc2hlZXRJZCA9ICdfX19fX19fX19fY3l0b3NjYXBlX3N0eWxlc2hlZXQnO1xuICAgIHZhciBjbGFzc05hbWUgPSAnX19fX19fX19fX2N5dG9zY2FwZV9jb250YWluZXInO1xuICAgIHZhciBzdHlsZXNoZWV0QWxyZWFkeUV4aXN0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHN0eWxlc2hlZXRJZCkgIT0gbnVsbDtcblxuICAgIGlmIChjdHIuY2xhc3NOYW1lLmluZGV4T2YoY2xhc3NOYW1lKSA8IDApIHtcbiAgICAgIGN0ci5jbGFzc05hbWUgPSAoY3RyLmNsYXNzTmFtZSB8fCAnJykgKyAnICcgKyBjbGFzc05hbWU7XG4gICAgfVxuXG4gICAgaWYgKCFzdHlsZXNoZWV0QWxyZWFkeUV4aXN0cykge1xuICAgICAgdmFyIHN0eWxlc2hlZXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuXG4gICAgICBzdHlsZXNoZWV0LmlkID0gc3R5bGVzaGVldElkO1xuICAgICAgc3R5bGVzaGVldC5pbm5lckhUTUwgPSAnLicgKyBjbGFzc05hbWUgKyAnIHsgcG9zaXRpb246IHJlbGF0aXZlOyB9JztcblxuICAgICAgaGVhZC5pbnNlcnRCZWZvcmUoc3R5bGVzaGVldCwgaGVhZC5jaGlsZHJlblswXSk7IC8vIGZpcnN0IHNvIGxvd2VzdCBwcmlvcml0eVxuICAgIH1cblxuICAgIHZhciBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoY3RyKTtcbiAgICB2YXIgcG9zaXRpb24gPSBjb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ3Bvc2l0aW9uJyk7XG5cbiAgICBpZiAocG9zaXRpb24gPT09ICdzdGF0aWMnKSB7XG4gICAgICB1dGlsLmVycm9yKCdBIEN5dG9zY2FwZSBjb250YWluZXIgaGFzIHN0eWxlIHBvc2l0aW9uOnN0YXRpYyBhbmQgc28gY2FuIG5vdCB1c2UgVUkgZXh0ZW5zaW9ucyBwcm9wZXJseScpO1xuICAgIH1cbiAgfVxuXG4gIHIuc2VsZWN0aW9uID0gW3VuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgMF07IC8vIENvb3JkaW5hdGVzIGZvciBzZWxlY3Rpb24gYm94LCBwbHVzIGVuYWJsZWQgZmxhZ1xuXG4gIHIuYmV6aWVyUHJvalBjdHMgPSBbMC4wNSwgMC4yMjUsIDAuNCwgMC41LCAwLjYsIDAuNzc1LCAwLjk1XTtcblxuICAvLy0tUG9pbnRlci1yZWxhdGVkIGRhdGFcbiAgci5ob3ZlckRhdGEgPSB7IGRvd246IG51bGwsIGxhc3Q6IG51bGwsXG4gICAgZG93blRpbWU6IG51bGwsIHRyaWdnZXJNb2RlOiBudWxsLFxuICAgIGRyYWdnaW5nOiBmYWxzZSxcbiAgICBpbml0aWFsUGFuOiBbbnVsbCwgbnVsbF0sIGNhcHR1cmU6IGZhbHNlIH07XG5cbiAgci5kcmFnRGF0YSA9IHsgcG9zc2libGVEcmFnRWxlbWVudHM6IFtdIH07XG5cbiAgci50b3VjaERhdGEgPSB7XG4gICAgc3RhcnQ6IG51bGwsIGNhcHR1cmU6IGZhbHNlLFxuXG4gICAgLy8gVGhlc2UgMyBmaWVsZHMgcmVsYXRlZCB0byB0YXAsIHRhcGhvbGQgZXZlbnRzXG4gICAgc3RhcnRQb3NpdGlvbjogW251bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGxdLFxuICAgIHNpbmdsZVRvdWNoU3RhcnRUaW1lOiBudWxsLFxuICAgIHNpbmdsZVRvdWNoTW92ZWQ6IHRydWUsXG5cbiAgICBub3c6IFtudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsXSxcbiAgICBlYXJsaWVyOiBbbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbF1cbiAgfTtcblxuICByLnJlZHJhd3MgPSAwO1xuICByLnNob3dGcHMgPSBvcHRpb25zLnNob3dGcHM7XG4gIHIuZGVidWcgPSBvcHRpb25zLmRlYnVnO1xuXG4gIHIuaGlkZUVkZ2VzT25WaWV3cG9ydCA9IG9wdGlvbnMuaGlkZUVkZ2VzT25WaWV3cG9ydDtcbiAgci5oaWRlTGFiZWxzT25WaWV3cG9ydCA9IG9wdGlvbnMuaGlkZUxhYmVsc09uVmlld3BvcnQ7XG4gIHIudGV4dHVyZU9uVmlld3BvcnQgPSBvcHRpb25zLnRleHR1cmVPblZpZXdwb3J0O1xuICByLndoZWVsU2Vuc2l0aXZpdHkgPSBvcHRpb25zLndoZWVsU2Vuc2l0aXZpdHk7XG4gIHIubW90aW9uQmx1ckVuYWJsZWQgPSBvcHRpb25zLm1vdGlvbkJsdXI7IC8vIG9uIGJ5IGRlZmF1bHRcbiAgci5mb3JjZWRQaXhlbFJhdGlvID0gb3B0aW9ucy5waXhlbFJhdGlvO1xuICByLm1vdGlvbkJsdXIgPSBvcHRpb25zLm1vdGlvbkJsdXI7IC8vIGZvciBpbml0aWFsIGtpY2sgb2ZmXG4gIHIubW90aW9uQmx1ck9wYWNpdHkgPSBvcHRpb25zLm1vdGlvbkJsdXJPcGFjaXR5O1xuICByLm1vdGlvbkJsdXJUcmFuc3BhcmVuY3kgPSAxIC0gci5tb3Rpb25CbHVyT3BhY2l0eTtcbiAgci5tb3Rpb25CbHVyUHhSYXRpbyA9IDE7XG4gIHIubWJQeFJCbHVycnkgPSAxOyAvLzAuODtcbiAgci5taW5NYkxvd1F1YWxGcmFtZXMgPSA0O1xuICByLmZ1bGxRdWFsaXR5TWIgPSBmYWxzZTtcbiAgci5jbGVhcmVkRm9yTW90aW9uQmx1ciA9IFtdO1xuICByLmRlc2t0b3BUYXBUaHJlc2hvbGQgPSBvcHRpb25zLmRlc2t0b3BUYXBUaHJlc2hvbGQ7XG4gIHIuZGVza3RvcFRhcFRocmVzaG9sZDIgPSBvcHRpb25zLmRlc2t0b3BUYXBUaHJlc2hvbGQgKiBvcHRpb25zLmRlc2t0b3BUYXBUaHJlc2hvbGQ7XG4gIHIudG91Y2hUYXBUaHJlc2hvbGQgPSBvcHRpb25zLnRvdWNoVGFwVGhyZXNob2xkO1xuICByLnRvdWNoVGFwVGhyZXNob2xkMiA9IG9wdGlvbnMudG91Y2hUYXBUaHJlc2hvbGQgKiBvcHRpb25zLnRvdWNoVGFwVGhyZXNob2xkO1xuICByLnRhcGhvbGREdXJhdGlvbiA9IDUwMDtcblxuICByLmJpbmRpbmdzID0gW107XG4gIHIuYmVmb3JlUmVuZGVyQ2FsbGJhY2tzID0gW107XG4gIHIuYmVmb3JlUmVuZGVyUHJpb3JpdGllcyA9IHsgLy8gaGlnaGVyIHByaW9yaXR5IGV4ZWNzIGJlZm9yZSBsb3dlciBvbmVcbiAgICBhbmltYXRpb25zOiA0MDAsXG4gICAgZWxlQ2FsY3M6IDMwMCxcbiAgICBlbGVUeHJEZXE6IDIwMCxcbiAgICBseXJUeHJEZXE6IDEwMFxuICB9O1xuXG4gIHIucmVnaXN0ZXJOb2RlU2hhcGVzKCk7XG4gIHIucmVnaXN0ZXJBcnJvd1NoYXBlcygpO1xuICByLnJlZ2lzdGVyQ2FsY3VsYXRpb25MaXN0ZW5lcnMoKTtcbn07XG5cbkJScC5ub3RpZnkgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gIHZhciB0eXBlcztcbiAgdmFyIHIgPSB0aGlzO1xuXG4gIC8vIHRoZSByZW5kZXJlciBjYW4ndCBiZSBub3RpZmllZCBhZnRlciBpdCdzIGRlc3Ryb3llZFxuICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaXMuYXJyYXkocGFyYW1zLnR5cGUpKSB7XG4gICAgdHlwZXMgPSBwYXJhbXMudHlwZTtcbiAgfSBlbHNlIHtcbiAgICB0eXBlcyA9IFtwYXJhbXMudHlwZV07XG4gIH1cblxuICB2YXIgaGFzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVzW2ldO1xuXG4gICAgaGFzW3R5cGVdID0gdHJ1ZTtcbiAgfSAvLyBmb3JcblxuICBpZiAoaGFzWydpbml0J10pIHtcbiAgICByLmxvYWQoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaGFzWydkZXN0cm95J10pIHtcbiAgICByLmRlc3Ryb3koKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaGFzWydhZGQnXSB8fCBoYXNbJ3JlbW92ZSddIHx8IGhhc1snbG9hZCddIHx8IGhhc1snem9yZGVyJ10pIHtcbiAgICByLmludmFsaWRhdGVDYWNoZWRaU29ydGVkRWxlcygpO1xuICB9XG5cbiAgaWYgKGhhc1sndmlld3BvcnQnXSkge1xuICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gIH1cblxuICBpZiAoaGFzWydsb2FkJ10gfHwgaGFzWydyZXNpemUnXSkge1xuICAgIHIuaW52YWxpZGF0ZUNvbnRhaW5lckNsaWVudENvb3Jkc0NhY2hlKCk7XG4gICAgci5tYXRjaENhbnZhc1NpemUoci5jb250YWluZXIpO1xuICB9XG5cbiAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gIHIucmVkcmF3SGludCgnZHJhZycsIHRydWUpO1xuXG4gIHRoaXMuc3RhcnRSZW5kZXJMb29wKCk7XG5cbiAgdGhpcy5yZWRyYXcoKTtcbn07XG5cbkJScC5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgciA9IHRoaXM7XG5cbiAgci5kZXN0cm95ZWQgPSB0cnVlO1xuXG4gIHIuY3kuc3RvcEFuaW1hdGlvbkxvb3AoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHIuYmluZGluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYmluZGluZyA9IHIuYmluZGluZ3NbaV07XG4gICAgdmFyIGIgPSBiaW5kaW5nO1xuICAgIHZhciB0Z3QgPSBiLnRhcmdldDtcblxuICAgICh0Z3Qub2ZmIHx8IHRndC5yZW1vdmVFdmVudExpc3RlbmVyKS5hcHBseSh0Z3QsIGIuYXJncyk7XG4gIH1cblxuICByLmJpbmRpbmdzID0gW107XG4gIHIuYmVmb3JlUmVuZGVyQ2FsbGJhY2tzID0gW107XG4gIHIub25VcGRhdGVFbGVDYWxjc0ZucyA9IFtdO1xuXG4gIGlmIChyLnJlbW92ZU9ic2VydmVyKSB7XG4gICAgci5yZW1vdmVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gIH1cblxuICBpZiAoci5zdHlsZU9ic2VydmVyKSB7XG4gICAgci5zdHlsZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgfVxuXG4gIGlmIChyLmxhYmVsQ2FsY0Rpdikge1xuICAgIHRyeSB7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHIubGFiZWxDYWxjRGl2KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIGllMTAgaXNzdWUgIzEwMTRcbiAgICB9XG4gIH1cbn07XG5cbltfX3dlYnBhY2tfcmVxdWlyZV9fKDEwOCksIF9fd2VicGFja19yZXF1aXJlX18oMTA5KSwgX193ZWJwYWNrX3JlcXVpcmVfXygxMTkpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyMCksIF9fd2VicGFja19yZXF1aXJlX18oMTIxKSwgX193ZWJwYWNrX3JlcXVpcmVfXygxMjIpXS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wcykge1xuICB1dGlsLmV4dGVuZChCUnAsIHByb3BzKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJSO1xuXG4vKioqLyB9KSxcbi8qIDEwOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgbWF0aCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG52YXIgaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgQlJwID0ge307XG5cbkJScC5hcnJvd1NoYXBlV2lkdGggPSAwLjM7XG5cbkJScC5yZWdpc3RlckFycm93U2hhcGVzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYXJyb3dTaGFwZXMgPSB0aGlzLmFycm93U2hhcGVzID0ge307XG4gIHZhciByZW5kZXJlciA9IHRoaXM7XG5cbiAgLy8gQ29udHJhY3QgZm9yIGFycm93IHNoYXBlczpcbiAgLy8gMCwgMCBpcyBhcnJvdyB0aXBcbiAgLy8gKDAsIDEpIGlzIGRpcmVjdGlvbiB0b3dhcmRzIG5vZGVcbiAgLy8gKDEsIDApIGlzIHJpZ2h0XG4gIC8vXG4gIC8vIGZ1bmN0aW9uYWwgYXBpOlxuICAvLyBjb2xsaWRlOiBjaGVjayB4LCB5IGluIHNoYXBlXG4gIC8vIHJvdWdoQ29sbGlkZTogY2FsbGVkIGJlZm9yZSBjb2xsaWRlLCBubyBmYWxzZSBuZWdhdGl2ZXNcbiAgLy8gZHJhdzogZHJhd1xuICAvLyBzcGFjaW5nOiBkaXN0KGFycm93VGlwLCBub2RlQm91bmRhcnkpXG4gIC8vIGdhcDogZGlzdChlZGdlVGlwLCBub2RlQm91bmRhcnkpLCBlZGdlVGlwIG1heSAhPSBhcnJvd1RpcFxuXG4gIHZhciBiYkNvbGxpZGUgPSBmdW5jdGlvbiBiYkNvbGxpZGUoeCwgeSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uLCBlZGdlV2lkdGgsIHBhZGRpbmcpIHtcbiAgICB2YXIgeDEgPSB0cmFuc2xhdGlvbi54IC0gc2l6ZSAvIDIgLSBwYWRkaW5nO1xuICAgIHZhciB4MiA9IHRyYW5zbGF0aW9uLnggKyBzaXplIC8gMiArIHBhZGRpbmc7XG4gICAgdmFyIHkxID0gdHJhbnNsYXRpb24ueSAtIHNpemUgLyAyIC0gcGFkZGluZztcbiAgICB2YXIgeTIgPSB0cmFuc2xhdGlvbi55ICsgc2l6ZSAvIDIgKyBwYWRkaW5nO1xuXG4gICAgdmFyIGluc2lkZSA9IHgxIDw9IHggJiYgeCA8PSB4MiAmJiB5MSA8PSB5ICYmIHkgPD0geTI7XG5cbiAgICByZXR1cm4gaW5zaWRlO1xuICB9O1xuXG4gIHZhciB0cmFuc2Zvcm0gPSBmdW5jdGlvbiB0cmFuc2Zvcm0oeCwgeSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKSB7XG4gICAgdmFyIHhSb3RhdGVkID0geCAqIE1hdGguY29zKGFuZ2xlKSAtIHkgKiBNYXRoLnNpbihhbmdsZSk7XG4gICAgdmFyIHlSb3RhdGVkID0geCAqIE1hdGguc2luKGFuZ2xlKSArIHkgKiBNYXRoLmNvcyhhbmdsZSk7XG5cbiAgICB2YXIgeFNjYWxlZCA9IHhSb3RhdGVkICogc2l6ZTtcbiAgICB2YXIgeVNjYWxlZCA9IHlSb3RhdGVkICogc2l6ZTtcblxuICAgIHZhciB4VHJhbnNsYXRlZCA9IHhTY2FsZWQgKyB0cmFuc2xhdGlvbi54O1xuICAgIHZhciB5VHJhbnNsYXRlZCA9IHlTY2FsZWQgKyB0cmFuc2xhdGlvbi55O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHhUcmFuc2xhdGVkLFxuICAgICAgeTogeVRyYW5zbGF0ZWRcbiAgICB9O1xuICB9O1xuXG4gIHZhciB0cmFuc2Zvcm1Qb2ludHMgPSBmdW5jdGlvbiB0cmFuc2Zvcm1Qb2ludHMocHRzLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pIHtcbiAgICB2YXIgcmV0UHRzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHB0cy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgdmFyIHggPSBwdHNbaV07XG4gICAgICB2YXIgeSA9IHB0c1tpICsgMV07XG5cbiAgICAgIHJldFB0cy5wdXNoKHRyYW5zZm9ybSh4LCB5LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0UHRzO1xuICB9O1xuXG4gIHZhciBwb2ludHNUb0FyciA9IGZ1bmN0aW9uIHBvaW50c1RvQXJyKHB0cykge1xuICAgIHZhciByZXQgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcCA9IHB0c1tpXTtcblxuICAgICAgcmV0LnB1c2gocC54LCBwLnkpO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgdmFyIHN0YW5kYXJkR2FwID0gZnVuY3Rpb24gc3RhbmRhcmRHYXAoZWRnZSkge1xuICAgIHJldHVybiBlZGdlLnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlICogZWRnZS5wc3R5bGUoJ2Fycm93LXNjYWxlJykucGZWYWx1ZSAqIDI7XG4gIH07XG5cbiAgdmFyIGRlZmluZUFycm93U2hhcGUgPSBmdW5jdGlvbiBkZWZpbmVBcnJvd1NoYXBlKG5hbWUsIGRlZm4pIHtcbiAgICBpZiAoaXMuc3RyaW5nKGRlZm4pKSB7XG4gICAgICBkZWZuID0gYXJyb3dTaGFwZXNbZGVmbl07XG4gICAgfVxuXG4gICAgYXJyb3dTaGFwZXNbbmFtZV0gPSB1dGlsLmV4dGVuZCh7XG4gICAgICBuYW1lOiBuYW1lLFxuXG4gICAgICBwb2ludHM6IFstMC4xNSwgLTAuMywgMC4xNSwgLTAuMywgMC4xNSwgMC4zLCAtMC4xNSwgMC4zXSxcblxuICAgICAgY29sbGlkZTogZnVuY3Rpb24gY29sbGlkZSh4LCB5LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIHBhZGRpbmcpIHtcbiAgICAgICAgdmFyIHBvaW50cyA9IHBvaW50c1RvQXJyKHRyYW5zZm9ybVBvaW50cyh0aGlzLnBvaW50cywgc2l6ZSArIDIgKiBwYWRkaW5nLCBhbmdsZSwgdHJhbnNsYXRpb24pKTtcbiAgICAgICAgdmFyIGluc2lkZSA9IG1hdGgucG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKHgsIHksIHBvaW50cyk7XG5cbiAgICAgICAgcmV0dXJuIGluc2lkZTtcbiAgICAgIH0sXG5cbiAgICAgIHJvdWdoQ29sbGlkZTogYmJDb2xsaWRlLFxuXG4gICAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNvbnRleHQsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbikge1xuICAgICAgICB2YXIgcG9pbnRzID0gdHJhbnNmb3JtUG9pbnRzKHRoaXMucG9pbnRzLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pO1xuXG4gICAgICAgIHJlbmRlcmVyLmFycm93U2hhcGVJbXBsKCdwb2x5Z29uJykoY29udGV4dCwgcG9pbnRzKTtcbiAgICAgIH0sXG5cbiAgICAgIHNwYWNpbmc6IGZ1bmN0aW9uIHNwYWNpbmcoZWRnZSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0sXG5cbiAgICAgIGdhcDogc3RhbmRhcmRHYXBcbiAgICB9LCBkZWZuKTtcbiAgfTtcblxuICBkZWZpbmVBcnJvd1NoYXBlKCdub25lJywge1xuICAgIGNvbGxpZGU6IHV0aWwuZmFsc2lmeSxcblxuICAgIHJvdWdoQ29sbGlkZTogdXRpbC5mYWxzaWZ5LFxuXG4gICAgZHJhdzogdXRpbC5ub29wLFxuXG4gICAgc3BhY2luZzogdXRpbC56ZXJvaWZ5LFxuXG4gICAgZ2FwOiB1dGlsLnplcm9pZnlcbiAgfSk7XG5cbiAgZGVmaW5lQXJyb3dTaGFwZSgndHJpYW5nbGUnLCB7XG4gICAgcG9pbnRzOiBbLTAuMTUsIC0wLjMsIDAsIDAsIDAuMTUsIC0wLjNdXG4gIH0pO1xuXG4gIGRlZmluZUFycm93U2hhcGUoJ2Fycm93JywgJ3RyaWFuZ2xlJyk7XG5cbiAgZGVmaW5lQXJyb3dTaGFwZSgndHJpYW5nbGUtYmFja2N1cnZlJywge1xuICAgIHBvaW50czogYXJyb3dTaGFwZXNbJ3RyaWFuZ2xlJ10ucG9pbnRzLFxuXG4gICAgY29udHJvbFBvaW50OiBbMCwgLTAuMTVdLFxuXG4gICAgcm91Z2hDb2xsaWRlOiBiYkNvbGxpZGUsXG5cbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNvbnRleHQsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiwgZWRnZVdpZHRoKSB7XG4gICAgICB2YXIgcHRzVHJhbnMgPSB0cmFuc2Zvcm1Qb2ludHModGhpcy5wb2ludHMsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbik7XG4gICAgICB2YXIgY3RybFB0ID0gdGhpcy5jb250cm9sUG9pbnQ7XG4gICAgICB2YXIgY3RybFB0VHJhbnMgPSB0cmFuc2Zvcm0oY3RybFB0WzBdLCBjdHJsUHRbMV0sIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbik7XG5cbiAgICAgIHJlbmRlcmVyLmFycm93U2hhcGVJbXBsKHRoaXMubmFtZSkoY29udGV4dCwgcHRzVHJhbnMsIGN0cmxQdFRyYW5zKTtcbiAgICB9LFxuXG4gICAgZ2FwOiBmdW5jdGlvbiBnYXAoZWRnZSkge1xuICAgICAgcmV0dXJuIHN0YW5kYXJkR2FwKGVkZ2UpICogMC44O1xuICAgIH1cbiAgfSk7XG5cbiAgZGVmaW5lQXJyb3dTaGFwZSgndHJpYW5nbGUtdGVlJywge1xuICAgIHBvaW50czogWy0wLjE1LCAtMC4zLCAwLCAwLCAwLjE1LCAtMC4zLCAtMC4xNSwgLTAuM10sXG5cbiAgICBwb2ludHNUZWU6IFstMC4xNSwgLTAuNCwgLTAuMTUsIC0wLjUsIDAuMTUsIC0wLjUsIDAuMTUsIC0wLjRdLFxuXG4gICAgY29sbGlkZTogZnVuY3Rpb24gY29sbGlkZSh4LCB5LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIGVkZ2VXaWR0aCwgcGFkZGluZykge1xuICAgICAgdmFyIHRyaVB0cyA9IHBvaW50c1RvQXJyKHRyYW5zZm9ybVBvaW50cyh0aGlzLnBvaW50cywgc2l6ZSArIDIgKiBwYWRkaW5nLCBhbmdsZSwgdHJhbnNsYXRpb24pKTtcbiAgICAgIHZhciB0ZWVQdHMgPSBwb2ludHNUb0Fycih0cmFuc2Zvcm1Qb2ludHModGhpcy5wb2ludHNUZWUsIHNpemUgKyAyICogcGFkZGluZywgYW5nbGUsIHRyYW5zbGF0aW9uKSk7XG5cbiAgICAgIHZhciBpbnNpZGUgPSBtYXRoLnBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCB0cmlQdHMpIHx8IG1hdGgucG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKHgsIHksIHRlZVB0cyk7XG5cbiAgICAgIHJldHVybiBpbnNpZGU7XG4gICAgfSxcblxuICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY29udGV4dCwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uLCBlZGdlV2lkdGgpIHtcbiAgICAgIHZhciB0cmlQdHMgPSB0cmFuc2Zvcm1Qb2ludHModGhpcy5wb2ludHMsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbik7XG4gICAgICB2YXIgdGVlUHRzID0gdHJhbnNmb3JtUG9pbnRzKHRoaXMucG9pbnRzVGVlLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pO1xuXG4gICAgICByZW5kZXJlci5hcnJvd1NoYXBlSW1wbCh0aGlzLm5hbWUpKGNvbnRleHQsIHRyaVB0cywgdGVlUHRzKTtcbiAgICB9XG4gIH0pO1xuXG4gIGRlZmluZUFycm93U2hhcGUoJ3RyaWFuZ2xlLWNyb3NzJywge1xuICAgIHBvaW50czogWy0wLjE1LCAtMC4zLCAwLCAwLCAwLjE1LCAtMC4zLCAtMC4xNSwgLTAuM10sXG5cbiAgICBiYXNlQ3Jvc3NMaW5lUHRzOiBbLTAuMTUsIC0wLjQsIC8vIGZpcnN0IGhhbGYgb2YgdGhlIHJlY3RhbmdsZVxuICAgIC0wLjE1LCAtMC40LCAwLjE1LCAtMC40LCAvLyBzZWNvbmQgaGFsZiBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgMC4xNSwgLTAuNF0sXG5cbiAgICBjcm9zc0xpbmVQdHM6IGZ1bmN0aW9uIGNyb3NzTGluZVB0cyhzaXplLCBlZGdlV2lkdGgpIHtcbiAgICAgIC8vIHNoaWZ0IHBvaW50cyBzbyB0aGF0IHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBjcm9zcyBwb2ludHMgbWF0Y2hlcyBlZGdlIHdpZHRoXG4gICAgICB2YXIgcCA9IHRoaXMuYmFzZUNyb3NzTGluZVB0cy5zbGljZSgpO1xuICAgICAgdmFyIHNoaWZ0RmFjdG9yID0gZWRnZVdpZHRoIC8gc2l6ZTtcbiAgICAgIHZhciB5MCA9IDM7XG4gICAgICB2YXIgeTEgPSA1O1xuXG4gICAgICBwW3kwXSA9IHBbeTBdIC0gc2hpZnRGYWN0b3I7XG4gICAgICBwW3kxXSA9IHBbeTFdIC0gc2hpZnRGYWN0b3I7XG5cbiAgICAgIHJldHVybiBwO1xuICAgIH0sXG5cbiAgICBjb2xsaWRlOiBmdW5jdGlvbiBjb2xsaWRlKHgsIHksIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiwgZWRnZVdpZHRoLCBwYWRkaW5nKSB7XG4gICAgICB2YXIgdHJpUHRzID0gcG9pbnRzVG9BcnIodHJhbnNmb3JtUG9pbnRzKHRoaXMucG9pbnRzLCBzaXplICsgMiAqIHBhZGRpbmcsIGFuZ2xlLCB0cmFuc2xhdGlvbikpO1xuICAgICAgdmFyIHRlZVB0cyA9IHBvaW50c1RvQXJyKHRyYW5zZm9ybVBvaW50cyh0aGlzLmNyb3NzTGluZVB0cyhzaXplLCBlZGdlV2lkdGgpLCBzaXplICsgMiAqIHBhZGRpbmcsIGFuZ2xlLCB0cmFuc2xhdGlvbikpO1xuICAgICAgdmFyIGluc2lkZSA9IG1hdGgucG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKHgsIHksIHRyaVB0cykgfHwgbWF0aC5wb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgdGVlUHRzKTtcblxuICAgICAgcmV0dXJuIGluc2lkZTtcbiAgICB9LFxuXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjb250ZXh0LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIGVkZ2VXaWR0aCkge1xuICAgICAgdmFyIHRyaVB0cyA9IHRyYW5zZm9ybVBvaW50cyh0aGlzLnBvaW50cywgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKTtcbiAgICAgIHZhciBjcm9zc0xpbmVQdHMgPSB0cmFuc2Zvcm1Qb2ludHModGhpcy5jcm9zc0xpbmVQdHMoc2l6ZSwgZWRnZVdpZHRoKSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKTtcblxuICAgICAgcmVuZGVyZXIuYXJyb3dTaGFwZUltcGwodGhpcy5uYW1lKShjb250ZXh0LCB0cmlQdHMsIGNyb3NzTGluZVB0cyk7XG4gICAgfVxuICB9KTtcblxuICBkZWZpbmVBcnJvd1NoYXBlKCd2ZWUnLCB7XG4gICAgcG9pbnRzOiBbLTAuMTUsIC0wLjMsIDAsIDAsIDAuMTUsIC0wLjMsIDAsIC0wLjE1XSxcblxuICAgIGdhcDogZnVuY3Rpb24gZ2FwKGVkZ2UpIHtcbiAgICAgIHJldHVybiBzdGFuZGFyZEdhcChlZGdlKSAqIDAuNTI1O1xuICAgIH1cbiAgfSk7XG5cbiAgZGVmaW5lQXJyb3dTaGFwZSgnY2lyY2xlJywge1xuICAgIHJhZGl1czogMC4xNSxcblxuICAgIGNvbGxpZGU6IGZ1bmN0aW9uIGNvbGxpZGUoeCwgeSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uLCBlZGdlV2lkdGgsIHBhZGRpbmcpIHtcbiAgICAgIHZhciB0ID0gdHJhbnNsYXRpb247XG4gICAgICB2YXIgaW5zaWRlID0gTWF0aC5wb3codC54IC0geCwgMikgKyBNYXRoLnBvdyh0LnkgLSB5LCAyKSA8PSBNYXRoLnBvdygoc2l6ZSArIDIgKiBwYWRkaW5nKSAqIHRoaXMucmFkaXVzLCAyKTtcblxuICAgICAgcmV0dXJuIGluc2lkZTtcbiAgICB9LFxuXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjb250ZXh0LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIGVkZ2VXaWR0aCkge1xuICAgICAgcmVuZGVyZXIuYXJyb3dTaGFwZUltcGwodGhpcy5uYW1lKShjb250ZXh0LCB0cmFuc2xhdGlvbi54LCB0cmFuc2xhdGlvbi55LCB0aGlzLnJhZGl1cyAqIHNpemUpO1xuICAgIH0sXG5cbiAgICBzcGFjaW5nOiBmdW5jdGlvbiBzcGFjaW5nKGVkZ2UpIHtcbiAgICAgIHJldHVybiByZW5kZXJlci5nZXRBcnJvd1dpZHRoKGVkZ2UucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWUsIGVkZ2UucHN0eWxlKCdhcnJvdy1zY2FsZScpLnZhbHVlKSAqIHRoaXMucmFkaXVzO1xuICAgIH1cbiAgfSk7XG5cbiAgZGVmaW5lQXJyb3dTaGFwZSgndGVlJywge1xuICAgIHBvaW50czogWy0wLjE1LCAwLCAtMC4xNSwgLTAuMSwgMC4xNSwgLTAuMSwgMC4xNSwgMF0sXG5cbiAgICBzcGFjaW5nOiBmdW5jdGlvbiBzcGFjaW5nKGVkZ2UpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0sXG5cbiAgICBnYXA6IGZ1bmN0aW9uIGdhcChlZGdlKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gIH0pO1xuXG4gIGRlZmluZUFycm93U2hhcGUoJ3NxdWFyZScsIHtcbiAgICBwb2ludHM6IFstMC4xNSwgMC4wMCwgMC4xNSwgMC4wMCwgMC4xNSwgLTAuMywgLTAuMTUsIC0wLjNdXG4gIH0pO1xuXG4gIGRlZmluZUFycm93U2hhcGUoJ2RpYW1vbmQnLCB7XG4gICAgcG9pbnRzOiBbLTAuMTUsIC0wLjE1LCAwLCAtMC4zLCAwLjE1LCAtMC4xNSwgMCwgMF0sXG5cbiAgICBnYXA6IGZ1bmN0aW9uIGdhcChlZGdlKSB7XG4gICAgICByZXR1cm4gZWRnZS5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZSAqIGVkZ2UucHN0eWxlKCdhcnJvdy1zY2FsZScpLnZhbHVlO1xuICAgIH1cbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJScDtcblxuLyoqKi8gfSksXG4vKiAxMDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgQlJwID0ge307XG5cbltfX3dlYnBhY2tfcmVxdWlyZV9fKDExMCksIF9fd2VicGFja19yZXF1aXJlX18oMTExKSwgX193ZWJwYWNrX3JlcXVpcmVfXygxMTIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDExMyksIF9fd2VicGFja19yZXF1aXJlX18oMTE0KSwgX193ZWJwYWNrX3JlcXVpcmVfXygxMTUpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDExNiksIF9fd2VicGFja19yZXF1aXJlX18oMTE3KSwgX193ZWJwYWNrX3JlcXVpcmVfXygxMTgpXS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wcykge1xuICB1dGlsLmV4dGVuZChCUnAsIHByb3BzKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJScDtcblxuLyoqKi8gfSksXG4vKiAxMTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIHdpbmRvdyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG52YXIgbWF0aCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG52YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG52YXIgd2luZG93ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIEJScCA9IHt9O1xuXG4vLyBQcm9qZWN0IG1vdXNlXG5CUnAucHJvamVjdEludG9WaWV3cG9ydCA9IGZ1bmN0aW9uIChjbGllbnRYLCBjbGllbnRZKSB7XG4gIHZhciBjeSA9IHRoaXMuY3k7XG4gIHZhciBvZmZzZXRzID0gdGhpcy5maW5kQ29udGFpbmVyQ2xpZW50Q29vcmRzKCk7XG4gIHZhciBvZmZzZXRMZWZ0ID0gb2Zmc2V0c1swXTtcbiAgdmFyIG9mZnNldFRvcCA9IG9mZnNldHNbMV07XG4gIHZhciBzY2FsZSA9IG9mZnNldHNbNF07XG4gIHZhciBwYW4gPSBjeS5wYW4oKTtcbiAgdmFyIHpvb20gPSBjeS56b29tKCk7XG5cbiAgdmFyIHggPSAoKGNsaWVudFggLSBvZmZzZXRMZWZ0KSAvIHNjYWxlIC0gcGFuLngpIC8gem9vbTtcbiAgdmFyIHkgPSAoKGNsaWVudFkgLSBvZmZzZXRUb3ApIC8gc2NhbGUgLSBwYW4ueSkgLyB6b29tO1xuXG4gIHJldHVybiBbeCwgeV07XG59O1xuXG5CUnAuZmluZENvbnRhaW5lckNsaWVudENvb3JkcyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuY29udGFpbmVyQkIpIHtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXJCQjtcbiAgfVxuXG4gIHZhciBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgdmFyIHJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGNvbnRhaW5lcik7XG4gIHZhciBzdHlsZVZhbHVlID0gZnVuY3Rpb24gc3R5bGVWYWx1ZShuYW1lKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKSk7XG4gIH07XG5cbiAgdmFyIHBhZGRpbmcgPSB7XG4gICAgbGVmdDogc3R5bGVWYWx1ZSgncGFkZGluZy1sZWZ0JyksXG4gICAgcmlnaHQ6IHN0eWxlVmFsdWUoJ3BhZGRpbmctcmlnaHQnKSxcbiAgICB0b3A6IHN0eWxlVmFsdWUoJ3BhZGRpbmctdG9wJyksXG4gICAgYm90dG9tOiBzdHlsZVZhbHVlKCdwYWRkaW5nLWJvdHRvbScpXG4gIH07XG5cbiAgdmFyIGJvcmRlciA9IHtcbiAgICBsZWZ0OiBzdHlsZVZhbHVlKCdib3JkZXItbGVmdC13aWR0aCcpLFxuICAgIHJpZ2h0OiBzdHlsZVZhbHVlKCdib3JkZXItcmlnaHQtd2lkdGgnKSxcbiAgICB0b3A6IHN0eWxlVmFsdWUoJ2JvcmRlci10b3Atd2lkdGgnKSxcbiAgICBib3R0b206IHN0eWxlVmFsdWUoJ2JvcmRlci1ib3R0b20td2lkdGgnKVxuICB9O1xuXG4gIHZhciBjbGllbnRXaWR0aCA9IGNvbnRhaW5lci5jbGllbnRXaWR0aDtcbiAgdmFyIGNsaWVudEhlaWdodCA9IGNvbnRhaW5lci5jbGllbnRIZWlnaHQ7XG5cbiAgdmFyIHBhZGRpbmdIb3IgPSBwYWRkaW5nLmxlZnQgKyBwYWRkaW5nLnJpZ2h0O1xuICB2YXIgcGFkZGluZ1ZlciA9IHBhZGRpbmcudG9wICsgcGFkZGluZy5ib3R0b207XG5cbiAgdmFyIGJvcmRlckhvciA9IGJvcmRlci5sZWZ0ICsgYm9yZGVyLnJpZ2h0O1xuICB2YXIgYm9yZGVyVmVyID0gYm9yZGVyLnRvcCArIGJvcmRlci5ib3R0b207XG5cbiAgdmFyIHNjYWxlID0gcmVjdC53aWR0aCAvIChjbGllbnRXaWR0aCArIGJvcmRlckhvcik7XG5cbiAgdmFyIHVuc2NhbGVkVyA9IGNsaWVudFdpZHRoIC0gcGFkZGluZ0hvcjtcbiAgdmFyIHVuc2NhbGVkSCA9IGNsaWVudEhlaWdodCAtIHBhZGRpbmdWZXI7XG5cbiAgdmFyIHNjYWxlZFcgPSByZWN0LndpZHRoIC0gKHBhZGRpbmdIb3IgKyBib3JkZXJIb3IpICogc2NhbGU7XG4gIHZhciBzY2FsZWRIID0gcmVjdC5oZWlnaHQgLSAocGFkZGluZ1ZlciArIGJvcmRlclZlcikgKiBzY2FsZTtcblxuICB2YXIgbGVmdCA9IHJlY3QubGVmdCArIHBhZGRpbmcubGVmdCArIGJvcmRlci5sZWZ0O1xuICB2YXIgdG9wID0gcmVjdC50b3AgKyBwYWRkaW5nLnRvcCArIGJvcmRlci50b3A7XG5cbiAgcmV0dXJuIHRoaXMuY29udGFpbmVyQkIgPSBbbGVmdCwgdG9wLCB1bnNjYWxlZFcsIHVuc2NhbGVkSCwgc2NhbGVdO1xufTtcblxuQlJwLmludmFsaWRhdGVDb250YWluZXJDbGllbnRDb29yZHNDYWNoZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5jb250YWluZXJCQiA9IG51bGw7XG59O1xuXG5CUnAuZmluZE5lYXJlc3RFbGVtZW50ID0gZnVuY3Rpb24gKHgsIHksIGludGVyYWN0aXZlRWxlbWVudHNPbmx5LCBpc1RvdWNoKSB7XG4gIHJldHVybiB0aGlzLmZpbmROZWFyZXN0RWxlbWVudHMoeCwgeSwgaW50ZXJhY3RpdmVFbGVtZW50c09ubHksIGlzVG91Y2gpWzBdO1xufTtcblxuQlJwLmZpbmROZWFyZXN0RWxlbWVudHMgPSBmdW5jdGlvbiAoeCwgeSwgaW50ZXJhY3RpdmVFbGVtZW50c09ubHksIGlzVG91Y2gpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBlbGVzID0gci5nZXRDYWNoZWRaU29ydGVkRWxlcygpO1xuICB2YXIgbmVhciA9IFtdOyAvLyAxIG5vZGUgbWF4LCAxIGVkZ2UgbWF4XG4gIHZhciB6b29tID0gci5jeS56b29tKCk7XG4gIHZhciBoYXNDb21wb3VuZHMgPSByLmN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcbiAgdmFyIGVkZ2VUaHJlc2hvbGQgPSAoaXNUb3VjaCA/IDI0IDogOCkgLyB6b29tO1xuICB2YXIgbm9kZVRocmVzaG9sZCA9IChpc1RvdWNoID8gOCA6IDIpIC8gem9vbTtcbiAgdmFyIGxhYmVsVGhyZXNob2xkID0gKGlzVG91Y2ggPyA4IDogMikgLyB6b29tO1xuICB2YXIgbWluU3FEaXN0ID0gSW5maW5pdHk7XG4gIHZhciBuZWFyRWRnZTtcbiAgdmFyIG5lYXJOb2RlO1xuXG4gIGlmIChpbnRlcmFjdGl2ZUVsZW1lbnRzT25seSkge1xuICAgIGVsZXMgPSBlbGVzLmludGVyYWN0aXZlO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkRWxlKGVsZSwgc3FEaXN0KSB7XG4gICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgaWYgKG5lYXJOb2RlKSB7XG4gICAgICAgIHJldHVybjsgLy8gY2FuJ3QgcmVwbGFjZSBub2RlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZWFyTm9kZSA9IGVsZTtcbiAgICAgICAgbmVhci5wdXNoKGVsZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVsZS5pc0VkZ2UoKSAmJiAoc3FEaXN0ID09IG51bGwgfHwgc3FEaXN0IDwgbWluU3FEaXN0KSkge1xuICAgICAgaWYgKG5lYXJFZGdlKSB7XG4gICAgICAgIC8vIHRoZW4gcmVwbGFjZSBleGlzdGluZyBlZGdlXG4gICAgICAgIC8vIGNhbiByZXBsYWNlIG9ubHkgaWYgc2FtZSB6LWluZGV4XG4gICAgICAgIGlmIChuZWFyRWRnZS5wc3R5bGUoJ3otY29tcG91bmQtZGVwdGgnKS52YWx1ZSA9PT0gZWxlLnBzdHlsZSgnei1jb21wb3VuZC1kZXB0aCcpLnZhbHVlICYmIG5lYXJFZGdlLnBzdHlsZSgnei1jb21wb3VuZC1kZXB0aCcpLnZhbHVlID09PSBlbGUucHN0eWxlKCd6LWNvbXBvdW5kLWRlcHRoJykudmFsdWUpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5lYXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChuZWFyW2ldLmlzRWRnZSgpKSB7XG4gICAgICAgICAgICAgIG5lYXJbaV0gPSBlbGU7XG4gICAgICAgICAgICAgIG5lYXJFZGdlID0gZWxlO1xuICAgICAgICAgICAgICBtaW5TcURpc3QgPSBzcURpc3QgIT0gbnVsbCA/IHNxRGlzdCA6IG1pblNxRGlzdDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZWFyLnB1c2goZWxlKTtcbiAgICAgICAgbmVhckVkZ2UgPSBlbGU7XG4gICAgICAgIG1pblNxRGlzdCA9IHNxRGlzdCAhPSBudWxsID8gc3FEaXN0IDogbWluU3FEaXN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrTm9kZShub2RlKSB7XG4gICAgdmFyIHdpZHRoID0gbm9kZS5vdXRlcldpZHRoKCkgKyAyICogbm9kZVRocmVzaG9sZDtcbiAgICB2YXIgaGVpZ2h0ID0gbm9kZS5vdXRlckhlaWdodCgpICsgMiAqIG5vZGVUaHJlc2hvbGQ7XG4gICAgdmFyIGh3ID0gd2lkdGggLyAyO1xuICAgIHZhciBoaCA9IGhlaWdodCAvIDI7XG4gICAgdmFyIHBvcyA9IG5vZGUucG9zaXRpb24oKTtcblxuICAgIGlmIChwb3MueCAtIGh3IDw9IHggJiYgeCA8PSBwb3MueCArIGh3IC8vIGJiIGNoZWNrIHhcbiAgICAmJiBwb3MueSAtIGhoIDw9IHkgJiYgeSA8PSBwb3MueSArIGhoIC8vIGJiIGNoZWNrIHlcbiAgICApIHtcbiAgICAgICAgdmFyIHNoYXBlID0gci5ub2RlU2hhcGVzW3NlbGYuZ2V0Tm9kZVNoYXBlKG5vZGUpXTtcblxuICAgICAgICBpZiAoc2hhcGUuY2hlY2tQb2ludCh4LCB5LCAwLCB3aWR0aCwgaGVpZ2h0LCBwb3MueCwgcG9zLnkpKSB7XG4gICAgICAgICAgYWRkRWxlKG5vZGUsIDApO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0VkZ2UoZWRnZSkge1xuICAgIHZhciBfcCA9IGVkZ2UuX3ByaXZhdGU7XG5cbiAgICB2YXIgcnMgPSBfcC5yc2NyYXRjaDtcbiAgICB2YXIgc3R5bGVXaWR0aCA9IGVkZ2UucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWU7XG4gICAgdmFyIHNjYWxlID0gZWRnZS5wc3R5bGUoJ2Fycm93LXNjYWxlJykudmFsdWU7XG4gICAgdmFyIHdpZHRoID0gc3R5bGVXaWR0aCAvIDIgKyBlZGdlVGhyZXNob2xkOyAvLyBtb3JlIGxpa2UgYSBkaXN0YW5jZSByYWRpdXMgZnJvbSBjZW50cmVcbiAgICB2YXIgd2lkdGhTcSA9IHdpZHRoICogd2lkdGg7XG4gICAgdmFyIHdpZHRoMiA9IHdpZHRoICogMjtcbiAgICB2YXIgc3JjID0gX3Auc291cmNlO1xuICAgIHZhciB0Z3QgPSBfcC50YXJnZXQ7XG4gICAgdmFyIGluRWRnZUJCID0gZmFsc2U7XG4gICAgdmFyIHNxRGlzdDtcblxuICAgIGlmIChycy5lZGdlVHlwZSA9PT0gJ3NlZ21lbnRzJyB8fCBycy5lZGdlVHlwZSA9PT0gJ3N0cmFpZ2h0JyB8fCBycy5lZGdlVHlwZSA9PT0gJ2hheXN0YWNrJykge1xuICAgICAgdmFyIHB0cyA9IHJzLmFsbHB0cztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgKyAzIDwgcHRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIGlmICgoaW5FZGdlQkIgPSBtYXRoLmluTGluZVZpY2luaXR5KHgsIHksIHB0c1tpXSwgcHRzW2kgKyAxXSwgcHRzW2kgKyAyXSwgcHRzW2kgKyAzXSwgd2lkdGgyKSkgJiYgd2lkdGhTcSA+IChzcURpc3QgPSBtYXRoLnNxZGlzdFRvRmluaXRlTGluZSh4LCB5LCBwdHNbaV0sIHB0c1tpICsgMV0sIHB0c1tpICsgMl0sIHB0c1tpICsgM10pKSkge1xuICAgICAgICAgIGFkZEVsZShlZGdlLCBzcURpc3QpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChycy5lZGdlVHlwZSA9PT0gJ2JlemllcicgfHwgcnMuZWRnZVR5cGUgPT09ICdtdWx0aWJlemllcicgfHwgcnMuZWRnZVR5cGUgPT09ICdzZWxmJyB8fCBycy5lZGdlVHlwZSA9PT0gJ2NvbXBvdW5kJykge1xuICAgICAgdmFyIHB0cyA9IHJzLmFsbHB0cztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpICsgNSA8IHJzLmFsbHB0cy5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgICBpZiAoKGluRWRnZUJCID0gbWF0aC5pbkJlemllclZpY2luaXR5KHgsIHksIHB0c1tpXSwgcHRzW2kgKyAxXSwgcHRzW2kgKyAyXSwgcHRzW2kgKyAzXSwgcHRzW2kgKyA0XSwgcHRzW2kgKyA1XSwgd2lkdGgyKSkgJiYgd2lkdGhTcSA+IChzcURpc3QgPSBtYXRoLnNxZGlzdFRvUXVhZHJhdGljQmV6aWVyKHgsIHksIHB0c1tpXSwgcHRzW2kgKyAxXSwgcHRzW2kgKyAyXSwgcHRzW2kgKyAzXSwgcHRzW2kgKyA0XSwgcHRzW2kgKyA1XSkpKSB7XG4gICAgICAgICAgYWRkRWxlKGVkZ2UsIHNxRGlzdCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiB3ZSdyZSBjbG9zZSB0byB0aGUgZWRnZSBidXQgZGlkbid0IGhpdCBpdCwgbWF5YmUgd2UgaGl0IGl0cyBhcnJvd3NcblxuICAgIHZhciBzcmMgPSBzcmMgfHwgX3Auc291cmNlO1xuICAgIHZhciB0Z3QgPSB0Z3QgfHwgX3AudGFyZ2V0O1xuXG4gICAgdmFyIGFyU2l6ZSA9IHNlbGYuZ2V0QXJyb3dXaWR0aChzdHlsZVdpZHRoLCBzY2FsZSk7XG5cbiAgICB2YXIgYXJyb3dzID0gW3sgbmFtZTogJ3NvdXJjZScsIHg6IHJzLmFycm93U3RhcnRYLCB5OiBycy5hcnJvd1N0YXJ0WSwgYW5nbGU6IHJzLnNyY0Fycm93QW5nbGUgfSwgeyBuYW1lOiAndGFyZ2V0JywgeDogcnMuYXJyb3dFbmRYLCB5OiBycy5hcnJvd0VuZFksIGFuZ2xlOiBycy50Z3RBcnJvd0FuZ2xlIH0sIHsgbmFtZTogJ21pZC1zb3VyY2UnLCB4OiBycy5taWRYLCB5OiBycy5taWRZLCBhbmdsZTogcnMubWlkc3JjQXJyb3dBbmdsZSB9LCB7IG5hbWU6ICdtaWQtdGFyZ2V0JywgeDogcnMubWlkWCwgeTogcnMubWlkWSwgYW5nbGU6IHJzLm1pZHRndEFycm93QW5nbGUgfV07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycm93cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGFyID0gYXJyb3dzW2ldO1xuICAgICAgdmFyIHNoYXBlID0gci5hcnJvd1NoYXBlc1tlZGdlLnBzdHlsZShhci5uYW1lICsgJy1hcnJvdy1zaGFwZScpLnZhbHVlXTtcbiAgICAgIHZhciBlZGdlV2lkdGggPSBlZGdlLnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlO1xuICAgICAgaWYgKHNoYXBlLnJvdWdoQ29sbGlkZSh4LCB5LCBhclNpemUsIGFyLmFuZ2xlLCB7IHg6IGFyLngsIHk6IGFyLnkgfSwgZWRnZVdpZHRoLCBlZGdlVGhyZXNob2xkKSAmJiBzaGFwZS5jb2xsaWRlKHgsIHksIGFyU2l6ZSwgYXIuYW5nbGUsIHsgeDogYXIueCwgeTogYXIueSB9LCBlZGdlV2lkdGgsIGVkZ2VUaHJlc2hvbGQpKSB7XG4gICAgICAgIGFkZEVsZShlZGdlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZm9yIGNvbXBvdW5kIGdyYXBocywgaGl0dGluZyBlZGdlIG1heSBhY3R1YWxseSB3YW50IGEgY29ubmVjdGVkIG5vZGUgaW5zdGVhZCAoYi9jIGVkZ2UgbWF5IGhhdmUgZ3JlYXRlciB6LWluZGV4IHByZWNlZGVuY2UpXG4gICAgaWYgKGhhc0NvbXBvdW5kcyAmJiBuZWFyLmxlbmd0aCA+IDApIHtcbiAgICAgIGNoZWNrTm9kZShzcmMpO1xuICAgICAgY2hlY2tOb2RlKHRndCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcHJlcHJvcChvYmosIG5hbWUsIHByZSkge1xuICAgIHJldHVybiB1dGlsLmdldFByZWZpeGVkUHJvcGVydHkob2JqLCBuYW1lLCBwcmUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tMYWJlbChlbGUsIHByZWZpeCkge1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICB2YXIgdGggPSBsYWJlbFRocmVzaG9sZDtcblxuICAgIHZhciBwcmVmaXhEYXNoO1xuICAgIGlmIChwcmVmaXgpIHtcbiAgICAgIHByZWZpeERhc2ggPSBwcmVmaXggKyAnLSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByZWZpeERhc2ggPSAnJztcbiAgICB9XG5cbiAgICB2YXIgdGV4dCA9IGVsZS5wc3R5bGUocHJlZml4RGFzaCArICdsYWJlbCcpLnZhbHVlO1xuICAgIHZhciBldmVudHNFbmFibGVkID0gZWxlLnBzdHlsZSgndGV4dC1ldmVudHMnKS5zdHJWYWx1ZSA9PT0gJ3llcyc7XG5cbiAgICBpZiAoIWV2ZW50c0VuYWJsZWQgfHwgIXRleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcnN0eWxlID0gX3AucnN0eWxlO1xuICAgIHZhciBidyA9IGVsZS5wc3R5bGUoJ3RleHQtYm9yZGVyLXdpZHRoJykucGZWYWx1ZTtcbiAgICB2YXIgcHcgPSBlbGUucHN0eWxlKCd0ZXh0LWJhY2tncm91bmQtcGFkZGluZycpLnBmVmFsdWU7XG4gICAgdmFyIGx3ID0gcHJlcHJvcChyc3R5bGUsICdsYWJlbFdpZHRoJywgcHJlZml4KSArIGJ3ICsgMiAqIHRoICsgMiAqIHB3O1xuICAgIHZhciBsaCA9IHByZXByb3AocnN0eWxlLCAnbGFiZWxIZWlnaHQnLCBwcmVmaXgpICsgYncgKyAyICogdGggKyAyICogcHc7XG4gICAgdmFyIGx4ID0gcHJlcHJvcChyc3R5bGUsICdsYWJlbFgnLCBwcmVmaXgpO1xuICAgIHZhciBseSA9IHByZXByb3AocnN0eWxlLCAnbGFiZWxZJywgcHJlZml4KTtcblxuICAgIHZhciB0aGV0YSA9IHByZXByb3AoX3AucnNjcmF0Y2gsICdsYWJlbEFuZ2xlJywgcHJlZml4KTtcblxuICAgIHZhciBseDEgPSBseCAtIGx3IC8gMjtcbiAgICB2YXIgbHgyID0gbHggKyBsdyAvIDI7XG4gICAgdmFyIGx5MSA9IGx5IC0gbGggLyAyO1xuICAgIHZhciBseTIgPSBseSArIGxoIC8gMjtcblxuICAgIGlmICh0aGV0YSkge1xuICAgICAgdmFyIGNvcyA9IE1hdGguY29zKHRoZXRhKTtcbiAgICAgIHZhciBzaW4gPSBNYXRoLnNpbih0aGV0YSk7XG5cbiAgICAgIHZhciByb3RhdGUgPSBmdW5jdGlvbiByb3RhdGUoeCwgeSkge1xuICAgICAgICB4ID0geCAtIGx4O1xuICAgICAgICB5ID0geSAtIGx5O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogeCAqIGNvcyAtIHkgKiBzaW4gKyBseCxcbiAgICAgICAgICB5OiB4ICogc2luICsgeSAqIGNvcyArIGx5XG4gICAgICAgIH07XG4gICAgICB9O1xuXG4gICAgICB2YXIgcHgxeTEgPSByb3RhdGUobHgxLCBseTEpO1xuICAgICAgdmFyIHB4MXkyID0gcm90YXRlKGx4MSwgbHkyKTtcbiAgICAgIHZhciBweDJ5MSA9IHJvdGF0ZShseDIsIGx5MSk7XG4gICAgICB2YXIgcHgyeTIgPSByb3RhdGUobHgyLCBseTIpO1xuXG4gICAgICB2YXIgcG9pbnRzID0gW3B4MXkxLngsIHB4MXkxLnksIHB4MnkxLngsIHB4MnkxLnksIHB4MnkyLngsIHB4MnkyLnksIHB4MXkyLngsIHB4MXkyLnldO1xuXG4gICAgICBpZiAobWF0aC5wb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgcG9pbnRzKSkge1xuICAgICAgICBhZGRFbGUoZWxlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGRvIGEgY2hlYXBlciBiYiBjaGVja1xuICAgICAgdmFyIGJiID0ge1xuICAgICAgICB3OiBsdyxcbiAgICAgICAgaDogbGgsXG4gICAgICAgIHgxOiBseDEsXG4gICAgICAgIHgyOiBseDIsXG4gICAgICAgIHkxOiBseTEsXG4gICAgICAgIHkyOiBseTJcbiAgICAgIH07XG5cbiAgICAgIGlmIChtYXRoLmluQm91bmRpbmdCb3goYmIsIHgsIHkpKSB7XG4gICAgICAgIGFkZEVsZShlbGUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gZWxlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIC8vIHJldmVyc2Ugb3JkZXIgZm9yIHByZWNlZGVuY2VcbiAgICB2YXIgZWxlID0gZWxlc1tpXTtcblxuICAgIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICAgIGNoZWNrTm9kZShlbGUpIHx8IGNoZWNrTGFiZWwoZWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdGhlbiBlZGdlXG4gICAgICBjaGVja0VkZ2UoZWxlKSB8fCBjaGVja0xhYmVsKGVsZSkgfHwgY2hlY2tMYWJlbChlbGUsICdzb3VyY2UnKSB8fCBjaGVja0xhYmVsKGVsZSwgJ3RhcmdldCcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZWFyO1xufTtcblxuLy8gJ0dpdmUgbWUgZXZlcnl0aGluZyBmcm9tIHRoaXMgYm94J1xuQlJwLmdldEFsbEluQm94ID0gZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKSB7XG4gIHZhciBlbGVzID0gdGhpcy5nZXRDYWNoZWRaU29ydGVkRWxlcygpLmludGVyYWN0aXZlO1xuICB2YXIgYm94ID0gW107XG5cbiAgdmFyIHgxYyA9IE1hdGgubWluKHgxLCB4Mik7XG4gIHZhciB4MmMgPSBNYXRoLm1heCh4MSwgeDIpO1xuICB2YXIgeTFjID0gTWF0aC5taW4oeTEsIHkyKTtcbiAgdmFyIHkyYyA9IE1hdGgubWF4KHkxLCB5Mik7XG5cbiAgeDEgPSB4MWM7XG4gIHgyID0geDJjO1xuICB5MSA9IHkxYztcbiAgeTIgPSB5MmM7XG5cbiAgdmFyIGJveEJiID0gbWF0aC5tYWtlQm91bmRpbmdCb3goe1xuICAgIHgxOiB4MSwgeTE6IHkxLFxuICAgIHgyOiB4MiwgeTI6IHkyXG4gIH0pO1xuXG4gIGZvciAodmFyIGUgPSAwOyBlIDwgZWxlcy5sZW5ndGg7IGUrKykge1xuICAgIHZhciBlbGUgPSBlbGVzW2VdO1xuXG4gICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgdmFyIG5vZGUgPSBlbGU7XG4gICAgICB2YXIgbm9kZUJiID0gbm9kZS5ib3VuZGluZ0JveCh7XG4gICAgICAgIGluY2x1ZGVOb2RlczogdHJ1ZSxcbiAgICAgICAgaW5jbHVkZUVkZ2VzOiBmYWxzZSxcbiAgICAgICAgaW5jbHVkZUxhYmVsczogZmFsc2VcbiAgICAgIH0pO1xuXG4gICAgICBpZiAobWF0aC5ib3VuZGluZ0JveGVzSW50ZXJzZWN0KGJveEJiLCBub2RlQmIpICYmICFtYXRoLmJvdW5kaW5nQm94SW5Cb3VuZGluZ0JveChub2RlQmIsIGJveEJiKSkge1xuICAgICAgICBib3gucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVkZ2UgPSBlbGU7XG4gICAgICB2YXIgX3AgPSBlZGdlLl9wcml2YXRlO1xuICAgICAgdmFyIHJzID0gX3AucnNjcmF0Y2g7XG5cbiAgICAgIGlmIChycy5zdGFydFggIT0gbnVsbCAmJiBycy5zdGFydFkgIT0gbnVsbCAmJiAhbWF0aC5pbkJvdW5kaW5nQm94KGJveEJiLCBycy5zdGFydFgsIHJzLnN0YXJ0WSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocnMuZW5kWCAhPSBudWxsICYmIHJzLmVuZFkgIT0gbnVsbCAmJiAhbWF0aC5pbkJvdW5kaW5nQm94KGJveEJiLCBycy5lbmRYLCBycy5lbmRZKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJzLmVkZ2VUeXBlID09PSAnYmV6aWVyJyB8fCBycy5lZGdlVHlwZSA9PT0gJ211bHRpYmV6aWVyJyB8fCBycy5lZGdlVHlwZSA9PT0gJ3NlbGYnIHx8IHJzLmVkZ2VUeXBlID09PSAnY29tcG91bmQnIHx8IHJzLmVkZ2VUeXBlID09PSAnc2VnbWVudHMnIHx8IHJzLmVkZ2VUeXBlID09PSAnaGF5c3RhY2snKSB7XG5cbiAgICAgICAgdmFyIHB0cyA9IF9wLnJzdHlsZS5iZXppZXJQdHMgfHwgX3AucnN0eWxlLmxpbmVQdHMgfHwgX3AucnN0eWxlLmhheXN0YWNrUHRzO1xuICAgICAgICB2YXIgYWxsSW5zaWRlID0gdHJ1ZTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHB0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICghbWF0aC5wb2ludEluQm91bmRpbmdCb3goYm94QmIsIHB0c1tpXSkpIHtcbiAgICAgICAgICAgIGFsbEluc2lkZSA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFsbEluc2lkZSkge1xuICAgICAgICAgIGJveC5wdXNoKGVkZ2UpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHJzLmVkZ2VUeXBlID09PSAnaGF5c3RhY2snIHx8IHJzLmVkZ2VUeXBlID09PSAnc3RyYWlnaHQnKSB7XG4gICAgICAgIGJveC5wdXNoKGVkZ2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBib3g7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJScDtcblxuLyoqKi8gfSksXG4vKiAxMTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIG1hdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgQlJwID0ge307XG5cbkJScC5jYWxjdWxhdGVBcnJvd0FuZ2xlcyA9IGZ1bmN0aW9uIChlZGdlKSB7XG4gIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHZhciBpc0hheXN0YWNrID0gcnMuZWRnZVR5cGUgPT09ICdoYXlzdGFjayc7XG4gIHZhciBpc0JlemllciA9IHJzLmVkZ2VUeXBlID09PSAnYmV6aWVyJztcbiAgdmFyIGlzTXVsdGliZXppZXIgPSBycy5lZGdlVHlwZSA9PT0gJ211bHRpYmV6aWVyJztcbiAgdmFyIGlzU2VnbWVudHMgPSBycy5lZGdlVHlwZSA9PT0gJ3NlZ21lbnRzJztcbiAgdmFyIGlzQ29tcG91bmQgPSBycy5lZGdlVHlwZSA9PT0gJ2NvbXBvdW5kJztcbiAgdmFyIGlzU2VsZiA9IHJzLmVkZ2VUeXBlID09PSAnc2VsZic7XG5cbiAgLy8gRGlzcGxhY2VtZW50IGdpdmVzIGRpcmVjdGlvbiBmb3IgYXJyb3doZWFkIG9yaWVudGF0aW9uXG4gIHZhciBkaXNwWCwgZGlzcFk7XG4gIHZhciBzdGFydFgsIHN0YXJ0WSwgZW5kWCwgZW5kWSwgbWlkWCwgbWlkWTtcblxuICBpZiAoaXNIYXlzdGFjaykge1xuICAgIHN0YXJ0WCA9IHJzLmhheXN0YWNrUHRzWzBdO1xuICAgIHN0YXJ0WSA9IHJzLmhheXN0YWNrUHRzWzFdO1xuICAgIGVuZFggPSBycy5oYXlzdGFja1B0c1syXTtcbiAgICBlbmRZID0gcnMuaGF5c3RhY2tQdHNbM107XG4gIH0gZWxzZSB7XG4gICAgc3RhcnRYID0gcnMuYXJyb3dTdGFydFg7XG4gICAgc3RhcnRZID0gcnMuYXJyb3dTdGFydFk7XG4gICAgZW5kWCA9IHJzLmFycm93RW5kWDtcbiAgICBlbmRZID0gcnMuYXJyb3dFbmRZO1xuICB9XG5cbiAgbWlkWCA9IHJzLm1pZFg7XG4gIG1pZFkgPSBycy5taWRZO1xuXG4gIC8vIHNvdXJjZVxuICAvL1xuXG4gIGlmIChpc1NlZ21lbnRzKSB7XG4gICAgZGlzcFggPSBzdGFydFggLSBycy5zZWdwdHNbMF07XG4gICAgZGlzcFkgPSBzdGFydFkgLSBycy5zZWdwdHNbMV07XG4gIH0gZWxzZSBpZiAoaXNNdWx0aWJlemllciB8fCBpc0NvbXBvdW5kIHx8IGlzU2VsZiB8fCBpc0Jlemllcikge1xuICAgIHZhciBwdHMgPSBycy5hbGxwdHM7XG4gICAgdmFyIGJYID0gbWF0aC5xYmV6aWVyQXQocHRzWzBdLCBwdHNbMl0sIHB0c1s0XSwgMC4xKTtcbiAgICB2YXIgYlkgPSBtYXRoLnFiZXppZXJBdChwdHNbMV0sIHB0c1szXSwgcHRzWzVdLCAwLjEpO1xuXG4gICAgZGlzcFggPSBzdGFydFggLSBiWDtcbiAgICBkaXNwWSA9IHN0YXJ0WSAtIGJZO1xuICB9IGVsc2Uge1xuICAgIGRpc3BYID0gc3RhcnRYIC0gbWlkWDtcbiAgICBkaXNwWSA9IHN0YXJ0WSAtIG1pZFk7XG4gIH1cblxuICBycy5zcmNBcnJvd0FuZ2xlID0gbWF0aC5nZXRBbmdsZUZyb21EaXNwKGRpc3BYLCBkaXNwWSk7XG5cbiAgLy8gbWlkIHRhcmdldFxuICAvL1xuXG4gIHZhciBtaWRYID0gcnMubWlkWDtcbiAgdmFyIG1pZFkgPSBycy5taWRZO1xuXG4gIGlmIChpc0hheXN0YWNrKSB7XG4gICAgbWlkWCA9IChzdGFydFggKyBlbmRYKSAvIDI7XG4gICAgbWlkWSA9IChzdGFydFkgKyBlbmRZKSAvIDI7XG4gIH1cblxuICBkaXNwWCA9IGVuZFggLSBzdGFydFg7XG4gIGRpc3BZID0gZW5kWSAtIHN0YXJ0WTtcblxuICBpZiAoaXNTZWdtZW50cykge1xuICAgIHZhciBwdHMgPSBycy5hbGxwdHM7XG5cbiAgICBpZiAocHRzLmxlbmd0aCAvIDIgJSAyID09PSAwKSB7XG4gICAgICB2YXIgaTIgPSBwdHMubGVuZ3RoIC8gMjtcbiAgICAgIHZhciBpMSA9IGkyIC0gMjtcblxuICAgICAgZGlzcFggPSBwdHNbaTJdIC0gcHRzW2kxXTtcbiAgICAgIGRpc3BZID0gcHRzW2kyICsgMV0gLSBwdHNbaTEgKyAxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGkyID0gcHRzLmxlbmd0aCAvIDIgLSAxO1xuICAgICAgdmFyIGkxID0gaTIgLSAyO1xuICAgICAgdmFyIGkzID0gaTIgKyAyO1xuXG4gICAgICBkaXNwWCA9IHB0c1tpMl0gLSBwdHNbaTFdO1xuICAgICAgZGlzcFkgPSBwdHNbaTIgKyAxXSAtIHB0c1tpMSArIDFdO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc011bHRpYmV6aWVyIHx8IGlzQ29tcG91bmQgfHwgaXNTZWxmKSB7XG4gICAgdmFyIHB0cyA9IHJzLmFsbHB0cztcbiAgICB2YXIgY3B0cyA9IHJzLmN0cmxwdHM7XG4gICAgdmFyIGJwMHgsIGJwMHk7XG4gICAgdmFyIGJwMXgsIGJwMXk7XG5cbiAgICBpZiAoY3B0cy5sZW5ndGggLyAyICUgMiA9PT0gMCkge1xuICAgICAgdmFyIHAwID0gcHRzLmxlbmd0aCAvIDIgLSAxOyAvLyBzdGFydHB0XG4gICAgICB2YXIgaWMgPSBwMCArIDI7XG4gICAgICB2YXIgcDEgPSBpYyArIDI7XG5cbiAgICAgIGJwMHggPSBtYXRoLnFiZXppZXJBdChwdHNbcDBdLCBwdHNbaWNdLCBwdHNbcDFdLCAwLjApO1xuICAgICAgYnAweSA9IG1hdGgucWJlemllckF0KHB0c1twMCArIDFdLCBwdHNbaWMgKyAxXSwgcHRzW3AxICsgMV0sIDAuMCk7XG5cbiAgICAgIGJwMXggPSBtYXRoLnFiZXppZXJBdChwdHNbcDBdLCBwdHNbaWNdLCBwdHNbcDFdLCAwLjAwMDEpO1xuICAgICAgYnAxeSA9IG1hdGgucWJlemllckF0KHB0c1twMCArIDFdLCBwdHNbaWMgKyAxXSwgcHRzW3AxICsgMV0sIDAuMDAwMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpYyA9IHB0cy5sZW5ndGggLyAyIC0gMTsgLy8gY3RycHRcbiAgICAgIHZhciBwMCA9IGljIC0gMjsgLy8gc3RhcnRwdFxuICAgICAgdmFyIHAxID0gaWMgKyAyOyAvLyBlbmRwdFxuXG4gICAgICBicDB4ID0gbWF0aC5xYmV6aWVyQXQocHRzW3AwXSwgcHRzW2ljXSwgcHRzW3AxXSwgMC40OTk5KTtcbiAgICAgIGJwMHkgPSBtYXRoLnFiZXppZXJBdChwdHNbcDAgKyAxXSwgcHRzW2ljICsgMV0sIHB0c1twMSArIDFdLCAwLjQ5OTkpO1xuXG4gICAgICBicDF4ID0gbWF0aC5xYmV6aWVyQXQocHRzW3AwXSwgcHRzW2ljXSwgcHRzW3AxXSwgMC41KTtcbiAgICAgIGJwMXkgPSBtYXRoLnFiZXppZXJBdChwdHNbcDAgKyAxXSwgcHRzW2ljICsgMV0sIHB0c1twMSArIDFdLCAwLjUpO1xuICAgIH1cblxuICAgIGRpc3BYID0gYnAxeCAtIGJwMHg7XG4gICAgZGlzcFkgPSBicDF5IC0gYnAweTtcbiAgfVxuXG4gIHJzLm1pZHRndEFycm93QW5nbGUgPSBtYXRoLmdldEFuZ2xlRnJvbURpc3AoZGlzcFgsIGRpc3BZKTtcblxuICBycy5taWREaXNwWCA9IGRpc3BYO1xuICBycy5taWREaXNwWSA9IGRpc3BZO1xuXG4gIC8vIG1pZCBzb3VyY2VcbiAgLy9cblxuICBkaXNwWCAqPSAtMTtcbiAgZGlzcFkgKj0gLTE7XG5cbiAgaWYgKGlzU2VnbWVudHMpIHtcbiAgICB2YXIgcHRzID0gcnMuYWxscHRzO1xuXG4gICAgaWYgKHB0cy5sZW5ndGggLyAyICUgMiA9PT0gMCkge1xuICAgICAgLy8gYWxyZWFkeSBva1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaTIgPSBwdHMubGVuZ3RoIC8gMiAtIDE7XG4gICAgICB2YXIgaTMgPSBpMiArIDI7XG5cbiAgICAgIGRpc3BYID0gLShwdHNbaTNdIC0gcHRzW2kyXSk7XG4gICAgICBkaXNwWSA9IC0ocHRzW2kzICsgMV0gLSBwdHNbaTIgKyAxXSk7XG4gICAgfVxuICB9XG5cbiAgcnMubWlkc3JjQXJyb3dBbmdsZSA9IG1hdGguZ2V0QW5nbGVGcm9tRGlzcChkaXNwWCwgZGlzcFkpO1xuXG4gIC8vIHRhcmdldFxuICAvL1xuXG4gIGlmIChpc1NlZ21lbnRzKSB7XG4gICAgZGlzcFggPSBlbmRYIC0gcnMuc2VncHRzW3JzLnNlZ3B0cy5sZW5ndGggLSAyXTtcbiAgICBkaXNwWSA9IGVuZFkgLSBycy5zZWdwdHNbcnMuc2VncHRzLmxlbmd0aCAtIDFdO1xuICB9IGVsc2UgaWYgKGlzTXVsdGliZXppZXIgfHwgaXNDb21wb3VuZCB8fCBpc1NlbGYgfHwgaXNCZXppZXIpIHtcbiAgICB2YXIgcHRzID0gcnMuYWxscHRzO1xuICAgIHZhciBsID0gcHRzLmxlbmd0aDtcbiAgICB2YXIgYlggPSBtYXRoLnFiZXppZXJBdChwdHNbbCAtIDZdLCBwdHNbbCAtIDRdLCBwdHNbbCAtIDJdLCAwLjkpO1xuICAgIHZhciBiWSA9IG1hdGgucWJlemllckF0KHB0c1tsIC0gNV0sIHB0c1tsIC0gM10sIHB0c1tsIC0gMV0sIDAuOSk7XG5cbiAgICBkaXNwWCA9IGVuZFggLSBiWDtcbiAgICBkaXNwWSA9IGVuZFkgLSBiWTtcbiAgfSBlbHNlIHtcbiAgICBkaXNwWCA9IGVuZFggLSBtaWRYO1xuICAgIGRpc3BZID0gZW5kWSAtIG1pZFk7XG4gIH1cblxuICBycy50Z3RBcnJvd0FuZ2xlID0gbWF0aC5nZXRBbmdsZUZyb21EaXNwKGRpc3BYLCBkaXNwWSk7XG59O1xuXG5CUnAuZ2V0QXJyb3dXaWR0aCA9IEJScC5nZXRBcnJvd0hlaWdodCA9IGZ1bmN0aW9uIChlZGdlV2lkdGgsIHNjYWxlKSB7XG4gIHZhciBjYWNoZSA9IHRoaXMuYXJyb3dXaWR0aENhY2hlID0gdGhpcy5hcnJvd1dpZHRoQ2FjaGUgfHwge307XG5cbiAgdmFyIGNhY2hlZFZhbCA9IGNhY2hlW2VkZ2VXaWR0aCArICcsICcgKyBzY2FsZV07XG4gIGlmIChjYWNoZWRWYWwpIHtcbiAgICByZXR1cm4gY2FjaGVkVmFsO1xuICB9XG5cbiAgY2FjaGVkVmFsID0gTWF0aC5tYXgoTWF0aC5wb3coZWRnZVdpZHRoICogMTMuMzcsIDAuOSksIDI5KSAqIHNjYWxlO1xuICBjYWNoZVtlZGdlV2lkdGggKyAnLCAnICsgc2NhbGVdID0gY2FjaGVkVmFsO1xuXG4gIHJldHVybiBjYWNoZWRWYWw7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJScDtcblxuLyoqKi8gfSksXG4vKiAxMTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIG1hdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xudmFyIGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIEJScCA9IHt9O1xuXG5CUnAuZmluZEVkZ2VDb250cm9sUG9pbnRzID0gZnVuY3Rpb24gKGVkZ2VzKSB7XG4gIGlmICghZWRnZXMgfHwgZWRnZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgY3kgPSByLmN5O1xuICB2YXIgaGFzQ29tcG91bmRzID0gY3kuaGFzQ29tcG91bmROb2RlcygpO1xuICB2YXIgaGFzaFRhYmxlID0ge307XG4gIHZhciBwYWlySWRzID0gW107XG4gIHZhciBoYXlzdGFja0VkZ2VzID0gW107XG5cbiAgLy8gY3JlYXRlIGEgdGFibGUgb2YgZWRnZSAoc3JjLCB0Z3QpID0+IGxpc3Qgb2YgZWRnZXMgYmV0d2VlbiB0aGVtXG4gIHZhciBwYWlySWQ7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWRnZSA9IGVkZ2VzW2ldO1xuICAgIHZhciBfcCA9IGVkZ2UuX3ByaXZhdGU7XG4gICAgdmFyIGRhdGEgPSBfcC5kYXRhO1xuICAgIHZhciBjdXJ2ZVN0eWxlID0gZWRnZS5wc3R5bGUoJ2N1cnZlLXN0eWxlJykudmFsdWU7XG4gICAgdmFyIGVkZ2VJc1VuYnVuZGxlZCA9IGN1cnZlU3R5bGUgPT09ICd1bmJ1bmRsZWQtYmV6aWVyJyB8fCBjdXJ2ZVN0eWxlID09PSAnc2VnbWVudHMnO1xuICAgIHZhciBlZGdlSXNCZXppZXIgPSBjdXJ2ZVN0eWxlID09PSAndW5idW5kbGVkLWJlemllcicgfHwgY3VydmVTdHlsZSA9PT0gJ2Jlemllcic7XG5cbiAgICAvLyBpZ25vcmUgZWRnZXMgd2hvIGFyZSBub3QgdG8gYmUgZGlzcGxheWVkXG4gICAgLy8gdGhleSBzaG91bGRuJ3QgdGFrZSB1cCBzcGFjZVxuICAgIGlmIChlZGdlLnBzdHlsZSgnZGlzcGxheScpLnZhbHVlID09PSAnbm9uZScpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChjdXJ2ZVN0eWxlID09PSAnaGF5c3RhY2snKSB7XG4gICAgICBoYXlzdGFja0VkZ2VzLnB1c2goZWRnZSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgc3JjSWQgPSBkYXRhLnNvdXJjZTtcbiAgICB2YXIgdGd0SWQgPSBkYXRhLnRhcmdldDtcblxuICAgIHBhaXJJZCA9IHNyY0lkID4gdGd0SWQgPyB0Z3RJZCArICckLSQnICsgc3JjSWQgOiBzcmNJZCArICckLSQnICsgdGd0SWQ7XG5cbiAgICBpZiAoZWRnZUlzVW5idW5kbGVkKSB7XG4gICAgICBwYWlySWQgPSAndW5idW5kbGVkJyArICckLSQnICsgZGF0YS5pZDtcbiAgICB9XG5cbiAgICB2YXIgdGFibGVFbnRyeSA9IGhhc2hUYWJsZVtwYWlySWRdO1xuXG4gICAgaWYgKHRhYmxlRW50cnkgPT0gbnVsbCkge1xuICAgICAgdGFibGVFbnRyeSA9IGhhc2hUYWJsZVtwYWlySWRdID0gW107XG4gICAgICBwYWlySWRzLnB1c2gocGFpcklkKTtcbiAgICB9XG5cbiAgICB0YWJsZUVudHJ5LnB1c2goZWRnZSk7XG5cbiAgICBpZiAoZWRnZUlzVW5idW5kbGVkKSB7XG4gICAgICB0YWJsZUVudHJ5Lmhhc1VuYnVuZGxlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGVkZ2VJc0Jlemllcikge1xuICAgICAgdGFibGVFbnRyeS5oYXNCZXppZXIgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBzcmMsIHRndCwgc3JjUG9zLCB0Z3RQb3MsIHNyY1csIHNyY0gsIHRndFcsIHRndEgsIHNyY1NoYXBlLCB0Z3RTaGFwZTtcbiAgdmFyIHZlY3Rvck5vcm1JbnZlcnNlO1xuICB2YXIgYmFkQmV6aWVyO1xuXG4gIC8vIGZvciBlYWNoIHBhaXIgKHNyYywgdGd0KSwgY3JlYXRlIHRoZSBjdHJsIHB0c1xuICAvLyBOZXN0ZWQgZm9yIGxvb3AgaXMgT0s7IHRvdGFsIG51bWJlciBvZiBpdGVyYXRpb25zIGZvciBib3RoIGxvb3BzID0gZWRnZUNvdW50XG4gIGZvciAodmFyIHAgPSAwOyBwIDwgcGFpcklkcy5sZW5ndGg7IHArKykge1xuICAgIHBhaXJJZCA9IHBhaXJJZHNbcF07XG4gICAgdmFyIHBhaXJFZGdlcyA9IGhhc2hUYWJsZVtwYWlySWRdO1xuXG4gICAgLy8gZm9yIGVhY2ggcGFpciBpZCwgdGhlIGVkZ2VzIHNob3VsZCBiZSBzb3J0ZWQgYnkgaW5kZXhcbiAgICBwYWlyRWRnZXMuc29ydChmdW5jdGlvbiAoZWRnZTEsIGVkZ2UyKSB7XG4gICAgICByZXR1cm4gZWRnZTEucG9vbEluZGV4KCkgLSBlZGdlMi5wb29sSW5kZXgoKTtcbiAgICB9KTtcblxuICAgIHNyYyA9IHBhaXJFZGdlc1swXS5fcHJpdmF0ZS5zb3VyY2U7XG4gICAgdGd0ID0gcGFpckVkZ2VzWzBdLl9wcml2YXRlLnRhcmdldDtcblxuICAgIC8vIG1ha2Ugc3VyZSBzcmMvdGd0IGRpc3RpbmN0aW9uIGlzIGNvbnNpc3RlbnQgZm9yIGJ1bmRsZWQgZWRnZXNcbiAgICBpZiAoIXBhaXJFZGdlcy5oYXNVbmJ1bmRsZWQgJiYgc3JjLmlkKCkgPiB0Z3QuaWQoKSkge1xuICAgICAgdmFyIHRlbXAgPSBzcmM7XG4gICAgICBzcmMgPSB0Z3Q7XG4gICAgICB0Z3QgPSB0ZW1wO1xuICAgIH1cblxuICAgIHNyY1BvcyA9IHNyYy5wb3NpdGlvbigpO1xuICAgIHRndFBvcyA9IHRndC5wb3NpdGlvbigpO1xuXG4gICAgc3JjVyA9IHNyYy5vdXRlcldpZHRoKCk7XG4gICAgc3JjSCA9IHNyYy5vdXRlckhlaWdodCgpO1xuXG4gICAgdGd0VyA9IHRndC5vdXRlcldpZHRoKCk7XG4gICAgdGd0SCA9IHRndC5vdXRlckhlaWdodCgpO1xuXG4gICAgc3JjU2hhcGUgPSByLm5vZGVTaGFwZXNbdGhpcy5nZXROb2RlU2hhcGUoc3JjKV07XG4gICAgdGd0U2hhcGUgPSByLm5vZGVTaGFwZXNbdGhpcy5nZXROb2RlU2hhcGUodGd0KV07XG5cbiAgICBiYWRCZXppZXIgPSBmYWxzZTtcblxuICAgIHZhciBlZGdlO1xuICAgIHZhciBlZGdlX3A7XG4gICAgdmFyIHJzO1xuXG4gICAgdmFyIGRpckNvdW50cyA9IHtcbiAgICAgICdub3J0aCc6IDAsXG4gICAgICAnd2VzdCc6IDAsXG4gICAgICAnc291dGgnOiAwLFxuICAgICAgJ2Vhc3QnOiAwLFxuICAgICAgJ25vcnRod2VzdCc6IDAsXG4gICAgICAnc291dGh3ZXN0JzogMCxcbiAgICAgICdub3J0aGVhc3QnOiAwLFxuICAgICAgJ3NvdXRoZWFzdCc6IDBcbiAgICB9O1xuXG4gICAgdmFyIHNyY1gyID0gc3JjUG9zLng7XG4gICAgdmFyIHNyY1kyID0gc3JjUG9zLnk7XG4gICAgdmFyIHNyY1cyID0gc3JjVztcbiAgICB2YXIgc3JjSDIgPSBzcmNIO1xuXG4gICAgdmFyIHRndFgyID0gdGd0UG9zLng7XG4gICAgdmFyIHRndFkyID0gdGd0UG9zLnk7XG4gICAgdmFyIHRndFcyID0gdGd0VztcbiAgICB2YXIgdGd0SDIgPSB0Z3RIO1xuXG4gICAgdmFyIG51bUVkZ2VzMiA9IHBhaXJFZGdlcy5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhaXJFZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgZWRnZSA9IHBhaXJFZGdlc1tpXTtcbiAgICAgIGVkZ2VfcCA9IGVkZ2UuX3ByaXZhdGU7XG4gICAgICBycyA9IGVkZ2VfcC5yc2NyYXRjaDtcblxuICAgICAgdmFyIGVkZ2VJbmRleDEgPSBycy5sYXN0RWRnZUluZGV4O1xuICAgICAgdmFyIGVkZ2VJbmRleDIgPSBpO1xuXG4gICAgICB2YXIgbnVtRWRnZXMxID0gcnMubGFzdE51bUVkZ2VzO1xuXG4gICAgICB2YXIgY3VydmVTdHlsZSA9IGVkZ2UucHN0eWxlKCdjdXJ2ZS1zdHlsZScpLnZhbHVlO1xuXG4gICAgICB2YXIgZWRnZUlzVW5idW5kbGVkID0gY3VydmVTdHlsZSA9PT0gJ3VuYnVuZGxlZC1iZXppZXInIHx8IGN1cnZlU3R5bGUgPT09ICdzZWdtZW50cyc7XG5cbiAgICAgIC8vIHdoZXRoZXIgdGhlIG5vcm1hbGlzZWQgcGFpciBvcmRlciBpcyB0aGUgcmV2ZXJzZSBvZiB0aGUgZWRnZSdzIHNyYy10Z3Qgb3JkZXJcbiAgICAgIHZhciBlZGdlSXNTd2FwcGVkID0gc3JjLmlkKCkgIT09IGVkZ2Uuc291cmNlKCkuaWQoKTtcblxuICAgICAgdmFyIGN0cmxwdERpc3RzID0gZWRnZS5wc3R5bGUoJ2NvbnRyb2wtcG9pbnQtZGlzdGFuY2VzJyk7XG4gICAgICB2YXIgbG9vcERpciA9IGVkZ2UucHN0eWxlKCdsb29wLWRpcmVjdGlvbicpLnBmVmFsdWU7XG4gICAgICB2YXIgbG9vcFN3cCA9IGVkZ2UucHN0eWxlKCdsb29wLXN3ZWVwJykucGZWYWx1ZTtcbiAgICAgIHZhciBjdHJscHRXcyA9IGVkZ2UucHN0eWxlKCdjb250cm9sLXBvaW50LXdlaWdodHMnKTtcbiAgICAgIHZhciBiZXppZXJOID0gY3RybHB0RGlzdHMgJiYgY3RybHB0V3MgPyBNYXRoLm1pbihjdHJscHREaXN0cy52YWx1ZS5sZW5ndGgsIGN0cmxwdFdzLnZhbHVlLmxlbmd0aCkgOiAxO1xuICAgICAgdmFyIHN0ZXBTaXplID0gZWRnZS5wc3R5bGUoJ2NvbnRyb2wtcG9pbnQtc3RlcC1zaXplJykucGZWYWx1ZTtcbiAgICAgIHZhciBjdHJscHREaXN0ID0gY3RybHB0RGlzdHMgPyBjdHJscHREaXN0cy5wZlZhbHVlWzBdIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIGN0cmxwdFdlaWdodCA9IGN0cmxwdFdzLnZhbHVlWzBdO1xuICAgICAgdmFyIGVkZ2VEaXN0YW5jZXMgPSBlZGdlLnBzdHlsZSgnZWRnZS1kaXN0YW5jZXMnKS52YWx1ZTtcbiAgICAgIHZhciBzcmNEaXN0Rk5vZGUgPSBlZGdlLnBzdHlsZSgnc291cmNlLWRpc3RhbmNlLWZyb20tbm9kZScpLnBmVmFsdWU7XG4gICAgICB2YXIgdGd0RGlzdEZOb2RlID0gZWRnZS5wc3R5bGUoJ3RhcmdldC1kaXN0YW5jZS1mcm9tLW5vZGUnKS5wZlZhbHVlO1xuICAgICAgdmFyIHNlZ21lbnRXcyA9IGVkZ2UucHN0eWxlKCdzZWdtZW50LXdlaWdodHMnKTtcbiAgICAgIHZhciBzZWdtZW50RHMgPSBlZGdlLnBzdHlsZSgnc2VnbWVudC1kaXN0YW5jZXMnKTtcbiAgICAgIHZhciBzZWdtZW50c04gPSBNYXRoLm1pbihzZWdtZW50V3MucGZWYWx1ZS5sZW5ndGgsIHNlZ21lbnREcy5wZlZhbHVlLmxlbmd0aCk7XG4gICAgICB2YXIgc3JjRW5kcHQgPSBlZGdlLnBzdHlsZSgnc291cmNlLWVuZHBvaW50JykudmFsdWU7XG4gICAgICB2YXIgdGd0RW5kcHQgPSBlZGdlLnBzdHlsZSgndGFyZ2V0LWVuZHBvaW50JykudmFsdWU7XG4gICAgICB2YXIgc3JjQXJyU2hhcGUgPSBlZGdlLnBzdHlsZSgnc291cmNlLWFycm93LXNoYXBlJykudmFsdWU7XG4gICAgICB2YXIgdGd0QXJyU2hhcGUgPSBlZGdlLnBzdHlsZSgndGFyZ2V0LWFycm93LXNoYXBlJykudmFsdWU7XG4gICAgICB2YXIgYXJyb3dTY2FsZSA9IGVkZ2UucHN0eWxlKCdhcnJvdy1zY2FsZScpLnZhbHVlO1xuICAgICAgdmFyIGxpbmVXaWR0aCA9IGVkZ2UucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWU7XG5cbiAgICAgIHZhciBzcmNYMSA9IHJzLmxhc3RTcmNDdGxQdFg7XG4gICAgICB2YXIgc3JjWTEgPSBycy5sYXN0U3JjQ3RsUHRZO1xuICAgICAgdmFyIHNyY1cxID0gcnMubGFzdFNyY0N0bFB0VztcbiAgICAgIHZhciBzcmNIMSA9IHJzLmxhc3RTcmNDdGxQdEg7XG5cbiAgICAgIHZhciB0Z3RYMSA9IHJzLmxhc3RUZ3RDdGxQdFg7XG4gICAgICB2YXIgdGd0WTEgPSBycy5sYXN0VGd0Q3RsUHRZO1xuICAgICAgdmFyIHRndFcxID0gcnMubGFzdFRndEN0bFB0VztcbiAgICAgIHZhciB0Z3RIMSA9IHJzLmxhc3RUZ3RDdGxQdEg7XG5cbiAgICAgIHZhciBjdXJ2ZVN0eWxlMSA9IHJzLmxhc3RDdXJ2ZVN0eWxlO1xuICAgICAgdmFyIGN1cnZlU3R5bGUyID0gY3VydmVTdHlsZTtcblxuICAgICAgdmFyIGN0cmxwdERpc3RzMSA9IHJzLmxhc3RDdHJscHREaXN0cztcbiAgICAgIHZhciBjdHJscHREaXN0czIgPSBjdHJscHREaXN0cyA/IGN0cmxwdERpc3RzLnN0clZhbHVlIDogbnVsbDtcblxuICAgICAgdmFyIGN0cmxwdFdzMSA9IHJzLmxhc3RDdHJscHRXcztcbiAgICAgIHZhciBjdHJscHRXczIgPSBjdHJscHRXcy5zdHJWYWx1ZTtcblxuICAgICAgdmFyIHNlZ21lbnRXczEgPSBycy5sYXN0U2VnbWVudFdzO1xuICAgICAgdmFyIHNlZ21lbnRXczIgPSBzZWdtZW50V3Muc3RyVmFsdWU7XG5cbiAgICAgIHZhciBzZWdtZW50RHMxID0gcnMubGFzdFNlZ21lbnREcztcbiAgICAgIHZhciBzZWdtZW50RHMyID0gc2VnbWVudERzLnN0clZhbHVlO1xuXG4gICAgICB2YXIgc3RlcFNpemUxID0gcnMubGFzdFN0ZXBTaXplO1xuICAgICAgdmFyIHN0ZXBTaXplMiA9IHN0ZXBTaXplO1xuXG4gICAgICB2YXIgbG9vcERpcjEgPSBycy5sYXN0TG9vcERpcjtcbiAgICAgIHZhciBsb29wRGlyMiA9IGxvb3BEaXI7XG5cbiAgICAgIHZhciBsb29wU3dwMSA9IHJzLmxhc3RMb29wU3dwO1xuICAgICAgdmFyIGxvb3BTd3AyID0gbG9vcFN3cDtcblxuICAgICAgdmFyIGVkZ2VEaXN0YW5jZXMxID0gcnMubGFzdEVkZ2VEaXN0YW5jZXM7XG4gICAgICB2YXIgZWRnZURpc3RhbmNlczIgPSBlZGdlRGlzdGFuY2VzO1xuXG4gICAgICB2YXIgc3JjRGlzdEZOb2RlMSA9IHJzLmxhc3RTcmNEaXN0Rk5vZGU7XG4gICAgICB2YXIgc3JjRGlzdEZOb2RlMiA9IHNyY0Rpc3RGTm9kZTtcblxuICAgICAgdmFyIHRndERpc3RGTm9kZTEgPSBycy5sYXN0VGd0RGlzdEZOb2RlO1xuICAgICAgdmFyIHRndERpc3RGTm9kZTIgPSB0Z3REaXN0Rk5vZGU7XG5cbiAgICAgIHZhciBzcmNFbmRwdDEgPSBycy5sYXN0U3JjRW5kcHQ7XG4gICAgICB2YXIgc3JjRW5kcHQyID0gc3JjRW5kcHQ7XG5cbiAgICAgIHZhciB0Z3RFbmRwdDEgPSBycy5sYXN0VGd0RW5kcHQ7XG4gICAgICB2YXIgdGd0RW5kcHQyID0gdGd0RW5kcHQ7XG5cbiAgICAgIHZhciBzcmNBcnIxID0gcnMubGFzdFNyY0FycjtcbiAgICAgIHZhciBzcmNBcnIyID0gc3JjQXJyU2hhcGU7XG5cbiAgICAgIHZhciB0Z3RBcnIxID0gcnMubGFzdFRndEFycjtcbiAgICAgIHZhciB0Z3RBcnIyID0gdGd0QXJyU2hhcGU7XG5cbiAgICAgIHZhciBsaW5lVzEgPSBycy5sYXN0TGluZVc7XG4gICAgICB2YXIgbGluZVcyID0gbGluZVdpZHRoO1xuXG4gICAgICB2YXIgYXJyU2NsMSA9IHJzLmxhc3RBcnJTY2w7XG4gICAgICB2YXIgYXJyU2NsMiA9IGFycm93U2NhbGU7XG5cbiAgICAgIGlmIChiYWRCZXppZXIpIHtcbiAgICAgICAgcnMuYmFkQmV6aWVyID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJzLmJhZEJlemllciA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHRDYWNoZUhpdDtcblxuICAgICAgaWYgKHNyY1gxID09PSBzcmNYMiAmJiBzcmNZMSA9PT0gc3JjWTIgJiYgc3JjVzEgPT09IHNyY1cyICYmIHNyY0gxID09PSBzcmNIMiAmJiB0Z3RYMSA9PT0gdGd0WDIgJiYgdGd0WTEgPT09IHRndFkyICYmIHRndFcxID09PSB0Z3RXMiAmJiB0Z3RIMSA9PT0gdGd0SDIgJiYgY3VydmVTdHlsZTEgPT09IGN1cnZlU3R5bGUyICYmIGN0cmxwdERpc3RzMSA9PT0gY3RybHB0RGlzdHMyICYmIGN0cmxwdFdzMSA9PT0gY3RybHB0V3MyICYmIHNlZ21lbnRXczEgPT09IHNlZ21lbnRXczIgJiYgc2VnbWVudERzMSA9PT0gc2VnbWVudERzMiAmJiBzdGVwU2l6ZTEgPT09IHN0ZXBTaXplMiAmJiBsb29wRGlyMSA9PT0gbG9vcERpcjIgJiYgbG9vcFN3cDEgPT09IGxvb3BTd3AyICYmIGVkZ2VEaXN0YW5jZXMxID09PSBlZGdlRGlzdGFuY2VzMiAmJiBzcmNEaXN0Rk5vZGUxID09PSBzcmNEaXN0Rk5vZGUyICYmIHRndERpc3RGTm9kZTEgPT09IHRndERpc3RGTm9kZTIgJiYgc3JjRW5kcHQxID09PSBzcmNFbmRwdDIgJiYgdGd0RW5kcHQxID09PSB0Z3RFbmRwdDIgJiYgc3JjQXJyMSA9PT0gc3JjQXJyMiAmJiB0Z3RBcnIxID09PSB0Z3RBcnIyICYmIGxpbmVXMSA9PT0gbGluZVcyICYmIGFyclNjbDEgPT09IGFyclNjbDIgJiYgKGVkZ2VJbmRleDEgPT09IGVkZ2VJbmRleDIgJiYgbnVtRWRnZXMxID09PSBudW1FZGdlczIgfHwgZWRnZUlzVW5idW5kbGVkKSkge1xuICAgICAgICBwdENhY2hlSGl0ID0gdHJ1ZTsgLy8gdGhlbiB0aGUgY29udHJvbCBwb2ludHMgaGF2ZW4ndCBjaGFuZ2VkIGFuZCB3ZSBjYW4gc2tpcCBjYWxjdWxhdGluZyB0aGVtXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwdENhY2hlSGl0ID0gZmFsc2U7XG5cbiAgICAgICAgcnMubGFzdFNyY0N0bFB0WCA9IHNyY1gyO1xuICAgICAgICBycy5sYXN0U3JjQ3RsUHRZID0gc3JjWTI7XG4gICAgICAgIHJzLmxhc3RTcmNDdGxQdFcgPSBzcmNXMjtcbiAgICAgICAgcnMubGFzdFNyY0N0bFB0SCA9IHNyY0gyO1xuICAgICAgICBycy5sYXN0VGd0Q3RsUHRYID0gdGd0WDI7XG4gICAgICAgIHJzLmxhc3RUZ3RDdGxQdFkgPSB0Z3RZMjtcbiAgICAgICAgcnMubGFzdFRndEN0bFB0VyA9IHRndFcyO1xuICAgICAgICBycy5sYXN0VGd0Q3RsUHRIID0gdGd0SDI7XG4gICAgICAgIHJzLmxhc3RFZGdlSW5kZXggPSBlZGdlSW5kZXgyO1xuICAgICAgICBycy5sYXN0TnVtRWRnZXMgPSBudW1FZGdlczI7XG4gICAgICAgIHJzLmxhc3RDdXJ2ZVN0eWxlID0gY3VydmVTdHlsZTI7XG4gICAgICAgIHJzLmxhc3RDdHJscHREaXN0cyA9IGN0cmxwdERpc3RzMjtcbiAgICAgICAgcnMubGFzdEN0cmxwdFdzID0gY3RybHB0V3MyO1xuICAgICAgICBycy5sYXN0U2VnbWVudERzID0gc2VnbWVudERzMjtcbiAgICAgICAgcnMubGFzdFNlZ21lbnRXcyA9IHNlZ21lbnRXczI7XG4gICAgICAgIHJzLmxhc3RTdGVwU2l6ZSA9IHN0ZXBTaXplMjtcbiAgICAgICAgcnMubGFzdExvb3BEaXIgPSBsb29wRGlyMjtcbiAgICAgICAgcnMubGFzdExvb3BTd3AgPSBsb29wU3dwMjtcbiAgICAgICAgcnMubGFzdEVkZ2VEaXN0YW5jZXMgPSBlZGdlRGlzdGFuY2VzMjtcbiAgICAgICAgcnMubGFzdFNyY0Rpc3RGTm9kZSA9IHNyY0Rpc3RGTm9kZTI7XG4gICAgICAgIHJzLmxhc3RUZ3REaXN0Rk5vZGUgPSB0Z3REaXN0Rk5vZGUyO1xuICAgICAgICBycy5sYXN0U3JjRW5kcHQgPSBzcmNFbmRwdDI7XG4gICAgICAgIHJzLmxhc3RUZ3RFbmRwdCA9IHRndEVuZHB0MjtcbiAgICAgICAgcnMubGFzdFNyY0FyciA9IHNyY0FycjI7XG4gICAgICAgIHJzLmxhc3RUZ3RBcnIgPSB0Z3RBcnIyO1xuICAgICAgICBycy5sYXN0TGluZVcgPSBsaW5lVzI7XG4gICAgICAgIHJzLmxhc3RBcnJTY2wgPSBhcnJTY2wyO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXB0Q2FjaGVIaXQpIHtcblxuICAgICAgICBpZiAoIXBhaXJFZGdlcy5jYWxjdWxhdGVkSW50ZXJzZWN0aW9uICYmIHNyYyAhPT0gdGd0ICYmIChwYWlyRWRnZXMuaGFzQmV6aWVyIHx8IHBhaXJFZGdlcy5oYXNVbmJ1bmRsZWQpKSB7XG5cbiAgICAgICAgICBwYWlyRWRnZXMuY2FsY3VsYXRlZEludGVyc2VjdGlvbiA9IHRydWU7XG5cbiAgICAgICAgICAvLyBwdCBvdXRzaWRlIHNyYyBzaGFwZSB0byBjYWxjIGRpc3RhbmNlL2Rpc3BsYWNlbWVudCBmcm9tIHNyYyB0byB0Z3RcbiAgICAgICAgICB2YXIgc3JjT3V0c2lkZSA9IHNyY1NoYXBlLmludGVyc2VjdExpbmUoc3JjUG9zLngsIHNyY1Bvcy55LCBzcmNXLCBzcmNILCB0Z3RQb3MueCwgdGd0UG9zLnksIDApO1xuXG4gICAgICAgICAgcGFpckVkZ2VzLnNyY0ludG4gPSBzcmNPdXRzaWRlO1xuXG4gICAgICAgICAgLy8gcHQgb3V0c2lkZSB0Z3Qgc2hhcGUgdG8gY2FsYyBkaXN0YW5jZS9kaXNwbGFjZW1lbnQgZnJvbSBzcmMgdG8gdGd0XG4gICAgICAgICAgdmFyIHRndE91dHNpZGUgPSB0Z3RTaGFwZS5pbnRlcnNlY3RMaW5lKHRndFBvcy54LCB0Z3RQb3MueSwgdGd0VywgdGd0SCwgc3JjUG9zLngsIHNyY1Bvcy55LCAwKTtcblxuICAgICAgICAgIHBhaXJFZGdlcy50Z3RJbnRuID0gdGd0T3V0c2lkZTtcblxuICAgICAgICAgIHZhciBtaWRwdFNyY1B0cyA9IHtcbiAgICAgICAgICAgIHgxOiBzcmNPdXRzaWRlWzBdLFxuICAgICAgICAgICAgeDI6IHRndE91dHNpZGVbMF0sXG4gICAgICAgICAgICB5MTogc3JjT3V0c2lkZVsxXSxcbiAgICAgICAgICAgIHkyOiB0Z3RPdXRzaWRlWzFdXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHZhciBwb3NQdHMgPSB7XG4gICAgICAgICAgICB4MTogc3JjUG9zLngsXG4gICAgICAgICAgICB4MjogdGd0UG9zLngsXG4gICAgICAgICAgICB5MTogc3JjUG9zLnksXG4gICAgICAgICAgICB5MjogdGd0UG9zLnlcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdmFyIGR5ID0gdGd0T3V0c2lkZVsxXSAtIHNyY091dHNpZGVbMV07XG4gICAgICAgICAgdmFyIGR4ID0gdGd0T3V0c2lkZVswXSAtIHNyY091dHNpZGVbMF07XG4gICAgICAgICAgdmFyIGwgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gICAgICAgICAgdmFyIHZlY3RvciA9IHtcbiAgICAgICAgICAgIHg6IGR4LFxuICAgICAgICAgICAgeTogZHlcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdmFyIHZlY3Rvck5vcm0gPSB7XG4gICAgICAgICAgICB4OiB2ZWN0b3IueCAvIGwsXG4gICAgICAgICAgICB5OiB2ZWN0b3IueSAvIGxcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZlY3Rvck5vcm1JbnZlcnNlID0ge1xuICAgICAgICAgICAgeDogLXZlY3Rvck5vcm0ueSxcbiAgICAgICAgICAgIHk6IHZlY3Rvck5vcm0ueFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICAvLyBpZiBub2RlIHNoYXBlcyBvdmVybGFwLCB0aGVuIG5vIGN0cmwgcHRzIHRvIGRyYXdcbiAgICAgICAgICBpZiAodGd0U2hhcGUuY2hlY2tQb2ludChzcmNPdXRzaWRlWzBdLCBzcmNPdXRzaWRlWzFdLCAwLCB0Z3RXLCB0Z3RILCB0Z3RQb3MueCwgdGd0UG9zLnkpICYmIHNyY1NoYXBlLmNoZWNrUG9pbnQodGd0T3V0c2lkZVswXSwgdGd0T3V0c2lkZVsxXSwgMCwgc3JjVywgc3JjSCwgc3JjUG9zLngsIHNyY1Bvcy55KSkge1xuICAgICAgICAgICAgdmVjdG9yTm9ybUludmVyc2UgPSB7fTtcbiAgICAgICAgICAgIGJhZEJlemllciA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFlZGdlSXNTd2FwcGVkKSB7XG4gICAgICAgICAgcnMuc3JjSW50biA9IHBhaXJFZGdlcy5zcmNJbnRuO1xuICAgICAgICAgIHJzLnRndEludG4gPSBwYWlyRWRnZXMudGd0SW50bjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBlbnN1cmUgdGhhdCB0aGUgcGVyLWVkZ2UgY2FjaGVkIHZhbHVlIGZvciBpbnRlcnNlY3Rpb25zIGFyZSBjb3JyZWN0IGZvciBzd2FwcGVkIGJ1bmRsZWQgZWRnZXNcbiAgICAgICAgICBycy5zcmNJbnRuID0gcGFpckVkZ2VzLnRndEludG47XG4gICAgICAgICAgcnMudGd0SW50biA9IHBhaXJFZGdlcy5zcmNJbnRuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNyYyA9PT0gdGd0KSB7XG4gICAgICAgICAgLy8gU2VsZi1lZGdlXG5cbiAgICAgICAgICBycy5lZGdlVHlwZSA9ICdzZWxmJztcblxuICAgICAgICAgIHZhciBqID0gaTtcbiAgICAgICAgICB2YXIgbG9vcERpc3QgPSBzdGVwU2l6ZTtcblxuICAgICAgICAgIGlmIChlZGdlSXNVbmJ1bmRsZWQpIHtcbiAgICAgICAgICAgIGogPSAwO1xuICAgICAgICAgICAgbG9vcERpc3QgPSBjdHJscHREaXN0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBsb29wQW5nbGUgPSBsb29wRGlyIC0gTWF0aC5QSSAvIDI7XG4gICAgICAgICAgdmFyIG91dEFuZ2xlID0gbG9vcEFuZ2xlIC0gbG9vcFN3cCAvIDI7XG4gICAgICAgICAgdmFyIGluQW5nbGUgPSBsb29wQW5nbGUgKyBsb29wU3dwIC8gMjtcblxuICAgICAgICAgIC8vIGluY3JlYXNlIGJ5IHN0ZXAgc2l6ZSBmb3Igb3ZlcmxhcHBpbmcgbG9vcHMsIGtleWVkIG9uIGRpcmVjdGlvbiBhbmQgc3dlZXAgdmFsdWVzXG4gICAgICAgICAgdmFyIGRjID0gU3RyaW5nKGxvb3BEaXIgKyAnXycgKyBsb29wU3dwKTtcbiAgICAgICAgICBqID0gZGlyQ291bnRzW2RjXSA9PT0gdW5kZWZpbmVkID8gZGlyQ291bnRzW2RjXSA9IDAgOiArK2RpckNvdW50c1tkY107XG5cbiAgICAgICAgICBycy5jdHJscHRzID0gW3NyY1Bvcy54ICsgTWF0aC5jb3Mob3V0QW5nbGUpICogMS40ICogbG9vcERpc3QgKiAoaiAvIDMgKyAxKSwgc3JjUG9zLnkgKyBNYXRoLnNpbihvdXRBbmdsZSkgKiAxLjQgKiBsb29wRGlzdCAqIChqIC8gMyArIDEpLCBzcmNQb3MueCArIE1hdGguY29zKGluQW5nbGUpICogMS40ICogbG9vcERpc3QgKiAoaiAvIDMgKyAxKSwgc3JjUG9zLnkgKyBNYXRoLnNpbihpbkFuZ2xlKSAqIDEuNCAqIGxvb3BEaXN0ICogKGogLyAzICsgMSldO1xuICAgICAgICB9IGVsc2UgaWYgKGhhc0NvbXBvdW5kcyAmJiAoc3JjLmlzUGFyZW50KCkgfHwgc3JjLmlzQ2hpbGQoKSB8fCB0Z3QuaXNQYXJlbnQoKSB8fCB0Z3QuaXNDaGlsZCgpKSAmJiAoc3JjLnBhcmVudHMoKS5hbnlTYW1lKHRndCkgfHwgdGd0LnBhcmVudHMoKS5hbnlTYW1lKHNyYykpKSB7XG4gICAgICAgICAgLy8gQ29tcG91bmQgZWRnZVxuXG4gICAgICAgICAgcnMuZWRnZVR5cGUgPSAnY29tcG91bmQnO1xuXG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGUgbGluZSBhcHByb3hpbWF0aW9uIGRvZXNuJ3QgYXBwbHkgZm9yIGNvbXBvdW5kIGJlemllcnNcbiAgICAgICAgICAvLyAobG9vcC9zZWxmIGVkZ2VzIGFyZSBhbHJlYWR5IGVsaWRlZCBiL2Mgb2YgY2hlYXAgc3JjPT10Z3QgY2hlY2spXG4gICAgICAgICAgcnMuYmFkQmV6aWVyID0gZmFsc2U7XG5cbiAgICAgICAgICB2YXIgaiA9IGk7XG4gICAgICAgICAgdmFyIGxvb3BEaXN0ID0gc3RlcFNpemU7XG5cbiAgICAgICAgICBpZiAoZWRnZUlzVW5idW5kbGVkKSB7XG4gICAgICAgICAgICBqID0gMDtcbiAgICAgICAgICAgIGxvb3BEaXN0ID0gY3RybHB0RGlzdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbG9vcFcgPSA1MDtcblxuICAgICAgICAgIHZhciBsb29wYVBvcyA9IHtcbiAgICAgICAgICAgIHg6IHNyY1Bvcy54IC0gc3JjVyAvIDIsXG4gICAgICAgICAgICB5OiBzcmNQb3MueSAtIHNyY0ggLyAyXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHZhciBsb29wYlBvcyA9IHtcbiAgICAgICAgICAgIHg6IHRndFBvcy54IC0gdGd0VyAvIDIsXG4gICAgICAgICAgICB5OiB0Z3RQb3MueSAtIHRndEggLyAyXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHZhciBsb29wUG9zID0ge1xuICAgICAgICAgICAgeDogTWF0aC5taW4obG9vcGFQb3MueCwgbG9vcGJQb3MueCksXG4gICAgICAgICAgICB5OiBNYXRoLm1pbihsb29wYVBvcy55LCBsb29wYlBvcy55KVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICAvLyBhdm9pZHMgY2FzZXMgd2l0aCBpbXBvc3NpYmxlIGJlemllcnNcbiAgICAgICAgICB2YXIgbWluQ29tcG91bmRTdHJldGNoID0gMC41O1xuICAgICAgICAgIHZhciBjb21wb3VuZFN0cmV0Y2hBID0gTWF0aC5tYXgobWluQ29tcG91bmRTdHJldGNoLCBNYXRoLmxvZyhzcmNXICogMC4wMSkpO1xuICAgICAgICAgIHZhciBjb21wb3VuZFN0cmV0Y2hCID0gTWF0aC5tYXgobWluQ29tcG91bmRTdHJldGNoLCBNYXRoLmxvZyh0Z3RXICogMC4wMSkpO1xuXG4gICAgICAgICAgcnMuY3RybHB0cyA9IFtsb29wUG9zLngsIGxvb3BQb3MueSAtICgxICsgTWF0aC5wb3cobG9vcFcsIDEuMTIpIC8gMTAwKSAqIGxvb3BEaXN0ICogKGogLyAzICsgMSkgKiBjb21wb3VuZFN0cmV0Y2hBLCBsb29wUG9zLnggLSAoMSArIE1hdGgucG93KGxvb3BXLCAxLjEyKSAvIDEwMCkgKiBsb29wRGlzdCAqIChqIC8gMyArIDEpICogY29tcG91bmRTdHJldGNoQiwgbG9vcFBvcy55XTtcbiAgICAgICAgfSBlbHNlIGlmIChjdXJ2ZVN0eWxlID09PSAnc2VnbWVudHMnKSB7XG4gICAgICAgICAgLy8gU2VnbWVudHMgKG11bHRpcGxlIHN0cmFpZ2h0IGxpbmVzKVxuXG4gICAgICAgICAgcnMuZWRnZVR5cGUgPSAnc2VnbWVudHMnO1xuICAgICAgICAgIHJzLnNlZ3B0cyA9IFtdO1xuXG4gICAgICAgICAgZm9yICh2YXIgcyA9IDA7IHMgPCBzZWdtZW50c047IHMrKykge1xuICAgICAgICAgICAgdmFyIHcgPSBzZWdtZW50V3MucGZWYWx1ZVtzXTtcbiAgICAgICAgICAgIHZhciBkID0gc2VnbWVudERzLnBmVmFsdWVbc107XG5cbiAgICAgICAgICAgIHZhciB3MSA9IDEgLSB3O1xuICAgICAgICAgICAgdmFyIHcyID0gdztcblxuICAgICAgICAgICAgdmFyIG1pZHB0UHRzID0gZWRnZURpc3RhbmNlcyA9PT0gJ25vZGUtcG9zaXRpb24nID8gcG9zUHRzIDogbWlkcHRTcmNQdHM7XG5cbiAgICAgICAgICAgIHZhciBhZGp1c3RlZE1pZHB0ID0ge1xuICAgICAgICAgICAgICB4OiBtaWRwdFB0cy54MSAqIHcxICsgbWlkcHRQdHMueDIgKiB3MixcbiAgICAgICAgICAgICAgeTogbWlkcHRQdHMueTEgKiB3MSArIG1pZHB0UHRzLnkyICogdzJcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJzLnNlZ3B0cy5wdXNoKGFkanVzdGVkTWlkcHQueCArIHZlY3Rvck5vcm1JbnZlcnNlLnggKiBkLCBhZGp1c3RlZE1pZHB0LnkgKyB2ZWN0b3JOb3JtSW52ZXJzZS55ICogZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU3RyYWlnaHQgZWRnZVxuICAgICAgICB9IGVsc2UgaWYgKHBhaXJFZGdlcy5sZW5ndGggJSAyID09PSAxICYmIGkgPT09IE1hdGguZmxvb3IocGFpckVkZ2VzLmxlbmd0aCAvIDIpICYmICFlZGdlSXNVbmJ1bmRsZWQpIHtcblxuICAgICAgICAgIHJzLmVkZ2VUeXBlID0gJ3N0cmFpZ2h0JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyAoTXVsdGkpYmV6aWVyXG5cbiAgICAgICAgICB2YXIgbXVsdGkgPSBlZGdlSXNVbmJ1bmRsZWQ7XG5cbiAgICAgICAgICBycy5lZGdlVHlwZSA9IG11bHRpID8gJ211bHRpYmV6aWVyJyA6ICdiZXppZXInO1xuICAgICAgICAgIHJzLmN0cmxwdHMgPSBbXTtcblxuICAgICAgICAgIGZvciAodmFyIGIgPSAwOyBiIDwgYmV6aWVyTjsgYisrKSB7XG4gICAgICAgICAgICB2YXIgbm9ybWN0cmxwdERpc3QgPSAoMC41IC0gcGFpckVkZ2VzLmxlbmd0aCAvIDIgKyBpKSAqIHN0ZXBTaXplO1xuICAgICAgICAgICAgdmFyIG1hbmN0cmxwdERpc3Q7XG4gICAgICAgICAgICB2YXIgc2lnbiA9IG1hdGguc2lnbnVtKG5vcm1jdHJscHREaXN0KTtcblxuICAgICAgICAgICAgaWYgKG11bHRpKSB7XG4gICAgICAgICAgICAgIGN0cmxwdERpc3QgPSBjdHJscHREaXN0cyA/IGN0cmxwdERpc3RzLnBmVmFsdWVbYl0gOiBzdGVwU2l6ZTsgLy8gZmFsbCBiYWNrIG9uIHN0ZXAgc2l6ZVxuICAgICAgICAgICAgICBjdHJscHRXZWlnaHQgPSBjdHJscHRXcy52YWx1ZVtiXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVkZ2VJc1VuYnVuZGxlZCkge1xuICAgICAgICAgICAgICAvLyBtdWx0aSBvciBzaW5nbGUgdW5idW5kbGVkXG4gICAgICAgICAgICAgIG1hbmN0cmxwdERpc3QgPSBjdHJscHREaXN0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbWFuY3RybHB0RGlzdCA9IGN0cmxwdERpc3QgIT09IHVuZGVmaW5lZCA/IHNpZ24gKiBjdHJscHREaXN0IDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZGlzdGFuY2VGcm9tTWlkcG9pbnQgPSBtYW5jdHJscHREaXN0ICE9PSB1bmRlZmluZWQgPyBtYW5jdHJscHREaXN0IDogbm9ybWN0cmxwdERpc3Q7XG5cbiAgICAgICAgICAgIHZhciB3MSA9IDEgLSBjdHJscHRXZWlnaHQ7XG4gICAgICAgICAgICB2YXIgdzIgPSBjdHJscHRXZWlnaHQ7XG5cbiAgICAgICAgICAgIGlmIChlZGdlSXNTd2FwcGVkKSB7XG4gICAgICAgICAgICAgIHZhciB0ZW1wID0gdzE7XG4gICAgICAgICAgICAgIHcxID0gdzI7XG4gICAgICAgICAgICAgIHcyID0gdGVtcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG1pZHB0UHRzID0gZWRnZURpc3RhbmNlcyA9PT0gJ25vZGUtcG9zaXRpb24nID8gcG9zUHRzIDogbWlkcHRTcmNQdHM7XG5cbiAgICAgICAgICAgIHZhciBhZGp1c3RlZE1pZHB0ID0ge1xuICAgICAgICAgICAgICB4OiBtaWRwdFB0cy54MSAqIHcxICsgbWlkcHRQdHMueDIgKiB3MixcbiAgICAgICAgICAgICAgeTogbWlkcHRQdHMueTEgKiB3MSArIG1pZHB0UHRzLnkyICogdzJcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJzLmN0cmxwdHMucHVzaChhZGp1c3RlZE1pZHB0LnggKyB2ZWN0b3JOb3JtSW52ZXJzZS54ICogZGlzdGFuY2VGcm9tTWlkcG9pbnQsIGFkanVzdGVkTWlkcHQueSArIHZlY3Rvck5vcm1JbnZlcnNlLnkgKiBkaXN0YW5jZUZyb21NaWRwb2ludCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmluZCBlbmRwdHMgZm9yIGVkZ2VcbiAgICAgICAgdGhpcy5maW5kRW5kcG9pbnRzKGVkZ2UpO1xuXG4gICAgICAgIHZhciBiYWRTdGFydCA9ICFpcy5udW1iZXIocnMuc3RhcnRYKSB8fCAhaXMubnVtYmVyKHJzLnN0YXJ0WSk7XG4gICAgICAgIHZhciBiYWRBU3RhcnQgPSAhaXMubnVtYmVyKHJzLmFycm93U3RhcnRYKSB8fCAhaXMubnVtYmVyKHJzLmFycm93U3RhcnRZKTtcbiAgICAgICAgdmFyIGJhZEVuZCA9ICFpcy5udW1iZXIocnMuZW5kWCkgfHwgIWlzLm51bWJlcihycy5lbmRZKTtcbiAgICAgICAgdmFyIGJhZEFFbmQgPSAhaXMubnVtYmVyKHJzLmFycm93RW5kWCkgfHwgIWlzLm51bWJlcihycy5hcnJvd0VuZFkpO1xuXG4gICAgICAgIHZhciBtaW5DcEFEaXN0RmFjdG9yID0gMztcbiAgICAgICAgdmFyIGFycm93VyA9IHRoaXMuZ2V0QXJyb3dXaWR0aChlZGdlLnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlLCBlZGdlLnBzdHlsZSgnYXJyb3ctc2NhbGUnKS52YWx1ZSkgKiB0aGlzLmFycm93U2hhcGVXaWR0aDtcbiAgICAgICAgdmFyIG1pbkNwQURpc3QgPSBtaW5DcEFEaXN0RmFjdG9yICogYXJyb3dXO1xuXG4gICAgICAgIGlmIChycy5lZGdlVHlwZSA9PT0gJ2JlemllcicpIHtcbiAgICAgICAgICB2YXIgc3RhcnRBQ3BEaXN0ID0gbWF0aC5kaXN0KHsgeDogcnMuY3RybHB0c1swXSwgeTogcnMuY3RybHB0c1sxXSB9LCB7IHg6IHJzLnN0YXJ0WCwgeTogcnMuc3RhcnRZIH0pO1xuICAgICAgICAgIHZhciBjbG9zZVN0YXJ0QUNwID0gc3RhcnRBQ3BEaXN0IDwgbWluQ3BBRGlzdDtcbiAgICAgICAgICB2YXIgZW5kQUNwRGlzdCA9IG1hdGguZGlzdCh7IHg6IHJzLmN0cmxwdHNbMF0sIHk6IHJzLmN0cmxwdHNbMV0gfSwgeyB4OiBycy5lbmRYLCB5OiBycy5lbmRZIH0pO1xuICAgICAgICAgIHZhciBjbG9zZUVuZEFDcCA9IGVuZEFDcERpc3QgPCBtaW5DcEFEaXN0O1xuXG4gICAgICAgICAgdmFyIG92ZXJsYXBwaW5nID0gZmFsc2U7XG5cbiAgICAgICAgICBpZiAoYmFkU3RhcnQgfHwgYmFkQVN0YXJ0IHx8IGNsb3NlU3RhcnRBQ3ApIHtcbiAgICAgICAgICAgIG92ZXJsYXBwaW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gcHJvamVjdCBjb250cm9sIHBvaW50IGFsb25nIGxpbmUgZnJvbSBzcmMgY2VudHJlIHRvIG91dHNpZGUgdGhlIHNyYyBzaGFwZVxuICAgICAgICAgICAgLy8gKG90aGVyd2lzZSBpbnRlcnNlY3Rpb24gd2lsbCB5aWVsZCBub3RoaW5nKVxuICAgICAgICAgICAgdmFyIGNwRCA9IHsgLy8gZGVsdGFcbiAgICAgICAgICAgICAgeDogcnMuY3RybHB0c1swXSAtIHNyY1Bvcy54LFxuICAgICAgICAgICAgICB5OiBycy5jdHJscHRzWzFdIC0gc3JjUG9zLnlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgY3BMID0gTWF0aC5zcXJ0KGNwRC54ICogY3BELnggKyBjcEQueSAqIGNwRC55KTsgLy8gbGVuZ3RoIG9mIGxpbmVcbiAgICAgICAgICAgIHZhciBjcE0gPSB7IC8vIG5vcm1hbGlzZWQgZGVsdGFcbiAgICAgICAgICAgICAgeDogY3BELnggLyBjcEwsXG4gICAgICAgICAgICAgIHk6IGNwRC55IC8gY3BMXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHJhZGl1cyA9IE1hdGgubWF4KHNyY1csIHNyY0gpO1xuICAgICAgICAgICAgdmFyIGNwUHJvaiA9IHsgLy8gKjIgcmFkaXVzIGd1YXJhbnRlZXMgb3V0c2lkZSBzaGFwZVxuICAgICAgICAgICAgICB4OiBycy5jdHJscHRzWzBdICsgY3BNLnggKiAyICogcmFkaXVzLFxuICAgICAgICAgICAgICB5OiBycy5jdHJscHRzWzFdICsgY3BNLnkgKiAyICogcmFkaXVzXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgc3JjQ3RybFB0SW50biA9IHNyY1NoYXBlLmludGVyc2VjdExpbmUoc3JjUG9zLngsIHNyY1Bvcy55LCBzcmNXLCBzcmNILCBjcFByb2oueCwgY3BQcm9qLnksIDApO1xuXG4gICAgICAgICAgICBpZiAoY2xvc2VTdGFydEFDcCkge1xuICAgICAgICAgICAgICBycy5jdHJscHRzWzBdID0gcnMuY3RybHB0c1swXSArIGNwTS54ICogKG1pbkNwQURpc3QgLSBzdGFydEFDcERpc3QpO1xuICAgICAgICAgICAgICBycy5jdHJscHRzWzFdID0gcnMuY3RybHB0c1sxXSArIGNwTS55ICogKG1pbkNwQURpc3QgLSBzdGFydEFDcERpc3QpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcnMuY3RybHB0c1swXSA9IHNyY0N0cmxQdEludG5bMF0gKyBjcE0ueCAqIG1pbkNwQURpc3Q7XG4gICAgICAgICAgICAgIHJzLmN0cmxwdHNbMV0gPSBzcmNDdHJsUHRJbnRuWzFdICsgY3BNLnkgKiBtaW5DcEFEaXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChiYWRFbmQgfHwgYmFkQUVuZCB8fCBjbG9zZUVuZEFDcCkge1xuICAgICAgICAgICAgb3ZlcmxhcHBpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBwcm9qZWN0IGNvbnRyb2wgcG9pbnQgYWxvbmcgbGluZSBmcm9tIHRndCBjZW50cmUgdG8gb3V0c2lkZSB0aGUgdGd0IHNoYXBlXG4gICAgICAgICAgICAvLyAob3RoZXJ3aXNlIGludGVyc2VjdGlvbiB3aWxsIHlpZWxkIG5vdGhpbmcpXG4gICAgICAgICAgICB2YXIgY3BEID0geyAvLyBkZWx0YVxuICAgICAgICAgICAgICB4OiBycy5jdHJscHRzWzBdIC0gdGd0UG9zLngsXG4gICAgICAgICAgICAgIHk6IHJzLmN0cmxwdHNbMV0gLSB0Z3RQb3MueVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBjcEwgPSBNYXRoLnNxcnQoY3BELnggKiBjcEQueCArIGNwRC55ICogY3BELnkpOyAvLyBsZW5ndGggb2YgbGluZVxuICAgICAgICAgICAgdmFyIGNwTSA9IHsgLy8gbm9ybWFsaXNlZCBkZWx0YVxuICAgICAgICAgICAgICB4OiBjcEQueCAvIGNwTCxcbiAgICAgICAgICAgICAgeTogY3BELnkgLyBjcExcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgcmFkaXVzID0gTWF0aC5tYXgoc3JjVywgc3JjSCk7XG4gICAgICAgICAgICB2YXIgY3BQcm9qID0geyAvLyAqMiByYWRpdXMgZ3VhcmFudGVlcyBvdXRzaWRlIHNoYXBlXG4gICAgICAgICAgICAgIHg6IHJzLmN0cmxwdHNbMF0gKyBjcE0ueCAqIDIgKiByYWRpdXMsXG4gICAgICAgICAgICAgIHk6IHJzLmN0cmxwdHNbMV0gKyBjcE0ueSAqIDIgKiByYWRpdXNcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciB0Z3RDdHJsUHRJbnRuID0gdGd0U2hhcGUuaW50ZXJzZWN0TGluZSh0Z3RQb3MueCwgdGd0UG9zLnksIHRndFcsIHRndEgsIGNwUHJvai54LCBjcFByb2oueSwgMCk7XG5cbiAgICAgICAgICAgIGlmIChjbG9zZUVuZEFDcCkge1xuICAgICAgICAgICAgICBycy5jdHJscHRzWzBdID0gcnMuY3RybHB0c1swXSArIGNwTS54ICogKG1pbkNwQURpc3QgLSBlbmRBQ3BEaXN0KTtcbiAgICAgICAgICAgICAgcnMuY3RybHB0c1sxXSA9IHJzLmN0cmxwdHNbMV0gKyBjcE0ueSAqIChtaW5DcEFEaXN0IC0gZW5kQUNwRGlzdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBycy5jdHJscHRzWzBdID0gdGd0Q3RybFB0SW50blswXSArIGNwTS54ICogbWluQ3BBRGlzdDtcbiAgICAgICAgICAgICAgcnMuY3RybHB0c1sxXSA9IHRndEN0cmxQdEludG5bMV0gKyBjcE0ueSAqIG1pbkNwQURpc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG92ZXJsYXBwaW5nKSB7XG4gICAgICAgICAgICAvLyByZWNhbGMgZW5kcHRzXG4gICAgICAgICAgICB0aGlzLmZpbmRFbmRwb2ludHMoZWRnZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJzLmVkZ2VUeXBlID09PSAnbXVsdGliZXppZXInIHx8IHJzLmVkZ2VUeXBlID09PSAnYmV6aWVyJyB8fCBycy5lZGdlVHlwZSA9PT0gJ3NlbGYnIHx8IHJzLmVkZ2VUeXBlID09PSAnY29tcG91bmQnKSB7XG4gICAgICAgICAgcnMuYWxscHRzID0gW107XG5cbiAgICAgICAgICBycy5hbGxwdHMucHVzaChycy5zdGFydFgsIHJzLnN0YXJ0WSk7XG5cbiAgICAgICAgICBmb3IgKHZhciBiID0gMDsgYiArIDEgPCBycy5jdHJscHRzLmxlbmd0aDsgYiArPSAyKSB7XG4gICAgICAgICAgICAvLyBjdHJsIHB0IGl0c2VsZlxuICAgICAgICAgICAgcnMuYWxscHRzLnB1c2gocnMuY3RybHB0c1tiXSwgcnMuY3RybHB0c1tiICsgMV0pO1xuXG4gICAgICAgICAgICAvLyB0aGUgbWlkcHQgYmV0d2VlbiBjdHJscHRzIGFzIGludGVybWVkaWF0ZSBkZXN0aW5hdGlvbiBwdHNcbiAgICAgICAgICAgIGlmIChiICsgMyA8IHJzLmN0cmxwdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJzLmFsbHB0cy5wdXNoKChycy5jdHJscHRzW2JdICsgcnMuY3RybHB0c1tiICsgMl0pIC8gMiwgKHJzLmN0cmxwdHNbYiArIDFdICsgcnMuY3RybHB0c1tiICsgM10pIC8gMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcnMuYWxscHRzLnB1c2gocnMuZW5kWCwgcnMuZW5kWSk7XG5cbiAgICAgICAgICB2YXIgbSwgbXQ7XG4gICAgICAgICAgaWYgKHJzLmN0cmxwdHMubGVuZ3RoIC8gMiAlIDIgPT09IDApIHtcbiAgICAgICAgICAgIG0gPSBycy5hbGxwdHMubGVuZ3RoIC8gMiAtIDE7XG5cbiAgICAgICAgICAgIHJzLm1pZFggPSBycy5hbGxwdHNbbV07XG4gICAgICAgICAgICBycy5taWRZID0gcnMuYWxscHRzW20gKyAxXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbSA9IHJzLmFsbHB0cy5sZW5ndGggLyAyIC0gMztcbiAgICAgICAgICAgIG10ID0gMC41O1xuXG4gICAgICAgICAgICBycy5taWRYID0gbWF0aC5xYmV6aWVyQXQocnMuYWxscHRzW21dLCBycy5hbGxwdHNbbSArIDJdLCBycy5hbGxwdHNbbSArIDRdLCBtdCk7XG4gICAgICAgICAgICBycy5taWRZID0gbWF0aC5xYmV6aWVyQXQocnMuYWxscHRzW20gKyAxXSwgcnMuYWxscHRzW20gKyAzXSwgcnMuYWxscHRzW20gKyA1XSwgbXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChycy5lZGdlVHlwZSA9PT0gJ3N0cmFpZ2h0Jykge1xuICAgICAgICAgIC8vIG5lZWQgdG8gY2FsYyB0aGVzZSBhZnRlciBlbmRwdHNcbiAgICAgICAgICBycy5hbGxwdHMgPSBbcnMuc3RhcnRYLCBycy5zdGFydFksIHJzLmVuZFgsIHJzLmVuZFldO1xuXG4gICAgICAgICAgLy8gZGVmYXVsdCBtaWRwdCBmb3IgbGFiZWxzIGV0Y1xuICAgICAgICAgIHJzLm1pZFggPSAocnMuc3RhcnRYICsgcnMuZW5kWCArIHJzLmFycm93U3RhcnRYICsgcnMuYXJyb3dFbmRYKSAvIDQ7XG4gICAgICAgICAgcnMubWlkWSA9IChycy5zdGFydFkgKyBycy5lbmRZICsgcnMuYXJyb3dTdGFydFkgKyBycy5hcnJvd0VuZFkpIC8gNDtcbiAgICAgICAgfSBlbHNlIGlmIChycy5lZGdlVHlwZSA9PT0gJ3NlZ21lbnRzJykge1xuICAgICAgICAgIHJzLmFsbHB0cyA9IFtdO1xuICAgICAgICAgIHJzLmFsbHB0cy5wdXNoKHJzLnN0YXJ0WCwgcnMuc3RhcnRZKTtcbiAgICAgICAgICBycy5hbGxwdHMucHVzaC5hcHBseShycy5hbGxwdHMsIHJzLnNlZ3B0cyk7XG4gICAgICAgICAgcnMuYWxscHRzLnB1c2gocnMuZW5kWCwgcnMuZW5kWSk7XG5cbiAgICAgICAgICBpZiAocnMuc2VncHRzLmxlbmd0aCAlIDQgPT09IDApIHtcbiAgICAgICAgICAgIHZhciBpMiA9IHJzLnNlZ3B0cy5sZW5ndGggLyAyO1xuICAgICAgICAgICAgdmFyIGkxID0gaTIgLSAyO1xuXG4gICAgICAgICAgICBycy5taWRYID0gKHJzLnNlZ3B0c1tpMV0gKyBycy5zZWdwdHNbaTJdKSAvIDI7XG4gICAgICAgICAgICBycy5taWRZID0gKHJzLnNlZ3B0c1tpMSArIDFdICsgcnMuc2VncHRzW2kyICsgMV0pIC8gMjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGkxID0gcnMuc2VncHRzLmxlbmd0aCAvIDIgLSAxO1xuXG4gICAgICAgICAgICBycy5taWRYID0gcnMuc2VncHRzW2kxXTtcbiAgICAgICAgICAgIHJzLm1pZFkgPSBycy5zZWdwdHNbaTEgKyAxXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0b3JlRWRnZVByb2plY3Rpb25zKGVkZ2UpO1xuICAgICAgICB0aGlzLmNhbGN1bGF0ZUFycm93QW5nbGVzKGVkZ2UpO1xuICAgICAgfSAvLyBpZiBwb2ludCBjYWNoZSBtaXNzXG5cbiAgICAgIHRoaXMucmVjYWxjdWxhdGVFZGdlTGFiZWxQcm9qZWN0aW9ucyhlZGdlKTtcbiAgICAgIHRoaXMuY2FsY3VsYXRlTGFiZWxBbmdsZXMoZWRnZSk7XG4gICAgfSAvLyBmb3IgcGFpciBlZGdlc1xuICB9IC8vIGZvciBwYWlyIGlkc1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaGF5c3RhY2tFZGdlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlZGdlID0gaGF5c3RhY2tFZGdlc1tpXTtcbiAgICB2YXIgX3AgPSBlZGdlLl9wcml2YXRlO1xuICAgIHZhciByc2NyYXRjaCA9IF9wLnJzY3JhdGNoO1xuICAgIHZhciBycyA9IHJzY3JhdGNoO1xuXG4gICAgaWYgKCFyc2NyYXRjaC5oYXlzdGFjaykge1xuICAgICAgdmFyIGFuZ2xlID0gTWF0aC5yYW5kb20oKSAqIDIgKiBNYXRoLlBJO1xuXG4gICAgICByc2NyYXRjaC5zb3VyY2UgPSB7XG4gICAgICAgIHg6IE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgeTogTWF0aC5zaW4oYW5nbGUpXG4gICAgICB9O1xuXG4gICAgICB2YXIgYW5nbGUgPSBNYXRoLnJhbmRvbSgpICogMiAqIE1hdGguUEk7XG5cbiAgICAgIHJzY3JhdGNoLnRhcmdldCA9IHtcbiAgICAgICAgeDogTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICB5OiBNYXRoLnNpbihhbmdsZSlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIHNyYyA9IF9wLnNvdXJjZTtcbiAgICB2YXIgdGd0ID0gX3AudGFyZ2V0O1xuICAgIHZhciBzcmNQb3MgPSBzcmMucG9zaXRpb24oKTtcbiAgICB2YXIgdGd0UG9zID0gdGd0LnBvc2l0aW9uKCk7XG4gICAgdmFyIHNyY1cgPSBzcmMud2lkdGgoKTtcbiAgICB2YXIgdGd0VyA9IHRndC53aWR0aCgpO1xuICAgIHZhciBzcmNIID0gc3JjLmhlaWdodCgpO1xuICAgIHZhciB0Z3RIID0gdGd0LmhlaWdodCgpO1xuICAgIHZhciByYWRpdXMgPSBlZGdlLnBzdHlsZSgnaGF5c3RhY2stcmFkaXVzJykudmFsdWU7XG4gICAgdmFyIGhhbGZSYWRpdXMgPSByYWRpdXMgLyAyOyAvLyBiL2MgaGF2ZSB0byBoYWxmIHdpZHRoL2hlaWdodFxuXG4gICAgcnMuaGF5c3RhY2tQdHMgPSBycy5hbGxwdHMgPSBbcnMuc291cmNlLnggKiBzcmNXICogaGFsZlJhZGl1cyArIHNyY1Bvcy54LCBycy5zb3VyY2UueSAqIHNyY0ggKiBoYWxmUmFkaXVzICsgc3JjUG9zLnksIHJzLnRhcmdldC54ICogdGd0VyAqIGhhbGZSYWRpdXMgKyB0Z3RQb3MueCwgcnMudGFyZ2V0LnkgKiB0Z3RIICogaGFsZlJhZGl1cyArIHRndFBvcy55XTtcblxuICAgIHJzLm1pZFggPSAocnMuYWxscHRzWzBdICsgcnMuYWxscHRzWzJdKSAvIDI7XG4gICAgcnMubWlkWSA9IChycy5hbGxwdHNbMV0gKyBycy5hbGxwdHNbM10pIC8gMjtcblxuICAgIC8vIGFsd2F5cyBvdmVycmlkZSBhcyBoYXlzdGFjayBpbiBjYXNlIHNldCB0byBkaWZmZXJlbnQgdHlwZSBwcmV2aW91c2x5XG4gICAgcnNjcmF0Y2guZWRnZVR5cGUgPSByc2NyYXRjaC5sYXN0Q3VydmVTdHlsZSA9ICdoYXlzdGFjayc7XG4gICAgcnNjcmF0Y2guaGF5c3RhY2sgPSB0cnVlO1xuXG4gICAgdGhpcy5zdG9yZUVkZ2VQcm9qZWN0aW9ucyhlZGdlKTtcbiAgICB0aGlzLmNhbGN1bGF0ZUFycm93QW5nbGVzKGVkZ2UpO1xuICAgIHRoaXMucmVjYWxjdWxhdGVFZGdlTGFiZWxQcm9qZWN0aW9ucyhlZGdlKTtcbiAgICB0aGlzLmNhbGN1bGF0ZUxhYmVsQW5nbGVzKGVkZ2UpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBnZXRQdHMocHRzKSB7XG4gIHZhciByZXRQdHMgPSBbXTtcblxuICBpZiAocHRzID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHB0cy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciB4ID0gcHRzW2ldO1xuICAgIHZhciB5ID0gcHRzW2kgKyAxXTtcblxuICAgIHJldFB0cy5wdXNoKHsgeDogeCwgeTogeSB9KTtcbiAgfVxuXG4gIHJldHVybiByZXRQdHM7XG59XG5cbkJScC5nZXRTZWdtZW50UG9pbnRzID0gZnVuY3Rpb24gKGVkZ2UpIHtcbiAgdmFyIHJzID0gZWRnZVswXS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgdmFyIHR5cGUgPSBycy5lZGdlVHlwZTtcblxuICBpZiAodHlwZSA9PT0gJ3NlZ21lbnRzJykge1xuICAgIHJldHVybiBnZXRQdHMocnMuc2VncHRzKTtcbiAgfVxufTtcblxuQlJwLmdldENvbnRyb2xQb2ludHMgPSBmdW5jdGlvbiAoZWRnZSkge1xuICB2YXIgcnMgPSBlZGdlWzBdLl9wcml2YXRlLnJzY3JhdGNoO1xuICB2YXIgdHlwZSA9IHJzLmVkZ2VUeXBlO1xuXG4gIGlmICh0eXBlID09PSAnYmV6aWVyJyB8fCB0eXBlID09PSAnbXVsdGliZXppZXInIHx8IHR5cGUgPT09ICdzZWxmJyB8fCB0eXBlID09PSAnY29tcG91bmQnKSB7XG4gICAgcmV0dXJuIGdldFB0cyhycy5jdHJscHRzKTtcbiAgfVxufTtcblxuQlJwLmdldEVkZ2VNaWRwb2ludCA9IGZ1bmN0aW9uIChlZGdlKSB7XG4gIHZhciBycyA9IGVkZ2VbMF0uX3ByaXZhdGUucnNjcmF0Y2g7XG5cbiAgcmV0dXJuIHtcbiAgICB4OiBycy5taWRYLFxuICAgIHk6IHJzLm1pZFlcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQlJwO1xuXG4vKioqLyB9KSxcbi8qIDExMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgbWF0aCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG52YXIgaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgQlJwID0ge307XG5cbkJScC5tYW51YWxFbmRwdFRvUHggPSBmdW5jdGlvbiAobm9kZSwgcHJvcCkge1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBucG9zID0gbm9kZS5wb3NpdGlvbigpO1xuICB2YXIgdyA9IG5vZGUub3V0ZXJXaWR0aCgpO1xuICB2YXIgaCA9IG5vZGUub3V0ZXJIZWlnaHQoKTtcblxuICBpZiAocHJvcC52YWx1ZS5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgcCA9IFtwcm9wLnBmVmFsdWVbMF0sIHByb3AucGZWYWx1ZVsxXV07XG5cbiAgICBpZiAocHJvcC51bml0c1swXSA9PT0gJyUnKSB7XG4gICAgICBwWzBdID0gcFswXSAqIHc7XG4gICAgfVxuXG4gICAgaWYgKHByb3AudW5pdHNbMV0gPT09ICclJykge1xuICAgICAgcFsxXSA9IHBbMV0gKiBoO1xuICAgIH1cblxuICAgIHBbMF0gKz0gbnBvcy54O1xuICAgIHBbMV0gKz0gbnBvcy55O1xuXG4gICAgcmV0dXJuIHA7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGFuZ2xlID0gcHJvcC5wZlZhbHVlWzBdO1xuXG4gICAgYW5nbGUgPSAtTWF0aC5QSSAvIDIgKyBhbmdsZTsgLy8gc3RhcnQgYXQgMTIgbydjbG9ja1xuXG4gICAgdmFyIGwgPSAyICogTWF0aC5tYXgodywgaCk7XG5cbiAgICB2YXIgX3AgPSBbbnBvcy54ICsgTWF0aC5jb3MoYW5nbGUpICogbCwgbnBvcy55ICsgTWF0aC5zaW4oYW5nbGUpICogbF07XG5cbiAgICByZXR1cm4gci5ub2RlU2hhcGVzW3RoaXMuZ2V0Tm9kZVNoYXBlKG5vZGUpXS5pbnRlcnNlY3RMaW5lKG5wb3MueCwgbnBvcy55LCB3LCBoLCBfcFswXSwgX3BbMV0sIDApO1xuICB9XG59O1xuXG5CUnAuZmluZEVuZHBvaW50cyA9IGZ1bmN0aW9uIChlZGdlKSB7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIGludGVyc2VjdCA9IHZvaWQgMDtcblxuICB2YXIgc291cmNlID0gZWRnZS5zb3VyY2UoKVswXTtcbiAgdmFyIHRhcmdldCA9IGVkZ2UudGFyZ2V0KClbMF07XG5cbiAgdmFyIHNyY1BvcyA9IHNvdXJjZS5wb3NpdGlvbigpO1xuICB2YXIgdGd0UG9zID0gdGFyZ2V0LnBvc2l0aW9uKCk7XG5cbiAgdmFyIHRndEFyU2hhcGUgPSBlZGdlLnBzdHlsZSgndGFyZ2V0LWFycm93LXNoYXBlJykudmFsdWU7XG4gIHZhciBzcmNBclNoYXBlID0gZWRnZS5wc3R5bGUoJ3NvdXJjZS1hcnJvdy1zaGFwZScpLnZhbHVlO1xuXG4gIHZhciB0Z3REaXN0ID0gZWRnZS5wc3R5bGUoJ3RhcmdldC1kaXN0YW5jZS1mcm9tLW5vZGUnKS5wZlZhbHVlO1xuICB2YXIgc3JjRGlzdCA9IGVkZ2UucHN0eWxlKCdzb3VyY2UtZGlzdGFuY2UtZnJvbS1ub2RlJykucGZWYWx1ZTtcblxuICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuXG4gIHZhciBldCA9IHJzLmVkZ2VUeXBlO1xuICB2YXIgc2VsZiA9IGV0ID09PSAnc2VsZicgfHwgZXQgPT09ICdjb21wb3VuZCc7XG4gIHZhciBiZXppZXIgPSBldCA9PT0gJ2JlemllcicgfHwgZXQgPT09ICdtdWx0aWJlemllcicgfHwgc2VsZjtcbiAgdmFyIG11bHRpID0gZXQgIT09ICdiZXppZXInO1xuICB2YXIgbGluZXMgPSBldCA9PT0gJ3N0cmFpZ2h0JyB8fCBldCA9PT0gJ3NlZ21lbnRzJztcbiAgdmFyIHNlZ21lbnRzID0gZXQgPT09ICdzZWdtZW50cyc7XG4gIHZhciBoYXNFbmRwdHMgPSBiZXppZXIgfHwgbXVsdGkgfHwgbGluZXM7XG4gIHZhciBzcmNNYW5FbmRwdCA9IGVkZ2UucHN0eWxlKCdzb3VyY2UtZW5kcG9pbnQnKTtcbiAgdmFyIHNyY01hbkVuZHB0VmFsID0gc2VsZiA/ICdvdXRzaWRlLXRvLW5vZGUnIDogc3JjTWFuRW5kcHQudmFsdWU7XG4gIHZhciB0Z3RNYW5FbmRwdCA9IGVkZ2UucHN0eWxlKCd0YXJnZXQtZW5kcG9pbnQnKTtcbiAgdmFyIHRndE1hbkVuZHB0VmFsID0gc2VsZiA/ICdvdXRzaWRlLXRvLW5vZGUnIDogdGd0TWFuRW5kcHQudmFsdWU7XG5cbiAgcnMuc3JjTWFuRW5kcHQgPSBzcmNNYW5FbmRwdDtcbiAgcnMudGd0TWFuRW5kcHQgPSB0Z3RNYW5FbmRwdDtcblxuICB2YXIgcDEgPSB2b2lkIDA7IC8vIGxhc3Qga25vd24gcG9pbnQgb2YgZWRnZSBvbiB0YXJnZXQgc2lkZVxuICB2YXIgcDIgPSB2b2lkIDA7IC8vIGxhc3Qga25vd24gcG9pbnQgb2YgZWRnZSBvbiBzb3VyY2Ugc2lkZVxuXG4gIHZhciBwMV9pID0gdm9pZCAwOyAvLyBwb2ludCB0byBpbnRlcnNlY3Qgd2l0aCB0YXJnZXQgc2hhcGVcbiAgdmFyIHAyX2kgPSB2b2lkIDA7IC8vIHBvaW50IHRvIGludGVyc2VjdCB3aXRoIHNvdXJjZSBzaGFwZVxuXG4gIGlmIChiZXppZXIpIHtcbiAgICB2YXIgY3BTdGFydCA9IFtycy5jdHJscHRzWzBdLCBycy5jdHJscHRzWzFdXTtcbiAgICB2YXIgY3BFbmQgPSBtdWx0aSA/IFtycy5jdHJscHRzW3JzLmN0cmxwdHMubGVuZ3RoIC0gMl0sIHJzLmN0cmxwdHNbcnMuY3RybHB0cy5sZW5ndGggLSAxXV0gOiBjcFN0YXJ0O1xuXG4gICAgcDEgPSBjcEVuZDtcbiAgICBwMiA9IGNwU3RhcnQ7XG4gIH0gZWxzZSBpZiAobGluZXMpIHtcbiAgICB2YXIgc3JjQXJyb3dGcm9tUHQgPSAhc2VnbWVudHMgPyBbdGd0UG9zLngsIHRndFBvcy55XSA6IHJzLnNlZ3B0cy5zbGljZSgwLCAyKTtcbiAgICB2YXIgdGd0QXJyb3dGcm9tUHQgPSAhc2VnbWVudHMgPyBbc3JjUG9zLngsIHNyY1Bvcy55XSA6IHJzLnNlZ3B0cy5zbGljZShycy5zZWdwdHMubGVuZ3RoIC0gMik7XG5cbiAgICBwMSA9IHRndEFycm93RnJvbVB0O1xuICAgIHAyID0gc3JjQXJyb3dGcm9tUHQ7XG4gIH1cblxuICBpZiAodGd0TWFuRW5kcHRWYWwgPT09ICdpbnNpZGUtdG8tbm9kZScpIHtcbiAgICBpbnRlcnNlY3QgPSBbdGd0UG9zLngsIHRndFBvcy55XTtcbiAgfSBlbHNlIGlmICh0Z3RNYW5FbmRwdC51bml0cykge1xuICAgIGludGVyc2VjdCA9IHRoaXMubWFudWFsRW5kcHRUb1B4KHRhcmdldCwgdGd0TWFuRW5kcHQpO1xuICB9IGVsc2UgaWYgKHRndE1hbkVuZHB0VmFsID09PSAnb3V0c2lkZS10by1saW5lJykge1xuICAgIGludGVyc2VjdCA9IHJzLnRndEludG47IC8vIHVzZSBjYWNoZWQgdmFsdWUgZnJvbSBjdHJscHQgY2FsY1xuICB9IGVsc2Uge1xuICAgIGlmICh0Z3RNYW5FbmRwdFZhbCA9PT0gJ291dHNpZGUtdG8tbm9kZScpIHtcbiAgICAgIHAxX2kgPSBwMTtcbiAgICB9IGVsc2UgaWYgKHRndE1hbkVuZHB0VmFsID09PSAnb3V0c2lkZS10by1saW5lJykge1xuICAgICAgcDFfaSA9IFtzcmNQb3MueCwgc3JjUG9zLnldO1xuICAgIH1cblxuICAgIGludGVyc2VjdCA9IHIubm9kZVNoYXBlc1t0aGlzLmdldE5vZGVTaGFwZSh0YXJnZXQpXS5pbnRlcnNlY3RMaW5lKHRndFBvcy54LCB0Z3RQb3MueSwgdGFyZ2V0Lm91dGVyV2lkdGgoKSwgdGFyZ2V0Lm91dGVySGVpZ2h0KCksIHAxX2lbMF0sIHAxX2lbMV0sIDApO1xuICB9XG5cbiAgdmFyIGFycm93RW5kID0gbWF0aC5zaG9ydGVuSW50ZXJzZWN0aW9uKGludGVyc2VjdCwgcDEsIHIuYXJyb3dTaGFwZXNbdGd0QXJTaGFwZV0uc3BhY2luZyhlZGdlKSArIHRndERpc3QpO1xuICB2YXIgZWRnZUVuZCA9IG1hdGguc2hvcnRlbkludGVyc2VjdGlvbihpbnRlcnNlY3QsIHAxLCByLmFycm93U2hhcGVzW3RndEFyU2hhcGVdLmdhcChlZGdlKSArIHRndERpc3QpO1xuXG4gIHJzLmVuZFggPSBlZGdlRW5kWzBdO1xuICBycy5lbmRZID0gZWRnZUVuZFsxXTtcblxuICBycy5hcnJvd0VuZFggPSBhcnJvd0VuZFswXTtcbiAgcnMuYXJyb3dFbmRZID0gYXJyb3dFbmRbMV07XG5cbiAgaWYgKHNyY01hbkVuZHB0VmFsID09PSAnaW5zaWRlLXRvLW5vZGUnKSB7XG4gICAgaW50ZXJzZWN0ID0gW3NyY1Bvcy54LCBzcmNQb3MueV07XG4gIH0gZWxzZSBpZiAoc3JjTWFuRW5kcHQudW5pdHMpIHtcbiAgICBpbnRlcnNlY3QgPSB0aGlzLm1hbnVhbEVuZHB0VG9QeChzb3VyY2UsIHNyY01hbkVuZHB0KTtcbiAgfSBlbHNlIGlmIChzcmNNYW5FbmRwdFZhbCA9PT0gJ291dHNpZGUtdG8tbGluZScpIHtcbiAgICBpbnRlcnNlY3QgPSBycy5zcmNJbnRuOyAvLyB1c2UgY2FjaGVkIHZhbHVlIGZyb20gY3RybHB0IGNhbGNcbiAgfSBlbHNlIHtcbiAgICBpZiAoc3JjTWFuRW5kcHRWYWwgPT09ICdvdXRzaWRlLXRvLW5vZGUnKSB7XG4gICAgICBwMl9pID0gcDI7XG4gICAgfSBlbHNlIGlmIChzcmNNYW5FbmRwdFZhbCA9PT0gJ291dHNpZGUtdG8tbGluZScpIHtcbiAgICAgIHAyX2kgPSBbdGd0UG9zLngsIHRndFBvcy55XTtcbiAgICB9XG5cbiAgICBpbnRlcnNlY3QgPSByLm5vZGVTaGFwZXNbdGhpcy5nZXROb2RlU2hhcGUoc291cmNlKV0uaW50ZXJzZWN0TGluZShzcmNQb3MueCwgc3JjUG9zLnksIHNvdXJjZS5vdXRlcldpZHRoKCksIHNvdXJjZS5vdXRlckhlaWdodCgpLCBwMl9pWzBdLCBwMl9pWzFdLCAwKTtcbiAgfVxuXG4gIHZhciBhcnJvd1N0YXJ0ID0gbWF0aC5zaG9ydGVuSW50ZXJzZWN0aW9uKGludGVyc2VjdCwgcDIsIHIuYXJyb3dTaGFwZXNbc3JjQXJTaGFwZV0uc3BhY2luZyhlZGdlKSArIHNyY0Rpc3QpO1xuICB2YXIgZWRnZVN0YXJ0ID0gbWF0aC5zaG9ydGVuSW50ZXJzZWN0aW9uKGludGVyc2VjdCwgcDIsIHIuYXJyb3dTaGFwZXNbc3JjQXJTaGFwZV0uZ2FwKGVkZ2UpICsgc3JjRGlzdCk7XG5cbiAgcnMuc3RhcnRYID0gZWRnZVN0YXJ0WzBdO1xuICBycy5zdGFydFkgPSBlZGdlU3RhcnRbMV07XG5cbiAgcnMuYXJyb3dTdGFydFggPSBhcnJvd1N0YXJ0WzBdO1xuICBycy5hcnJvd1N0YXJ0WSA9IGFycm93U3RhcnRbMV07XG5cbiAgaWYgKGhhc0VuZHB0cykge1xuICAgIGlmICghaXMubnVtYmVyKHJzLnN0YXJ0WCkgfHwgIWlzLm51bWJlcihycy5zdGFydFkpIHx8ICFpcy5udW1iZXIocnMuZW5kWCkgfHwgIWlzLm51bWJlcihycy5lbmRZKSkge1xuICAgICAgcnMuYmFkTGluZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJzLmJhZExpbmUgPSBmYWxzZTtcbiAgICB9XG4gIH1cbn07XG5cbkJScC5nZXRTb3VyY2VFbmRwb2ludCA9IGZ1bmN0aW9uIChlZGdlKSB7XG4gIHZhciBycyA9IGVkZ2VbMF0uX3ByaXZhdGUucnNjcmF0Y2g7XG5cbiAgc3dpdGNoIChycy5lZGdlVHlwZSkge1xuICAgIGNhc2UgJ2hheXN0YWNrJzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHJzLmhheXN0YWNrUHRzWzBdLFxuICAgICAgICB5OiBycy5oYXlzdGFja1B0c1sxXVxuICAgICAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogcnMuYXJyb3dTdGFydFgsXG4gICAgICAgIHk6IHJzLmFycm93U3RhcnRZXG4gICAgICB9O1xuICB9XG59O1xuXG5CUnAuZ2V0VGFyZ2V0RW5kcG9pbnQgPSBmdW5jdGlvbiAoZWRnZSkge1xuICB2YXIgcnMgPSBlZGdlWzBdLl9wcml2YXRlLnJzY3JhdGNoO1xuXG4gIHN3aXRjaCAocnMuZWRnZVR5cGUpIHtcbiAgICBjYXNlICdoYXlzdGFjayc6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBycy5oYXlzdGFja1B0c1syXSxcbiAgICAgICAgeTogcnMuaGF5c3RhY2tQdHNbM11cbiAgICAgIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHJzLmFycm93RW5kWCxcbiAgICAgICAgeTogcnMuYXJyb3dFbmRZXG4gICAgICB9O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJScDtcblxuLyoqKi8gfSksXG4vKiAxMTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIG1hdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgQlJwID0ge307XG5cbmZ1bmN0aW9uIHB1c2hCZXppZXJQdHMociwgZWRnZSwgcHRzKSB7XG4gIHZhciBxYmV6aWVyQXQgPSBmdW5jdGlvbiBxYmV6aWVyQXQocDEsIHAyLCBwMywgdCkge1xuICAgIHJldHVybiBtYXRoLnFiZXppZXJBdChwMSwgcDIsIHAzLCB0KTtcbiAgfTtcbiAgdmFyIF9wID0gZWRnZS5fcHJpdmF0ZTtcbiAgdmFyIGJwdHMgPSBfcC5yc3R5bGUuYmV6aWVyUHRzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgci5iZXppZXJQcm9qUGN0cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwID0gci5iZXppZXJQcm9qUGN0c1tpXTtcblxuICAgIGJwdHMucHVzaCh7XG4gICAgICB4OiBxYmV6aWVyQXQocHRzWzBdLCBwdHNbMl0sIHB0c1s0XSwgcCksXG4gICAgICB5OiBxYmV6aWVyQXQocHRzWzFdLCBwdHNbM10sIHB0c1s1XSwgcClcbiAgICB9KTtcbiAgfVxufVxuXG5CUnAuc3RvcmVFZGdlUHJvamVjdGlvbnMgPSBmdW5jdGlvbiAoZWRnZSkge1xuICB2YXIgX3AgPSBlZGdlLl9wcml2YXRlO1xuICB2YXIgcnMgPSBfcC5yc2NyYXRjaDtcbiAgdmFyIGV0ID0gcnMuZWRnZVR5cGU7XG5cbiAgLy8gY2xlYXIgdGhlIGNhY2hlZCBwb2ludHMgc3RhdGVcbiAgX3AucnN0eWxlLmJlemllclB0cyA9IG51bGw7XG4gIF9wLnJzdHlsZS5saW5lUHRzID0gbnVsbDtcbiAgX3AucnN0eWxlLmhheXN0YWNrUHRzID0gbnVsbDtcblxuICBpZiAoZXQgPT09ICdtdWx0aWJlemllcicgfHwgZXQgPT09ICdiZXppZXInIHx8IGV0ID09PSAnc2VsZicgfHwgZXQgPT09ICdjb21wb3VuZCcpIHtcbiAgICB2YXIgYnB0cyA9IF9wLnJzdHlsZS5iZXppZXJQdHMgPSBbXTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSArIDUgPCBycy5hbGxwdHMubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgIHB1c2hCZXppZXJQdHModGhpcywgZWRnZSwgcnMuYWxscHRzLnNsaWNlKGksIGkgKyA2KSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGV0ID09PSAnc2VnbWVudHMnKSB7XG4gICAgdmFyIGxwdHMgPSBfcC5yc3R5bGUubGluZVB0cyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgKyAxIDwgcnMuYWxscHRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBscHRzLnB1c2goe1xuICAgICAgICB4OiBycy5hbGxwdHNbaV0sXG4gICAgICAgIHk6IHJzLmFsbHB0c1tpICsgMV1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIGlmIChldCA9PT0gJ2hheXN0YWNrJykge1xuICAgIHZhciBocHRzID0gcnMuaGF5c3RhY2tQdHM7XG5cbiAgICBfcC5yc3R5bGUuaGF5c3RhY2tQdHMgPSBbeyB4OiBocHRzWzBdLCB5OiBocHRzWzFdIH0sIHsgeDogaHB0c1syXSwgeTogaHB0c1szXSB9XTtcbiAgfVxuXG4gIF9wLnJzdHlsZS5hcnJvd1dpZHRoID0gdGhpcy5nZXRBcnJvd1dpZHRoKGVkZ2UucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWUsIGVkZ2UucHN0eWxlKCdhcnJvdy1zY2FsZScpLnZhbHVlKSAqIHRoaXMuYXJyb3dTaGFwZVdpZHRoO1xufTtcblxuQlJwLnJlY2FsY3VsYXRlRWRnZVByb2plY3Rpb25zID0gZnVuY3Rpb24gKGVkZ2VzKSB7XG4gIHRoaXMuZmluZEVkZ2VDb250cm9sUG9pbnRzKGVkZ2VzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQlJwO1xuXG4vKioqLyB9KSxcbi8qIDExNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgbWF0aCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG52YXIgaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgQlJwID0ge307XG5cbkJScC5yZWNhbGN1bGF0ZU5vZGVMYWJlbFByb2plY3Rpb24gPSBmdW5jdGlvbiAobm9kZSkge1xuICB2YXIgY29udGVudCA9IG5vZGUucHN0eWxlKCdsYWJlbCcpLnN0clZhbHVlO1xuXG4gIGlmIChpcy5lbXB0eVN0cmluZyhjb250ZW50KSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciB0ZXh0WCwgdGV4dFk7XG4gIHZhciBfcCA9IG5vZGUuX3ByaXZhdGU7XG4gIHZhciBub2RlV2lkdGggPSBub2RlLndpZHRoKCk7XG4gIHZhciBub2RlSGVpZ2h0ID0gbm9kZS5oZWlnaHQoKTtcbiAgdmFyIHBhZGRpbmcgPSBub2RlLnBhZGRpbmcoKTtcbiAgdmFyIG5vZGVQb3MgPSBub2RlLnBvc2l0aW9uKCk7XG4gIHZhciB0ZXh0SGFsaWduID0gbm9kZS5wc3R5bGUoJ3RleHQtaGFsaWduJykuc3RyVmFsdWU7XG4gIHZhciB0ZXh0VmFsaWduID0gbm9kZS5wc3R5bGUoJ3RleHQtdmFsaWduJykuc3RyVmFsdWU7XG4gIHZhciBycyA9IF9wLnJzY3JhdGNoO1xuICB2YXIgcnN0eWxlID0gX3AucnN0eWxlO1xuXG4gIHN3aXRjaCAodGV4dEhhbGlnbikge1xuICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgdGV4dFggPSBub2RlUG9zLnggLSBub2RlV2lkdGggLyAyIC0gcGFkZGluZztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncmlnaHQnOlxuICAgICAgdGV4dFggPSBub2RlUG9zLnggKyBub2RlV2lkdGggLyAyICsgcGFkZGluZztcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIGUuZy4gY2VudGVyXG4gICAgICB0ZXh0WCA9IG5vZGVQb3MueDtcbiAgfVxuXG4gIHN3aXRjaCAodGV4dFZhbGlnbikge1xuICAgIGNhc2UgJ3RvcCc6XG4gICAgICB0ZXh0WSA9IG5vZGVQb3MueSAtIG5vZGVIZWlnaHQgLyAyIC0gcGFkZGluZztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYm90dG9tJzpcbiAgICAgIHRleHRZID0gbm9kZVBvcy55ICsgbm9kZUhlaWdodCAvIDIgKyBwYWRkaW5nO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgLy8gZS5nLiBtaWRkbGVcbiAgICAgIHRleHRZID0gbm9kZVBvcy55O1xuICB9XG5cbiAgcnMubGFiZWxYID0gdGV4dFg7XG4gIHJzLmxhYmVsWSA9IHRleHRZO1xuICByc3R5bGUubGFiZWxYID0gdGV4dFg7XG4gIHJzdHlsZS5sYWJlbFkgPSB0ZXh0WTtcblxuICB0aGlzLmFwcGx5TGFiZWxEaW1lbnNpb25zKG5vZGUpO1xufTtcblxudmFyIGxpbmVBbmdsZUZyb21EZWx0YSA9IGZ1bmN0aW9uIGxpbmVBbmdsZUZyb21EZWx0YShkeCwgZHkpIHtcbiAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuKGR5IC8gZHgpO1xuXG4gIGlmIChkeCA9PT0gMCAmJiBhbmdsZSA8IDApIHtcbiAgICBhbmdsZSA9IGFuZ2xlICogLTE7XG4gIH1cblxuICByZXR1cm4gYW5nbGU7XG59O1xuXG52YXIgbGluZUFuZ2xlID0gZnVuY3Rpb24gbGluZUFuZ2xlKHAwLCBwMSkge1xuICB2YXIgZHggPSBwMS54IC0gcDAueDtcbiAgdmFyIGR5ID0gcDEueSAtIHAwLnk7XG5cbiAgcmV0dXJuIGxpbmVBbmdsZUZyb21EZWx0YShkeCwgZHkpO1xufTtcblxudmFyIGJlemllckFuZ2xlID0gZnVuY3Rpb24gYmV6aWVyQW5nbGUocDAsIHAxLCBwMiwgdCkge1xuICB2YXIgdDAgPSBtYXRoLmJvdW5kKDAsIHQgLSAwLjAwMSwgMSk7XG4gIHZhciB0MSA9IG1hdGguYm91bmQoMCwgdCArIDAuMDAxLCAxKTtcblxuICB2YXIgbHAwID0gbWF0aC5xYmV6aWVyUHRBdChwMCwgcDEsIHAyLCB0MCk7XG4gIHZhciBscDEgPSBtYXRoLnFiZXppZXJQdEF0KHAwLCBwMSwgcDIsIHQxKTtcblxuICByZXR1cm4gbGluZUFuZ2xlKGxwMCwgbHAxKTtcbn07XG5cbkJScC5yZWNhbGN1bGF0ZUVkZ2VMYWJlbFByb2plY3Rpb25zID0gZnVuY3Rpb24gKGVkZ2UpIHtcbiAgdmFyIHA7XG4gIHZhciBfcCA9IGVkZ2UuX3ByaXZhdGU7XG4gIHZhciBycyA9IF9wLnJzY3JhdGNoO1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBjb250ZW50ID0ge1xuICAgIG1pZDogZWRnZS5wc3R5bGUoJ2xhYmVsJykuc3RyVmFsdWUsXG4gICAgc291cmNlOiBlZGdlLnBzdHlsZSgnc291cmNlLWxhYmVsJykuc3RyVmFsdWUsXG4gICAgdGFyZ2V0OiBlZGdlLnBzdHlsZSgndGFyZ2V0LWxhYmVsJykuc3RyVmFsdWVcbiAgfTtcblxuICBpZiAoY29udGVudC5taWQgfHwgY29udGVudC5zb3VyY2UgfHwgY29udGVudC50YXJnZXQpIHtcbiAgICAvLyB0aGVuIHdlIGhhdmUgdG8gY2FsY3VsYXRlLi4uXG4gIH0gZWxzZSB7XG4gICAgICByZXR1cm47IC8vIG5vIGxhYmVscyA9PiBubyBjYWxjc1xuICAgIH1cblxuICAvLyBhZGQgY2VudGVyIHBvaW50IHRvIHN0eWxlIHNvIGJvdW5kaW5nIGJveCBjYWxjdWxhdGlvbnMgY2FuIHVzZSBpdFxuICAvL1xuICBwID0ge1xuICAgIHg6IHJzLm1pZFgsXG4gICAgeTogcnMubWlkWVxuICB9O1xuXG4gIHZhciBzZXRScyA9IGZ1bmN0aW9uIHNldFJzKHByb3BOYW1lLCBwcmVmaXgsIHZhbHVlKSB7XG4gICAgdXRpbC5zZXRQcmVmaXhlZFByb3BlcnR5KF9wLnJzY3JhdGNoLCBwcm9wTmFtZSwgcHJlZml4LCB2YWx1ZSk7XG4gICAgdXRpbC5zZXRQcmVmaXhlZFByb3BlcnR5KF9wLnJzdHlsZSwgcHJvcE5hbWUsIHByZWZpeCwgdmFsdWUpO1xuICB9O1xuXG4gIHNldFJzKCdsYWJlbFgnLCBudWxsLCBwLngpO1xuICBzZXRScygnbGFiZWxZJywgbnVsbCwgcC55KTtcblxuICB2YXIgbWlkQW5nbGUgPSBsaW5lQW5nbGVGcm9tRGVsdGEocnMubWlkRGlzcFgsIHJzLm1pZERpc3BZKTtcbiAgc2V0UnMoJ2xhYmVsQXV0b0FuZ2xlJywgbnVsbCwgbWlkQW5nbGUpO1xuXG4gIHZhciBjcmVhdGVDb250cm9sUG9pbnRJbmZvID0gZnVuY3Rpb24gY3JlYXRlQ29udHJvbFBvaW50SW5mbygpIHtcbiAgICBpZiAoY3JlYXRlQ29udHJvbFBvaW50SW5mby5jYWNoZSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUNvbnRyb2xQb2ludEluZm8uY2FjaGU7XG4gICAgfSAvLyB1c2UgY2FjaGUgc28gb25seSAxeCBwZXIgZWRnZVxuXG4gICAgdmFyIGN0cmxwdHMgPSBbXTtcblxuICAgIC8vIHN0b3JlIGVhY2ggY3RybHB0IGluZm8gaW5pdFxuICAgIGZvciAodmFyIGkgPSAwOyBpICsgNSA8IHJzLmFsbHB0cy5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgdmFyIHAwID0geyB4OiBycy5hbGxwdHNbaV0sIHk6IHJzLmFsbHB0c1tpICsgMV0gfTtcbiAgICAgIHZhciBwMSA9IHsgeDogcnMuYWxscHRzW2kgKyAyXSwgeTogcnMuYWxscHRzW2kgKyAzXSB9OyAvLyBjdHJscHRcbiAgICAgIHZhciBwMiA9IHsgeDogcnMuYWxscHRzW2kgKyA0XSwgeTogcnMuYWxscHRzW2kgKyA1XSB9O1xuXG4gICAgICBjdHJscHRzLnB1c2goe1xuICAgICAgICBwMDogcDAsXG4gICAgICAgIHAxOiBwMSxcbiAgICAgICAgcDI6IHAyLFxuICAgICAgICBzdGFydERpc3Q6IDAsXG4gICAgICAgIGxlbmd0aDogMCxcbiAgICAgICAgc2VnbWVudHM6IFtdXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgYnB0cyA9IF9wLnJzdHlsZS5iZXppZXJQdHM7XG4gICAgdmFyIG5Qcm9qcyA9IHIuYmV6aWVyUHJvalBjdHMubGVuZ3RoO1xuXG4gICAgZnVuY3Rpb24gYWRkU2VnbWVudChjcCwgcDAsIHAxLCB0MCwgdDEpIHtcbiAgICAgIHZhciBsZW5ndGggPSBtYXRoLmRpc3QocDAsIHAxKTtcbiAgICAgIHZhciBwcmV2U2VnbWVudCA9IGNwLnNlZ21lbnRzW2NwLnNlZ21lbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgdmFyIHNlZ21lbnQgPSB7XG4gICAgICAgIHAwOiBwMCxcbiAgICAgICAgcDE6IHAxLFxuICAgICAgICB0MDogdDAsXG4gICAgICAgIHQxOiB0MSxcbiAgICAgICAgc3RhcnREaXN0OiBwcmV2U2VnbWVudCA/IHByZXZTZWdtZW50LnN0YXJ0RGlzdCArIHByZXZTZWdtZW50Lmxlbmd0aCA6IDAsXG4gICAgICAgIGxlbmd0aDogbGVuZ3RoXG4gICAgICB9O1xuXG4gICAgICBjcC5zZWdtZW50cy5wdXNoKHNlZ21lbnQpO1xuXG4gICAgICBjcC5sZW5ndGggKz0gbGVuZ3RoO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBlYWNoIGN0cmxwdCB3aXRoIHNlZ21lbnQgaW5mb1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3RybHB0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNwID0gY3RybHB0c1tpXTtcbiAgICAgIHZhciBwcmV2Q3AgPSBjdHJscHRzW2kgLSAxXTtcblxuICAgICAgaWYgKHByZXZDcCkge1xuICAgICAgICBjcC5zdGFydERpc3QgPSBwcmV2Q3Auc3RhcnREaXN0ICsgcHJldkNwLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgYWRkU2VnbWVudChjcCwgY3AucDAsIGJwdHNbaSAqIG5Qcm9qc10sIDAsIHIuYmV6aWVyUHJvalBjdHNbMF0pOyAvLyBmaXJzdFxuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5Qcm9qcyAtIDE7IGorKykge1xuICAgICAgICBhZGRTZWdtZW50KGNwLCBicHRzW2kgKiBuUHJvanMgKyBqXSwgYnB0c1tpICogblByb2pzICsgaiArIDFdLCByLmJlemllclByb2pQY3RzW2pdLCByLmJlemllclByb2pQY3RzW2ogKyAxXSk7XG4gICAgICB9XG5cbiAgICAgIGFkZFNlZ21lbnQoY3AsIGJwdHNbaSAqIG5Qcm9qcyArIG5Qcm9qcyAtIDFdLCBjcC5wMiwgci5iZXppZXJQcm9qUGN0c1tuUHJvanMgLSAxXSwgMSk7IC8vIGxhc3RcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlQ29udHJvbFBvaW50SW5mby5jYWNoZSA9IGN0cmxwdHM7XG4gIH07XG5cbiAgdmFyIGNhbGN1bGF0ZUVuZFByb2plY3Rpb24gPSBmdW5jdGlvbiBjYWxjdWxhdGVFbmRQcm9qZWN0aW9uKHByZWZpeCkge1xuICAgIHZhciBhbmdsZTtcbiAgICB2YXIgaXNTcmMgPSBwcmVmaXggPT09ICdzb3VyY2UnO1xuXG4gICAgaWYgKCFjb250ZW50W3ByZWZpeF0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgb2Zmc2V0ID0gZWRnZS5wc3R5bGUocHJlZml4ICsgJy10ZXh0LW9mZnNldCcpLnBmVmFsdWU7XG5cbiAgICBzd2l0Y2ggKHJzLmVkZ2VUeXBlKSB7XG4gICAgICBjYXNlICdzZWxmJzpcbiAgICAgIGNhc2UgJ2NvbXBvdW5kJzpcbiAgICAgIGNhc2UgJ2Jlemllcic6XG4gICAgICBjYXNlICdtdWx0aWJlemllcic6XG4gICAgICAgIHZhciBjcHMgPSBjcmVhdGVDb250cm9sUG9pbnRJbmZvKCk7XG4gICAgICAgIHZhciBzZWxlY3RlZDtcbiAgICAgICAgdmFyIHN0YXJ0RGlzdCA9IDA7XG4gICAgICAgIHZhciB0b3RhbERpc3QgPSAwO1xuXG4gICAgICAgIC8vIGZpbmQgdGhlIHNlZ21lbnQgd2UncmUgb25cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgY3AgPSBjcHNbaXNTcmMgPyBpIDogY3BzLmxlbmd0aCAtIDEgLSBpXTtcblxuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY3Auc2VnbWVudHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBzZWcgPSBjcC5zZWdtZW50c1tpc1NyYyA/IGogOiBjcC5zZWdtZW50cy5sZW5ndGggLSAxIC0gal07XG4gICAgICAgICAgICB2YXIgbGFzdFNlZyA9IGkgPT09IGNwcy5sZW5ndGggLSAxICYmIGogPT09IGNwLnNlZ21lbnRzLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgICAgIHN0YXJ0RGlzdCA9IHRvdGFsRGlzdDtcbiAgICAgICAgICAgIHRvdGFsRGlzdCArPSBzZWcubGVuZ3RoO1xuXG4gICAgICAgICAgICBpZiAodG90YWxEaXN0ID49IG9mZnNldCB8fCBsYXN0U2VnKSB7XG4gICAgICAgICAgICAgIHNlbGVjdGVkID0geyBjcDogY3AsIHNlZ21lbnQ6IHNlZyB9O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjcCA9IHNlbGVjdGVkLmNwO1xuICAgICAgICB2YXIgc2VnID0gc2VsZWN0ZWQuc2VnbWVudDtcbiAgICAgICAgdmFyIHRTZWdtZW50ID0gKG9mZnNldCAtIHN0YXJ0RGlzdCkgLyBzZWcubGVuZ3RoO1xuICAgICAgICB2YXIgc2VnRHQgPSBzZWcudDEgLSBzZWcudDA7XG4gICAgICAgIHZhciB0ID0gaXNTcmMgPyBzZWcudDAgKyBzZWdEdCAqIHRTZWdtZW50IDogc2VnLnQxIC0gc2VnRHQgKiB0U2VnbWVudDtcblxuICAgICAgICB0ID0gbWF0aC5ib3VuZCgwLCB0LCAxKTtcbiAgICAgICAgcCA9IG1hdGgucWJlemllclB0QXQoY3AucDAsIGNwLnAxLCBjcC5wMiwgdCk7XG4gICAgICAgIGFuZ2xlID0gYmV6aWVyQW5nbGUoY3AucDAsIGNwLnAxLCBjcC5wMiwgdCwgcCk7XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3N0cmFpZ2h0JzpcbiAgICAgIGNhc2UgJ3NlZ21lbnRzJzpcbiAgICAgIGNhc2UgJ2hheXN0YWNrJzpcbiAgICAgICAgdmFyIGQgPSAwLFxuICAgICAgICAgICAgZGksXG4gICAgICAgICAgICBkMDtcbiAgICAgICAgdmFyIHAwLCBwMTtcbiAgICAgICAgdmFyIGwgPSBycy5hbGxwdHMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpICsgMyA8IGw7IGkgKz0gMikge1xuICAgICAgICAgIGlmIChpc1NyYykge1xuICAgICAgICAgICAgcDAgPSB7IHg6IHJzLmFsbHB0c1tpXSwgeTogcnMuYWxscHRzW2kgKyAxXSB9O1xuICAgICAgICAgICAgcDEgPSB7IHg6IHJzLmFsbHB0c1tpICsgMl0sIHk6IHJzLmFsbHB0c1tpICsgM10gfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcDAgPSB7IHg6IHJzLmFsbHB0c1tsIC0gMiAtIGldLCB5OiBycy5hbGxwdHNbbCAtIDEgLSBpXSB9O1xuICAgICAgICAgICAgcDEgPSB7IHg6IHJzLmFsbHB0c1tsIC0gNCAtIGldLCB5OiBycy5hbGxwdHNbbCAtIDMgLSBpXSB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRpID0gbWF0aC5kaXN0KHAwLCBwMSk7XG4gICAgICAgICAgZDAgPSBkO1xuICAgICAgICAgIGQgKz0gZGk7XG5cbiAgICAgICAgICBpZiAoZCA+PSBvZmZzZXQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwRCA9IG9mZnNldCAtIGQwO1xuICAgICAgICB2YXIgdCA9IHBEIC8gZGk7XG5cbiAgICAgICAgdCA9IG1hdGguYm91bmQoMCwgdCwgMSk7XG4gICAgICAgIHAgPSBtYXRoLmxpbmVBdChwMCwgcDEsIHQpO1xuICAgICAgICBhbmdsZSA9IGxpbmVBbmdsZShwMCwgcDEpO1xuXG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHNldFJzKCdsYWJlbFgnLCBwcmVmaXgsIHAueCk7XG4gICAgc2V0UnMoJ2xhYmVsWScsIHByZWZpeCwgcC55KTtcbiAgICBzZXRScygnbGFiZWxBdXRvQW5nbGUnLCBwcmVmaXgsIGFuZ2xlKTtcbiAgfTtcblxuICBjYWxjdWxhdGVFbmRQcm9qZWN0aW9uKCdzb3VyY2UnKTtcbiAgY2FsY3VsYXRlRW5kUHJvamVjdGlvbigndGFyZ2V0Jyk7XG5cbiAgdGhpcy5hcHBseUxhYmVsRGltZW5zaW9ucyhlZGdlKTtcbn07XG5cbkJScC5hcHBseUxhYmVsRGltZW5zaW9ucyA9IGZ1bmN0aW9uIChlbGUpIHtcbiAgdGhpcy5hcHBseVByZWZpeGVkTGFiZWxEaW1lbnNpb25zKGVsZSk7XG5cbiAgaWYgKGVsZS5pc0VkZ2UoKSkge1xuICAgIHRoaXMuYXBwbHlQcmVmaXhlZExhYmVsRGltZW5zaW9ucyhlbGUsICdzb3VyY2UnKTtcbiAgICB0aGlzLmFwcGx5UHJlZml4ZWRMYWJlbERpbWVuc2lvbnMoZWxlLCAndGFyZ2V0Jyk7XG4gIH1cbn07XG5cbkJScC5hcHBseVByZWZpeGVkTGFiZWxEaW1lbnNpb25zID0gZnVuY3Rpb24gKGVsZSwgcHJlZml4KSB7XG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcblxuICB2YXIgdGV4dCA9IHRoaXMuZ2V0TGFiZWxUZXh0KGVsZSwgcHJlZml4KTtcbiAgdmFyIGxhYmVsRGltcyA9IHRoaXMuY2FsY3VsYXRlTGFiZWxEaW1lbnNpb25zKGVsZSwgdGV4dCk7XG5cbiAgdXRpbC5zZXRQcmVmaXhlZFByb3BlcnR5KF9wLnJzdHlsZSwgJ2xhYmVsV2lkdGgnLCBwcmVmaXgsIGxhYmVsRGltcy53aWR0aCk7XG4gIHV0aWwuc2V0UHJlZml4ZWRQcm9wZXJ0eShfcC5yc2NyYXRjaCwgJ2xhYmVsV2lkdGgnLCBwcmVmaXgsIGxhYmVsRGltcy53aWR0aCk7XG5cbiAgdXRpbC5zZXRQcmVmaXhlZFByb3BlcnR5KF9wLnJzdHlsZSwgJ2xhYmVsSGVpZ2h0JywgcHJlZml4LCBsYWJlbERpbXMuaGVpZ2h0KTtcbiAgdXRpbC5zZXRQcmVmaXhlZFByb3BlcnR5KF9wLnJzY3JhdGNoLCAnbGFiZWxIZWlnaHQnLCBwcmVmaXgsIGxhYmVsRGltcy5oZWlnaHQpO1xufTtcblxuQlJwLmdldExhYmVsVGV4dCA9IGZ1bmN0aW9uIChlbGUsIHByZWZpeCkge1xuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciBwZmQgPSBwcmVmaXggPyBwcmVmaXggKyAnLScgOiAnJztcbiAgdmFyIHRleHQgPSBlbGUucHN0eWxlKHBmZCArICdsYWJlbCcpLnN0clZhbHVlO1xuICB2YXIgdGV4dFRyYW5zZm9ybSA9IGVsZS5wc3R5bGUoJ3RleHQtdHJhbnNmb3JtJykudmFsdWU7XG4gIHZhciByc2NyYXRjaCA9IGZ1bmN0aW9uIHJzY3JhdGNoKHByb3BOYW1lLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdXRpbC5zZXRQcmVmaXhlZFByb3BlcnR5KF9wLnJzY3JhdGNoLCBwcm9wTmFtZSwgcHJlZml4LCB2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB1dGlsLmdldFByZWZpeGVkUHJvcGVydHkoX3AucnNjcmF0Y2gsIHByb3BOYW1lLCBwcmVmaXgpO1xuICAgIH1cbiAgfTtcblxuICAvLyBmb3IgZW1wdHkgdGV4dCwgc2tpcCBhbGwgcHJvY2Vzc2luZ1xuICBpZiAoIXRleHQpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodGV4dFRyYW5zZm9ybSA9PSAnbm9uZScpIHtcbiAgICAvLyBwYXNzdGhyb3VnaFxuICB9IGVsc2UgaWYgKHRleHRUcmFuc2Zvcm0gPT0gJ3VwcGVyY2FzZScpIHtcbiAgICB0ZXh0ID0gdGV4dC50b1VwcGVyQ2FzZSgpO1xuICB9IGVsc2UgaWYgKHRleHRUcmFuc2Zvcm0gPT0gJ2xvd2VyY2FzZScpIHtcbiAgICB0ZXh0ID0gdGV4dC50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgdmFyIHdyYXBTdHlsZSA9IGVsZS5wc3R5bGUoJ3RleHQtd3JhcCcpLnZhbHVlO1xuXG4gIGlmICh3cmFwU3R5bGUgPT09ICd3cmFwJykge1xuICAgIC8vY29uc29sZS5sb2coJ3dyYXAnKTtcblxuICAgIHZhciBsYWJlbEtleSA9IHJzY3JhdGNoKCdsYWJlbEtleScpO1xuXG4gICAgLy8gc2F2ZSByZWNhbGMgaWYgdGhlIGxhYmVsIGlzIHRoZSBzYW1lIGFzIGJlZm9yZVxuICAgIGlmIChsYWJlbEtleSAmJiByc2NyYXRjaCgnbGFiZWxXcmFwS2V5JykgPT09IGxhYmVsS2V5KSB7XG4gICAgICAvLyBjb25zb2xlLmxvZygnd3JhcCBjYWNoZSBoaXQnKTtcbiAgICAgIHJldHVybiByc2NyYXRjaCgnbGFiZWxXcmFwQ2FjaGVkVGV4dCcpO1xuICAgIH1cbiAgICAvLyBjb25zb2xlLmxvZygnd3JhcCBjYWNoZSBtaXNzJyk7XG5cbiAgICB2YXIgbGluZXMgPSB0ZXh0LnNwbGl0KCdcXG4nKTtcbiAgICB2YXIgbWF4VyA9IGVsZS5wc3R5bGUoJ3RleHQtbWF4LXdpZHRoJykucGZWYWx1ZTtcbiAgICB2YXIgd3JhcHBlZExpbmVzID0gW107XG5cbiAgICBmb3IgKHZhciBsID0gMDsgbCA8IGxpbmVzLmxlbmd0aDsgbCsrKSB7XG4gICAgICB2YXIgbGluZSA9IGxpbmVzW2xdO1xuICAgICAgdmFyIGxpbmVEaW1zID0gdGhpcy5jYWxjdWxhdGVMYWJlbERpbWVuc2lvbnMoZWxlLCBsaW5lLCAnbGluZT0nICsgbGluZSk7XG4gICAgICB2YXIgbGluZVcgPSBsaW5lRGltcy53aWR0aDtcblxuICAgICAgaWYgKGxpbmVXID4gbWF4Vykge1xuICAgICAgICAvLyBsaW5lIGlzIHRvbyBsb25nXG4gICAgICAgIHZhciB3b3JkcyA9IGxpbmUuc3BsaXQoL1xccysvKTsgLy8gTkI6IGFzc3VtZSBjb2xsYXBzZWQgd2hpdGVzcGFjZSBpbnRvIHNpbmdsZSBzcGFjZVxuICAgICAgICB2YXIgc3VibGluZSA9ICcnO1xuXG4gICAgICAgIGZvciAodmFyIHcgPSAwOyB3IDwgd29yZHMubGVuZ3RoOyB3KyspIHtcbiAgICAgICAgICB2YXIgd29yZCA9IHdvcmRzW3ddO1xuICAgICAgICAgIHZhciB0ZXN0TGluZSA9IHN1YmxpbmUubGVuZ3RoID09PSAwID8gd29yZCA6IHN1YmxpbmUgKyAnICcgKyB3b3JkO1xuICAgICAgICAgIHZhciB0ZXN0RGltcyA9IHRoaXMuY2FsY3VsYXRlTGFiZWxEaW1lbnNpb25zKGVsZSwgdGVzdExpbmUsICd0ZXN0TGluZT0nICsgdGVzdExpbmUpO1xuICAgICAgICAgIHZhciB0ZXN0VyA9IHRlc3REaW1zLndpZHRoO1xuXG4gICAgICAgICAgaWYgKHRlc3RXIDw9IG1heFcpIHtcbiAgICAgICAgICAgIC8vIHdvcmQgZml0cyBvbiBjdXJyZW50IGxpbmVcbiAgICAgICAgICAgIHN1YmxpbmUgKz0gd29yZCArICcgJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gd29yZCBzdGFydHMgbmV3IGxpbmVcbiAgICAgICAgICAgIHdyYXBwZWRMaW5lcy5wdXNoKHN1YmxpbmUpO1xuICAgICAgICAgICAgc3VibGluZSA9IHdvcmQgKyAnICc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhlcmUncyByZW1haW5pbmcgdGV4dCwgcHV0IGl0IGluIGEgd3JhcHBlZCBsaW5lXG4gICAgICAgIGlmICghc3VibGluZS5tYXRjaCgvXlxccyskLykpIHtcbiAgICAgICAgICB3cmFwcGVkTGluZXMucHVzaChzdWJsaW5lKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbGluZSBpcyBhbHJlYWR5IHNob3J0IGVub3VnaFxuICAgICAgICB3cmFwcGVkTGluZXMucHVzaChsaW5lKTtcbiAgICAgIH1cbiAgICB9IC8vIGZvclxuXG4gICAgcnNjcmF0Y2goJ2xhYmVsV3JhcENhY2hlZExpbmVzJywgd3JhcHBlZExpbmVzKTtcbiAgICB0ZXh0ID0gcnNjcmF0Y2goJ2xhYmVsV3JhcENhY2hlZFRleHQnLCB3cmFwcGVkTGluZXMuam9pbignXFxuJykpO1xuICAgIHJzY3JhdGNoKCdsYWJlbFdyYXBLZXknLCBsYWJlbEtleSk7XG5cbiAgICAvLyBjb25zb2xlLmxvZyh0ZXh0KVxuICB9IGVsc2UgaWYgKHdyYXBTdHlsZSA9PT0gJ2VsbGlwc2lzJykge1xuICAgIHZhciBtYXhXID0gZWxlLnBzdHlsZSgndGV4dC1tYXgtd2lkdGgnKS5wZlZhbHVlO1xuICAgIHZhciBlbGxpcHNpemVkID0gJyc7XG4gICAgdmFyIGVsbGlwc2lzID0gJ1xcdTIwMjYnO1xuICAgIHZhciBpbmNMYXN0Q2ggPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHdpZHRoV2l0aE5leHRDaCA9IHRoaXMuY2FsY3VsYXRlTGFiZWxEaW1lbnNpb25zKGVsZSwgZWxsaXBzaXplZCArIHRleHRbaV0gKyBlbGxpcHNpcykud2lkdGg7XG5cbiAgICAgIGlmICh3aWR0aFdpdGhOZXh0Q2ggPiBtYXhXKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBlbGxpcHNpemVkICs9IHRleHRbaV07XG5cbiAgICAgIGlmIChpID09PSB0ZXh0Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgaW5jTGFzdENoID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWluY0xhc3RDaCkge1xuICAgICAgZWxsaXBzaXplZCArPSBlbGxpcHNpcztcbiAgICB9XG5cbiAgICByZXR1cm4gZWxsaXBzaXplZDtcbiAgfSAvLyBpZiBlbGxpcHNpemVcblxuICByZXR1cm4gdGV4dDtcbn07XG5cbkJScC5jYWxjdWxhdGVMYWJlbERpbWVuc2lvbnMgPSBmdW5jdGlvbiAoZWxlLCB0ZXh0LCBleHRyYUtleSkge1xuICB2YXIgciA9IHRoaXM7XG5cbiAgdmFyIGNhY2hlS2V5ID0gZWxlLl9wcml2YXRlLmxhYmVsU3R5bGVLZXkgKyAnJEAkJyArIHRleHQ7XG5cbiAgaWYgKGV4dHJhS2V5KSB7XG4gICAgY2FjaGVLZXkgKz0gJyRAJCcgKyBleHRyYUtleTtcbiAgfVxuXG4gIHZhciBjYWNoZSA9IHIubGFiZWxEaW1DYWNoZSB8fCAoci5sYWJlbERpbUNhY2hlID0ge30pO1xuXG4gIGlmIChjYWNoZVtjYWNoZUtleV0pIHtcbiAgICByZXR1cm4gY2FjaGVbY2FjaGVLZXldO1xuICB9XG5cbiAgdmFyIHNpemVNdWx0ID0gMTsgLy8gaW5jcmVhc2UgdGhlIHNjYWxlIHRvIGluY3JlYXNlIGFjY3VyYWN5IHcuci50LiB6b29tZWQgdGV4dFxuICB2YXIgZlN0eWxlID0gZWxlLnBzdHlsZSgnZm9udC1zdHlsZScpLnN0clZhbHVlO1xuICB2YXIgc2l6ZSA9IHNpemVNdWx0ICogZWxlLnBzdHlsZSgnZm9udC1zaXplJykucGZWYWx1ZSArICdweCc7XG4gIHZhciBmYW1pbHkgPSBlbGUucHN0eWxlKCdmb250LWZhbWlseScpLnN0clZhbHVlO1xuICB2YXIgd2VpZ2h0ID0gZWxlLnBzdHlsZSgnZm9udC13ZWlnaHQnKS5zdHJWYWx1ZTtcblxuICB2YXIgZGl2ID0gdGhpcy5sYWJlbENhbGNEaXY7XG5cbiAgaWYgKCFkaXYpIHtcbiAgICBkaXYgPSB0aGlzLmxhYmVsQ2FsY0RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gIH1cblxuICB2YXIgZHMgPSBkaXYuc3R5bGU7XG5cbiAgLy8gZnJvbSBlbGUgc3R5bGVcbiAgZHMuZm9udEZhbWlseSA9IGZhbWlseTtcbiAgZHMuZm9udFN0eWxlID0gZlN0eWxlO1xuICBkcy5mb250U2l6ZSA9IHNpemU7XG4gIGRzLmZvbnRXZWlnaHQgPSB3ZWlnaHQ7XG5cbiAgLy8gZm9yY2VkIHN0eWxlXG4gIGRzLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgZHMubGVmdCA9ICctOTk5OXB4JztcbiAgZHMudG9wID0gJy05OTk5cHgnO1xuICBkcy56SW5kZXggPSAnLTEnO1xuICBkcy52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gIGRzLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gIGRzLnBhZGRpbmcgPSAnMCc7XG4gIGRzLmxpbmVIZWlnaHQgPSAnMSc7XG5cbiAgaWYgKGVsZS5wc3R5bGUoJ3RleHQtd3JhcCcpLnZhbHVlID09PSAnd3JhcCcpIHtcbiAgICBkcy53aGl0ZVNwYWNlID0gJ3ByZSc7IC8vIHNvIG5ld2xpbmVzIGFyZSB0YWtlbiBpbnRvIGFjY291bnRcbiAgfSBlbHNlIHtcbiAgICBkcy53aGl0ZVNwYWNlID0gJ25vcm1hbCc7XG4gIH1cblxuICAvLyBwdXQgbGFiZWwgY29udGVudCBpbiBkaXZcbiAgZGl2LnRleHRDb250ZW50ID0gdGV4dDtcblxuICBjYWNoZVtjYWNoZUtleV0gPSB7XG4gICAgd2lkdGg6IE1hdGguY2VpbChkaXYuY2xpZW50V2lkdGggLyBzaXplTXVsdCksXG4gICAgaGVpZ2h0OiBNYXRoLmNlaWwoZGl2LmNsaWVudEhlaWdodCAvIHNpemVNdWx0KVxuICB9O1xuXG4gIHJldHVybiBjYWNoZVtjYWNoZUtleV07XG59O1xuXG5CUnAuY2FsY3VsYXRlTGFiZWxBbmdsZXMgPSBmdW5jdGlvbiAoZWxlKSB7XG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgdmFyIHJzID0gX3AucnNjcmF0Y2g7XG4gIHZhciBpc0VkZ2UgPSBlbGUuaXNFZGdlKCk7XG4gIHZhciByb3QgPSBlbGUucHN0eWxlKCd0ZXh0LXJvdGF0aW9uJyk7XG4gIHZhciByb3RTdHIgPSByb3Quc3RyVmFsdWU7XG5cbiAgaWYgKHJvdFN0ciA9PT0gJ25vbmUnKSB7XG4gICAgcnMubGFiZWxBbmdsZSA9IHJzLnNvdXJjZUxhYmVsQW5nbGUgPSBycy50YXJnZXRMYWJlbEFuZ2xlID0gMDtcbiAgfSBlbHNlIGlmIChpc0VkZ2UgJiYgcm90U3RyID09PSAnYXV0b3JvdGF0ZScpIHtcbiAgICBycy5sYWJlbEFuZ2xlID0gcnMubGFiZWxBdXRvQW5nbGU7XG4gICAgcnMuc291cmNlTGFiZWxBbmdsZSA9IHJzLnNvdXJjZUxhYmVsQXV0b0FuZ2xlO1xuICAgIHJzLnRhcmdldExhYmVsQW5nbGUgPSBycy50YXJnZXRMYWJlbEF1dG9BbmdsZTtcbiAgfSBlbHNlIGlmIChyb3RTdHIgPT09ICdhdXRvcm90YXRlJykge1xuICAgIHJzLmxhYmVsQW5nbGUgPSBycy5zb3VyY2VMYWJlbEFuZ2xlID0gcnMudGFyZ2V0TGFiZWxBbmdsZSA9IDA7XG4gIH0gZWxzZSB7XG4gICAgcnMubGFiZWxBbmdsZSA9IHJzLnNvdXJjZUxhYmVsQW5nbGUgPSBycy50YXJnZXRMYWJlbEFuZ2xlID0gcm90LnBmVmFsdWU7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQlJwO1xuXG4vKioqLyB9KSxcbi8qIDExNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgQlJwID0ge307XG5cbkJScC5nZXROb2RlU2hhcGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBzaGFwZSA9IG5vZGUucHN0eWxlKCdzaGFwZScpLnZhbHVlO1xuXG4gIGlmIChub2RlLmlzUGFyZW50KCkpIHtcbiAgICBpZiAoc2hhcGUgPT09ICdyZWN0YW5nbGUnIHx8IHNoYXBlID09PSAncm91bmRyZWN0YW5nbGUnIHx8IHNoYXBlID09PSAnY3V0cmVjdGFuZ2xlJyB8fCBzaGFwZSA9PT0gJ2JhcnJlbCcpIHtcbiAgICAgIHJldHVybiBzaGFwZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICdyZWN0YW5nbGUnO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzaGFwZSA9PT0gJ3BvbHlnb24nKSB7XG4gICAgdmFyIHBvaW50cyA9IG5vZGUucHN0eWxlKCdzaGFwZS1wb2x5Z29uLXBvaW50cycpLnZhbHVlO1xuXG4gICAgcmV0dXJuIHIubm9kZVNoYXBlcy5tYWtlUG9seWdvbihwb2ludHMpLm5hbWU7XG4gIH1cblxuICByZXR1cm4gc2hhcGU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJScDtcblxuLyoqKi8gfSksXG4vKiAxMTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIEJScCA9IHt9O1xuXG5CUnAucmVnaXN0ZXJDYWxjdWxhdGlvbkxpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGN5ID0gdGhpcy5jeTtcbiAgdmFyIGVsZXNUb1VwZGF0ZSA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgdmFyIHIgPSB0aGlzO1xuXG4gIHZhciBlbnF1ZXVlID0gZnVuY3Rpb24gZW5xdWV1ZShlbGVzLCBlKSB7XG4gICAgdmFyIGRpcnR5U3R5bGVDYWNoZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRydWU7XG5cbiAgICBlbGVzVG9VcGRhdGUubWVyZ2UoZWxlcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgICAgdmFyIHJzdHlsZSA9IF9wLnJzdHlsZTtcblxuICAgICAgaWYgKGRpcnR5U3R5bGVDYWNoZXMpIHtcbiAgICAgICAgcnN0eWxlLmNsZWFuID0gZmFsc2U7XG4gICAgICAgIF9wLmJiQ2FjaGUgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgZXZ0cyA9IHJzdHlsZS5kaXJ0eUV2ZW50cyA9IHJzdHlsZS5kaXJ0eUV2ZW50cyB8fCB7IGxlbmd0aDogMCB9O1xuXG4gICAgICBpZiAoIWV2dHNbZS50eXBlXSkge1xuICAgICAgICBldnRzW2UudHlwZV0gPSB0cnVlO1xuICAgICAgICBldnRzLmxlbmd0aCsrO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByLmJpbmRlcihjeSlcbiAgLy8gbm9kZXNcblxuICAub24oJ3Bvc2l0aW9uLiogc3R5bGUuKiBmcmVlLiogYm91bmRzLionLCAnbm9kZScsIGZ1bmN0aW9uIG9uRGlydHlNb2ROb2RlKGUpIHtcbiAgICB2YXIgbm9kZSA9IGUudGFyZ2V0O1xuXG4gICAgZW5xdWV1ZShub2RlLCBlKTtcbiAgICBlbnF1ZXVlKG5vZGUuY29ubmVjdGVkRWRnZXMoKSwgZSk7XG4gIH0pLm9uKCdhZGQuKicsICdub2RlJywgZnVuY3Rpb24gb25EaXJ0eUFkZE5vZGUoZSkge1xuICAgIHZhciBlbGUgPSBlLnRhcmdldDtcblxuICAgIGVucXVldWUoZWxlLCBlKTtcbiAgfSkub24oJ2JhY2tncm91bmQuKicsICdub2RlJywgZnVuY3Rpb24gb25EaXJ0eUJnTm9kZShlKSB7XG4gICAgdmFyIGVsZSA9IGUudGFyZ2V0O1xuXG4gICAgZW5xdWV1ZShlbGUsIGUsIGZhbHNlKTtcbiAgfSlcblxuICAvLyBlZGdlc1xuXG4gIC5vbignYWRkLiogc3R5bGUuKicsICdlZGdlJywgZnVuY3Rpb24gb25EaXJ0eUVkZ2UoZSkge1xuICAgIHZhciBlZGdlID0gZS50YXJnZXQ7XG5cbiAgICBlbnF1ZXVlKGVkZ2UsIGUpO1xuICAgIGVucXVldWUoZWRnZS5wYXJhbGxlbEVkZ2VzKCksIGUpO1xuICB9KS5vbigncmVtb3ZlLionLCAnZWRnZScsIGZ1bmN0aW9uIG9uRGlydHlSZW1vdmVFZGdlKGUpIHtcbiAgICB2YXIgZWRnZSA9IGUudGFyZ2V0O1xuICAgIHZhciBwRWRnZXMgPSBlZGdlLnBhcmFsbGVsRWRnZXMoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcEVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcEVkZ2UgPSBwRWRnZXNbaV07XG5cbiAgICAgIGlmICghcEVkZ2UucmVtb3ZlZCgpKSB7XG4gICAgICAgIGVucXVldWUocEVkZ2UsIGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSlcblxuICAvLyBtYW51YWwgZGlydHlpbmdcblxuICAub24oJ2RpcnR5LionLCAnbm9kZScsIGZ1bmN0aW9uIG9uRGlydHlFbGUoZSkge1xuICAgIHZhciBlbGUgPSBlLnRhcmdldDtcblxuICAgIGVucXVldWUoZWxlLCBlKTtcbiAgfSk7XG5cbiAgdmFyIHVwZGF0ZUVsZUNhbGNzID0gZnVuY3Rpb24gdXBkYXRlRWxlQ2FsY3Mod2lsbERyYXcpIHtcbiAgICBpZiAod2lsbERyYXcpIHtcbiAgICAgIHZhciBmbnMgPSByLm9uVXBkYXRlRWxlQ2FsY3NGbnM7XG5cbiAgICAgIGlmIChmbnMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZm4gPSBmbnNbaV07XG5cbiAgICAgICAgICBmbih3aWxsRHJhdywgZWxlc1RvVXBkYXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByLnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZShlbGVzVG9VcGRhdGUsIGZhbHNlKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzVG9VcGRhdGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZWxlc1RvVXBkYXRlW2ldLl9wcml2YXRlLnJzdHlsZS5kaXJ0eUV2ZW50cyA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGVsZXNUb1VwZGF0ZSA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICB9XG4gIH07XG5cbiAgci5iZWZvcmVSZW5kZXIodXBkYXRlRWxlQ2FsY3MsIHIuYmVmb3JlUmVuZGVyUHJpb3JpdGllcy5lbGVDYWxjcyk7XG59O1xuXG5CUnAub25VcGRhdGVFbGVDYWxjcyA9IGZ1bmN0aW9uIChmbikge1xuICB2YXIgZm5zID0gdGhpcy5vblVwZGF0ZUVsZUNhbGNzRm5zID0gdGhpcy5vblVwZGF0ZUVsZUNhbGNzRm5zIHx8IFtdO1xuXG4gIGZucy5wdXNoKGZuKTtcbn07XG5cbkJScC5yZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGUgPSBmdW5jdGlvbiAoZWxlcywgdXNlQ2FjaGUpIHtcbiAgdmFyIGVkZ2VzID0gW107XG4gIHZhciBub2RlcyA9IFtdO1xuXG4gIC8vIHRoZSByZW5kZXJlciBjYW4ndCBiZSB1c2VkIGZvciBjYWxjcyB3aGVuIGRlc3Ryb3llZCwgZS5nLiBlbGUuYm91bmRpbmdCb3goKVxuICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyB1c2UgY2FjaGUgYnkgZGVmYXVsdCBmb3IgcGVyZlxuICBpZiAodXNlQ2FjaGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHVzZUNhY2hlID0gdHJ1ZTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICB2YXIgcnN0eWxlID0gX3AucnN0eWxlO1xuXG4gICAgLy8gb25seSB1cGRhdGUgaWYgZGlydHkgYW5kIGluIGdyYXBoXG4gICAgaWYgKHVzZUNhY2hlICYmIHJzdHlsZS5jbGVhbiB8fCBlbGUucmVtb3ZlZCgpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBvbmx5IHVwZGF0ZSBpZiBub3QgZGlzcGxheTogbm9uZVxuICAgIGlmIChlbGUucHN0eWxlKCdkaXNwbGF5JykudmFsdWUgPT09ICdub25lJykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKF9wLmdyb3VwID09PSAnbm9kZXMnKSB7XG4gICAgICBub2Rlcy5wdXNoKGVsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVkZ2VzXG4gICAgICBlZGdlcy5wdXNoKGVsZSk7XG4gICAgfVxuXG4gICAgcnN0eWxlLmNsZWFuID0gdHJ1ZTtcbiAgICAvLyByc3R5bGUuZGlydHlFdmVudHMgPSBudWxsO1xuICB9XG5cbiAgLy8gdXBkYXRlIG5vZGUgZGF0YSBmcm9tIHByb2plY3Rpb25zXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlID0gbm9kZXNbaV07XG4gICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgIHZhciByc3R5bGUgPSBfcC5yc3R5bGU7XG4gICAgdmFyIHBvcyA9IGVsZS5wb3NpdGlvbigpO1xuXG4gICAgdGhpcy5yZWNhbGN1bGF0ZU5vZGVMYWJlbFByb2plY3Rpb24oZWxlKTtcblxuICAgIHJzdHlsZS5ub2RlWCA9IHBvcy54O1xuICAgIHJzdHlsZS5ub2RlWSA9IHBvcy55O1xuICAgIHJzdHlsZS5ub2RlVyA9IGVsZS5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZTtcbiAgICByc3R5bGUubm9kZUggPSBlbGUucHN0eWxlKCdoZWlnaHQnKS5wZlZhbHVlO1xuICB9XG5cbiAgdGhpcy5yZWNhbGN1bGF0ZUVkZ2VQcm9qZWN0aW9ucyhlZGdlcyk7XG5cbiAgLy8gdXBkYXRlIGVkZ2UgZGF0YSBmcm9tIHByb2plY3Rpb25zXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlID0gZWRnZXNbaV07XG4gICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgIHZhciByc3R5bGUgPSBfcC5yc3R5bGU7XG4gICAgdmFyIHJzID0gX3AucnNjcmF0Y2g7XG5cbiAgICB0aGlzLnJlY2FsY3VsYXRlRWRnZUxhYmVsUHJvamVjdGlvbnMoZWxlKTtcblxuICAgIC8vIHVwZGF0ZSByc3R5bGUgcG9zaXRpb25zXG4gICAgcnN0eWxlLnNyY1ggPSBycy5hcnJvd1N0YXJ0WDtcbiAgICByc3R5bGUuc3JjWSA9IHJzLmFycm93U3RhcnRZO1xuICAgIHJzdHlsZS50Z3RYID0gcnMuYXJyb3dFbmRYO1xuICAgIHJzdHlsZS50Z3RZID0gcnMuYXJyb3dFbmRZO1xuICAgIHJzdHlsZS5taWRYID0gcnMubWlkWDtcbiAgICByc3R5bGUubWlkWSA9IHJzLm1pZFk7XG4gICAgcnN0eWxlLmxhYmVsQW5nbGUgPSBycy5sYWJlbEFuZ2xlO1xuICAgIHJzdHlsZS5zb3VyY2VMYWJlbEFuZ2xlID0gcnMuc291cmNlTGFiZWxBbmdsZTtcbiAgICByc3R5bGUudGFyZ2V0TGFiZWxBbmdsZSA9IHJzLnRhcmdldExhYmVsQW5nbGU7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQlJwO1xuXG4vKioqLyB9KSxcbi8qIDExOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgekluZGV4U29ydCA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xuXG52YXIgQlJwID0ge307XG5cbkJScC51cGRhdGVDYWNoZWRHcmFiYmVkRWxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVsZXMgPSB0aGlzLmNhY2hlZFpTb3J0ZWRFbGVzO1xuXG4gIGlmICghZWxlcykge1xuICAgIC8vIGp1c3QgbGV0IHRoaXMgYmUgcmVjYWxjdWxhdGVkIG9uIHRoZSBuZXh0IHogc29ydCB0aWNrXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZWxlcy5kcmFnID0gW107XG4gIGVsZXMubm9uZHJhZyA9IFtdO1xuXG4gIHZhciBncmFiVGFyZ2V0cyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgIHZhciBycyA9IGVsZS5fcHJpdmF0ZS5yc2NyYXRjaDtcblxuICAgIGlmIChlbGUuZ3JhYmJlZCgpICYmICFlbGUuaXNQYXJlbnQoKSkge1xuICAgICAgZ3JhYlRhcmdldHMucHVzaChlbGUpO1xuICAgIH0gZWxzZSBpZiAocnMuaW5EcmFnTGF5ZXIpIHtcbiAgICAgIGVsZXMuZHJhZy5wdXNoKGVsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZXMubm9uZHJhZy5wdXNoKGVsZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcHV0IHRoZSBncmFiIHRhcmdldCBub2RlcyBsYXN0IHNvIGl0J3Mgb24gdG9wIG9mIGl0cyBuZWlnaGJvdXJob29kXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JhYlRhcmdldHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlID0gZ3JhYlRhcmdldHNbaV07XG5cbiAgICBlbGVzLmRyYWcucHVzaChlbGUpO1xuICB9XG59O1xuXG5CUnAuaW52YWxpZGF0ZUNhY2hlZFpTb3J0ZWRFbGVzID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmNhY2hlZFpTb3J0ZWRFbGVzID0gbnVsbDtcbn07XG5cbkJScC5nZXRDYWNoZWRaU29ydGVkRWxlcyA9IGZ1bmN0aW9uIChmb3JjZVJlY2FsYykge1xuICBpZiAoZm9yY2VSZWNhbGMgfHwgIXRoaXMuY2FjaGVkWlNvcnRlZEVsZXMpIHtcbiAgICAvL2NvbnNvbGUudGltZSgnY2FjaGV6b3JkZXInKVxuXG4gICAgdmFyIGVsZXMgPSB0aGlzLmN5Lm11dGFibGVFbGVtZW50cygpLnRvQXJyYXkoKTtcblxuICAgIGVsZXMuc29ydCh6SW5kZXhTb3J0KTtcblxuICAgIGVsZXMuaW50ZXJhY3RpdmUgPSBlbGVzLmZpbHRlcihmdW5jdGlvbiAoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLmludGVyYWN0aXZlKCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmNhY2hlZFpTb3J0ZWRFbGVzID0gZWxlcztcblxuICAgIHRoaXMudXBkYXRlQ2FjaGVkR3JhYmJlZEVsZXMoKTtcbiAgfSBlbHNlIHtcbiAgICBlbGVzID0gdGhpcy5jYWNoZWRaU29ydGVkRWxlcztcbiAgfVxuXG4gIHJldHVybiBlbGVzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCUnA7XG5cbi8qKiovIH0pLFxuLyogMTE5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBCUnAgPSB7fTtcblxuQlJwLmdldENhY2hlZEltYWdlID0gZnVuY3Rpb24gKHVybCwgY3Jvc3NPcmlnaW4sIG9uTG9hZCkge1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBpbWFnZUNhY2hlID0gci5pbWFnZUNhY2hlID0gci5pbWFnZUNhY2hlIHx8IHt9O1xuICB2YXIgY2FjaGUgPSBpbWFnZUNhY2hlW3VybF07XG5cbiAgaWYgKGNhY2hlKSB7XG4gICAgaWYgKCFjYWNoZS5pbWFnZS5jb21wbGV0ZSkge1xuICAgICAgY2FjaGUuaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIG9uTG9hZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhY2hlLmltYWdlO1xuICB9IGVsc2Uge1xuICAgIGNhY2hlID0gaW1hZ2VDYWNoZVt1cmxdID0gaW1hZ2VDYWNoZVt1cmxdIHx8IHt9O1xuXG4gICAgdmFyIGltYWdlID0gY2FjaGUuaW1hZ2UgPSBuZXcgSW1hZ2UoKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIG9uTG9hZCk7XG4gICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpbWFnZS5lcnJvciA9IHRydWU7XG4gICAgfSk7XG5cbiAgICAvLyAjMTU4MiBzYWZhcmkgZG9lc24ndCBsb2FkIGRhdGEgdXJpcyB3aXRoIGNyb3NzT3JpZ2luIHByb3Blcmx5XG4gICAgLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEyMzk3OFxuICAgIHZhciBkYXRhVXJpUHJlZml4ID0gJ2RhdGE6JztcbiAgICB2YXIgaXNEYXRhVXJpID0gdXJsLnN1YnN0cmluZygwLCBkYXRhVXJpUHJlZml4Lmxlbmd0aCkudG9Mb3dlckNhc2UoKSA9PT0gZGF0YVVyaVByZWZpeDtcbiAgICBpZiAoIWlzRGF0YVVyaSkge1xuICAgICAgaW1hZ2UuY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbjsgLy8gcHJldmVudCB0YWludGVkIGNhbnZhc1xuICAgIH1cblxuICAgIGltYWdlLnNyYyA9IHVybDtcblxuICAgIHJldHVybiBpbWFnZTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCUnA7XG5cbi8qKiovIH0pLFxuLyogMTIwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBpcyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG52YXIgbWF0aCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG52YXIgRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcblxudmFyIEJScCA9IHt9O1xuXG5CUnAucmVnaXN0ZXJCaW5kaW5nID0gZnVuY3Rpb24gKHRhcmdldCwgZXZlbnQsIGhhbmRsZXIsIHVzZUNhcHR1cmUpIHtcbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoYXJndW1lbnRzLCBbMV0pOyAvLyBjb3B5XG4gIHZhciBiID0gdGhpcy5iaW5kZXIodGFyZ2V0KTtcblxuICByZXR1cm4gYi5vbi5hcHBseShiLCBhcmdzKTtcbn07XG5cbkJScC5iaW5kZXIgPSBmdW5jdGlvbiAodGd0KSB7XG4gIHZhciByID0gdGhpcztcblxuICB2YXIgdGd0SXNEb20gPSB0Z3QgPT09IHdpbmRvdyB8fCB0Z3QgPT09IGRvY3VtZW50IHx8IHRndCA9PT0gZG9jdW1lbnQuYm9keSB8fCBpcy5kb21FbGVtZW50KHRndCk7XG5cbiAgaWYgKHIuc3VwcG9ydHNQYXNzaXZlRXZlbnRzID09IG51bGwpIHtcblxuICAgIC8vIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL1dJQ0cvRXZlbnRMaXN0ZW5lck9wdGlvbnMvYmxvYi9naC1wYWdlcy9leHBsYWluZXIubWQjZmVhdHVyZS1kZXRlY3Rpb25cbiAgICB2YXIgc3VwcG9ydHNQYXNzaXZlID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBvcHRzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAncGFzc2l2ZScsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgc3VwcG9ydHNQYXNzaXZlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwgb3B0cyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7fVxuXG4gICAgci5zdXBwb3J0c1Bhc3NpdmVFdmVudHMgPSBzdXBwb3J0c1Bhc3NpdmU7XG4gIH1cblxuICB2YXIgb24gPSBmdW5jdGlvbiBvbihldmVudCwgaGFuZGxlciwgdXNlQ2FwdHVyZSkge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICAgIGlmICh0Z3RJc0RvbSAmJiByLnN1cHBvcnRzUGFzc2l2ZUV2ZW50cykge1xuICAgICAgLy8gcmVwbGFjZSB1c2VDYXB0dXJlIHcvIG9wdHMgb2JqXG4gICAgICBhcmdzWzJdID0ge1xuICAgICAgICBjYXB0dXJlOiB1c2VDYXB0dXJlICE9IG51bGwgPyB1c2VDYXB0dXJlIDogZmFsc2UsXG4gICAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgICBvbmNlOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICByLmJpbmRpbmdzLnB1c2goe1xuICAgICAgdGFyZ2V0OiB0Z3QsXG4gICAgICBhcmdzOiBhcmdzXG4gICAgfSk7XG5cbiAgICAodGd0LmFkZEV2ZW50TGlzdGVuZXIgfHwgdGd0Lm9uKS5hcHBseSh0Z3QsIGFyZ3MpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBvbjogb24sXG4gICAgYWRkRXZlbnRMaXN0ZW5lcjogb24sXG4gICAgYWRkTGlzdGVuZXI6IG9uLFxuICAgIGJpbmQ6IG9uXG4gIH07XG59O1xuXG5CUnAubm9kZUlzRHJhZ2dhYmxlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgJiYgbm9kZS5pc05vZGUoKSAmJiAhbm9kZS5sb2NrZWQoKSAmJiBub2RlLmdyYWJiYWJsZSgpO1xufTtcblxuQlJwLm5vZGVJc0dyYWJiYWJsZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHJldHVybiB0aGlzLm5vZGVJc0RyYWdnYWJsZShub2RlKSAmJiBub2RlLmludGVyYWN0aXZlKCk7XG59O1xuXG5CUnAubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHIgPSB0aGlzO1xuXG4gIHZhciB0cmlnZ2VyRXZlbnRzID0gZnVuY3Rpb24gdHJpZ2dlckV2ZW50cyh0YXJnZXQsIG5hbWVzLCBlLCBwcm9wcykge1xuICAgIGlmICh0YXJnZXQgPT0gbnVsbCkge1xuICAgICAgdGFyZ2V0ID0gci5jeTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbmFtZSA9IG5hbWVzW2ldO1xuXG4gICAgICB0YXJnZXQuZW1pdCh1dGlsLmV4dGVuZCh7IG9yaWdpbmFsRXZlbnQ6IGUsIHR5cGU6IG5hbWUgfSwgcHJvcHMpKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGlzTXVsdFNlbEtleURvd24gPSBmdW5jdGlvbiBpc011bHRTZWxLZXlEb3duKGUpIHtcbiAgICByZXR1cm4gZS5zaGlmdEtleSB8fCBlLm1ldGFLZXkgfHwgZS5jdHJsS2V5OyAvLyBtYXliZSBlLmFsdEtleVxuICB9O1xuXG4gIHZhciBhbGxvd1Bhbm5pbmdQYXNzdGhyb3VnaCA9IGZ1bmN0aW9uIGFsbG93UGFubmluZ1Bhc3N0aHJvdWdoKGRvd24sIGRvd25zKSB7XG4gICAgdmFyIGFsbG93UGFzc3Rocm91Z2ggPSB0cnVlO1xuXG4gICAgaWYgKHIuY3kuaGFzQ29tcG91bmROb2RlcygpICYmIGRvd24gJiYgZG93bi5pc0VkZ2UoKSkge1xuICAgICAgLy8gYSBjb21wb3VuZCBub2RlIGJlbG93IHRoZSBlZGdlID0+IG5vIHBhc3N0aHJvdWdoIHBhbm5pbmdcbiAgICAgIGZvciAodmFyIGkgPSAwOyBkb3ducyAmJiBpIDwgZG93bnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGRvd24gPSBkb3duc1tpXTtcblxuICAgICAgICBpZiAoZG93bi5pc05vZGUoKSAmJiBkb3duLmlzUGFyZW50KCkpIHtcbiAgICAgICAgICBhbGxvd1Bhc3N0aHJvdWdoID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYWxsb3dQYXNzdGhyb3VnaCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFsbG93UGFzc3Rocm91Z2g7XG4gIH07XG5cbiAgdmFyIGdldERyYWdMaXN0SWRzID0gZnVuY3Rpb24gZ2V0RHJhZ0xpc3RJZHMob3B0cykge1xuICAgIHZhciBsaXN0SGFzSWQ7XG5cbiAgICBpZiAob3B0cy5hZGRUb0xpc3QgJiYgci5jeS5oYXNDb21wb3VuZE5vZGVzKCkpIHtcbiAgICAgIC8vIG9ubHkgbmVlZGVkIGZvciBjb21wb3VuZCBncmFwaHNcbiAgICAgIGlmICghb3B0cy5hZGRUb0xpc3QuaGFzSWQpIHtcbiAgICAgICAgLy8gYnVpbGQgaWRzIGxvb2t1cCBpZiBkb2Vzbid0IGFscmVhZHkgZXhpc3RcbiAgICAgICAgb3B0cy5hZGRUb0xpc3QuaGFzSWQgPSB7fTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdHMuYWRkVG9MaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVsZSA9IG9wdHMuYWRkVG9MaXN0W2ldO1xuXG4gICAgICAgICAgb3B0cy5hZGRUb0xpc3QuaGFzSWRbZWxlLmlkKCldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsaXN0SGFzSWQgPSBvcHRzLmFkZFRvTGlzdC5oYXNJZDtcbiAgICB9XG5cbiAgICByZXR1cm4gbGlzdEhhc0lkIHx8IHt9O1xuICB9O1xuXG4gIHZhciBzZXRHcmFiYmVkID0gZnVuY3Rpb24gc2V0R3JhYmJlZChlbGUpIHtcbiAgICBlbGVbMF0uX3ByaXZhdGUuZ3JhYmJlZCA9IHRydWU7XG4gIH07XG5cbiAgdmFyIHNldEZyZWVkID0gZnVuY3Rpb24gc2V0RnJlZWQoZWxlKSB7XG4gICAgZWxlWzBdLl9wcml2YXRlLmdyYWJiZWQgPSBmYWxzZTtcbiAgfTtcblxuICB2YXIgc2V0SW5EcmFnTGF5ZXIgPSBmdW5jdGlvbiBzZXRJbkRyYWdMYXllcihlbGUpIHtcbiAgICBlbGVbMF0uX3ByaXZhdGUucnNjcmF0Y2guaW5EcmFnTGF5ZXIgPSB0cnVlO1xuICB9O1xuXG4gIHZhciBzZXRPdXREcmFnTGF5ZXIgPSBmdW5jdGlvbiBzZXRPdXREcmFnTGF5ZXIoZWxlKSB7XG4gICAgZWxlWzBdLl9wcml2YXRlLnJzY3JhdGNoLmluRHJhZ0xheWVyID0gZmFsc2U7XG4gIH07XG5cbiAgdmFyIHNldEdyYWJUYXJnZXQgPSBmdW5jdGlvbiBzZXRHcmFiVGFyZ2V0KGVsZSkge1xuICAgIGVsZVswXS5fcHJpdmF0ZS5yc2NyYXRjaC5pc0dyYWJUYXJnZXQgPSB0cnVlO1xuICB9O1xuXG4gIHZhciByZW1vdmVHcmFiVGFyZ2V0ID0gZnVuY3Rpb24gcmVtb3ZlR3JhYlRhcmdldChlbGUpIHtcbiAgICBlbGVbMF0uX3ByaXZhdGUucnNjcmF0Y2guaXNHcmFiVGFyZ2V0ID0gZmFsc2U7XG4gIH07XG5cbiAgdmFyIGFkZFRvRHJhZ0xpc3QgPSBmdW5jdGlvbiBhZGRUb0RyYWdMaXN0KGVsZSwgb3B0cykge1xuICAgIHZhciBsaXN0SGFzSWQgPSBnZXREcmFnTGlzdElkcyhvcHRzKTtcblxuICAgIGlmICghbGlzdEhhc0lkW2VsZS5pZCgpXSkge1xuICAgICAgb3B0cy5hZGRUb0xpc3QucHVzaChlbGUpO1xuICAgICAgbGlzdEhhc0lkW2VsZS5pZCgpXSA9IHRydWU7XG5cbiAgICAgIHNldEdyYWJiZWQoZWxlKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gaGVscGVyIGZ1bmN0aW9uIHRvIGRldGVybWluZSB3aGljaCBjaGlsZCBub2RlcyBhbmQgaW5uZXIgZWRnZXNcbiAgLy8gb2YgYSBjb21wb3VuZCBub2RlIHRvIGJlIGRyYWdnZWQgYXMgd2VsbCBhcyB0aGUgZ3JhYmJlZCBhbmQgc2VsZWN0ZWQgbm9kZXNcbiAgdmFyIGFkZERlc2NlbmRhbnRzVG9EcmFnID0gZnVuY3Rpb24gYWRkRGVzY2VuZGFudHNUb0RyYWcobm9kZSwgb3B0cykge1xuICAgIGlmICghbm9kZS5jeSgpLmhhc0NvbXBvdW5kTm9kZXMoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChvcHRzLmluRHJhZ0xheWVyID09IG51bGwgJiYgb3B0cy5hZGRUb0xpc3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gbm90aGluZyB0byBkb1xuXG4gICAgdmFyIGlubmVyTm9kZXMgPSBub2RlLmRlc2NlbmRhbnRzKCk7XG5cbiAgICBpZiAob3B0cy5pbkRyYWdMYXllcikge1xuICAgICAgaW5uZXJOb2Rlcy5mb3JFYWNoKHNldEluRHJhZ0xheWVyKTtcbiAgICAgIGlubmVyTm9kZXMuY29ubmVjdGVkRWRnZXMoKS5mb3JFYWNoKHNldEluRHJhZ0xheWVyKTtcbiAgICB9XG5cbiAgICBpZiAob3B0cy5hZGRUb0xpc3QpIHtcbiAgICAgIGlubmVyTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgIGFkZFRvRHJhZ0xpc3QoZWxlLCBvcHRzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICAvLyBhZGRzIHRoZSBnaXZlbiBub2RlcyBhbmQgaXRzIG5laWdoYm91cmhvb2QgdG8gdGhlIGRyYWcgbGF5ZXJcbiAgdmFyIGFkZE5vZGVzVG9EcmFnID0gZnVuY3Rpb24gYWRkTm9kZXNUb0RyYWcobm9kZXMsIG9wdHMpIHtcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgIHZhciBoYXNDb21wb3VuZE5vZGVzID0gbm9kZXMuY3koKS5oYXNDb21wb3VuZE5vZGVzKCk7XG5cbiAgICBpZiAob3B0cy5pbkRyYWdMYXllcikge1xuICAgICAgbm9kZXMuZm9yRWFjaChzZXRJbkRyYWdMYXllcik7XG5cbiAgICAgIG5vZGVzLm5laWdoYm9yaG9vZCgpLnN0ZEZpbHRlcihmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgIHJldHVybiAhaGFzQ29tcG91bmROb2RlcyB8fCBlbGUuaXNFZGdlKCk7XG4gICAgICB9KS5mb3JFYWNoKHNldEluRHJhZ0xheWVyKTtcbiAgICB9XG5cbiAgICBpZiAob3B0cy5hZGRUb0xpc3QpIHtcbiAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICBhZGRUb0RyYWdMaXN0KGVsZSwgb3B0cyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBhZGREZXNjZW5kYW50c1RvRHJhZyhub2Rlcywgb3B0cyk7IC8vIGFsd2F5cyBhZGQgdG8gZHJhZ1xuXG4gICAgLy8gYWxzbyBhZGQgbm9kZXMgYW5kIGVkZ2VzIHJlbGF0ZWQgdG8gdGhlIHRvcG1vc3QgYW5jZXN0b3JcbiAgICB1cGRhdGVBbmNlc3RvcnNJbkRyYWdMYXllcihub2Rlcywge1xuICAgICAgaW5EcmFnTGF5ZXI6IG9wdHMuaW5EcmFnTGF5ZXJcbiAgICB9KTtcblxuICAgIHIudXBkYXRlQ2FjaGVkR3JhYmJlZEVsZXMoKTtcbiAgfTtcblxuICB2YXIgYWRkTm9kZVRvRHJhZyA9IGFkZE5vZGVzVG9EcmFnO1xuXG4gIHZhciBmcmVlRHJhZ2dlZEVsZW1lbnRzID0gZnVuY3Rpb24gZnJlZURyYWdnZWRFbGVtZW50cyhncmFiYmVkRWxlcykge1xuICAgIGlmICghZ3JhYmJlZEVsZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBncmFiYmVkRWxlcy5oYXNJZCA9IHt9OyAvLyBjbGVhciB0aGUgaWQgbGlzdFxuXG4gICAgLy8ganVzdCBnbyBvdmVyIGFsbCBlbGVtZW50cyByYXRoZXIgdGhhbiBkb2luZyBhIGJ1bmNoIG9mIChwb3NzaWJseSBleHBlbnNpdmUpIHRyYXZlcnNhbHNcbiAgICByLmdldENhY2hlZFpTb3J0ZWRFbGVzKCkuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICBzZXRGcmVlZChlbGUpO1xuICAgICAgc2V0T3V0RHJhZ0xheWVyKGVsZSk7XG4gICAgICByZW1vdmVHcmFiVGFyZ2V0KGVsZSk7XG4gICAgfSk7XG5cbiAgICByLnVwZGF0ZUNhY2hlZEdyYWJiZWRFbGVzKCk7XG4gIH07XG5cbiAgLy8gaGVscGVyIGZ1bmN0aW9uIHRvIGRldGVybWluZSB3aGljaCBhbmNlc3RvciBub2RlcyBhbmQgZWRnZXMgc2hvdWxkIGdvXG4gIC8vIHRvIHRoZSBkcmFnIGxheWVyIChvciBzaG91bGQgYmUgcmVtb3ZlZCBmcm9tIGRyYWcgbGF5ZXIpLlxuICB2YXIgdXBkYXRlQW5jZXN0b3JzSW5EcmFnTGF5ZXIgPSBmdW5jdGlvbiB1cGRhdGVBbmNlc3RvcnNJbkRyYWdMYXllcihub2RlLCBvcHRzKSB7XG5cbiAgICBpZiAob3B0cy5pbkRyYWdMYXllciA9PSBudWxsICYmIG9wdHMuYWRkVG9MaXN0ID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIG5vdGhpbmcgdG8gZG9cblxuICAgIGlmICghbm9kZS5jeSgpLmhhc0NvbXBvdW5kTm9kZXMoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGZpbmQgdG9wLWxldmVsIHBhcmVudFxuICAgIHZhciBwYXJlbnQgPSBub2RlLmFuY2VzdG9ycygpLm9ycGhhbnMoKTtcblxuICAgIC8vIG5vIHBhcmVudCBub2RlOiBubyBub2RlcyB0byBhZGQgdG8gdGhlIGRyYWcgbGF5ZXJcbiAgICBpZiAocGFyZW50LnNhbWUobm9kZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbm9kZXMgPSBwYXJlbnQuZGVzY2VuZGFudHMoKS5zcGF3blNlbGYoKS5tZXJnZShwYXJlbnQpLnVubWVyZ2Uobm9kZSkudW5tZXJnZShub2RlLmRlc2NlbmRhbnRzKCkpO1xuXG4gICAgdmFyIGVkZ2VzID0gbm9kZXMuY29ubmVjdGVkRWRnZXMoKTtcblxuICAgIGlmIChvcHRzLmluRHJhZ0xheWVyKSB7XG4gICAgICBlZGdlcy5mb3JFYWNoKHNldEluRHJhZ0xheWVyKTtcbiAgICAgIG5vZGVzLmZvckVhY2goc2V0SW5EcmFnTGF5ZXIpO1xuICAgIH1cblxuICAgIGlmIChvcHRzLmFkZFRvTGlzdCkge1xuICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgIGFkZFRvRHJhZ0xpc3QoZWxlLCBvcHRzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICB2YXIgYmx1ckFjdGl2ZURvbUVsZW1lbnQgPSBmdW5jdGlvbiBibHVyQWN0aXZlRG9tRWxlbWVudCgpIHtcbiAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPSBudWxsICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1ciAhPSBudWxsKSB7XG4gICAgICBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmJsdXIoKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGhhdmVNdXRhdGlvbnNBcGkgPSB0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCc7XG5cbiAgLy8gd2F0Y2ggZm9yIHdoZW4gdGhlIGN5IGNvbnRhaW5lciBpcyByZW1vdmVkIGZyb20gdGhlIGRvbVxuICBpZiAoaGF2ZU11dGF0aW9uc0FwaSkge1xuICAgIHIucmVtb3ZlT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbiAobXV0bnMpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXV0bnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG11dG4gPSBtdXRuc1tpXTtcbiAgICAgICAgdmFyIHJOb2RlcyA9IG11dG4ucmVtb3ZlZE5vZGVzO1xuXG4gICAgICAgIGlmIChyTm9kZXMpIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJOb2Rlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIHJOb2RlID0gck5vZGVzW2pdO1xuXG4gICAgICAgICAgICBpZiAock5vZGUgPT09IHIuY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgIHIuZGVzdHJveSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChyLmNvbnRhaW5lci5wYXJlbnROb2RlKSB7XG4gICAgICByLnJlbW92ZU9ic2VydmVyLm9ic2VydmUoci5jb250YWluZXIucGFyZW50Tm9kZSwgeyBjaGlsZExpc3Q6IHRydWUgfSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAnRE9NTm9kZVJlbW92ZWQnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgci5kZXN0cm95KCk7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgb25SZXNpemUgPSB1dGlsLmRlYm91bmNlKGZ1bmN0aW9uICgpIHtcbiAgICByLmN5LnJlc2l6ZSgpO1xuICB9LCAxMDApO1xuXG4gIGlmIChoYXZlTXV0YXRpb25zQXBpKSB7XG4gICAgci5zdHlsZU9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIob25SZXNpemUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbiAgICByLnN0eWxlT2JzZXJ2ZXIub2JzZXJ2ZShyLmNvbnRhaW5lciwgeyBhdHRyaWJ1dGVzOiB0cnVlIH0pO1xuICB9XG5cbiAgLy8gYXV0byByZXNpemVcbiAgci5yZWdpc3RlckJpbmRpbmcod2luZG93LCAncmVzaXplJywgb25SZXNpemUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbiAgdmFyIGZvckVhY2hVcCA9IGZ1bmN0aW9uIGZvckVhY2hVcChkb21FbGUsIGZuKSB7XG4gICAgd2hpbGUgKGRvbUVsZSAhPSBudWxsKSB7XG4gICAgICBmbihkb21FbGUpO1xuXG4gICAgICBkb21FbGUgPSBkb21FbGUucGFyZW50Tm9kZTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGludmFsaWRhdGVDb29yZHMgPSBmdW5jdGlvbiBpbnZhbGlkYXRlQ29vcmRzKCkge1xuICAgIHIuaW52YWxpZGF0ZUNvbnRhaW5lckNsaWVudENvb3Jkc0NhY2hlKCk7XG4gIH07XG5cbiAgZm9yRWFjaFVwKHIuY29udGFpbmVyLCBmdW5jdGlvbiAoZG9tRWxlKSB7XG4gICAgci5yZWdpc3RlckJpbmRpbmcoZG9tRWxlLCAndHJhbnNpdGlvbmVuZCcsIGludmFsaWRhdGVDb29yZHMpO1xuICAgIHIucmVnaXN0ZXJCaW5kaW5nKGRvbUVsZSwgJ2FuaW1hdGlvbmVuZCcsIGludmFsaWRhdGVDb29yZHMpO1xuICAgIHIucmVnaXN0ZXJCaW5kaW5nKGRvbUVsZSwgJ3Njcm9sbCcsIGludmFsaWRhdGVDb29yZHMpO1xuICB9KTtcblxuICAvLyBzdG9wIHJpZ2h0IGNsaWNrIG1lbnUgZnJvbSBhcHBlYXJpbmcgb24gY3lcbiAgci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdjb250ZXh0bWVudScsIGZ1bmN0aW9uIChlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9KTtcblxuICB2YXIgaW5Cb3hTZWxlY3Rpb24gPSBmdW5jdGlvbiBpbkJveFNlbGVjdGlvbigpIHtcbiAgICByZXR1cm4gci5zZWxlY3Rpb25bNF0gIT09IDA7XG4gIH07XG5cbiAgdmFyIGV2ZW50SW5Db250YWluZXIgPSBmdW5jdGlvbiBldmVudEluQ29udGFpbmVyKGUpIHtcbiAgICAvLyBzYXZlIGN5Y2xlcyBpZiBtb3VzZSBldmVudHMgYXJlbid0IHRvIGJlIGNhcHR1cmVkXG4gICAgdmFyIGNvbnRhaW5lclBhZ2VDb29yZHMgPSByLmZpbmRDb250YWluZXJDbGllbnRDb29yZHMoKTtcbiAgICB2YXIgeCA9IGNvbnRhaW5lclBhZ2VDb29yZHNbMF07XG4gICAgdmFyIHkgPSBjb250YWluZXJQYWdlQ29vcmRzWzFdO1xuICAgIHZhciB3aWR0aCA9IGNvbnRhaW5lclBhZ2VDb29yZHNbMl07XG4gICAgdmFyIGhlaWdodCA9IGNvbnRhaW5lclBhZ2VDb29yZHNbM107XG5cbiAgICB2YXIgcG9zaXRpb25zID0gZS50b3VjaGVzID8gZS50b3VjaGVzIDogW2VdO1xuICAgIHZhciBhdExlYXN0T25lUG9zSW5zaWRlID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvc2l0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHAgPSBwb3NpdGlvbnNbaV07XG5cbiAgICAgIGlmICh4IDw9IHAuY2xpZW50WCAmJiBwLmNsaWVudFggPD0geCArIHdpZHRoICYmIHkgPD0gcC5jbGllbnRZICYmIHAuY2xpZW50WSA8PSB5ICsgaGVpZ2h0KSB7XG4gICAgICAgIGF0TGVhc3RPbmVQb3NJbnNpZGUgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWF0TGVhc3RPbmVQb3NJbnNpZGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgY29udGFpbmVyID0gci5jb250YWluZXI7XG4gICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0O1xuICAgIHZhciB0UGFyZW50ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG4gICAgdmFyIGNvbnRhaW5lcklzVGFyZ2V0ID0gZmFsc2U7XG5cbiAgICB3aGlsZSAodFBhcmVudCkge1xuICAgICAgaWYgKHRQYXJlbnQgPT09IGNvbnRhaW5lcikge1xuICAgICAgICBjb250YWluZXJJc1RhcmdldCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB0UGFyZW50ID0gdFBhcmVudC5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIGlmICghY29udGFpbmVySXNUYXJnZXQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIGlmIHRhcmdldCBpcyBvdXRpc2RlIGN5IGNvbnRhaW5lciwgdGhlbiB0aGlzIGV2ZW50IGlzIG5vdCBmb3IgdXNcblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIFByaW1hcnkga2V5XG4gIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAnbW91c2Vkb3duJywgZnVuY3Rpb24gbW91c2Vkb3duSGFuZGxlcihlKSB7XG4gICAgaWYgKCFldmVudEluQ29udGFpbmVyKGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgYmx1ckFjdGl2ZURvbUVsZW1lbnQoKTtcblxuICAgIHIuaG92ZXJEYXRhLmNhcHR1cmUgPSB0cnVlO1xuICAgIHIuaG92ZXJEYXRhLndoaWNoID0gZS53aGljaDtcblxuICAgIHZhciBjeSA9IHIuY3k7XG4gICAgdmFyIGdwb3MgPSBbZS5jbGllbnRYLCBlLmNsaWVudFldO1xuICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZ3Bvc1swXSwgZ3Bvc1sxXSk7XG4gICAgdmFyIHNlbGVjdCA9IHIuc2VsZWN0aW9uO1xuICAgIHZhciBuZWFycyA9IHIuZmluZE5lYXJlc3RFbGVtZW50cyhwb3NbMF0sIHBvc1sxXSwgdHJ1ZSwgZmFsc2UpO1xuICAgIHZhciBuZWFyID0gbmVhcnNbMF07XG4gICAgdmFyIGRyYWdnZWRFbGVtZW50cyA9IHIuZHJhZ0RhdGEucG9zc2libGVEcmFnRWxlbWVudHM7XG5cbiAgICByLmhvdmVyRGF0YS5tZG93blBvcyA9IHBvcztcbiAgICByLmhvdmVyRGF0YS5tZG93bkdQb3MgPSBncG9zO1xuXG4gICAgdmFyIGNoZWNrRm9yVGFwaG9sZCA9IGZ1bmN0aW9uIGNoZWNrRm9yVGFwaG9sZCgpIHtcbiAgICAgIHIuaG92ZXJEYXRhLnRhcGhvbGRDYW5jZWxsZWQgPSBmYWxzZTtcblxuICAgICAgY2xlYXJUaW1lb3V0KHIuaG92ZXJEYXRhLnRhcGhvbGRUaW1lb3V0KTtcblxuICAgICAgci5ob3ZlckRhdGEudGFwaG9sZFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblxuICAgICAgICBpZiAoci5ob3ZlckRhdGEudGFwaG9sZENhbmNlbGxlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgZWxlID0gci5ob3ZlckRhdGEuZG93bjtcblxuICAgICAgICAgIGlmIChlbGUpIHtcbiAgICAgICAgICAgIGVsZS5lbWl0KHtcbiAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICAgICAgdHlwZTogJ3RhcGhvbGQnLFxuICAgICAgICAgICAgICBwb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3kuZW1pdCh7XG4gICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgICAgIHR5cGU6ICd0YXBob2xkJyxcbiAgICAgICAgICAgICAgcG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCByLnRhcGhvbGREdXJhdGlvbik7XG4gICAgfTtcblxuICAgIC8vIFJpZ2h0IGNsaWNrIGJ1dHRvblxuICAgIGlmIChlLndoaWNoID09IDMpIHtcblxuICAgICAgci5ob3ZlckRhdGEuY3h0U3RhcnRlZCA9IHRydWU7XG5cbiAgICAgIHZhciBjeHRFdnQgPSB7XG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgIHR5cGU6ICdjeHR0YXBzdGFydCcsXG4gICAgICAgIHBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgIH07XG5cbiAgICAgIGlmIChuZWFyKSB7XG4gICAgICAgIG5lYXIuYWN0aXZhdGUoKTtcbiAgICAgICAgbmVhci5lbWl0KGN4dEV2dCk7XG5cbiAgICAgICAgci5ob3ZlckRhdGEuZG93biA9IG5lYXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjeS5lbWl0KGN4dEV2dCk7XG4gICAgICB9XG5cbiAgICAgIHIuaG92ZXJEYXRhLmRvd25UaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICByLmhvdmVyRGF0YS5jeHREcmFnZ2VkID0gZmFsc2U7XG5cbiAgICAgIC8vIFByaW1hcnkgYnV0dG9uXG4gICAgfSBlbHNlIGlmIChlLndoaWNoID09IDEpIHtcblxuICAgICAgaWYgKG5lYXIpIHtcbiAgICAgICAgbmVhci5hY3RpdmF0ZSgpO1xuICAgICAgfVxuXG4gICAgICAvLyBFbGVtZW50IGRyYWdnaW5nXG4gICAgICB7XG4gICAgICAgIC8vIElmIHNvbWV0aGluZyBpcyB1bmRlciB0aGUgY3Vyc29yIGFuZCBpdCBpcyBkcmFnZ2FibGUsIHByZXBhcmUgdG8gZ3JhYiBpdFxuICAgICAgICBpZiAobmVhciAhPSBudWxsKSB7XG5cbiAgICAgICAgICBpZiAoci5ub2RlSXNHcmFiYmFibGUobmVhcikpIHtcblxuICAgICAgICAgICAgdmFyIG1ha2VFdmVudCA9IGZ1bmN0aW9uIG1ha2VFdmVudCh0eXBlKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciB0cmlnZ2VyR3JhYiA9IGZ1bmN0aW9uIHRyaWdnZXJHcmFiKGVsZSkge1xuICAgICAgICAgICAgICBlbGUuZW1pdChtYWtlRXZlbnQoJ2dyYWInKSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBzZXRHcmFiVGFyZ2V0KG5lYXIpO1xuXG4gICAgICAgICAgICBpZiAoIW5lYXIuc2VsZWN0ZWQoKSkge1xuXG4gICAgICAgICAgICAgIGRyYWdnZWRFbGVtZW50cyA9IHIuZHJhZ0RhdGEucG9zc2libGVEcmFnRWxlbWVudHMgPSBbXTtcbiAgICAgICAgICAgICAgYWRkTm9kZVRvRHJhZyhuZWFyLCB7IGFkZFRvTGlzdDogZHJhZ2dlZEVsZW1lbnRzIH0pO1xuXG4gICAgICAgICAgICAgIG5lYXIuZW1pdChtYWtlRXZlbnQoJ2dyYWJvbicpKS5lbWl0KG1ha2VFdmVudCgnZ3JhYicpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRyYWdnZWRFbGVtZW50cyA9IHIuZHJhZ0RhdGEucG9zc2libGVEcmFnRWxlbWVudHMgPSBbXTtcblxuICAgICAgICAgICAgICB2YXIgc2VsZWN0ZWROb2RlcyA9IGN5LiQoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGUuaXNOb2RlKCkgJiYgZWxlLnNlbGVjdGVkKCkgJiYgci5ub2RlSXNHcmFiYmFibGUoZWxlKTtcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgYWRkTm9kZXNUb0RyYWcoc2VsZWN0ZWROb2RlcywgeyBhZGRUb0xpc3Q6IGRyYWdnZWRFbGVtZW50cyB9KTtcblxuICAgICAgICAgICAgICBuZWFyLmVtaXQobWFrZUV2ZW50KCdncmFib24nKSk7XG5cbiAgICAgICAgICAgICAgc2VsZWN0ZWROb2Rlcy5mb3JFYWNoKHRyaWdnZXJHcmFiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgICAgICByLnJlZHJhd0hpbnQoJ2RyYWcnLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByLmhvdmVyRGF0YS5kb3duID0gbmVhcjtcbiAgICAgICAgci5ob3ZlckRhdGEuZG93bnMgPSBuZWFycztcbiAgICAgICAgci5ob3ZlckRhdGEuZG93blRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgIH1cblxuICAgICAgdHJpZ2dlckV2ZW50cyhuZWFyLCBbJ21vdXNlZG93bicsICd0YXBzdGFydCcsICd2bW91c2Vkb3duJ10sIGUsIHtcbiAgICAgICAgcG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChuZWFyID09IG51bGwpIHtcbiAgICAgICAgc2VsZWN0WzRdID0gMTtcblxuICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB7XG4gICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICB9O1xuXG4gICAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG5cbiAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgIH0gZWxzZSBpZiAobmVhci5pc0VkZ2UoKSkge1xuICAgICAgICBzZWxlY3RbNF0gPSAxOyAvLyBmb3IgZnV0dXJlIHBhblxuICAgICAgfVxuXG4gICAgICBjaGVja0ZvclRhcGhvbGQoKTtcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXplIHNlbGVjdGlvbiBib3ggY29vcmRpbmF0ZXNcbiAgICBzZWxlY3RbMF0gPSBzZWxlY3RbMl0gPSBwb3NbMF07XG4gICAgc2VsZWN0WzFdID0gc2VsZWN0WzNdID0gcG9zWzFdO1xuICB9LCBmYWxzZSk7XG5cbiAgci5yZWdpc3RlckJpbmRpbmcod2luZG93LCAnbW91c2Vtb3ZlJywgZnVuY3Rpb24gbW91c2Vtb3ZlSGFuZGxlcihlKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgIHZhciBjYXB0dXJlID0gci5ob3ZlckRhdGEuY2FwdHVyZTtcblxuICAgIGlmICghY2FwdHVyZSAmJiAhZXZlbnRJbkNvbnRhaW5lcihlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwcmV2ZW50RGVmYXVsdCA9IGZhbHNlO1xuICAgIHZhciBjeSA9IHIuY3k7XG4gICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgdmFyIGdwb3MgPSBbZS5jbGllbnRYLCBlLmNsaWVudFldO1xuICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZ3Bvc1swXSwgZ3Bvc1sxXSk7XG4gICAgdmFyIG1kb3duUG9zID0gci5ob3ZlckRhdGEubWRvd25Qb3M7XG4gICAgdmFyIG1kb3duR1BvcyA9IHIuaG92ZXJEYXRhLm1kb3duR1BvcztcbiAgICB2YXIgc2VsZWN0ID0gci5zZWxlY3Rpb247XG5cbiAgICB2YXIgbmVhciA9IG51bGw7XG4gICAgaWYgKCFyLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgJiYgIXIuaG92ZXJEYXRhLmRyYWdnaW5nICYmICFyLmhvdmVyRGF0YS5zZWxlY3RpbmcpIHtcbiAgICAgIG5lYXIgPSByLmZpbmROZWFyZXN0RWxlbWVudChwb3NbMF0sIHBvc1sxXSwgdHJ1ZSwgZmFsc2UpO1xuICAgIH1cbiAgICB2YXIgbGFzdCA9IHIuaG92ZXJEYXRhLmxhc3Q7XG4gICAgdmFyIGRvd24gPSByLmhvdmVyRGF0YS5kb3duO1xuXG4gICAgdmFyIGRpc3AgPSBbcG9zWzBdIC0gc2VsZWN0WzJdLCBwb3NbMV0gLSBzZWxlY3RbM11dO1xuXG4gICAgdmFyIGRyYWdnZWRFbGVtZW50cyA9IHIuZHJhZ0RhdGEucG9zc2libGVEcmFnRWxlbWVudHM7XG5cbiAgICB2YXIgaXNPdmVyVGhyZXNob2xkRHJhZztcblxuICAgIGlmIChtZG93bkdQb3MpIHtcbiAgICAgIHZhciBkeCA9IGdwb3NbMF0gLSBtZG93bkdQb3NbMF07XG4gICAgICB2YXIgZHgyID0gZHggKiBkeDtcbiAgICAgIHZhciBkeSA9IGdwb3NbMV0gLSBtZG93bkdQb3NbMV07XG4gICAgICB2YXIgZHkyID0gZHkgKiBkeTtcbiAgICAgIHZhciBkaXN0MiA9IGR4MiArIGR5MjtcblxuICAgICAgci5ob3ZlckRhdGEuaXNPdmVyVGhyZXNob2xkRHJhZyA9IGlzT3ZlclRocmVzaG9sZERyYWcgPSBkaXN0MiA+PSByLmRlc2t0b3BUYXBUaHJlc2hvbGQyO1xuICAgIH1cblxuICAgIHZhciBtdWx0U2VsS2V5RG93biA9IGlzTXVsdFNlbEtleURvd24oZSk7XG5cbiAgICBpZiAoaXNPdmVyVGhyZXNob2xkRHJhZykge1xuICAgICAgci5ob3ZlckRhdGEudGFwaG9sZENhbmNlbGxlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHVwZGF0ZURyYWdEZWx0YSA9IGZ1bmN0aW9uIHVwZGF0ZURyYWdEZWx0YSgpIHtcbiAgICAgIHZhciBkcmFnRGVsdGEgPSByLmhvdmVyRGF0YS5kcmFnRGVsdGEgPSByLmhvdmVyRGF0YS5kcmFnRGVsdGEgfHwgW107XG5cbiAgICAgIGlmIChkcmFnRGVsdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGRyYWdEZWx0YS5wdXNoKGRpc3BbMF0pO1xuICAgICAgICBkcmFnRGVsdGEucHVzaChkaXNwWzFdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRyYWdEZWx0YVswXSArPSBkaXNwWzBdO1xuICAgICAgICBkcmFnRGVsdGFbMV0gKz0gZGlzcFsxXTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcHJldmVudERlZmF1bHQgPSB0cnVlO1xuXG4gICAgdHJpZ2dlckV2ZW50cyhuZWFyLCBbJ21vdXNlbW92ZScsICd2bW91c2Vtb3ZlJywgJ3RhcGRyYWcnXSwgZSwge1xuICAgICAgcG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgIH0pO1xuXG4gICAgdmFyIGdvSW50b0JveE1vZGUgPSBmdW5jdGlvbiBnb0ludG9Cb3hNb2RlKCkge1xuICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoIXIuaG92ZXJEYXRhLnNlbGVjdGluZykge1xuICAgICAgICBjeS5lbWl0KCdib3hzdGFydCcpO1xuICAgICAgfVxuXG4gICAgICBzZWxlY3RbNF0gPSAxO1xuICAgICAgci5ob3ZlckRhdGEuc2VsZWN0aW5nID0gdHJ1ZTtcblxuICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgIHIucmVkcmF3KCk7XG4gICAgfTtcblxuICAgIC8vIHRyaWdnZXIgY29udGV4dCBkcmFnIGlmIHJtb3VzZSBkb3duXG4gICAgaWYgKHIuaG92ZXJEYXRhLndoaWNoID09PSAzKSB7XG4gICAgICAvLyBidXQgb25seSBpZiBvdmVyIHRocmVzaG9sZFxuICAgICAgaWYgKGlzT3ZlclRocmVzaG9sZERyYWcpIHtcbiAgICAgICAgdmFyIGN4dEV2dCA9IHtcbiAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgIHR5cGU6ICdjeHRkcmFnJyxcbiAgICAgICAgICBwb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGRvd24pIHtcbiAgICAgICAgICBkb3duLmVtaXQoY3h0RXZ0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjeS5lbWl0KGN4dEV2dCk7XG4gICAgICAgIH1cblxuICAgICAgICByLmhvdmVyRGF0YS5jeHREcmFnZ2VkID0gdHJ1ZTtcblxuICAgICAgICBpZiAoIXIuaG92ZXJEYXRhLmN4dE92ZXIgfHwgbmVhciAhPT0gci5ob3ZlckRhdGEuY3h0T3Zlcikge1xuXG4gICAgICAgICAgaWYgKHIuaG92ZXJEYXRhLmN4dE92ZXIpIHtcbiAgICAgICAgICAgIHIuaG92ZXJEYXRhLmN4dE92ZXIuZW1pdCh7XG4gICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgICAgIHR5cGU6ICdjeHRkcmFnb3V0JyxcbiAgICAgICAgICAgICAgcG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgci5ob3ZlckRhdGEuY3h0T3ZlciA9IG5lYXI7XG5cbiAgICAgICAgICBpZiAobmVhcikge1xuICAgICAgICAgICAgbmVhci5lbWl0KHtcbiAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICAgICAgdHlwZTogJ2N4dGRyYWdvdmVyJyxcbiAgICAgICAgICAgICAgcG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGlmIHdlIGFyZSBkcmFnIHBhbm5pbmcgdGhlIGVudGlyZSBncmFwaFxuICAgIH0gZWxzZSBpZiAoci5ob3ZlckRhdGEuZHJhZ2dpbmcpIHtcbiAgICAgIHByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcblxuICAgICAgaWYgKGN5LnBhbm5pbmdFbmFibGVkKCkgJiYgY3kudXNlclBhbm5pbmdFbmFibGVkKCkpIHtcbiAgICAgICAgdmFyIGRlbHRhUDtcblxuICAgICAgICBpZiAoci5ob3ZlckRhdGEuanVzdFN0YXJ0ZWRQYW4pIHtcbiAgICAgICAgICB2YXIgbWRQb3MgPSByLmhvdmVyRGF0YS5tZG93blBvcztcblxuICAgICAgICAgIGRlbHRhUCA9IHtcbiAgICAgICAgICAgIHg6IChwb3NbMF0gLSBtZFBvc1swXSkgKiB6b29tLFxuICAgICAgICAgICAgeTogKHBvc1sxXSAtIG1kUG9zWzFdKSAqIHpvb21cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgci5ob3ZlckRhdGEuanVzdFN0YXJ0ZWRQYW4gPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWx0YVAgPSB7XG4gICAgICAgICAgICB4OiBkaXNwWzBdICogem9vbSxcbiAgICAgICAgICAgIHk6IGRpc3BbMV0gKiB6b29tXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN5LnBhbkJ5KGRlbHRhUCk7XG5cbiAgICAgICAgci5ob3ZlckRhdGEuZHJhZ2dlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIE5lZWRzIHJlcHJvamVjdCBkdWUgdG8gcGFuIGNoYW5naW5nIHZpZXdwb3J0XG4gICAgICBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS5jbGllbnRYLCBlLmNsaWVudFkpO1xuXG4gICAgICAvLyBDaGVja3MgcHJpbWFyeSBidXR0b24gZG93biAmIG91dCBvZiB0aW1lICYgbW91c2Ugbm90IG1vdmVkIG11Y2hcbiAgICB9IGVsc2UgaWYgKHNlbGVjdFs0XSA9PSAxICYmIChkb3duID09IG51bGwgfHwgZG93bi5pc0VkZ2UoKSkpIHtcblxuICAgICAgaWYgKGlzT3ZlclRocmVzaG9sZERyYWcpIHtcblxuICAgICAgICBpZiAoIXIuaG92ZXJEYXRhLmRyYWdnaW5nICYmIGN5LmJveFNlbGVjdGlvbkVuYWJsZWQoKSAmJiAobXVsdFNlbEtleURvd24gfHwgIWN5LnBhbm5pbmdFbmFibGVkKCkgfHwgIWN5LnVzZXJQYW5uaW5nRW5hYmxlZCgpKSkge1xuICAgICAgICAgIGdvSW50b0JveE1vZGUoKTtcbiAgICAgICAgfSBlbHNlIGlmICghci5ob3ZlckRhdGEuc2VsZWN0aW5nICYmIGN5LnBhbm5pbmdFbmFibGVkKCkgJiYgY3kudXNlclBhbm5pbmdFbmFibGVkKCkpIHtcbiAgICAgICAgICB2YXIgYWxsb3dQYXNzdGhyb3VnaCA9IGFsbG93UGFubmluZ1Bhc3N0aHJvdWdoKGRvd24sIHIuaG92ZXJEYXRhLmRvd25zKTtcblxuICAgICAgICAgIGlmIChhbGxvd1Bhc3N0aHJvdWdoKSB7XG4gICAgICAgICAgICByLmhvdmVyRGF0YS5kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICByLmhvdmVyRGF0YS5qdXN0U3RhcnRlZFBhbiA9IHRydWU7XG4gICAgICAgICAgICBzZWxlY3RbNF0gPSAwO1xuXG4gICAgICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSBtYXRoLmFycmF5MnBvaW50KG1kb3duUG9zKTtcblxuICAgICAgICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgICAgICAgIHIucmVkcmF3KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRvd24gJiYgZG93bi5pc0VkZ2UoKSAmJiBkb3duLmFjdGl2ZSgpKSB7XG4gICAgICAgICAgZG93bi51bmFjdGl2YXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGRvd24gJiYgZG93bi5pc0VkZ2UoKSAmJiBkb3duLmFjdGl2ZSgpKSB7XG4gICAgICAgIGRvd24udW5hY3RpdmF0ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoKCFkb3duIHx8ICFkb3duLmdyYWJiZWQoKSkgJiYgbmVhciAhPSBsYXN0KSB7XG5cbiAgICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgICB0cmlnZ2VyRXZlbnRzKGxhc3QsIFsnbW91c2VvdXQnLCAndGFwZHJhZ291dCddLCBlLCB7XG4gICAgICAgICAgICBwb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmVhcikge1xuICAgICAgICAgIHRyaWdnZXJFdmVudHMobmVhciwgWydtb3VzZW92ZXInLCAndGFwZHJhZ292ZXInXSwgZSwge1xuICAgICAgICAgICAgcG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgci5ob3ZlckRhdGEubGFzdCA9IG5lYXI7XG4gICAgICB9XG5cbiAgICAgIGlmIChkb3duKSB7XG5cbiAgICAgICAgaWYgKGlzT3ZlclRocmVzaG9sZERyYWcpIHtcbiAgICAgICAgICAvLyB0aGVuIHdlIGNhbiB0YWtlIGFjdGlvblxuXG4gICAgICAgICAgaWYgKGN5LmJveFNlbGVjdGlvbkVuYWJsZWQoKSAmJiBtdWx0U2VsS2V5RG93bikge1xuICAgICAgICAgICAgLy8gdGhlbiBzZWxlY3Rpb24gb3ZlcnJpZGVzXG4gICAgICAgICAgICBpZiAoZG93biAmJiBkb3duLmdyYWJiZWQoKSkge1xuICAgICAgICAgICAgICBmcmVlRHJhZ2dlZEVsZW1lbnRzKGRyYWdnZWRFbGVtZW50cyk7XG5cbiAgICAgICAgICAgICAgZG93bi5lbWl0KCdmcmVlJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdvSW50b0JveE1vZGUoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGRvd24gJiYgZG93bi5ncmFiYmVkKCkgJiYgci5ub2RlSXNEcmFnZ2FibGUoZG93bikpIHtcbiAgICAgICAgICAgIC8vIGRyYWcgbm9kZVxuICAgICAgICAgICAgdmFyIGp1c3RTdGFydGVkRHJhZyA9ICFyLmRyYWdEYXRhLmRpZERyYWc7XG5cbiAgICAgICAgICAgIGlmIChqdXN0U3RhcnRlZERyYWcpIHtcbiAgICAgICAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHIuZHJhZ0RhdGEuZGlkRHJhZyA9IHRydWU7IC8vIGluZGljYXRlIHRoYXQgd2UgYWN0dWFsbHkgZGlkIGRyYWcgdGhlIG5vZGVcblxuICAgICAgICAgICAgdmFyIHRvVHJpZ2dlciA9IFtdO1xuXG4gICAgICAgICAgICAvLyBub3csIGFkZCB0aGUgZWxlbWVudHMgdG8gdGhlIGRyYWcgbGF5ZXIgaWYgbm90IGRvbmUgYWxyZWFkeVxuICAgICAgICAgICAgaWYgKCFyLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMpIHtcbiAgICAgICAgICAgICAgYWRkTm9kZXNUb0RyYWcoY3kuY29sbGVjdGlvbihkcmFnZ2VkRWxlbWVudHMpLCB7IGluRHJhZ0xheWVyOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRyYWdnZWRFbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgZEVsZSA9IGRyYWdnZWRFbGVtZW50c1tpXTtcblxuICAgICAgICAgICAgICAvLyBMb2NrZWQgbm9kZXMgbm90IGRyYWdnYWJsZSwgYXMgd2VsbCBhcyBub24tdmlzaWJsZSBub2Rlc1xuICAgICAgICAgICAgICBpZiAoci5ub2RlSXNEcmFnZ2FibGUoZEVsZSkgJiYgZEVsZS5ncmFiYmVkKCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZFBvcyA9IGRFbGUucG9zaXRpb24oKTtcblxuICAgICAgICAgICAgICAgIHRvVHJpZ2dlci5wdXNoKGRFbGUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzLm51bWJlcihkaXNwWzBdKSAmJiBpcy5udW1iZXIoZGlzcFsxXSkpIHtcbiAgICAgICAgICAgICAgICAgIGRQb3MueCArPSBkaXNwWzBdO1xuICAgICAgICAgICAgICAgICAgZFBvcy55ICs9IGRpc3BbMV07XG5cbiAgICAgICAgICAgICAgICAgIGlmIChqdXN0U3RhcnRlZERyYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRyYWdEZWx0YSA9IHIuaG92ZXJEYXRhLmRyYWdEZWx0YTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZHJhZ0RlbHRhICYmIGlzLm51bWJlcihkcmFnRGVsdGFbMF0pICYmIGlzLm51bWJlcihkcmFnRGVsdGFbMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZFBvcy54ICs9IGRyYWdEZWx0YVswXTtcbiAgICAgICAgICAgICAgICAgICAgICBkUG9zLnkgKz0gZHJhZ0RlbHRhWzFdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcyA9IHRydWU7XG5cbiAgICAgICAgICAgIHZhciB0Y29sID0gY3kuY29sbGVjdGlvbih0b1RyaWdnZXIpO1xuXG4gICAgICAgICAgICB0Y29sLmRpcnR5Q29tcG91bmRCb3VuZHNDYWNoZSgpO1xuICAgICAgICAgICAgdGNvbC5lbWl0KCdwb3NpdGlvbiBkcmFnJyk7XG5cbiAgICAgICAgICAgIHIucmVkcmF3SGludCgnZHJhZycsIHRydWUpO1xuICAgICAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gb3RoZXJ3aXNlIHNhdmUgZHJhZyBkZWx0YSBmb3Igd2hlbiB3ZSBhY3R1YWxseSBzdGFydCBkcmFnZ2luZyBzbyB0aGUgcmVsYXRpdmUgZ3JhYiBwb3MgaXMgY29uc3RhbnRcbiAgICAgICAgICB1cGRhdGVEcmFnRGVsdGEoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBwcmV2ZW50IHRoZSBkcmFnZ2luZyBmcm9tIHRyaWdnZXJpbmcgdGV4dCBzZWxlY3Rpb24gb24gdGhlIHBhZ2VcbiAgICAgIHByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBzZWxlY3RbMl0gPSBwb3NbMF07c2VsZWN0WzNdID0gcG9zWzFdO1xuXG4gICAgaWYgKHByZXZlbnREZWZhdWx0KSB7XG4gICAgICBpZiAoZS5zdG9wUHJvcGFnYXRpb24pIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwgZmFsc2UpO1xuXG4gIHIucmVnaXN0ZXJCaW5kaW5nKHdpbmRvdywgJ21vdXNldXAnLCBmdW5jdGlvbiBtb3VzZXVwSGFuZGxlcihlKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgIHZhciBjYXB0dXJlID0gci5ob3ZlckRhdGEuY2FwdHVyZTtcbiAgICBpZiAoIWNhcHR1cmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgci5ob3ZlckRhdGEuY2FwdHVyZSA9IGZhbHNlO1xuXG4gICAgdmFyIGN5ID0gci5jeTt2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUuY2xpZW50WCwgZS5jbGllbnRZKTt2YXIgc2VsZWN0ID0gci5zZWxlY3Rpb247XG4gICAgdmFyIG5lYXIgPSByLmZpbmROZWFyZXN0RWxlbWVudChwb3NbMF0sIHBvc1sxXSwgdHJ1ZSwgZmFsc2UpO1xuICAgIHZhciBkcmFnZ2VkRWxlbWVudHMgPSByLmRyYWdEYXRhLnBvc3NpYmxlRHJhZ0VsZW1lbnRzO3ZhciBkb3duID0gci5ob3ZlckRhdGEuZG93bjtcbiAgICB2YXIgbXVsdFNlbEtleURvd24gPSBpc011bHRTZWxLZXlEb3duKGUpO1xuXG4gICAgaWYgKHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbikge1xuICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgIHIucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgci5ob3ZlckRhdGEudGFwaG9sZENhbmNlbGxlZCA9IHRydWU7XG5cbiAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7IC8vIG5vdCBhY3RpdmUgYmcgbm93XG5cbiAgICBpZiAoZG93bikge1xuICAgICAgZG93bi51bmFjdGl2YXRlKCk7XG4gICAgfVxuXG4gICAgaWYgKHIuaG92ZXJEYXRhLndoaWNoID09PSAzKSB7XG4gICAgICB2YXIgY3h0RXZ0ID0ge1xuICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICB0eXBlOiAnY3h0dGFwZW5kJyxcbiAgICAgICAgcG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgfTtcblxuICAgICAgaWYgKGRvd24pIHtcbiAgICAgICAgZG93bi5lbWl0KGN4dEV2dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjeS5lbWl0KGN4dEV2dCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghci5ob3ZlckRhdGEuY3h0RHJhZ2dlZCkge1xuICAgICAgICB2YXIgY3h0VGFwID0ge1xuICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgdHlwZTogJ2N4dHRhcCcsXG4gICAgICAgICAgcG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChkb3duKSB7XG4gICAgICAgICAgZG93bi5lbWl0KGN4dFRhcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3kuZW1pdChjeHRUYXApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHIuaG92ZXJEYXRhLmN4dERyYWdnZWQgPSBmYWxzZTtcbiAgICAgIHIuaG92ZXJEYXRhLndoaWNoID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKHIuaG92ZXJEYXRhLndoaWNoID09PSAxKSB7XG5cbiAgICAgIC8vIERlc2VsZWN0IGFsbCBlbGVtZW50cyBpZiBub3RoaW5nIGlzIGN1cnJlbnRseSB1bmRlciB0aGUgbW91c2UgY3Vyc29yIGFuZCB3ZSBhcmVuJ3QgZHJhZ2dpbmcgc29tZXRoaW5nXG4gICAgICBpZiAoZG93biA9PSBudWxsICYmIC8vIG5vdCBtb3VzZWRvd24gb24gbm9kZVxuICAgICAgIXIuZHJhZ0RhdGEuZGlkRHJhZyAvLyBkaWRuJ3QgbW92ZSB0aGUgbm9kZSBhcm91bmRcbiAgICAgICYmICFyLmhvdmVyRGF0YS5zZWxlY3RpbmcgLy8gbm90IGJveCBzZWxlY3Rpb25cbiAgICAgICYmICFyLmhvdmVyRGF0YS5kcmFnZ2VkIC8vIGRpZG4ndCBwYW5cbiAgICAgICYmICFpc011bHRTZWxLZXlEb3duKGUpKSB7XG5cbiAgICAgICAgY3kuJChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgICAgcmV0dXJuIGVsZS5zZWxlY3RlZCgpO1xuICAgICAgICB9KS51bnNlbGVjdCgpO1xuXG4gICAgICAgIGlmIChkcmFnZ2VkRWxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgci5kcmFnRGF0YS5wb3NzaWJsZURyYWdFbGVtZW50cyA9IGRyYWdnZWRFbGVtZW50cyA9IFtdO1xuICAgICAgfVxuXG4gICAgICB0cmlnZ2VyRXZlbnRzKG5lYXIsIFsnbW91c2V1cCcsICd0YXBlbmQnLCAndm1vdXNldXAnXSwgZSwge1xuICAgICAgICBwb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKCFyLmRyYWdEYXRhLmRpZERyYWcgLy8gZGlkbid0IG1vdmUgYSBub2RlIGFyb3VuZFxuICAgICAgJiYgIXIuaG92ZXJEYXRhLmRyYWdnZWQgLy8gZGlkbid0IHBhblxuICAgICAgJiYgIXIuaG92ZXJEYXRhLnNlbGVjdGluZyAvLyBub3QgYm94IHNlbGVjdGlvblxuICAgICAgJiYgIXIuaG92ZXJEYXRhLmlzT3ZlclRocmVzaG9sZERyYWcgLy8gZGlkbid0IG1vdmUgdG9vIG11Y2hcbiAgICAgICkge1xuICAgICAgICAgIHRyaWdnZXJFdmVudHMoZG93biwgWydjbGljaycsICd0YXAnLCAndmNsaWNrJ10sIGUsIHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAvLyBTaW5nbGUgc2VsZWN0aW9uXG4gICAgICBpZiAobmVhciA9PSBkb3duICYmICFyLmRyYWdEYXRhLmRpZERyYWcgJiYgIXIuaG92ZXJEYXRhLnNlbGVjdGluZykge1xuICAgICAgICBpZiAobmVhciAhPSBudWxsICYmIG5lYXIuX3ByaXZhdGUuc2VsZWN0YWJsZSkge1xuXG4gICAgICAgICAgaWYgKHIuaG92ZXJEYXRhLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICAvLyBpZiBwYW5uaW5nLCBkb24ndCBjaGFuZ2Ugc2VsZWN0aW9uIHN0YXRlXG4gICAgICAgICAgfSBlbHNlIGlmIChjeS5zZWxlY3Rpb25UeXBlKCkgPT09ICdhZGRpdGl2ZScgfHwgbXVsdFNlbEtleURvd24pIHtcbiAgICAgICAgICAgIGlmIChuZWFyLnNlbGVjdGVkKCkpIHtcbiAgICAgICAgICAgICAgbmVhci51bnNlbGVjdCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmVhci5zZWxlY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFtdWx0U2VsS2V5RG93bikge1xuICAgICAgICAgICAgICBjeS4kKCc6c2VsZWN0ZWQnKS51bm1lcmdlKG5lYXIpLnVuc2VsZWN0KCk7XG4gICAgICAgICAgICAgIG5lYXIuc2VsZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHIuaG92ZXJEYXRhLnNlbGVjdGluZykge1xuICAgICAgICB2YXIgYm94ID0gY3kuY29sbGVjdGlvbihyLmdldEFsbEluQm94KHNlbGVjdFswXSwgc2VsZWN0WzFdLCBzZWxlY3RbMl0sIHNlbGVjdFszXSkpO1xuXG4gICAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKGJveC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjeS5lbWl0KCdib3hlbmQnKTtcblxuICAgICAgICB2YXIgZWxlV291bGRCZVNlbGVjdGVkID0gZnVuY3Rpb24gZWxlV291bGRCZVNlbGVjdGVkKGVsZSkge1xuICAgICAgICAgIHJldHVybiBlbGUuc2VsZWN0YWJsZSgpICYmICFlbGUuc2VsZWN0ZWQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoY3kuc2VsZWN0aW9uVHlwZSgpID09PSAnYWRkaXRpdmUnKSB7XG4gICAgICAgICAgYm94LmVtaXQoJ2JveCcpLnN0ZEZpbHRlcihlbGVXb3VsZEJlU2VsZWN0ZWQpLnNlbGVjdCgpLmVtaXQoJ2JveHNlbGVjdCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghbXVsdFNlbEtleURvd24pIHtcbiAgICAgICAgICAgIGN5LiQoJzpzZWxlY3RlZCcpLnVubWVyZ2UoYm94KS51bnNlbGVjdCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJveC5lbWl0KCdib3gnKS5zdGRGaWx0ZXIoZWxlV291bGRCZVNlbGVjdGVkKS5zZWxlY3QoKS5lbWl0KCdib3hzZWxlY3QnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFsd2F5cyBuZWVkIHJlZHJhdyBpbiBjYXNlIGVsZXMgdW5zZWxlY3RhYmxlXG4gICAgICAgIHIucmVkcmF3KCk7XG4gICAgICB9XG5cbiAgICAgIC8vIENhbmNlbCBkcmFnIHBhblxuICAgICAgaWYgKHIuaG92ZXJEYXRhLmRyYWdnaW5nKSB7XG4gICAgICAgIHIuaG92ZXJEYXRhLmRyYWdnaW5nID0gZmFsc2U7XG5cbiAgICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG5cbiAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFzZWxlY3RbNF0pIHtcbiAgICAgICAgci5yZWRyYXdIaW50KCdkcmFnJywgdHJ1ZSk7XG4gICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuXG4gICAgICAgIHZhciBkb3duV2FzR3JhYmJlZCA9IGRvd24gJiYgZG93bi5ncmFiYmVkKCk7XG5cbiAgICAgICAgZnJlZURyYWdnZWRFbGVtZW50cyhkcmFnZ2VkRWxlbWVudHMpO1xuXG4gICAgICAgIGlmIChkb3duV2FzR3JhYmJlZCkge1xuICAgICAgICAgIGRvd24uZW1pdCgnZnJlZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBlbHNlIG5vdCByaWdodCBtb3VzZVxuXG4gICAgc2VsZWN0WzRdID0gMDtyLmhvdmVyRGF0YS5kb3duID0gbnVsbDtcblxuICAgIHIuaG92ZXJEYXRhLmN4dFN0YXJ0ZWQgPSBmYWxzZTtcbiAgICByLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgPSBmYWxzZTtcbiAgICByLmhvdmVyRGF0YS5zZWxlY3RpbmcgPSBmYWxzZTtcbiAgICByLmhvdmVyRGF0YS5pc092ZXJUaHJlc2hvbGREcmFnID0gZmFsc2U7XG4gICAgci5kcmFnRGF0YS5kaWREcmFnID0gZmFsc2U7XG4gICAgci5ob3ZlckRhdGEuZHJhZ2dlZCA9IGZhbHNlO1xuICAgIHIuaG92ZXJEYXRhLmRyYWdEZWx0YSA9IFtdO1xuICAgIHIuaG92ZXJEYXRhLm1kb3duUG9zID0gbnVsbDtcbiAgICByLmhvdmVyRGF0YS5tZG93bkdQb3MgPSBudWxsO1xuICB9LCBmYWxzZSk7XG5cbiAgdmFyIHdoZWVsSGFuZGxlciA9IGZ1bmN0aW9uIHdoZWVsSGFuZGxlcihlKSB7XG5cbiAgICBpZiAoci5zY3JvbGxpbmdQYWdlKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyB3aGlsZSBzY3JvbGxpbmcsIGlnbm9yZSB3aGVlbC10by16b29tXG5cbiAgICB2YXIgY3kgPSByLmN5O1xuICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS5jbGllbnRYLCBlLmNsaWVudFkpO1xuICAgIHZhciBycG9zID0gW3Bvc1swXSAqIGN5Lnpvb20oKSArIGN5LnBhbigpLngsIHBvc1sxXSAqIGN5Lnpvb20oKSArIGN5LnBhbigpLnldO1xuXG4gICAgaWYgKHIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcyB8fCByLmhvdmVyRGF0YS5kcmFnZ2luZyB8fCByLmhvdmVyRGF0YS5jeHRTdGFydGVkIHx8IGluQm94U2VsZWN0aW9uKCkpIHtcbiAgICAgIC8vIGlmIHBhbiBkcmFnZ2luZyBvciBjeHQgZHJhZ2dpbmcsIHdoZWVsIG1vdmVtZW50cyBtYWtlIG5vIHpvb21cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY3kucGFubmluZ0VuYWJsZWQoKSAmJiBjeS51c2VyUGFubmluZ0VuYWJsZWQoKSAmJiBjeS56b29taW5nRW5hYmxlZCgpICYmIGN5LnVzZXJab29taW5nRW5hYmxlZCgpKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIHIuZGF0YS53aGVlbFpvb21pbmcgPSB0cnVlO1xuICAgICAgY2xlYXJUaW1lb3V0KHIuZGF0YS53aGVlbFRpbWVvdXQpO1xuICAgICAgci5kYXRhLndoZWVsVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICByLmRhdGEud2hlZWxab29taW5nID0gZmFsc2U7XG5cbiAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgIHIucmVkcmF3KCk7XG4gICAgICB9LCAxNTApO1xuXG4gICAgICB2YXIgZGlmZjtcblxuICAgICAgaWYgKGUuZGVsdGFZICE9IG51bGwpIHtcbiAgICAgICAgZGlmZiA9IGUuZGVsdGFZIC8gLTI1MDtcbiAgICAgIH0gZWxzZSBpZiAoZS53aGVlbERlbHRhWSAhPSBudWxsKSB7XG4gICAgICAgIGRpZmYgPSBlLndoZWVsRGVsdGFZIC8gMTAwMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpZmYgPSBlLndoZWVsRGVsdGEgLyAxMDAwO1xuICAgICAgfVxuXG4gICAgICBkaWZmID0gZGlmZiAqIHIud2hlZWxTZW5zaXRpdml0eTtcblxuICAgICAgdmFyIG5lZWRzV2hlZWxGaXggPSBlLmRlbHRhTW9kZSA9PT0gMTtcbiAgICAgIGlmIChuZWVkc1doZWVsRml4KSB7XG4gICAgICAgIC8vIGZpeGVzIHNsb3cgd2hlZWwgZXZlbnRzIG9uIGZmL2xpbnV4IGFuZCBmZi93aW5kb3dzXG4gICAgICAgIGRpZmYgKj0gMzM7XG4gICAgICB9XG5cbiAgICAgIGN5Lnpvb20oe1xuICAgICAgICBsZXZlbDogY3kuem9vbSgpICogTWF0aC5wb3coMTAsIGRpZmYpLFxuICAgICAgICByZW5kZXJlZFBvc2l0aW9uOiB7IHg6IHJwb3NbMF0sIHk6IHJwb3NbMV0gfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIEZ1bmN0aW9ucyB0byBoZWxwIHdpdGggd2hldGhlciBtb3VzZSB3aGVlbCBzaG91bGQgdHJpZ2dlciB6b29taW5nXG4gIC8vIC0tXG4gIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAnd2hlZWwnLCB3aGVlbEhhbmRsZXIsIHRydWUpO1xuXG4gIC8vIGRpc2FibGUgbm9uc3RhbmRhcmQgd2hlZWwgZXZlbnRzXG4gIC8vIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAnbW91c2V3aGVlbCcsIHdoZWVsSGFuZGxlciwgdHJ1ZSk7XG4gIC8vIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAnRE9NTW91c2VTY3JvbGwnLCB3aGVlbEhhbmRsZXIsIHRydWUpO1xuICAvLyByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ01vek1vdXNlUGl4ZWxTY3JvbGwnLCB3aGVlbEhhbmRsZXIsIHRydWUpOyAvLyBvbGRlciBmaXJlZm94XG5cbiAgci5yZWdpc3RlckJpbmRpbmcod2luZG93LCAnc2Nyb2xsJywgZnVuY3Rpb24gc2Nyb2xsSGFuZGxlcihlKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgIHIuc2Nyb2xsaW5nUGFnZSA9IHRydWU7XG5cbiAgICBjbGVhclRpbWVvdXQoci5zY3JvbGxpbmdQYWdlVGltZW91dCk7XG4gICAgci5zY3JvbGxpbmdQYWdlVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgci5zY3JvbGxpbmdQYWdlID0gZmFsc2U7XG4gICAgfSwgMjUwKTtcbiAgfSwgdHJ1ZSk7XG5cbiAgLy8gRnVuY3Rpb25zIHRvIGhlbHAgd2l0aCBoYW5kbGluZyBtb3VzZW91dC9tb3VzZW92ZXIgb24gdGhlIEN5dG9zY2FwZSBjb250YWluZXJcbiAgLy8gSGFuZGxlIG1vdXNlb3V0IG9uIEN5dG9zY2FwZSBjb250YWluZXJcbiAgci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdtb3VzZW91dCcsIGZ1bmN0aW9uIG1vdXNlT3V0SGFuZGxlcihlKSB7XG4gICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLmNsaWVudFgsIGUuY2xpZW50WSk7XG5cbiAgICByLmN5LmVtaXQoe1xuICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgIHR5cGU6ICdtb3VzZW91dCcsXG4gICAgICBwb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgfSk7XG4gIH0sIGZhbHNlKTtcblxuICByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ21vdXNlb3ZlcicsIGZ1bmN0aW9uIG1vdXNlT3ZlckhhbmRsZXIoZSkge1xuICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS5jbGllbnRYLCBlLmNsaWVudFkpO1xuXG4gICAgci5jeS5lbWl0KHtcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICB0eXBlOiAnbW91c2VvdmVyJyxcbiAgICAgIHBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICB9KTtcbiAgfSwgZmFsc2UpO1xuXG4gIHZhciBmMXgxLCBmMXkxLCBmMngxLCBmMnkxOyAvLyBzdGFydGluZyBwb2ludHMgZm9yIHBpbmNoLXRvLXpvb21cbiAgdmFyIGRpc3RhbmNlMSwgZGlzdGFuY2UxU3E7IC8vIGluaXRpYWwgZGlzdGFuY2UgYmV0d2VlbiBmaW5nZXIgMSBhbmQgZmluZ2VyIDIgZm9yIHBpbmNoLXRvLXpvb21cbiAgdmFyIGNlbnRlcjEsIG1vZGVsQ2VudGVyMTsgLy8gY2VudGVyIHBvaW50IG9uIHN0YXJ0IHBpbmNoIHRvIHpvb21cbiAgdmFyIG9mZnNldExlZnQsIG9mZnNldFRvcDtcbiAgdmFyIGNvbnRhaW5lcldpZHRoLCBjb250YWluZXJIZWlnaHQ7XG4gIHZhciB0d29GaW5nZXJzU3RhcnRJbnNpZGU7XG5cbiAgdmFyIGRpc3RhbmNlID0gZnVuY3Rpb24gZGlzdGFuY2UoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KCh4MiAtIHgxKSAqICh4MiAtIHgxKSArICh5MiAtIHkxKSAqICh5MiAtIHkxKSk7XG4gIH07XG5cbiAgdmFyIGRpc3RhbmNlU3EgPSBmdW5jdGlvbiBkaXN0YW5jZVNxKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgcmV0dXJuICh4MiAtIHgxKSAqICh4MiAtIHgxKSArICh5MiAtIHkxKSAqICh5MiAtIHkxKTtcbiAgfTtcblxuICB2YXIgdG91Y2hzdGFydEhhbmRsZXI7XG4gIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRvdWNoc3RhcnRIYW5kbGVyID0gZnVuY3Rpb24gdG91Y2hzdGFydEhhbmRsZXIoZSkge1xuICAgIGlmICghZXZlbnRJbkNvbnRhaW5lcihlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGJsdXJBY3RpdmVEb21FbGVtZW50KCk7XG5cbiAgICByLnRvdWNoRGF0YS5jYXB0dXJlID0gdHJ1ZTtcbiAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG5cbiAgICB2YXIgY3kgPSByLmN5O1xuICAgIHZhciBub3cgPSByLnRvdWNoRGF0YS5ub3c7XG4gICAgdmFyIGVhcmxpZXIgPSByLnRvdWNoRGF0YS5lYXJsaWVyO1xuXG4gICAgaWYgKGUudG91Y2hlc1swXSkge1xuICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMF0uY2xpZW50WCwgZS50b3VjaGVzWzBdLmNsaWVudFkpO25vd1swXSA9IHBvc1swXTtub3dbMV0gPSBwb3NbMV07XG4gICAgfVxuICAgIGlmIChlLnRvdWNoZXNbMV0pIHtcbiAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzFdLmNsaWVudFgsIGUudG91Y2hlc1sxXS5jbGllbnRZKTtub3dbMl0gPSBwb3NbMF07bm93WzNdID0gcG9zWzFdO1xuICAgIH1cbiAgICBpZiAoZS50b3VjaGVzWzJdKSB7XG4gICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1syXS5jbGllbnRYLCBlLnRvdWNoZXNbMl0uY2xpZW50WSk7bm93WzRdID0gcG9zWzBdO25vd1s1XSA9IHBvc1sxXTtcbiAgICB9XG5cbiAgICAvLyByZWNvcmQgc3RhcnRpbmcgcG9pbnRzIGZvciBwaW5jaC10by16b29tXG4gICAgaWYgKGUudG91Y2hlc1sxXSkge1xuXG4gICAgICBmcmVlRHJhZ2dlZEVsZW1lbnRzKHIuZHJhZ0RhdGEudG91Y2hEcmFnRWxlcyk7XG5cbiAgICAgIHZhciBvZmZzZXRzID0gci5maW5kQ29udGFpbmVyQ2xpZW50Q29vcmRzKCk7XG4gICAgICBvZmZzZXRMZWZ0ID0gb2Zmc2V0c1swXTtcbiAgICAgIG9mZnNldFRvcCA9IG9mZnNldHNbMV07XG4gICAgICBjb250YWluZXJXaWR0aCA9IG9mZnNldHNbMl07XG4gICAgICBjb250YWluZXJIZWlnaHQgPSBvZmZzZXRzWzNdO1xuXG4gICAgICBmMXgxID0gZS50b3VjaGVzWzBdLmNsaWVudFggLSBvZmZzZXRMZWZ0O1xuICAgICAgZjF5MSA9IGUudG91Y2hlc1swXS5jbGllbnRZIC0gb2Zmc2V0VG9wO1xuXG4gICAgICBmMngxID0gZS50b3VjaGVzWzFdLmNsaWVudFggLSBvZmZzZXRMZWZ0O1xuICAgICAgZjJ5MSA9IGUudG91Y2hlc1sxXS5jbGllbnRZIC0gb2Zmc2V0VG9wO1xuXG4gICAgICB0d29GaW5nZXJzU3RhcnRJbnNpZGUgPSAwIDw9IGYxeDEgJiYgZjF4MSA8PSBjb250YWluZXJXaWR0aCAmJiAwIDw9IGYyeDEgJiYgZjJ4MSA8PSBjb250YWluZXJXaWR0aCAmJiAwIDw9IGYxeTEgJiYgZjF5MSA8PSBjb250YWluZXJIZWlnaHQgJiYgMCA8PSBmMnkxICYmIGYyeTEgPD0gY29udGFpbmVySGVpZ2h0O1xuXG4gICAgICB2YXIgcGFuID0gY3kucGFuKCk7XG4gICAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcblxuICAgICAgZGlzdGFuY2UxID0gZGlzdGFuY2UoZjF4MSwgZjF5MSwgZjJ4MSwgZjJ5MSk7XG4gICAgICBkaXN0YW5jZTFTcSA9IGRpc3RhbmNlU3EoZjF4MSwgZjF5MSwgZjJ4MSwgZjJ5MSk7XG4gICAgICBjZW50ZXIxID0gWyhmMXgxICsgZjJ4MSkgLyAyLCAoZjF5MSArIGYyeTEpIC8gMl07XG4gICAgICBtb2RlbENlbnRlcjEgPSBbKGNlbnRlcjFbMF0gLSBwYW4ueCkgLyB6b29tLCAoY2VudGVyMVsxXSAtIHBhbi55KSAvIHpvb21dO1xuXG4gICAgICAvLyBjb25zaWRlciBjb250ZXh0IHRhcFxuICAgICAgdmFyIGN4dERpc3RUaHJlc2hvbGQgPSAyMDA7XG4gICAgICB2YXIgY3h0RGlzdFRocmVzaG9sZFNxID0gY3h0RGlzdFRocmVzaG9sZCAqIGN4dERpc3RUaHJlc2hvbGQ7XG4gICAgICBpZiAoZGlzdGFuY2UxU3EgPCBjeHREaXN0VGhyZXNob2xkU3EgJiYgIWUudG91Y2hlc1syXSkge1xuXG4gICAgICAgIHZhciBuZWFyMSA9IHIuZmluZE5lYXJlc3RFbGVtZW50KG5vd1swXSwgbm93WzFdLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgdmFyIG5lYXIyID0gci5maW5kTmVhcmVzdEVsZW1lbnQobm93WzJdLCBub3dbM10sIHRydWUsIHRydWUpO1xuXG4gICAgICAgIGlmIChuZWFyMSAmJiBuZWFyMS5pc05vZGUoKSkge1xuICAgICAgICAgIG5lYXIxLmFjdGl2YXRlKCkuZW1pdCh7XG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgICAgdHlwZTogJ2N4dHRhcHN0YXJ0JyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydCA9IG5lYXIxO1xuICAgICAgICB9IGVsc2UgaWYgKG5lYXIyICYmIG5lYXIyLmlzTm9kZSgpKSB7XG4gICAgICAgICAgbmVhcjIuYWN0aXZhdGUoKS5lbWl0KHtcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgICB0eXBlOiAnY3h0dGFwc3RhcnQnLFxuICAgICAgICAgICAgcG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0ID0gbmVhcjI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3kuZW1pdCh7XG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgICAgdHlwZTogJ2N4dHRhcHN0YXJ0JyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyLnRvdWNoRGF0YS5zdGFydCkge1xuICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0Ll9wcml2YXRlLmdyYWJiZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByLnRvdWNoRGF0YS5jeHQgPSB0cnVlO1xuICAgICAgICByLnRvdWNoRGF0YS5jeHREcmFnZ2VkID0gZmFsc2U7XG4gICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcblxuICAgICAgICByLnJlZHJhdygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGUudG91Y2hlc1syXSkge1xuICAgICAgLy8gaWdub3JlXG4gICAgfSBlbHNlIGlmIChlLnRvdWNoZXNbMV0pIHtcbiAgICAgIC8vIGlnbm9yZVxuICAgIH0gZWxzZSBpZiAoZS50b3VjaGVzWzBdKSB7XG4gICAgICB2YXIgbmVhcnMgPSByLmZpbmROZWFyZXN0RWxlbWVudHMobm93WzBdLCBub3dbMV0sIHRydWUsIHRydWUpO1xuICAgICAgdmFyIG5lYXIgPSBuZWFyc1swXTtcblxuICAgICAgaWYgKG5lYXIgIT0gbnVsbCkge1xuICAgICAgICBuZWFyLmFjdGl2YXRlKCk7XG5cbiAgICAgICAgci50b3VjaERhdGEuc3RhcnQgPSBuZWFyO1xuICAgICAgICByLnRvdWNoRGF0YS5zdGFydHMgPSBuZWFycztcblxuICAgICAgICBpZiAoci5ub2RlSXNHcmFiYmFibGUobmVhcikpIHtcblxuICAgICAgICAgIHZhciBkcmFnZ2VkRWxlcyA9IHIuZHJhZ0RhdGEudG91Y2hEcmFnRWxlcyA9IFtdO1xuICAgICAgICAgIHZhciBzZWxlY3RlZE5vZGVzID0gbnVsbDtcblxuICAgICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICAgIHIucmVkcmF3SGludCgnZHJhZycsIHRydWUpO1xuXG4gICAgICAgICAgaWYgKG5lYXIuc2VsZWN0ZWQoKSkge1xuICAgICAgICAgICAgLy8gcmVzZXQgZHJhZyBlbGVtZW50cywgc2luY2UgbmVhciB3aWxsIGJlIGFkZGVkIGFnYWluXG5cbiAgICAgICAgICAgIHNlbGVjdGVkTm9kZXMgPSBjeS4kKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGVsZS5zZWxlY3RlZCgpICYmIHIubm9kZUlzR3JhYmJhYmxlKGVsZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgYWRkTm9kZXNUb0RyYWcoc2VsZWN0ZWROb2RlcywgeyBhZGRUb0xpc3Q6IGRyYWdnZWRFbGVzIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhZGROb2RlVG9EcmFnKG5lYXIsIHsgYWRkVG9MaXN0OiBkcmFnZ2VkRWxlcyB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZXRHcmFiVGFyZ2V0KG5lYXIpO1xuXG4gICAgICAgICAgdmFyIG1ha2VFdmVudCA9IGZ1bmN0aW9uIG1ha2VFdmVudCh0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICBwb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBuZWFyLmVtaXQobWFrZUV2ZW50KCdncmFib24nKSk7XG5cbiAgICAgICAgICBpZiAoc2VsZWN0ZWROb2Rlcykge1xuICAgICAgICAgICAgc2VsZWN0ZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICAgIG4uZW1pdChtYWtlRXZlbnQoJ2dyYWInKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmVhci5lbWl0KG1ha2VFdmVudCgnZ3JhYicpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdHJpZ2dlckV2ZW50cyhuZWFyLCBbJ3RvdWNoc3RhcnQnLCAndGFwc3RhcnQnLCAndm1vdXNlZG93biddLCBlLCB7XG4gICAgICAgIHBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAobmVhciA9PSBudWxsKSB7XG4gICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHtcbiAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgIH07XG5cbiAgICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgIH1cblxuICAgICAgLy8gVGFwLCB0YXBob2xkXG4gICAgICAvLyAtLS0tLVxuXG4gICAgICByLnRvdWNoRGF0YS5zaW5nbGVUb3VjaE1vdmVkID0gZmFsc2U7XG4gICAgICByLnRvdWNoRGF0YS5zaW5nbGVUb3VjaFN0YXJ0VGltZSA9ICtuZXcgRGF0ZSgpO1xuXG4gICAgICBjbGVhclRpbWVvdXQoci50b3VjaERhdGEudGFwaG9sZFRpbWVvdXQpO1xuICAgICAgci50b3VjaERhdGEudGFwaG9sZFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHIudG91Y2hEYXRhLnNpbmdsZVRvdWNoTW92ZWQgPT09IGZhbHNlICYmICFyLnBpbmNoaW5nIC8vIGlmIHBpbmNoaW5nLCB0aGVuIHRhcGhvbGQgdW5zZWxlY3Qgc2hvdWxkbid0IHRha2UgZWZmZWN0XG4gICAgICAgICYmICFyLnRvdWNoRGF0YS5zZWxlY3RpbmcgLy8gYm94IHNlbGVjdGlvbiBzaG91bGRuJ3QgYWxsb3cgdGFwaG9sZCB0aHJvdWdoXG4gICAgICAgICkge1xuICAgICAgICAgICAgdHJpZ2dlckV2ZW50cyhyLnRvdWNoRGF0YS5zdGFydCwgWyd0YXBob2xkJ10sIGUsIHtcbiAgICAgICAgICAgICAgcG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICghci50b3VjaERhdGEuc3RhcnQpIHtcbiAgICAgICAgICAgICAgY3kuJCgnOnNlbGVjdGVkJykudW5zZWxlY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9LCByLnRhcGhvbGREdXJhdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPj0gMSkge1xuICAgICAgdmFyIHNQb3MgPSByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNQb3NbaV0gPSBlYXJsaWVyW2ldID0gbm93W2ldO1xuICAgICAgfVxuXG4gICAgICB2YXIgdG91Y2gwID0gZS50b3VjaGVzWzBdO1xuXG4gICAgICByLnRvdWNoRGF0YS5zdGFydEdQb3NpdGlvbiA9IFt0b3VjaDAuY2xpZW50WCwgdG91Y2gwLmNsaWVudFldO1xuICAgIH1cbiAgfSwgZmFsc2UpO1xuXG4gIHZhciB0b3VjaG1vdmVIYW5kbGVyO1xuICByLnJlZ2lzdGVyQmluZGluZyh3aW5kb3csICd0b3VjaG1vdmUnLCB0b3VjaG1vdmVIYW5kbGVyID0gZnVuY3Rpb24gdG91Y2htb3ZlSGFuZGxlcihlKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgIHZhciBjYXB0dXJlID0gci50b3VjaERhdGEuY2FwdHVyZTtcblxuICAgIGlmICghY2FwdHVyZSAmJiAhZXZlbnRJbkNvbnRhaW5lcihlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzZWxlY3QgPSByLnNlbGVjdGlvbjtcbiAgICB2YXIgY3kgPSByLmN5O1xuICAgIHZhciBub3cgPSByLnRvdWNoRGF0YS5ub3c7XG4gICAgdmFyIGVhcmxpZXIgPSByLnRvdWNoRGF0YS5lYXJsaWVyO1xuICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuXG4gICAgaWYgKGUudG91Y2hlc1swXSkge1xuICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMF0uY2xpZW50WCwgZS50b3VjaGVzWzBdLmNsaWVudFkpO25vd1swXSA9IHBvc1swXTtub3dbMV0gPSBwb3NbMV07XG4gICAgfVxuICAgIGlmIChlLnRvdWNoZXNbMV0pIHtcbiAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzFdLmNsaWVudFgsIGUudG91Y2hlc1sxXS5jbGllbnRZKTtub3dbMl0gPSBwb3NbMF07bm93WzNdID0gcG9zWzFdO1xuICAgIH1cbiAgICBpZiAoZS50b3VjaGVzWzJdKSB7XG4gICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1syXS5jbGllbnRYLCBlLnRvdWNoZXNbMl0uY2xpZW50WSk7bm93WzRdID0gcG9zWzBdO25vd1s1XSA9IHBvc1sxXTtcbiAgICB9XG5cbiAgICB2YXIgc3RhcnRHUG9zID0gci50b3VjaERhdGEuc3RhcnRHUG9zaXRpb247XG4gICAgdmFyIGlzT3ZlclRocmVzaG9sZERyYWc7XG5cbiAgICBpZiAoY2FwdHVyZSAmJiBlLnRvdWNoZXNbMF0gJiYgc3RhcnRHUG9zKSB7XG4gICAgICB2YXIgZGlzcCA9IFtdO2ZvciAodmFyIGogPSAwOyBqIDwgbm93Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGRpc3Bbal0gPSBub3dbal0gLSBlYXJsaWVyW2pdO1xuICAgICAgfVxuICAgICAgdmFyIGR4ID0gZS50b3VjaGVzWzBdLmNsaWVudFggLSBzdGFydEdQb3NbMF07XG4gICAgICB2YXIgZHgyID0gZHggKiBkeDtcbiAgICAgIHZhciBkeSA9IGUudG91Y2hlc1swXS5jbGllbnRZIC0gc3RhcnRHUG9zWzFdO1xuICAgICAgdmFyIGR5MiA9IGR5ICogZHk7XG4gICAgICB2YXIgZGlzdDIgPSBkeDIgKyBkeTI7XG5cbiAgICAgIGlzT3ZlclRocmVzaG9sZERyYWcgPSBkaXN0MiA+PSByLnRvdWNoVGFwVGhyZXNob2xkMjtcbiAgICB9XG5cbiAgICAvLyBjb250ZXh0IHN3aXBlIGNhbmNlbGxpbmdcbiAgICBpZiAoY2FwdHVyZSAmJiByLnRvdWNoRGF0YS5jeHQpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgdmFyIGYxeDIgPSBlLnRvdWNoZXNbMF0uY2xpZW50WCAtIG9mZnNldExlZnQsXG4gICAgICAgICAgZjF5MiA9IGUudG91Y2hlc1swXS5jbGllbnRZIC0gb2Zmc2V0VG9wO1xuICAgICAgdmFyIGYyeDIgPSBlLnRvdWNoZXNbMV0uY2xpZW50WCAtIG9mZnNldExlZnQsXG4gICAgICAgICAgZjJ5MiA9IGUudG91Y2hlc1sxXS5jbGllbnRZIC0gb2Zmc2V0VG9wO1xuICAgICAgLy8gdmFyIGRpc3RhbmNlMiA9IGRpc3RhbmNlKCBmMXgyLCBmMXkyLCBmMngyLCBmMnkyICk7XG4gICAgICB2YXIgZGlzdGFuY2UyU3EgPSBkaXN0YW5jZVNxKGYxeDIsIGYxeTIsIGYyeDIsIGYyeTIpO1xuICAgICAgdmFyIGZhY3RvclNxID0gZGlzdGFuY2UyU3EgLyBkaXN0YW5jZTFTcTtcblxuICAgICAgdmFyIGRpc3RUaHJlc2hvbGQgPSAxNTA7XG4gICAgICB2YXIgZGlzdFRocmVzaG9sZFNxID0gZGlzdFRocmVzaG9sZCAqIGRpc3RUaHJlc2hvbGQ7XG4gICAgICB2YXIgZmFjdG9yVGhyZXNob2xkID0gMS41O1xuICAgICAgdmFyIGZhY3RvclRocmVzaG9sZFNxID0gZmFjdG9yVGhyZXNob2xkICogZmFjdG9yVGhyZXNob2xkO1xuXG4gICAgICAvLyBjYW5jZWwgY3R4IGdlc3R1cmVzIGlmIHRoZSBkaXN0YW5jZSBiL3QgdGhlIGZpbmdlcnMgaW5jcmVhc2VzXG4gICAgICBpZiAoZmFjdG9yU3EgPj0gZmFjdG9yVGhyZXNob2xkU3EgfHwgZGlzdGFuY2UyU3EgPj0gZGlzdFRocmVzaG9sZFNxKSB7XG4gICAgICAgIHIudG91Y2hEYXRhLmN4dCA9IGZhbHNlO1xuXG4gICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcblxuICAgICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuXG4gICAgICAgIHZhciBjeHRFdnQgPSB7XG4gICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICB0eXBlOiAnY3h0dGFwZW5kJyxcbiAgICAgICAgICBwb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHIudG91Y2hEYXRhLnN0YXJ0KSB7XG4gICAgICAgICAgci50b3VjaERhdGEuc3RhcnQudW5hY3RpdmF0ZSgpLmVtaXQoY3h0RXZ0KTtcblxuICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0ID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjeS5lbWl0KGN4dEV2dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjb250ZXh0IHN3aXBlXG4gICAgaWYgKGNhcHR1cmUgJiYgci50b3VjaERhdGEuY3h0KSB7XG4gICAgICB2YXIgY3h0RXZ0ID0ge1xuICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICB0eXBlOiAnY3h0ZHJhZycsXG4gICAgICAgIHBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgIH07XG4gICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuXG4gICAgICBpZiAoci50b3VjaERhdGEuc3RhcnQpIHtcbiAgICAgICAgci50b3VjaERhdGEuc3RhcnQuZW1pdChjeHRFdnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3kuZW1pdChjeHRFdnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoci50b3VjaERhdGEuc3RhcnQpIHtcbiAgICAgICAgci50b3VjaERhdGEuc3RhcnQuX3ByaXZhdGUuZ3JhYmJlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgci50b3VjaERhdGEuY3h0RHJhZ2dlZCA9IHRydWU7XG5cbiAgICAgIHZhciBuZWFyID0gci5maW5kTmVhcmVzdEVsZW1lbnQobm93WzBdLCBub3dbMV0sIHRydWUsIHRydWUpO1xuXG4gICAgICBpZiAoIXIudG91Y2hEYXRhLmN4dE92ZXIgfHwgbmVhciAhPT0gci50b3VjaERhdGEuY3h0T3Zlcikge1xuXG4gICAgICAgIGlmIChyLnRvdWNoRGF0YS5jeHRPdmVyKSB7XG4gICAgICAgICAgci50b3VjaERhdGEuY3h0T3Zlci5lbWl0KHtcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgICB0eXBlOiAnY3h0ZHJhZ291dCcsXG4gICAgICAgICAgICBwb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByLnRvdWNoRGF0YS5jeHRPdmVyID0gbmVhcjtcblxuICAgICAgICBpZiAobmVhcikge1xuICAgICAgICAgIG5lYXIuZW1pdCh7XG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgICAgdHlwZTogJ2N4dGRyYWdvdmVyJyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBib3ggc2VsZWN0aW9uXG4gICAgfSBlbHNlIGlmIChjYXB0dXJlICYmIGUudG91Y2hlc1syXSAmJiBjeS5ib3hTZWxlY3Rpb25FbmFibGVkKCkpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLmxhc3RUaHJlZVRvdWNoID0gK25ldyBEYXRlKCk7XG5cbiAgICAgIGlmICghci50b3VjaERhdGEuc2VsZWN0aW5nKSB7XG4gICAgICAgIGN5LmVtaXQoJ2JveHN0YXJ0Jyk7XG4gICAgICB9XG5cbiAgICAgIHIudG91Y2hEYXRhLnNlbGVjdGluZyA9IHRydWU7XG5cbiAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG5cbiAgICAgIGlmICghc2VsZWN0IHx8IHNlbGVjdC5sZW5ndGggPT09IDAgfHwgc2VsZWN0WzBdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc2VsZWN0WzBdID0gKG5vd1swXSArIG5vd1syXSArIG5vd1s0XSkgLyAzO1xuICAgICAgICBzZWxlY3RbMV0gPSAobm93WzFdICsgbm93WzNdICsgbm93WzVdKSAvIDM7XG4gICAgICAgIHNlbGVjdFsyXSA9IChub3dbMF0gKyBub3dbMl0gKyBub3dbNF0pIC8gMyArIDE7XG4gICAgICAgIHNlbGVjdFszXSA9IChub3dbMV0gKyBub3dbM10gKyBub3dbNV0pIC8gMyArIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxlY3RbMl0gPSAobm93WzBdICsgbm93WzJdICsgbm93WzRdKSAvIDM7XG4gICAgICAgIHNlbGVjdFszXSA9IChub3dbMV0gKyBub3dbM10gKyBub3dbNV0pIC8gMztcbiAgICAgIH1cblxuICAgICAgc2VsZWN0WzRdID0gMTtcbiAgICAgIHIudG91Y2hEYXRhLnNlbGVjdGluZyA9IHRydWU7XG5cbiAgICAgIHIucmVkcmF3KCk7XG5cbiAgICAgIC8vIHBpbmNoIHRvIHpvb21cbiAgICB9IGVsc2UgaWYgKGNhcHR1cmUgJiYgZS50b3VjaGVzWzFdICYmIGN5Lnpvb21pbmdFbmFibGVkKCkgJiYgY3kucGFubmluZ0VuYWJsZWQoKSAmJiBjeS51c2VyWm9vbWluZ0VuYWJsZWQoKSAmJiBjeS51c2VyUGFubmluZ0VuYWJsZWQoKSkge1xuICAgICAgLy8gdHdvIGZpbmdlcnMgPT4gcGluY2ggdG8gem9vbVxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuXG4gICAgICB2YXIgZHJhZ2dlZEVsZXMgPSByLmRyYWdEYXRhLnRvdWNoRHJhZ0VsZXM7XG4gICAgICBpZiAoZHJhZ2dlZEVsZXMpIHtcbiAgICAgICAgci5yZWRyYXdIaW50KCdkcmFnJywgdHJ1ZSk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkcmFnZ2VkRWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBkZV9wID0gZHJhZ2dlZEVsZXNbaV0uX3ByaXZhdGU7XG5cbiAgICAgICAgICBkZV9wLmdyYWJiZWQgPSBmYWxzZTtcbiAgICAgICAgICBkZV9wLnJzY3JhdGNoLmluRHJhZ0xheWVyID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gKHgyLCB5MikgZm9yIGZpbmdlcnMgMSBhbmQgMlxuICAgICAgdmFyIGYxeDIgPSBlLnRvdWNoZXNbMF0uY2xpZW50WCAtIG9mZnNldExlZnQsXG4gICAgICAgICAgZjF5MiA9IGUudG91Y2hlc1swXS5jbGllbnRZIC0gb2Zmc2V0VG9wO1xuICAgICAgdmFyIGYyeDIgPSBlLnRvdWNoZXNbMV0uY2xpZW50WCAtIG9mZnNldExlZnQsXG4gICAgICAgICAgZjJ5MiA9IGUudG91Y2hlc1sxXS5jbGllbnRZIC0gb2Zmc2V0VG9wO1xuXG4gICAgICB2YXIgZGlzdGFuY2UyID0gZGlzdGFuY2UoZjF4MiwgZjF5MiwgZjJ4MiwgZjJ5Mik7XG4gICAgICAvLyB2YXIgZGlzdGFuY2UyU3EgPSBkaXN0YW5jZVNxKCBmMXgyLCBmMXkyLCBmMngyLCBmMnkyICk7XG4gICAgICAvLyB2YXIgZmFjdG9yID0gTWF0aC5zcXJ0KCBkaXN0YW5jZTJTcSApIC8gTWF0aC5zcXJ0KCBkaXN0YW5jZTFTcSApO1xuICAgICAgdmFyIGZhY3RvciA9IGRpc3RhbmNlMiAvIGRpc3RhbmNlMTtcblxuICAgICAgaWYgKHR3b0ZpbmdlcnNTdGFydEluc2lkZSkge1xuICAgICAgICAvLyBkZWx0YSBmaW5nZXIxXG4gICAgICAgIHZhciBkZjF4ID0gZjF4MiAtIGYxeDE7XG4gICAgICAgIHZhciBkZjF5ID0gZjF5MiAtIGYxeTE7XG5cbiAgICAgICAgLy8gZGVsdGEgZmluZ2VyIDJcbiAgICAgICAgdmFyIGRmMnggPSBmMngyIC0gZjJ4MTtcbiAgICAgICAgdmFyIGRmMnkgPSBmMnkyIC0gZjJ5MTtcblxuICAgICAgICAvLyB0cmFuc2xhdGlvbiBpcyB0aGUgbm9ybWFsaXNlZCB2ZWN0b3Igb2YgdGhlIHR3byBmaW5nZXJzIG1vdmVtZW50XG4gICAgICAgIC8vIGkuZS4gc28gcGluY2hpbmcgY2FuY2VscyBvdXQgYW5kIG1vdmluZyB0b2dldGhlciBwYW5zXG4gICAgICAgIHZhciB0eCA9IChkZjF4ICsgZGYyeCkgLyAyO1xuICAgICAgICB2YXIgdHkgPSAoZGYxeSArIGRmMnkpIC8gMjtcblxuICAgICAgICAvLyBhZGp1c3QgZmFjdG9yIGJ5IHRoZSBzcGVlZCBtdWx0aXBsaWVyXG4gICAgICAgIC8vIHZhciBzcGVlZCA9IDEuNTtcbiAgICAgICAgLy8gaWYoIGZhY3RvciA+IDEgKXtcbiAgICAgICAgLy8gICBmYWN0b3IgPSAoZmFjdG9yIC0gMSkgKiBzcGVlZCArIDE7XG4gICAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAgIC8vICAgZmFjdG9yID0gMSAtICgxIC0gZmFjdG9yKSAqIHNwZWVkO1xuICAgICAgICAvLyB9XG5cbiAgICAgICAgLy8gbm93IGNhbGN1bGF0ZSB0aGUgem9vbVxuICAgICAgICB2YXIgem9vbTEgPSBjeS56b29tKCk7XG4gICAgICAgIHZhciB6b29tMiA9IHpvb20xICogZmFjdG9yO1xuICAgICAgICB2YXIgcGFuMSA9IGN5LnBhbigpO1xuXG4gICAgICAgIC8vIHRoZSBtb2RlbCBjZW50ZXIgcG9pbnQgY29udmVydGVkIHRvIHRoZSBjdXJyZW50IHJlbmRlcmVkIHBvc1xuICAgICAgICB2YXIgY3RyeCA9IG1vZGVsQ2VudGVyMVswXSAqIHpvb20xICsgcGFuMS54O1xuICAgICAgICB2YXIgY3RyeSA9IG1vZGVsQ2VudGVyMVsxXSAqIHpvb20xICsgcGFuMS55O1xuXG4gICAgICAgIHZhciBwYW4yID0ge1xuICAgICAgICAgIHg6IC16b29tMiAvIHpvb20xICogKGN0cnggLSBwYW4xLnggLSB0eCkgKyBjdHJ4LFxuICAgICAgICAgIHk6IC16b29tMiAvIHpvb20xICogKGN0cnkgLSBwYW4xLnkgLSB0eSkgKyBjdHJ5XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gcmVtb3ZlIGRyYWdnZWQgZWxlc1xuICAgICAgICBpZiAoci50b3VjaERhdGEuc3RhcnQgJiYgci50b3VjaERhdGEuc3RhcnQuYWN0aXZlKCkpIHtcbiAgICAgICAgICB2YXIgZHJhZ2dlZEVsZXMgPSByLmRyYWdEYXRhLnRvdWNoRHJhZ0VsZXM7XG5cbiAgICAgICAgICBmcmVlRHJhZ2dlZEVsZW1lbnRzKGRyYWdnZWRFbGVzKTtcblxuICAgICAgICAgIHIucmVkcmF3SGludCgnZHJhZycsIHRydWUpO1xuICAgICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuXG4gICAgICAgICAgci50b3VjaERhdGEuc3RhcnQudW5hY3RpdmF0ZSgpLmVtaXQoJ2ZyZWUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN5LnZpZXdwb3J0KHtcbiAgICAgICAgICB6b29tOiB6b29tMixcbiAgICAgICAgICBwYW46IHBhbjIsXG4gICAgICAgICAgY2FuY2VsT25GYWlsZWRab29tOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRpc3RhbmNlMSA9IGRpc3RhbmNlMjtcbiAgICAgICAgZjF4MSA9IGYxeDI7XG4gICAgICAgIGYxeTEgPSBmMXkyO1xuICAgICAgICBmMngxID0gZjJ4MjtcbiAgICAgICAgZjJ5MSA9IGYyeTI7XG5cbiAgICAgICAgci5waW5jaGluZyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlLXByb2plY3RcbiAgICAgIGlmIChlLnRvdWNoZXNbMF0pIHtcbiAgICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMF0uY2xpZW50WCwgZS50b3VjaGVzWzBdLmNsaWVudFkpO25vd1swXSA9IHBvc1swXTtub3dbMV0gPSBwb3NbMV07XG4gICAgICB9XG4gICAgICBpZiAoZS50b3VjaGVzWzFdKSB7XG4gICAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzFdLmNsaWVudFgsIGUudG91Y2hlc1sxXS5jbGllbnRZKTtub3dbMl0gPSBwb3NbMF07bm93WzNdID0gcG9zWzFdO1xuICAgICAgfVxuICAgICAgaWYgKGUudG91Y2hlc1syXSkge1xuICAgICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1syXS5jbGllbnRYLCBlLnRvdWNoZXNbMl0uY2xpZW50WSk7bm93WzRdID0gcG9zWzBdO25vd1s1XSA9IHBvc1sxXTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGUudG91Y2hlc1swXSkge1xuICAgICAgdmFyIHN0YXJ0ID0gci50b3VjaERhdGEuc3RhcnQ7XG4gICAgICB2YXIgbGFzdCA9IHIudG91Y2hEYXRhLmxhc3Q7XG4gICAgICB2YXIgbmVhcjtcblxuICAgICAgaWYgKCFyLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgJiYgIXIuc3dpcGVQYW5uaW5nKSB7XG4gICAgICAgIG5lYXIgPSByLmZpbmROZWFyZXN0RWxlbWVudChub3dbMF0sIG5vd1sxXSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjYXB0dXJlICYmIHN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuXG4gICAgICAvLyBkcmFnZ2luZyBub2Rlc1xuICAgICAgaWYgKGNhcHR1cmUgJiYgc3RhcnQgIT0gbnVsbCAmJiByLm5vZGVJc0RyYWdnYWJsZShzdGFydCkpIHtcblxuICAgICAgICBpZiAoaXNPdmVyVGhyZXNob2xkRHJhZykge1xuICAgICAgICAgIC8vIHRoZW4gZHJhZ2dpbmcgY2FuIGhhcHBlblxuICAgICAgICAgIHZhciBkcmFnZ2VkRWxlcyA9IHIuZHJhZ0RhdGEudG91Y2hEcmFnRWxlcztcbiAgICAgICAgICB2YXIganVzdFN0YXJ0ZWREcmFnID0gIXIuZHJhZ0RhdGEuZGlkRHJhZztcblxuICAgICAgICAgIGlmIChqdXN0U3RhcnRlZERyYWcpIHtcbiAgICAgICAgICAgIGFkZE5vZGVzVG9EcmFnKGN5LmNvbGxlY3Rpb24oZHJhZ2dlZEVsZXMpLCB7IGluRHJhZ0xheWVyOiB0cnVlIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgZHJhZ2dlZEVsZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIHZhciBkcmFnZ2VkRWxlID0gZHJhZ2dlZEVsZXNba107XG5cbiAgICAgICAgICAgIGlmIChyLm5vZGVJc0RyYWdnYWJsZShkcmFnZ2VkRWxlKSAmJiBkcmFnZ2VkRWxlLmdyYWJiZWQoKSkge1xuICAgICAgICAgICAgICByLmRyYWdEYXRhLmRpZERyYWcgPSB0cnVlO1xuICAgICAgICAgICAgICB2YXIgZFBvcyA9IGRyYWdnZWRFbGUucG9zaXRpb24oKTtcblxuICAgICAgICAgICAgICBpZiAoaXMubnVtYmVyKGRpc3BbMF0pICYmIGlzLm51bWJlcihkaXNwWzFdKSkge1xuICAgICAgICAgICAgICAgIGRQb3MueCArPSBkaXNwWzBdO1xuICAgICAgICAgICAgICAgIGRQb3MueSArPSBkaXNwWzFdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGp1c3RTdGFydGVkRHJhZykge1xuICAgICAgICAgICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGRyYWdEZWx0YSA9IHIudG91Y2hEYXRhLmRyYWdEZWx0YTtcblxuICAgICAgICAgICAgICAgIGlmIChkcmFnRGVsdGEgJiYgaXMubnVtYmVyKGRyYWdEZWx0YVswXSkgJiYgaXMubnVtYmVyKGRyYWdEZWx0YVsxXSkpIHtcbiAgICAgICAgICAgICAgICAgIGRQb3MueCArPSBkcmFnRGVsdGFbMF07XG4gICAgICAgICAgICAgICAgICBkUG9zLnkgKz0gZHJhZ0RlbHRhWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB0Y29sID0gY3kuY29sbGVjdGlvbihkcmFnZ2VkRWxlcyk7XG5cbiAgICAgICAgICB0Y29sLmRpcnR5Q29tcG91bmRCb3VuZHNDYWNoZSgpO1xuICAgICAgICAgIHRjb2wuZW1pdCgncG9zaXRpb24gZHJhZycpO1xuXG4gICAgICAgICAgci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzID0gdHJ1ZTtcblxuICAgICAgICAgIHIucmVkcmF3SGludCgnZHJhZycsIHRydWUpO1xuXG4gICAgICAgICAgaWYgKHIudG91Y2hEYXRhLnN0YXJ0UG9zaXRpb25bMF0gPT0gZWFybGllclswXSAmJiByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uWzFdID09IGVhcmxpZXJbMV0pIHtcblxuICAgICAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBvdGhlcmlzZSBrZWVwIHRyYWNrIG9mIGRyYWcgZGVsdGEgZm9yIGxhdGVyXG4gICAgICAgICAgdmFyIGRyYWdEZWx0YSA9IHIudG91Y2hEYXRhLmRyYWdEZWx0YSA9IHIudG91Y2hEYXRhLmRyYWdEZWx0YSB8fCBbXTtcblxuICAgICAgICAgIGlmIChkcmFnRGVsdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBkcmFnRGVsdGEucHVzaChkaXNwWzBdKTtcbiAgICAgICAgICAgIGRyYWdEZWx0YS5wdXNoKGRpc3BbMV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkcmFnRGVsdGFbMF0gKz0gZGlzcFswXTtcbiAgICAgICAgICAgIGRyYWdEZWx0YVsxXSArPSBkaXNwWzFdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyB0b3VjaG1vdmVcbiAgICAgIHtcbiAgICAgICAgdHJpZ2dlckV2ZW50cyhzdGFydCB8fCBuZWFyLCBbJ3RvdWNobW92ZScsICd0YXBkcmFnJywgJ3Ztb3VzZW1vdmUnXSwgZSwge1xuICAgICAgICAgIHBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCghc3RhcnQgfHwgIXN0YXJ0LmdyYWJiZWQoKSkgJiYgbmVhciAhPSBsYXN0KSB7XG4gICAgICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgICAgIGxhc3QuZW1pdCh7IG9yaWdpbmFsRXZlbnQ6IGUsIHR5cGU6ICd0YXBkcmFnb3V0JywgcG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5lYXIpIHtcbiAgICAgICAgICAgIG5lYXIuZW1pdCh7IG9yaWdpbmFsRXZlbnQ6IGUsIHR5cGU6ICd0YXBkcmFnb3ZlcicsIHBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH0gfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgci50b3VjaERhdGEubGFzdCA9IG5lYXI7XG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIHRvIGNhbmNlbCB0YXBob2xkXG4gICAgICBpZiAoY2FwdHVyZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vdy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChub3dbaV0gJiYgci50b3VjaERhdGEuc3RhcnRQb3NpdGlvbltpXSAmJiBpc092ZXJUaHJlc2hvbGREcmFnKSB7XG5cbiAgICAgICAgICAgIHIudG91Y2hEYXRhLnNpbmdsZVRvdWNoTW92ZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBwYW5uaW5nXG4gICAgICBpZiAoY2FwdHVyZSAmJiAoc3RhcnQgPT0gbnVsbCB8fCBzdGFydC5pc0VkZ2UoKSkgJiYgY3kucGFubmluZ0VuYWJsZWQoKSAmJiBjeS51c2VyUGFubmluZ0VuYWJsZWQoKSkge1xuXG4gICAgICAgIHZhciBhbGxvd1Bhc3N0aHJvdWdoID0gYWxsb3dQYW5uaW5nUGFzc3Rocm91Z2goc3RhcnQsIHIudG91Y2hEYXRhLnN0YXJ0cyk7XG5cbiAgICAgICAgaWYgKGFsbG93UGFzc3Rocm91Z2gpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICBpZiAoci5zd2lwZVBhbm5pbmcpIHtcbiAgICAgICAgICAgIGN5LnBhbkJ5KHtcbiAgICAgICAgICAgICAgeDogZGlzcFswXSAqIHpvb20sXG4gICAgICAgICAgICAgIHk6IGRpc3BbMV0gKiB6b29tXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzT3ZlclRocmVzaG9sZERyYWcpIHtcbiAgICAgICAgICAgIHIuc3dpcGVQYW5uaW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgY3kucGFuQnkoe1xuICAgICAgICAgICAgICB4OiBkeCAqIHpvb20sXG4gICAgICAgICAgICAgIHk6IGR5ICogem9vbVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChzdGFydCkge1xuICAgICAgICAgICAgICBzdGFydC51bmFjdGl2YXRlKCk7XG5cbiAgICAgICAgICAgICAgaWYgKCFyLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24pIHtcbiAgICAgICAgICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSBtYXRoLmFycmF5MnBvaW50KHIudG91Y2hEYXRhLnN0YXJ0UG9zaXRpb24pO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcblxuICAgICAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmUtcHJvamVjdFxuICAgICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1swXS5jbGllbnRYLCBlLnRvdWNoZXNbMF0uY2xpZW50WSk7XG4gICAgICAgIG5vd1swXSA9IHBvc1swXTtub3dbMV0gPSBwb3NbMV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBub3cubGVuZ3RoOyBqKyspIHtcbiAgICAgIGVhcmxpZXJbal0gPSBub3dbal07XG4gICAgfVxuICAgIC8vci5yZWRyYXcoKTtcblxuICAgIC8vIHRoZSBhY3RpdmUgYmcgaW5kaWNhdG9yIHNob3VsZCBiZSByZW1vdmVkIHdoZW4gbWFraW5nIGEgc3dpcGUgdGhhdCBpcyBuZWl0aGVyIGZvciBkcmFnZ2luZyBub2RlcyBvciBwYW5uaW5nXG4gICAgaWYgKGNhcHR1cmUgJiYgZS50b3VjaGVzLmxlbmd0aCA+IDAgJiYgIXIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcyAmJiAhci5zd2lwZVBhbm5pbmcgJiYgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uICE9IG51bGwpIHtcbiAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gICAgICByLnJlZHJhdygpO1xuICAgIH1cbiAgfSwgZmFsc2UpO1xuICB2YXIgdG91Y2hjYW5jZWxIYW5kbGVyO1xuICByLnJlZ2lzdGVyQmluZGluZyh3aW5kb3csICd0b3VjaGNhbmNlbCcsIHRvdWNoY2FuY2VsSGFuZGxlciA9IGZ1bmN0aW9uIHRvdWNoY2FuY2VsSGFuZGxlcihlKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgIHZhciBzdGFydCA9IHIudG91Y2hEYXRhLnN0YXJ0O1xuXG4gICAgci50b3VjaERhdGEuY2FwdHVyZSA9IGZhbHNlO1xuXG4gICAgaWYgKHN0YXJ0KSB7XG4gICAgICBzdGFydC51bmFjdGl2YXRlKCk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgdG91Y2hlbmRIYW5kbGVyO1xuICByLnJlZ2lzdGVyQmluZGluZyh3aW5kb3csICd0b3VjaGVuZCcsIHRvdWNoZW5kSGFuZGxlciA9IGZ1bmN0aW9uIHRvdWNoZW5kSGFuZGxlcihlKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgIHZhciBzdGFydCA9IHIudG91Y2hEYXRhLnN0YXJ0O1xuXG4gICAgdmFyIGNhcHR1cmUgPSByLnRvdWNoRGF0YS5jYXB0dXJlO1xuXG4gICAgaWYgKGNhcHR1cmUpIHtcbiAgICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHIudG91Y2hEYXRhLmNhcHR1cmUgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHNlbGVjdCA9IHIuc2VsZWN0aW9uO1xuXG4gICAgci5zd2lwZVBhbm5pbmcgPSBmYWxzZTtcbiAgICByLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgPSBmYWxzZTtcblxuICAgIHZhciBjeSA9IHIuY3k7XG4gICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgdmFyIG5vdyA9IHIudG91Y2hEYXRhLm5vdztcbiAgICB2YXIgZWFybGllciA9IHIudG91Y2hEYXRhLmVhcmxpZXI7XG5cbiAgICBpZiAoZS50b3VjaGVzWzBdKSB7XG4gICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1swXS5jbGllbnRYLCBlLnRvdWNoZXNbMF0uY2xpZW50WSk7bm93WzBdID0gcG9zWzBdO25vd1sxXSA9IHBvc1sxXTtcbiAgICB9XG4gICAgaWYgKGUudG91Y2hlc1sxXSkge1xuICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMV0uY2xpZW50WCwgZS50b3VjaGVzWzFdLmNsaWVudFkpO25vd1syXSA9IHBvc1swXTtub3dbM10gPSBwb3NbMV07XG4gICAgfVxuICAgIGlmIChlLnRvdWNoZXNbMl0pIHtcbiAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzJdLmNsaWVudFgsIGUudG91Y2hlc1syXS5jbGllbnRZKTtub3dbNF0gPSBwb3NbMF07bm93WzVdID0gcG9zWzFdO1xuICAgIH1cblxuICAgIGlmIChzdGFydCkge1xuICAgICAgc3RhcnQudW5hY3RpdmF0ZSgpO1xuICAgIH1cblxuICAgIHZhciBjdHhUYXBlbmQ7XG4gICAgaWYgKHIudG91Y2hEYXRhLmN4dCkge1xuICAgICAgY3R4VGFwZW5kID0ge1xuICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICB0eXBlOiAnY3h0dGFwZW5kJyxcbiAgICAgICAgcG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgfTtcblxuICAgICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgIHN0YXJ0LmVtaXQoY3R4VGFwZW5kKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN5LmVtaXQoY3R4VGFwZW5kKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFyLnRvdWNoRGF0YS5jeHREcmFnZ2VkKSB7XG4gICAgICAgIHZhciBjdHhUYXAgPSB7XG4gICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICB0eXBlOiAnY3h0dGFwJyxcbiAgICAgICAgICBwb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgICAgc3RhcnQuZW1pdChjdHhUYXApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN5LmVtaXQoY3R4VGFwKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoci50b3VjaERhdGEuc3RhcnQpIHtcbiAgICAgICAgci50b3VjaERhdGEuc3RhcnQuX3ByaXZhdGUuZ3JhYmJlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgci50b3VjaERhdGEuY3h0ID0gZmFsc2U7XG4gICAgICByLnRvdWNoRGF0YS5zdGFydCA9IG51bGw7XG5cbiAgICAgIHIucmVkcmF3KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gbm8gbW9yZSBib3ggc2VsZWN0aW9uIGlmIHdlIGRvbid0IGhhdmUgdGhyZWUgZmluZ2Vyc1xuICAgIGlmICghZS50b3VjaGVzWzJdICYmIGN5LmJveFNlbGVjdGlvbkVuYWJsZWQoKSAmJiByLnRvdWNoRGF0YS5zZWxlY3RpbmcpIHtcbiAgICAgIHIudG91Y2hEYXRhLnNlbGVjdGluZyA9IGZhbHNlO1xuXG4gICAgICB2YXIgYm94ID0gY3kuY29sbGVjdGlvbihyLmdldEFsbEluQm94KHNlbGVjdFswXSwgc2VsZWN0WzFdLCBzZWxlY3RbMl0sIHNlbGVjdFszXSkpO1xuXG4gICAgICBzZWxlY3RbMF0gPSB1bmRlZmluZWQ7XG4gICAgICBzZWxlY3RbMV0gPSB1bmRlZmluZWQ7XG4gICAgICBzZWxlY3RbMl0gPSB1bmRlZmluZWQ7XG4gICAgICBzZWxlY3RbM10gPSB1bmRlZmluZWQ7XG4gICAgICBzZWxlY3RbNF0gPSAwO1xuXG4gICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuXG4gICAgICBjeS5lbWl0KCdib3hlbmQnKTtcblxuICAgICAgdmFyIGVsZVdvdWxkQmVTZWxlY3RlZCA9IGZ1bmN0aW9uIGVsZVdvdWxkQmVTZWxlY3RlZChlbGUpIHtcbiAgICAgICAgcmV0dXJuIGVsZS5zZWxlY3RhYmxlKCkgJiYgIWVsZS5zZWxlY3RlZCgpO1xuICAgICAgfTtcblxuICAgICAgYm94LmVtaXQoJ2JveCcpLnN0ZEZpbHRlcihlbGVXb3VsZEJlU2VsZWN0ZWQpLnNlbGVjdCgpLmVtaXQoJ2JveHNlbGVjdCcpO1xuXG4gICAgICBpZiAoYm94Lm5vbmVtcHR5KCkpIHtcbiAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHIucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0ICE9IG51bGwpIHtcbiAgICAgIHN0YXJ0LnVuYWN0aXZhdGUoKTtcbiAgICB9XG5cbiAgICBpZiAoZS50b3VjaGVzWzJdKSB7XG4gICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAoZS50b3VjaGVzWzFdKSB7XG4gICAgICAvLyBpZ25vcmVcbiAgICB9IGVsc2UgaWYgKGUudG91Y2hlc1swXSkge1xuICAgICAgLy8gaWdub3JlXG5cbiAgICAgIC8vIExhc3QgdG91Y2ggcmVsZWFzZWRcbiAgICB9IGVsc2UgaWYgKCFlLnRvdWNoZXNbMF0pIHtcblxuICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcblxuICAgICAgdmFyIGRyYWdnZWRFbGVzID0gci5kcmFnRGF0YS50b3VjaERyYWdFbGVzO1xuXG4gICAgICBpZiAoc3RhcnQgIT0gbnVsbCkge1xuXG4gICAgICAgIHZhciBzdGFydFdhc0dyYWJiZWQgPSBzdGFydC5fcHJpdmF0ZS5ncmFiYmVkO1xuXG4gICAgICAgIGZyZWVEcmFnZ2VkRWxlbWVudHMoZHJhZ2dlZEVsZXMpO1xuXG4gICAgICAgIHIucmVkcmF3SGludCgnZHJhZycsIHRydWUpO1xuICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcblxuICAgICAgICBpZiAoc3RhcnRXYXNHcmFiYmVkKSB7XG4gICAgICAgICAgc3RhcnQuZW1pdCgnZnJlZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJpZ2dlckV2ZW50cyhzdGFydCwgWyd0b3VjaGVuZCcsICd0YXBlbmQnLCAndm1vdXNldXAnLCAndGFwZHJhZ291dCddLCBlLCB7XG4gICAgICAgICAgcG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICB9KTtcblxuICAgICAgICBzdGFydC51bmFjdGl2YXRlKCk7XG5cbiAgICAgICAgci50b3VjaERhdGEuc3RhcnQgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG5lYXIgPSByLmZpbmROZWFyZXN0RWxlbWVudChub3dbMF0sIG5vd1sxXSwgdHJ1ZSwgdHJ1ZSk7XG5cbiAgICAgICAgdHJpZ2dlckV2ZW50cyhuZWFyLCBbJ3RvdWNoZW5kJywgJ3RhcGVuZCcsICd2bW91c2V1cCcsICd0YXBkcmFnb3V0J10sIGUsIHtcbiAgICAgICAgICBwb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgZHggPSByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uWzBdIC0gbm93WzBdO1xuICAgICAgdmFyIGR4MiA9IGR4ICogZHg7XG4gICAgICB2YXIgZHkgPSByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uWzFdIC0gbm93WzFdO1xuICAgICAgdmFyIGR5MiA9IGR5ICogZHk7XG4gICAgICB2YXIgZGlzdDIgPSBkeDIgKyBkeTI7XG4gICAgICB2YXIgcmRpc3QyID0gZGlzdDIgKiB6b29tICogem9vbTtcblxuICAgICAgLy8gUHJlcGFyZSB0byBzZWxlY3QgdGhlIGN1cnJlbnRseSB0b3VjaGVkIG5vZGUsIG9ubHkgaWYgaXQgaGFzbid0IGJlZW4gZHJhZ2dlZCBwYXN0IGEgY2VydGFpbiBkaXN0YW5jZVxuICAgICAgaWYgKHN0YXJ0ICE9IG51bGwgJiYgIXIuZHJhZ0RhdGEuZGlkRHJhZyAvLyBkaWRuJ3QgZHJhZyBub2RlcyBhcm91bmRcbiAgICAgICYmIHN0YXJ0Ll9wcml2YXRlLnNlbGVjdGFibGUgJiYgcmRpc3QyIDwgci50b3VjaFRhcFRocmVzaG9sZDIgJiYgIXIucGluY2hpbmcgLy8gcGluY2ggdG8gem9vbSBzaG91bGQgbm90IGFmZmVjdCBzZWxlY3Rpb25cbiAgICAgICkge1xuXG4gICAgICAgICAgaWYgKGN5LnNlbGVjdGlvblR5cGUoKSA9PT0gJ3NpbmdsZScpIHtcbiAgICAgICAgICAgIGN5LiQoJzpzZWxlY3RlZCcpLnVubWVyZ2Uoc3RhcnQpLnVuc2VsZWN0KCk7XG4gICAgICAgICAgICBzdGFydC5zZWxlY3QoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHN0YXJ0LnNlbGVjdGVkKCkpIHtcbiAgICAgICAgICAgICAgc3RhcnQudW5zZWxlY3QoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0YXJ0LnNlbGVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgIC8vIFRhcCBldmVudCwgcm91Z2hseSBzYW1lIGFzIG1vdXNlIGNsaWNrIGV2ZW50IGZvciB0b3VjaFxuICAgICAgaWYgKCFyLnRvdWNoRGF0YS5zaW5nbGVUb3VjaE1vdmVkKSB7XG4gICAgICAgIHRyaWdnZXJFdmVudHMoc3RhcnQsIFsndGFwJywgJ3ZjbGljayddLCBlLCB7XG4gICAgICAgICAgcG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgci50b3VjaERhdGEuc2luZ2xlVG91Y2hNb3ZlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBub3cubGVuZ3RoOyBqKyspIHtcbiAgICAgIGVhcmxpZXJbal0gPSBub3dbal07XG4gICAgfVxuXG4gICAgci5kcmFnRGF0YS5kaWREcmFnID0gZmFsc2U7IC8vIHJlc2V0IGZvciBuZXh0IG1vdXNlZG93blxuXG4gICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHIudG91Y2hEYXRhLmRyYWdEZWx0YSA9IFtdO1xuICAgICAgci50b3VjaERhdGEuc3RhcnRQb3NpdGlvbiA9IG51bGw7XG4gICAgICByLnRvdWNoRGF0YS5zdGFydEdQb3NpdGlvbiA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPCAyKSB7XG4gICAgICByLnBpbmNoaW5nID0gZmFsc2U7XG4gICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgIHIucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgLy9yLnJlZHJhdygpO1xuICB9LCBmYWxzZSk7XG5cbiAgLy8gZmFsbGJhY2sgY29tcGF0aWJpbGl0eSBsYXllciBmb3IgbXMgcG9pbnRlciBldmVudHNcbiAgaWYgKHR5cGVvZiBUb3VjaEV2ZW50ID09PSAndW5kZWZpbmVkJykge1xuXG4gICAgdmFyIHBvaW50ZXJzID0gW107XG5cbiAgICB2YXIgbWFrZVRvdWNoID0gZnVuY3Rpb24gbWFrZVRvdWNoKGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNsaWVudFg6IGUuY2xpZW50WCxcbiAgICAgICAgY2xpZW50WTogZS5jbGllbnRZLFxuICAgICAgICBmb3JjZTogMSxcbiAgICAgICAgaWRlbnRpZmllcjogZS5wb2ludGVySWQsXG4gICAgICAgIHBhZ2VYOiBlLnBhZ2VYLFxuICAgICAgICBwYWdlWTogZS5wYWdlWSxcbiAgICAgICAgcmFkaXVzWDogZS53aWR0aCAvIDIsXG4gICAgICAgIHJhZGl1c1k6IGUuaGVpZ2h0IC8gMixcbiAgICAgICAgc2NyZWVuWDogZS5zY3JlZW5YLFxuICAgICAgICBzY3JlZW5ZOiBlLnNjcmVlblksXG4gICAgICAgIHRhcmdldDogZS50YXJnZXRcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBtYWtlUG9pbnRlciA9IGZ1bmN0aW9uIG1ha2VQb2ludGVyKGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGV2ZW50OiBlLFxuICAgICAgICB0b3VjaDogbWFrZVRvdWNoKGUpXG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgYWRkUG9pbnRlciA9IGZ1bmN0aW9uIGFkZFBvaW50ZXIoZSkge1xuICAgICAgcG9pbnRlcnMucHVzaChtYWtlUG9pbnRlcihlKSk7XG4gICAgfTtcblxuICAgIHZhciByZW1vdmVQb2ludGVyID0gZnVuY3Rpb24gcmVtb3ZlUG9pbnRlcihlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwID0gcG9pbnRlcnNbaV07XG5cbiAgICAgICAgaWYgKHAuZXZlbnQucG9pbnRlcklkID09PSBlLnBvaW50ZXJJZCkge1xuICAgICAgICAgIHBvaW50ZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHVwZGF0ZVBvaW50ZXIgPSBmdW5jdGlvbiB1cGRhdGVQb2ludGVyKGUpIHtcbiAgICAgIHZhciBwID0gcG9pbnRlcnMuZmlsdGVyKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHJldHVybiBwLmV2ZW50LnBvaW50ZXJJZCA9PT0gZS5wb2ludGVySWQ7XG4gICAgICB9KVswXTtcblxuICAgICAgcC5ldmVudCA9IGU7XG4gICAgICBwLnRvdWNoID0gbWFrZVRvdWNoKGUpO1xuICAgIH07XG5cbiAgICB2YXIgYWRkVG91Y2hlc1RvRXZlbnQgPSBmdW5jdGlvbiBhZGRUb3VjaGVzVG9FdmVudChlKSB7XG4gICAgICBlLnRvdWNoZXMgPSBwb2ludGVycy5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcmV0dXJuIHAudG91Y2g7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIHBvaW50ZXJJc01vdXNlID0gZnVuY3Rpb24gcG9pbnRlcklzTW91c2UoZSkge1xuICAgICAgcmV0dXJuIGUucG9pbnRlclR5cGUgPT09ICdtb3VzZScgfHwgZS5wb2ludGVyVHlwZSA9PT0gNDtcbiAgICB9O1xuXG4gICAgci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdwb2ludGVyZG93bicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAocG9pbnRlcklzTW91c2UoZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBtb3VzZSBhbHJlYWR5IGhhbmRsZWRcblxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICBhZGRQb2ludGVyKGUpO1xuXG4gICAgICBhZGRUb3VjaGVzVG9FdmVudChlKTtcbiAgICAgIHRvdWNoc3RhcnRIYW5kbGVyKGUpO1xuICAgIH0pO1xuXG4gICAgci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdwb2ludGVydXAnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKHBvaW50ZXJJc01vdXNlKGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gbW91c2UgYWxyZWFkeSBoYW5kbGVkXG5cbiAgICAgIHJlbW92ZVBvaW50ZXIoZSk7XG5cbiAgICAgIGFkZFRvdWNoZXNUb0V2ZW50KGUpO1xuICAgICAgdG91Y2hlbmRIYW5kbGVyKGUpO1xuICAgIH0pO1xuXG4gICAgci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdwb2ludGVyY2FuY2VsJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChwb2ludGVySXNNb3VzZShlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIG1vdXNlIGFscmVhZHkgaGFuZGxlZFxuXG4gICAgICByZW1vdmVQb2ludGVyKGUpO1xuXG4gICAgICBhZGRUb3VjaGVzVG9FdmVudChlKTtcbiAgICAgIHRvdWNoY2FuY2VsSGFuZGxlcihlKTtcbiAgICB9KTtcblxuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAncG9pbnRlcm1vdmUnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKHBvaW50ZXJJc01vdXNlKGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gbW91c2UgYWxyZWFkeSBoYW5kbGVkXG5cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgdXBkYXRlUG9pbnRlcihlKTtcblxuICAgICAgYWRkVG91Y2hlc1RvRXZlbnQoZSk7XG4gICAgICB0b3VjaG1vdmVIYW5kbGVyKGUpO1xuICAgIH0pO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJScDtcblxuLyoqKi8gfSksXG4vKiAxMjEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIG1hdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgQlJwID0ge307XG5cbkJScC5nZW5lcmF0ZVBvbHlnb24gPSBmdW5jdGlvbiAobmFtZSwgcG9pbnRzKSB7XG4gIHJldHVybiB0aGlzLm5vZGVTaGFwZXNbbmFtZV0gPSB7XG4gICAgcmVuZGVyZXI6IHRoaXMsXG5cbiAgICBuYW1lOiBuYW1lLFxuXG4gICAgcG9pbnRzOiBwb2ludHMsXG5cbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIubm9kZVNoYXBlSW1wbCgncG9seWdvbicsIGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIHRoaXMucG9pbnRzKTtcbiAgICB9LFxuXG4gICAgaW50ZXJzZWN0TGluZTogZnVuY3Rpb24gaW50ZXJzZWN0TGluZShub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHgsIHksIHBhZGRpbmcpIHtcbiAgICAgIHJldHVybiBtYXRoLnBvbHlnb25JbnRlcnNlY3RMaW5lKHgsIHksIHRoaXMucG9pbnRzLCBub2RlWCwgbm9kZVksIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMiwgcGFkZGluZyk7XG4gICAgfSxcblxuICAgIGNoZWNrUG9pbnQ6IGZ1bmN0aW9uIGNoZWNrUG9pbnQoeCwgeSwgcGFkZGluZywgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSkge1xuICAgICAgcmV0dXJuIG1hdGgucG9pbnRJbnNpZGVQb2x5Z29uKHgsIHksIHRoaXMucG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBbMCwgLTFdLCBwYWRkaW5nKTtcbiAgICB9XG4gIH07XG59O1xuXG5CUnAuZ2VuZXJhdGVFbGxpcHNlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ub2RlU2hhcGVzWydlbGxpcHNlJ10gPSB7XG4gICAgcmVuZGVyZXI6IHRoaXMsXG5cbiAgICBuYW1lOiAnZWxsaXBzZScsXG5cbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIubm9kZVNoYXBlSW1wbCh0aGlzLm5hbWUsIGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0sXG5cbiAgICBpbnRlcnNlY3RMaW5lOiBmdW5jdGlvbiBpbnRlcnNlY3RMaW5lKG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgeCwgeSwgcGFkZGluZykge1xuICAgICAgcmV0dXJuIG1hdGguaW50ZXJzZWN0TGluZUVsbGlwc2UoeCwgeSwgbm9kZVgsIG5vZGVZLCB3aWR0aCAvIDIgKyBwYWRkaW5nLCBoZWlnaHQgLyAyICsgcGFkZGluZyk7XG4gICAgfSxcblxuICAgIGNoZWNrUG9pbnQ6IGZ1bmN0aW9uIGNoZWNrUG9pbnQoeCwgeSwgcGFkZGluZywgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSkge1xuICAgICAgcmV0dXJuIG1hdGguY2hlY2tJbkVsbGlwc2UoeCwgeSwgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSwgcGFkZGluZyk7XG4gICAgfVxuICB9O1xufTtcblxuQlJwLmdlbmVyYXRlUm91bmRSZWN0YW5nbGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm5vZGVTaGFwZXNbJ3JvdW5kcmVjdGFuZ2xlJ10gPSB7XG4gICAgcmVuZGVyZXI6IHRoaXMsXG5cbiAgICBuYW1lOiAncm91bmRyZWN0YW5nbGUnLFxuXG4gICAgcG9pbnRzOiBtYXRoLmdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg0LCAwKSxcblxuICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgdGhpcy5yZW5kZXJlci5ub2RlU2hhcGVJbXBsKHRoaXMubmFtZSwgY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfSxcblxuICAgIGludGVyc2VjdExpbmU6IGZ1bmN0aW9uIGludGVyc2VjdExpbmUobm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCB4LCB5LCBwYWRkaW5nKSB7XG4gICAgICByZXR1cm4gbWF0aC5yb3VuZFJlY3RhbmdsZUludGVyc2VjdExpbmUoeCwgeSwgbm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCBwYWRkaW5nKTtcbiAgICB9LFxuXG4gICAgY2hlY2tQb2ludDogZnVuY3Rpb24gY2hlY2tQb2ludCh4LCB5LCBwYWRkaW5nLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZKSB7XG5cbiAgICAgIHZhciBjb3JuZXJSYWRpdXMgPSBtYXRoLmdldFJvdW5kUmVjdGFuZ2xlUmFkaXVzKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgdmFyIGRpYW0gPSBjb3JuZXJSYWRpdXMgKiAyO1xuXG4gICAgICAvLyBDaGVjayBoQm94XG4gICAgICBpZiAobWF0aC5wb2ludEluc2lkZVBvbHlnb24oeCwgeSwgdGhpcy5wb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQgLSBkaWFtLCBbMCwgLTFdLCBwYWRkaW5nKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgdkJveFxuICAgICAgaWYgKG1hdGgucG9pbnRJbnNpZGVQb2x5Z29uKHgsIHksIHRoaXMucG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCAtIGRpYW0sIGhlaWdodCwgWzAsIC0xXSwgcGFkZGluZykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIHRvcCBsZWZ0IHF1YXJ0ZXIgY2lyY2xlXG4gICAgICBpZiAobWF0aC5jaGVja0luRWxsaXBzZSh4LCB5LCBkaWFtLCBkaWFtLCBjZW50ZXJYIC0gd2lkdGggLyAyICsgY29ybmVyUmFkaXVzLCBjZW50ZXJZIC0gaGVpZ2h0IC8gMiArIGNvcm5lclJhZGl1cywgcGFkZGluZykpIHtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgdG9wIHJpZ2h0IHF1YXJ0ZXIgY2lyY2xlXG4gICAgICBpZiAobWF0aC5jaGVja0luRWxsaXBzZSh4LCB5LCBkaWFtLCBkaWFtLCBjZW50ZXJYICsgd2lkdGggLyAyIC0gY29ybmVyUmFkaXVzLCBjZW50ZXJZIC0gaGVpZ2h0IC8gMiArIGNvcm5lclJhZGl1cywgcGFkZGluZykpIHtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgYm90dG9tIHJpZ2h0IHF1YXJ0ZXIgY2lyY2xlXG4gICAgICBpZiAobWF0aC5jaGVja0luRWxsaXBzZSh4LCB5LCBkaWFtLCBkaWFtLCBjZW50ZXJYICsgd2lkdGggLyAyIC0gY29ybmVyUmFkaXVzLCBjZW50ZXJZICsgaGVpZ2h0IC8gMiAtIGNvcm5lclJhZGl1cywgcGFkZGluZykpIHtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgYm90dG9tIGxlZnQgcXVhcnRlciBjaXJjbGVcbiAgICAgIGlmIChtYXRoLmNoZWNrSW5FbGxpcHNlKHgsIHksIGRpYW0sIGRpYW0sIGNlbnRlclggLSB3aWR0aCAvIDIgKyBjb3JuZXJSYWRpdXMsIGNlbnRlclkgKyBoZWlnaHQgLyAyIC0gY29ybmVyUmFkaXVzLCBwYWRkaW5nKSkge1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xufTtcblxuQlJwLmdlbmVyYXRlQ3V0UmVjdGFuZ2xlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ub2RlU2hhcGVzWydjdXRyZWN0YW5nbGUnXSA9IHtcbiAgICByZW5kZXJlcjogdGhpcyxcblxuICAgIG5hbWU6ICdjdXRyZWN0YW5nbGUnLFxuXG4gICAgY29ybmVyTGVuZ3RoOiBtYXRoLmdldEN1dFJlY3RhbmdsZUNvcm5lckxlbmd0aCgpLFxuXG4gICAgcG9pbnRzOiBtYXRoLmdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg0LCAwKSxcblxuICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgdGhpcy5yZW5kZXJlci5ub2RlU2hhcGVJbXBsKHRoaXMubmFtZSwgY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfSxcblxuICAgIGdlbmVyYXRlQ3V0VHJpYW5nbGVQdHM6IGZ1bmN0aW9uIGdlbmVyYXRlQ3V0VHJpYW5nbGVQdHMod2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSkge1xuICAgICAgdmFyIGNsID0gdGhpcy5jb3JuZXJMZW5ndGg7XG4gICAgICB2YXIgaGggPSBoZWlnaHQgLyAyO1xuICAgICAgdmFyIGh3ID0gd2lkdGggLyAyO1xuICAgICAgdmFyIHhCZWdpbiA9IGNlbnRlclggLSBodztcbiAgICAgIHZhciB4RW5kID0gY2VudGVyWCArIGh3O1xuICAgICAgdmFyIHlCZWdpbiA9IGNlbnRlclkgLSBoaDtcbiAgICAgIHZhciB5RW5kID0gY2VudGVyWSArIGhoO1xuXG4gICAgICAvLyBwb2ludHMgYXJlIGluIGNsb2Nrd2lzZSBvcmRlciwgaW5uZXIgKGltYWdpbmFyeSkgdHJpYW5nbGUgcHQgb24gWzQsIDVdXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b3BMZWZ0OiBbeEJlZ2luLCB5QmVnaW4gKyBjbCwgeEJlZ2luICsgY2wsIHlCZWdpbiwgeEJlZ2luICsgY2wsIHlCZWdpbiArIGNsXSxcbiAgICAgICAgdG9wUmlnaHQ6IFt4RW5kIC0gY2wsIHlCZWdpbiwgeEVuZCwgeUJlZ2luICsgY2wsIHhFbmQgLSBjbCwgeUJlZ2luICsgY2xdLFxuICAgICAgICBib3R0b21SaWdodDogW3hFbmQsIHlFbmQgLSBjbCwgeEVuZCAtIGNsLCB5RW5kLCB4RW5kIC0gY2wsIHlFbmQgLSBjbF0sXG4gICAgICAgIGJvdHRvbUxlZnQ6IFt4QmVnaW4gKyBjbCwgeUVuZCwgeEJlZ2luLCB5RW5kIC0gY2wsIHhCZWdpbiArIGNsLCB5RW5kIC0gY2xdXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICBpbnRlcnNlY3RMaW5lOiBmdW5jdGlvbiBpbnRlcnNlY3RMaW5lKG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgeCwgeSwgcGFkZGluZykge1xuICAgICAgdmFyIGNQdHMgPSB0aGlzLmdlbmVyYXRlQ3V0VHJpYW5nbGVQdHMod2lkdGggKyAyICogcGFkZGluZywgaGVpZ2h0ICsgMiAqIHBhZGRpbmcsIG5vZGVYLCBub2RlWSk7XG4gICAgICB2YXIgcHRzID0gW10uY29uY2F0LmFwcGx5KFtdLCBbY1B0cy50b3BMZWZ0LnNwbGljZSgwLCA0KSwgY1B0cy50b3BSaWdodC5zcGxpY2UoMCwgNCksIGNQdHMuYm90dG9tUmlnaHQuc3BsaWNlKDAsIDQpLCBjUHRzLmJvdHRvbUxlZnQuc3BsaWNlKDAsIDQpXSk7XG5cbiAgICAgIHJldHVybiBtYXRoLnBvbHlnb25JbnRlcnNlY3RMaW5lKHgsIHksIHB0cywgbm9kZVgsIG5vZGVZKTtcbiAgICB9LFxuXG4gICAgY2hlY2tQb2ludDogZnVuY3Rpb24gY2hlY2tQb2ludCh4LCB5LCBwYWRkaW5nLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZKSB7XG4gICAgICAvLyBDaGVjayBoQm94XG4gICAgICBpZiAobWF0aC5wb2ludEluc2lkZVBvbHlnb24oeCwgeSwgdGhpcy5wb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQgLSAyICogdGhpcy5jb3JuZXJMZW5ndGgsIFswLCAtMV0sIHBhZGRpbmcpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayB2Qm94XG4gICAgICBpZiAobWF0aC5wb2ludEluc2lkZVBvbHlnb24oeCwgeSwgdGhpcy5wb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoIC0gMiAqIHRoaXMuY29ybmVyTGVuZ3RoLCBoZWlnaHQsIFswLCAtMV0sIHBhZGRpbmcpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIGN1dFRyaWFuZ2xlUHRzID0gdGhpcy5nZW5lcmF0ZUN1dFRyaWFuZ2xlUHRzKHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclkpO1xuICAgICAgcmV0dXJuIG1hdGgucG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKHgsIHksIGN1dFRyaWFuZ2xlUHRzLnRvcExlZnQpIHx8IG1hdGgucG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKHgsIHksIGN1dFRyaWFuZ2xlUHRzLnRvcFJpZ2h0KSB8fCBtYXRoLnBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCBjdXRUcmlhbmdsZVB0cy5ib3R0b21SaWdodCkgfHwgbWF0aC5wb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgY3V0VHJpYW5nbGVQdHMuYm90dG9tTGVmdCk7XG4gICAgfVxuXG4gIH07XG59O1xuXG5CUnAuZ2VuZXJhdGVCYXJyZWwgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm5vZGVTaGFwZXNbJ2JhcnJlbCddID0ge1xuICAgIHJlbmRlcmVyOiB0aGlzLFxuXG4gICAgbmFtZTogJ2JhcnJlbCcsXG5cbiAgICBwb2ludHM6IG1hdGguZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDQsIDApLFxuXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLm5vZGVTaGFwZUltcGwodGhpcy5uYW1lLCBjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgaW50ZXJzZWN0TGluZTogZnVuY3Rpb24gaW50ZXJzZWN0TGluZShub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHgsIHksIHBhZGRpbmcpIHtcbiAgICAgIC8vIHVzZSB0d28gZml4ZWQgdCB2YWx1ZXMgZm9yIHRoZSBiZXppZXIgY3VydmUgYXBwcm94aW1hdGlvblxuXG4gICAgICB2YXIgdDAgPSAwLjE1O1xuICAgICAgdmFyIHQxID0gMC41O1xuICAgICAgdmFyIHQyID0gMC44NTtcblxuICAgICAgdmFyIGJQdHMgPSB0aGlzLmdlbmVyYXRlQmFycmVsQmV6aWVyUHRzKHdpZHRoICsgMiAqIHBhZGRpbmcsIGhlaWdodCArIDIgKiBwYWRkaW5nLCBub2RlWCwgbm9kZVkpO1xuXG4gICAgICB2YXIgYXBwcm94aW1hdGVCYXJyZWxDdXJ2ZVB0cyA9IGZ1bmN0aW9uIGFwcHJveGltYXRlQmFycmVsQ3VydmVQdHMocHRzKSB7XG4gICAgICAgIC8vIGFwcHJveGltYXRlIGN1cnZlIHB0cyBiYXNlZCBvbiB0aGUgdHdvIHQgdmFsdWVzXG4gICAgICAgIHZhciBtMCA9IG1hdGgucWJlemllclB0QXQoeyB4OiBwdHNbMF0sIHk6IHB0c1sxXSB9LCB7IHg6IHB0c1syXSwgeTogcHRzWzNdIH0sIHsgeDogcHRzWzRdLCB5OiBwdHNbNV0gfSwgdDApO1xuICAgICAgICB2YXIgbTEgPSBtYXRoLnFiZXppZXJQdEF0KHsgeDogcHRzWzBdLCB5OiBwdHNbMV0gfSwgeyB4OiBwdHNbMl0sIHk6IHB0c1szXSB9LCB7IHg6IHB0c1s0XSwgeTogcHRzWzVdIH0sIHQxKTtcbiAgICAgICAgdmFyIG0yID0gbWF0aC5xYmV6aWVyUHRBdCh7IHg6IHB0c1swXSwgeTogcHRzWzFdIH0sIHsgeDogcHRzWzJdLCB5OiBwdHNbM10gfSwgeyB4OiBwdHNbNF0sIHk6IHB0c1s1XSB9LCB0Mik7XG5cbiAgICAgICAgcmV0dXJuIFtwdHNbMF0sIHB0c1sxXSwgbTAueCwgbTAueSwgbTEueCwgbTEueSwgbTIueCwgbTIueSwgcHRzWzRdLCBwdHNbNV1dO1xuICAgICAgfTtcblxuICAgICAgdmFyIHB0cyA9IFtdLmNvbmNhdChhcHByb3hpbWF0ZUJhcnJlbEN1cnZlUHRzKGJQdHMudG9wTGVmdCksIGFwcHJveGltYXRlQmFycmVsQ3VydmVQdHMoYlB0cy50b3BSaWdodCksIGFwcHJveGltYXRlQmFycmVsQ3VydmVQdHMoYlB0cy5ib3R0b21SaWdodCksIGFwcHJveGltYXRlQmFycmVsQ3VydmVQdHMoYlB0cy5ib3R0b21MZWZ0KSk7XG5cbiAgICAgIHJldHVybiBtYXRoLnBvbHlnb25JbnRlcnNlY3RMaW5lKHgsIHksIHB0cywgbm9kZVgsIG5vZGVZKTtcbiAgICB9LFxuXG4gICAgZ2VuZXJhdGVCYXJyZWxCZXppZXJQdHM6IGZ1bmN0aW9uIGdlbmVyYXRlQmFycmVsQmV6aWVyUHRzKHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclkpIHtcbiAgICAgIHZhciBoaCA9IGhlaWdodCAvIDI7XG4gICAgICB2YXIgaHcgPSB3aWR0aCAvIDI7XG4gICAgICB2YXIgeEJlZ2luID0gY2VudGVyWCAtIGh3O1xuICAgICAgdmFyIHhFbmQgPSBjZW50ZXJYICsgaHc7XG4gICAgICB2YXIgeUJlZ2luID0gY2VudGVyWSAtIGhoO1xuICAgICAgdmFyIHlFbmQgPSBjZW50ZXJZICsgaGg7XG5cbiAgICAgIHZhciBjdXJ2ZUNvbnN0YW50cyA9IG1hdGguZ2V0QmFycmVsQ3VydmVDb25zdGFudHMod2lkdGgsIGhlaWdodCk7XG4gICAgICB2YXIgaE9mZnNldCA9IGN1cnZlQ29uc3RhbnRzLmhlaWdodE9mZnNldDtcbiAgICAgIHZhciB3T2Zmc2V0ID0gY3VydmVDb25zdGFudHMud2lkdGhPZmZzZXQ7XG4gICAgICB2YXIgY3RybFB0WE9mZnNldCA9IGN1cnZlQ29uc3RhbnRzLmN0cmxQdE9mZnNldFBjdCAqIHdpZHRoO1xuXG4gICAgICAvLyBwb2ludHMgYXJlIGluIGNsb2Nrd2lzZSBvcmRlciwgaW5uZXIgKGltYWdpbmFyeSkgY29udHJvbCBwdCBvbiBbNCwgNV1cbiAgICAgIHZhciBwdHMgPSB7XG4gICAgICAgIHRvcExlZnQ6IFt4QmVnaW4sIHlCZWdpbiArIGhPZmZzZXQsIHhCZWdpbiArIGN0cmxQdFhPZmZzZXQsIHlCZWdpbiwgeEJlZ2luICsgd09mZnNldCwgeUJlZ2luXSxcbiAgICAgICAgdG9wUmlnaHQ6IFt4RW5kIC0gd09mZnNldCwgeUJlZ2luLCB4RW5kIC0gY3RybFB0WE9mZnNldCwgeUJlZ2luLCB4RW5kLCB5QmVnaW4gKyBoT2Zmc2V0XSxcbiAgICAgICAgYm90dG9tUmlnaHQ6IFt4RW5kLCB5RW5kIC0gaE9mZnNldCwgeEVuZCAtIGN0cmxQdFhPZmZzZXQsIHlFbmQsIHhFbmQgLSB3T2Zmc2V0LCB5RW5kXSxcbiAgICAgICAgYm90dG9tTGVmdDogW3hCZWdpbiArIHdPZmZzZXQsIHlFbmQsIHhCZWdpbiArIGN0cmxQdFhPZmZzZXQsIHlFbmQsIHhCZWdpbiwgeUVuZCAtIGhPZmZzZXRdXG4gICAgICB9O1xuXG4gICAgICBwdHMudG9wTGVmdC5pc1RvcCA9IHRydWU7XG4gICAgICBwdHMudG9wUmlnaHQuaXNUb3AgPSB0cnVlO1xuICAgICAgcHRzLmJvdHRvbUxlZnQuaXNCb3R0b20gPSB0cnVlO1xuICAgICAgcHRzLmJvdHRvbVJpZ2h0LmlzQm90dG9tID0gdHJ1ZTtcblxuICAgICAgcmV0dXJuIHB0cztcbiAgICB9LFxuXG4gICAgY2hlY2tQb2ludDogZnVuY3Rpb24gY2hlY2tQb2ludCh4LCB5LCBwYWRkaW5nLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZKSB7XG5cbiAgICAgIHZhciBjdXJ2ZUNvbnN0YW50cyA9IG1hdGguZ2V0QmFycmVsQ3VydmVDb25zdGFudHMod2lkdGgsIGhlaWdodCk7XG4gICAgICB2YXIgaE9mZnNldCA9IGN1cnZlQ29uc3RhbnRzLmhlaWdodE9mZnNldDtcbiAgICAgIHZhciB3T2Zmc2V0ID0gY3VydmVDb25zdGFudHMud2lkdGhPZmZzZXQ7XG5cbiAgICAgIC8vIENoZWNrIGhCb3hcbiAgICAgIGlmIChtYXRoLnBvaW50SW5zaWRlUG9seWdvbih4LCB5LCB0aGlzLnBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCAtIDIgKiBoT2Zmc2V0LCBbMCwgLTFdLCBwYWRkaW5nKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgdkJveFxuICAgICAgaWYgKG1hdGgucG9pbnRJbnNpZGVQb2x5Z29uKHgsIHksIHRoaXMucG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCAtIDIgKiB3T2Zmc2V0LCBoZWlnaHQsIFswLCAtMV0sIHBhZGRpbmcpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgYmFycmVsQ3VydmVQdHMgPSB0aGlzLmdlbmVyYXRlQmFycmVsQmV6aWVyUHRzKHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclkpO1xuXG4gICAgICB2YXIgZ2V0Q3VydmVUID0gZnVuY3Rpb24gZ2V0Q3VydmVUKHgsIHksIGN1cnZlUHRzKSB7XG4gICAgICAgIHZhciB4MCA9IGN1cnZlUHRzWzRdO1xuICAgICAgICB2YXIgeDEgPSBjdXJ2ZVB0c1syXTtcbiAgICAgICAgdmFyIHgyID0gY3VydmVQdHNbMF07XG4gICAgICAgIHZhciB5MCA9IGN1cnZlUHRzWzVdO1xuICAgICAgICAvLyB2YXIgeTEgPSBjdXJ2ZVB0c1sgMyBdO1xuICAgICAgICB2YXIgeTIgPSBjdXJ2ZVB0c1sxXTtcblxuICAgICAgICB2YXIgeE1pbiA9IE1hdGgubWluKHgwLCB4Mik7XG4gICAgICAgIHZhciB4TWF4ID0gTWF0aC5tYXgoeDAsIHgyKTtcbiAgICAgICAgdmFyIHlNaW4gPSBNYXRoLm1pbih5MCwgeTIpO1xuICAgICAgICB2YXIgeU1heCA9IE1hdGgubWF4KHkwLCB5Mik7XG5cbiAgICAgICAgaWYgKHhNaW4gPD0geCAmJiB4IDw9IHhNYXggJiYgeU1pbiA8PSB5ICYmIHkgPD0geU1heCkge1xuICAgICAgICAgIHZhciBjb2VmZiA9IG1hdGguYmV6aWVyUHRzVG9RdWFkQ29lZmYoeDAsIHgxLCB4Mik7XG4gICAgICAgICAgdmFyIHJvb3RzID0gbWF0aC5zb2x2ZVF1YWRyYXRpYyhjb2VmZlswXSwgY29lZmZbMV0sIGNvZWZmWzJdLCB4KTtcblxuICAgICAgICAgIHZhciB2YWxpZFJvb3RzID0gcm9vdHMuZmlsdGVyKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICByZXR1cm4gMCA8PSByICYmIHIgPD0gMTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICh2YWxpZFJvb3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB2YWxpZFJvb3RzWzBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG5cbiAgICAgIHZhciBjdXJ2ZVJlZ2lvbnMgPSBPYmplY3Qua2V5cyhiYXJyZWxDdXJ2ZVB0cyk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN1cnZlUmVnaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29ybmVyID0gY3VydmVSZWdpb25zW2ldO1xuICAgICAgICB2YXIgY29ybmVyUHRzID0gYmFycmVsQ3VydmVQdHNbY29ybmVyXTtcbiAgICAgICAgdmFyIHQgPSBnZXRDdXJ2ZVQoeCwgeSwgY29ybmVyUHRzKTtcblxuICAgICAgICBpZiAodCA9PSBudWxsKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeTAgPSBjb3JuZXJQdHNbNV07XG4gICAgICAgIHZhciB5MSA9IGNvcm5lclB0c1szXTtcbiAgICAgICAgdmFyIHkyID0gY29ybmVyUHRzWzFdO1xuICAgICAgICB2YXIgYmV6WSA9IG1hdGgucWJlemllckF0KHkwLCB5MSwgeTIsIHQpO1xuXG4gICAgICAgIGlmIChjb3JuZXJQdHMuaXNUb3AgJiYgYmV6WSA8PSB5KSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvcm5lclB0cy5pc0JvdHRvbSAmJiB5IDw9IGJlelkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcbn07XG5cbkJScC5nZW5lcmF0ZUJvdHRvbVJvdW5kcmVjdGFuZ2xlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ub2RlU2hhcGVzWydib3R0b21yb3VuZHJlY3RhbmdsZSddID0ge1xuICAgIHJlbmRlcmVyOiB0aGlzLFxuXG4gICAgbmFtZTogJ2JvdHRvbXJvdW5kcmVjdGFuZ2xlJyxcblxuICAgIHBvaW50czogbWF0aC5nZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNCwgMCksXG5cbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIubm9kZVNoYXBlSW1wbCh0aGlzLm5hbWUsIGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0sXG5cbiAgICBpbnRlcnNlY3RMaW5lOiBmdW5jdGlvbiBpbnRlcnNlY3RMaW5lKG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgeCwgeSwgcGFkZGluZykge1xuICAgICAgdmFyIHRvcFN0YXJ0WCA9IG5vZGVYIC0gKHdpZHRoIC8gMiArIHBhZGRpbmcpO1xuICAgICAgdmFyIHRvcFN0YXJ0WSA9IG5vZGVZIC0gKGhlaWdodCAvIDIgKyBwYWRkaW5nKTtcbiAgICAgIHZhciB0b3BFbmRZID0gdG9wU3RhcnRZO1xuICAgICAgdmFyIHRvcEVuZFggPSBub2RlWCArICh3aWR0aCAvIDIgKyBwYWRkaW5nKTtcblxuICAgICAgdmFyIHRvcEludGVyc2VjdGlvbnMgPSBtYXRoLmZpbml0ZUxpbmVzSW50ZXJzZWN0KHgsIHksIG5vZGVYLCBub2RlWSwgdG9wU3RhcnRYLCB0b3BTdGFydFksIHRvcEVuZFgsIHRvcEVuZFksIGZhbHNlKTtcbiAgICAgIGlmICh0b3BJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHRvcEludGVyc2VjdGlvbnM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXRoLnJvdW5kUmVjdGFuZ2xlSW50ZXJzZWN0TGluZSh4LCB5LCBub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHBhZGRpbmcpO1xuICAgIH0sXG5cbiAgICBjaGVja1BvaW50OiBmdW5jdGlvbiBjaGVja1BvaW50KHgsIHksIHBhZGRpbmcsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclkpIHtcblxuICAgICAgdmFyIGNvcm5lclJhZGl1cyA9IG1hdGguZ2V0Um91bmRSZWN0YW5nbGVSYWRpdXMod2lkdGgsIGhlaWdodCk7XG4gICAgICB2YXIgZGlhbSA9IDIgKiBjb3JuZXJSYWRpdXM7XG5cbiAgICAgIC8vIENoZWNrIGhCb3hcbiAgICAgIGlmIChtYXRoLnBvaW50SW5zaWRlUG9seWdvbih4LCB5LCB0aGlzLnBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCAtIGRpYW0sIFswLCAtMV0sIHBhZGRpbmcpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayB2Qm94XG4gICAgICBpZiAobWF0aC5wb2ludEluc2lkZVBvbHlnb24oeCwgeSwgdGhpcy5wb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoIC0gZGlhbSwgaGVpZ2h0LCBbMCwgLTFdLCBwYWRkaW5nKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gY2hlY2sgbm9uLXJvdW5kZWQgdG9wIHNpZGVcbiAgICAgIHZhciBvdXRlcldpZHRoID0gd2lkdGggLyAyICsgMiAqIHBhZGRpbmc7XG4gICAgICB2YXIgb3V0ZXJIZWlnaHQgPSBoZWlnaHQgLyAyICsgMiAqIHBhZGRpbmc7XG4gICAgICB2YXIgcG9pbnRzID0gW2NlbnRlclggLSBvdXRlcldpZHRoLCBjZW50ZXJZIC0gb3V0ZXJIZWlnaHQsIGNlbnRlclggLSBvdXRlcldpZHRoLCBjZW50ZXJZLCBjZW50ZXJYICsgb3V0ZXJXaWR0aCwgY2VudGVyWSwgY2VudGVyWCArIG91dGVyV2lkdGgsIGNlbnRlclkgLSBvdXRlckhlaWdodF07XG4gICAgICBpZiAobWF0aC5wb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgcG9pbnRzKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgYm90dG9tIHJpZ2h0IHF1YXJ0ZXIgY2lyY2xlXG4gICAgICBpZiAobWF0aC5jaGVja0luRWxsaXBzZSh4LCB5LCBkaWFtLCBkaWFtLCBjZW50ZXJYICsgd2lkdGggLyAyIC0gY29ybmVyUmFkaXVzLCBjZW50ZXJZICsgaGVpZ2h0IC8gMiAtIGNvcm5lclJhZGl1cywgcGFkZGluZykpIHtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgYm90dG9tIGxlZnQgcXVhcnRlciBjaXJjbGVcbiAgICAgIGlmIChtYXRoLmNoZWNrSW5FbGxpcHNlKHgsIHksIGRpYW0sIGRpYW0sIGNlbnRlclggLSB3aWR0aCAvIDIgKyBjb3JuZXJSYWRpdXMsIGNlbnRlclkgKyBoZWlnaHQgLyAyIC0gY29ybmVyUmFkaXVzLCBwYWRkaW5nKSkge1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xufTtcblxuQlJwLnJlZ2lzdGVyTm9kZVNoYXBlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGVTaGFwZXMgPSB0aGlzLm5vZGVTaGFwZXMgPSB7fTtcbiAgdmFyIHJlbmRlcmVyID0gdGhpcztcblxuICB0aGlzLmdlbmVyYXRlRWxsaXBzZSgpO1xuXG4gIHRoaXMuZ2VuZXJhdGVQb2x5Z29uKCd0cmlhbmdsZScsIG1hdGguZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDMsIDApKTtcblxuICB0aGlzLmdlbmVyYXRlUG9seWdvbigncmVjdGFuZ2xlJywgbWF0aC5nZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNCwgMCkpO1xuICBub2RlU2hhcGVzWydzcXVhcmUnXSA9IG5vZGVTaGFwZXNbJ3JlY3RhbmdsZSddO1xuXG4gIHRoaXMuZ2VuZXJhdGVSb3VuZFJlY3RhbmdsZSgpO1xuXG4gIHRoaXMuZ2VuZXJhdGVDdXRSZWN0YW5nbGUoKTtcblxuICB0aGlzLmdlbmVyYXRlQmFycmVsKCk7XG5cbiAgdGhpcy5nZW5lcmF0ZUJvdHRvbVJvdW5kcmVjdGFuZ2xlKCk7XG5cbiAgdGhpcy5nZW5lcmF0ZVBvbHlnb24oJ2RpYW1vbmQnLCBbMCwgMSwgMSwgMCwgMCwgLTEsIC0xLCAwXSk7XG5cbiAgdGhpcy5nZW5lcmF0ZVBvbHlnb24oJ3BlbnRhZ29uJywgbWF0aC5nZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNSwgMCkpO1xuXG4gIHRoaXMuZ2VuZXJhdGVQb2x5Z29uKCdoZXhhZ29uJywgbWF0aC5nZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNiwgMCkpO1xuXG4gIHRoaXMuZ2VuZXJhdGVQb2x5Z29uKCdoZXB0YWdvbicsIG1hdGguZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDcsIDApKTtcblxuICB0aGlzLmdlbmVyYXRlUG9seWdvbignb2N0YWdvbicsIG1hdGguZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDgsIDApKTtcblxuICB2YXIgc3RhcjVQb2ludHMgPSBuZXcgQXJyYXkoMjApO1xuICB7XG4gICAgdmFyIG91dGVyUG9pbnRzID0gbWF0aC5nZW5lcmF0ZVVuaXROZ29uUG9pbnRzKDUsIDApO1xuICAgIHZhciBpbm5lclBvaW50cyA9IG1hdGguZ2VuZXJhdGVVbml0TmdvblBvaW50cyg1LCBNYXRoLlBJIC8gNSk7XG5cbiAgICAvLyBPdXRlciByYWRpdXMgaXMgMTsgaW5uZXIgcmFkaXVzIG9mIHN0YXIgaXMgc21hbGxlclxuICAgIHZhciBpbm5lclJhZGl1cyA9IDAuNSAqICgzIC0gTWF0aC5zcXJ0KDUpKTtcbiAgICBpbm5lclJhZGl1cyAqPSAxLjU3O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbm5lclBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgIGlubmVyUG9pbnRzW2kgKiAyXSAqPSBpbm5lclJhZGl1cztcbiAgICAgIGlubmVyUG9pbnRzW2kgKiAyICsgMV0gKj0gaW5uZXJSYWRpdXM7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyMCAvIDQ7IGkrKykge1xuICAgICAgc3RhcjVQb2ludHNbaSAqIDRdID0gb3V0ZXJQb2ludHNbaSAqIDJdO1xuICAgICAgc3RhcjVQb2ludHNbaSAqIDQgKyAxXSA9IG91dGVyUG9pbnRzW2kgKiAyICsgMV07XG5cbiAgICAgIHN0YXI1UG9pbnRzW2kgKiA0ICsgMl0gPSBpbm5lclBvaW50c1tpICogMl07XG4gICAgICBzdGFyNVBvaW50c1tpICogNCArIDNdID0gaW5uZXJQb2ludHNbaSAqIDIgKyAxXTtcbiAgICB9XG4gIH1cblxuICBzdGFyNVBvaW50cyA9IG1hdGguZml0UG9seWdvblRvU3F1YXJlKHN0YXI1UG9pbnRzKTtcblxuICB0aGlzLmdlbmVyYXRlUG9seWdvbignc3RhcicsIHN0YXI1UG9pbnRzKTtcblxuICB0aGlzLmdlbmVyYXRlUG9seWdvbigndmVlJywgWy0xLCAtMSwgMCwgLTAuMzMzLCAxLCAtMSwgMCwgMV0pO1xuXG4gIHRoaXMuZ2VuZXJhdGVQb2x5Z29uKCdyaG9tYm9pZCcsIFstMSwgLTEsIDAuMzMzLCAtMSwgMSwgMSwgLTAuMzMzLCAxXSk7XG5cbiAgdGhpcy5nZW5lcmF0ZVBvbHlnb24oJ2NvbmNhdmVoZXhhZ29uJywgWy0xLCAtMC45NSwgLTAuNzUsIDAsIC0xLCAwLjk1LCAxLCAwLjk1LCAwLjc1LCAwLCAxLCAtMC45NV0pO1xuXG4gIHRoaXMuZ2VuZXJhdGVQb2x5Z29uKCd0YWcnLCBbLTEsIC0xLCAwLjI1LCAtMSwgMSwgMCwgMC4yNSwgMSwgLTEsIDFdKTtcblxuICBub2RlU2hhcGVzLm1ha2VQb2x5Z29uID0gZnVuY3Rpb24gKHBvaW50cykge1xuXG4gICAgLy8gdXNlIGNhY2hpbmcgb24gdXNlci1zcGVjaWZpZWQgcG9seWdvbnMgc28gdGhleSBhcmUgYXMgZmFzdCBhcyBuYXRpdmUgc2hhcGVzXG5cbiAgICB2YXIga2V5ID0gcG9pbnRzLmpvaW4oJyQnKTtcbiAgICB2YXIgbmFtZSA9ICdwb2x5Z29uLScgKyBrZXk7XG4gICAgdmFyIHNoYXBlO1xuXG4gICAgaWYgKHNoYXBlID0gdGhpc1tuYW1lXSkge1xuICAgICAgLy8gZ290IGNhY2hlZCBzaGFwZVxuICAgICAgcmV0dXJuIHNoYXBlO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBhbmQgY2FjaGUgbmV3IHNoYXBlXG4gICAgcmV0dXJuIHJlbmRlcmVyLmdlbmVyYXRlUG9seWdvbihuYW1lLCBwb2ludHMpO1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCUnA7XG5cbi8qKiovIH0pLFxuLyogMTIyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIEJScCA9IHt9O1xuXG5CUnAudGltZVRvUmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5yZWRyYXdUb3RhbFRpbWUgLyB0aGlzLnJlZHJhd0NvdW50O1xufTtcblxuQlJwLnJlZHJhdyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHV0aWwuc3RhdGljRW1wdHlPYmplY3QoKTtcblxuICB2YXIgciA9IHRoaXM7XG5cbiAgaWYgKHIuYXZlcmFnZVJlZHJhd1RpbWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHIuYXZlcmFnZVJlZHJhd1RpbWUgPSAwO1xuICB9XG4gIGlmIChyLmxhc3RSZWRyYXdUaW1lID09PSB1bmRlZmluZWQpIHtcbiAgICByLmxhc3RSZWRyYXdUaW1lID0gMDtcbiAgfVxuICBpZiAoci5sYXN0RHJhd1RpbWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHIubGFzdERyYXdUaW1lID0gMDtcbiAgfVxuXG4gIHIucmVxdWVzdGVkRnJhbWUgPSB0cnVlO1xuICByLnJlbmRlck9wdGlvbnMgPSBvcHRpb25zO1xufTtcblxuQlJwLmJlZm9yZVJlbmRlciA9IGZ1bmN0aW9uIChmbiwgcHJpb3JpdHkpIHtcbiAgLy8gdGhlIHJlbmRlcmVyIGNhbid0IGFkZCB0aWNrIGNhbGxiYWNrcyB3aGVuIGRlc3Ryb3llZFxuICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBwcmlvcml0eSA9IHByaW9yaXR5IHx8IDA7XG5cbiAgdmFyIGNicyA9IHRoaXMuYmVmb3JlUmVuZGVyQ2FsbGJhY2tzO1xuXG4gIGNicy5wdXNoKHsgZm46IGZuLCBwcmlvcml0eTogcHJpb3JpdHkgfSk7XG5cbiAgLy8gaGlnaGVyIHByaW9yaXR5IGNhbGxiYWNrcyBleGVjdXRlZCBmaXJzdFxuICBjYnMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBiLnByaW9yaXR5IC0gYS5wcmlvcml0eTtcbiAgfSk7XG59O1xuXG52YXIgYmVmb3JlUmVuZGVyQ2FsbGJhY2tzID0gZnVuY3Rpb24gYmVmb3JlUmVuZGVyQ2FsbGJhY2tzKHIsIHdpbGxEcmF3LCBzdGFydFRpbWUpIHtcbiAgdmFyIGNicyA9IHIuYmVmb3JlUmVuZGVyQ2FsbGJhY2tzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2JzLmxlbmd0aDsgaSsrKSB7XG4gICAgY2JzW2ldLmZuKHdpbGxEcmF3LCBzdGFydFRpbWUpO1xuICB9XG59O1xuXG5CUnAuc3RhcnRSZW5kZXJMb29wID0gZnVuY3Rpb24gKCkge1xuICB2YXIgciA9IHRoaXM7XG5cbiAgaWYgKHIucmVuZGVyTG9vcFN0YXJ0ZWQpIHtcbiAgICByZXR1cm47XG4gIH0gZWxzZSB7XG4gICAgci5yZW5kZXJMb29wU3RhcnRlZCA9IHRydWU7XG4gIH1cblxuICB2YXIgcmVuZGVyRm4gPSBmdW5jdGlvbiByZW5kZXJGbihyZXF1ZXN0VGltZSkge1xuICAgIGlmIChyLmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChyLnJlcXVlc3RlZEZyYW1lICYmICFyLnNraXBGcmFtZSkge1xuICAgICAgYmVmb3JlUmVuZGVyQ2FsbGJhY2tzKHIsIHRydWUsIHJlcXVlc3RUaW1lKTtcblxuICAgICAgdmFyIHN0YXJ0VGltZSA9IHV0aWwucGVyZm9ybWFuY2VOb3coKTtcblxuICAgICAgci5yZW5kZXIoci5yZW5kZXJPcHRpb25zKTtcblxuICAgICAgdmFyIGVuZFRpbWUgPSByLmxhc3REcmF3VGltZSA9IHV0aWwucGVyZm9ybWFuY2VOb3coKTtcblxuICAgICAgaWYgKHIuYXZlcmFnZVJlZHJhd1RpbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByLmF2ZXJhZ2VSZWRyYXdUaW1lID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHIucmVkcmF3Q291bnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByLnJlZHJhd0NvdW50ID0gMDtcbiAgICAgIH1cblxuICAgICAgci5yZWRyYXdDb3VudCsrO1xuXG4gICAgICBpZiAoci5yZWRyYXdUb3RhbFRpbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByLnJlZHJhd1RvdGFsVGltZSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBkdXJhdGlvbiA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG5cbiAgICAgIHIucmVkcmF3VG90YWxUaW1lICs9IGR1cmF0aW9uO1xuICAgICAgci5sYXN0UmVkcmF3VGltZSA9IGR1cmF0aW9uO1xuXG4gICAgICAvLyB1c2UgYSB3ZWlnaHRlZCBhdmVyYWdlIHdpdGggYSBiaWFzIGZyb20gdGhlIHByZXZpb3VzIGF2ZXJhZ2Ugc28gd2UgZG9uJ3Qgc3Bpa2Ugc28gZWFzaWx5XG4gICAgICByLmF2ZXJhZ2VSZWRyYXdUaW1lID0gci5hdmVyYWdlUmVkcmF3VGltZSAvIDIgKyBkdXJhdGlvbiAvIDI7XG5cbiAgICAgIHIucmVxdWVzdGVkRnJhbWUgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmVmb3JlUmVuZGVyQ2FsbGJhY2tzKHIsIGZhbHNlLCByZXF1ZXN0VGltZSk7XG4gICAgfVxuXG4gICAgci5za2lwRnJhbWUgPSBmYWxzZTtcblxuICAgIHV0aWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlbmRlckZuKTtcbiAgfTtcblxuICB1dGlsLnJlcXVlc3RBbmltYXRpb25GcmFtZShyZW5kZXJGbik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJScDtcblxuLyoqKi8gfSksXG4vKiAxMjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLypcblRoZSBjYW52YXMgcmVuZGVyZXIgd2FzIHdyaXR0ZW4gYnkgWXVlIERvbmcuXG5cbk1vZGlmaWNhdGlvbnMgdHJhY2tlZCBvbiBHaXRodWIuXG4qL1xuXG52YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG52YXIgaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIEVsZW1lbnRUZXh0dXJlQ2FjaGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyNCk7XG52YXIgTGF5ZXJlZFRleHR1cmVDYWNoZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTI1KTtcblxudmFyIENSID0gQ2FudmFzUmVuZGVyZXI7XG52YXIgQ1JwID0gQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlO1xuXG5DUnAuQ0FOVkFTX0xBWUVSUyA9IDM7XG4vL1xuQ1JwLlNFTEVDVF9CT1ggPSAwO1xuQ1JwLkRSQUcgPSAxO1xuQ1JwLk5PREUgPSAyO1xuXG5DUnAuQlVGRkVSX0NPVU5UID0gMztcbi8vXG5DUnAuVEVYVFVSRV9CVUZGRVIgPSAwO1xuQ1JwLk1PVElPTkJMVVJfQlVGRkVSX05PREUgPSAxO1xuQ1JwLk1PVElPTkJMVVJfQlVGRkVSX0RSQUcgPSAyO1xuXG5mdW5jdGlvbiBDYW52YXNSZW5kZXJlcihvcHRpb25zKSB7XG4gIHZhciByID0gdGhpcztcblxuICByLmRhdGEgPSB7XG4gICAgY2FudmFzZXM6IG5ldyBBcnJheShDUnAuQ0FOVkFTX0xBWUVSUyksXG4gICAgY29udGV4dHM6IG5ldyBBcnJheShDUnAuQ0FOVkFTX0xBWUVSUyksXG4gICAgY2FudmFzTmVlZHNSZWRyYXc6IG5ldyBBcnJheShDUnAuQ0FOVkFTX0xBWUVSUyksXG5cbiAgICBidWZmZXJDYW52YXNlczogbmV3IEFycmF5KENScC5CVUZGRVJfQ09VTlQpLFxuICAgIGJ1ZmZlckNvbnRleHRzOiBuZXcgQXJyYXkoQ1JwLkNBTlZBU19MQVlFUlMpXG4gIH07XG5cbiAgdmFyIHRhcEhsT2ZmID0gJy13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogcmdiYSgwLDAsMCwwKTsnO1xuXG4gIHIuZGF0YS5jYW52YXNDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICB2YXIgY29udGFpbmVyU3R5bGUgPSByLmRhdGEuY2FudmFzQ29udGFpbmVyLnN0eWxlO1xuICByLmRhdGEuY2FudmFzQ29udGFpbmVyLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCB0YXBIbE9mZik7XG4gIGNvbnRhaW5lclN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgY29udGFpbmVyU3R5bGUuekluZGV4ID0gJzAnO1xuICBjb250YWluZXJTdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuXG4gIHZhciBjb250YWluZXIgPSBvcHRpb25zLmN5LmNvbnRhaW5lcigpO1xuICBjb250YWluZXIuYXBwZW5kQ2hpbGQoci5kYXRhLmNhbnZhc0NvbnRhaW5lcik7XG5cbiAgaWYgKChjb250YWluZXIuZ2V0QXR0cmlidXRlKCdzdHlsZScpIHx8ICcnKS5pbmRleE9mKHRhcEhsT2ZmKSA8IDApIHtcbiAgICBjb250YWluZXIuc2V0QXR0cmlidXRlKCdzdHlsZScsIChjb250YWluZXIuZ2V0QXR0cmlidXRlKCdzdHlsZScpIHx8ICcnKSArIHRhcEhsT2ZmKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgQ1JwLkNBTlZBU19MQVlFUlM7IGkrKykge1xuICAgIHZhciBjYW52YXMgPSByLmRhdGEuY2FudmFzZXNbaV0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgIHIuZGF0YS5jb250ZXh0c1tpXSA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJy13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7IC1tb3otdXNlci1zZWxlY3Q6IC1tb3otbm9uZTsgdXNlci1zZWxlY3Q6IG5vbmU7IC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogcmdiYSgwLDAsMCwwKTsgb3V0bGluZS1zdHlsZTogbm9uZTsnICsgKGlzLm1zKCkgPyAnIC1tcy10b3VjaC1hY3Rpb246IG5vbmU7IHRvdWNoLWFjdGlvbjogbm9uZTsgJyA6ICcnKSk7XG4gICAgY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBjYW52YXMuc2V0QXR0cmlidXRlKCdkYXRhLWlkJywgJ2xheWVyJyArIGkpO1xuICAgIGNhbnZhcy5zdHlsZS56SW5kZXggPSBTdHJpbmcoQ1JwLkNBTlZBU19MQVlFUlMgLSBpKTtcbiAgICByLmRhdGEuY2FudmFzQ29udGFpbmVyLmFwcGVuZENoaWxkKGNhbnZhcyk7XG5cbiAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbaV0gPSBmYWxzZTtcbiAgfVxuICByLmRhdGEudG9wQ2FudmFzID0gci5kYXRhLmNhbnZhc2VzWzBdO1xuXG4gIHIuZGF0YS5jYW52YXNlc1tDUnAuTk9ERV0uc2V0QXR0cmlidXRlKCdkYXRhLWlkJywgJ2xheWVyJyArIENScC5OT0RFICsgJy1ub2RlJyk7XG4gIHIuZGF0YS5jYW52YXNlc1tDUnAuU0VMRUNUX0JPWF0uc2V0QXR0cmlidXRlKCdkYXRhLWlkJywgJ2xheWVyJyArIENScC5TRUxFQ1RfQk9YICsgJy1zZWxlY3Rib3gnKTtcbiAgci5kYXRhLmNhbnZhc2VzW0NScC5EUkFHXS5zZXRBdHRyaWJ1dGUoJ2RhdGEtaWQnLCAnbGF5ZXInICsgQ1JwLkRSQUcgKyAnLWRyYWcnKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IENScC5CVUZGRVJfQ09VTlQ7IGkrKykge1xuICAgIHIuZGF0YS5idWZmZXJDYW52YXNlc1tpXSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgci5kYXRhLmJ1ZmZlckNvbnRleHRzW2ldID0gci5kYXRhLmJ1ZmZlckNhbnZhc2VzW2ldLmdldENvbnRleHQoJzJkJyk7XG4gICAgci5kYXRhLmJ1ZmZlckNhbnZhc2VzW2ldLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICByLmRhdGEuYnVmZmVyQ2FudmFzZXNbaV0uc2V0QXR0cmlidXRlKCdkYXRhLWlkJywgJ2J1ZmZlcicgKyBpKTtcbiAgICByLmRhdGEuYnVmZmVyQ2FudmFzZXNbaV0uc3R5bGUuekluZGV4ID0gU3RyaW5nKC1pIC0gMSk7XG4gICAgci5kYXRhLmJ1ZmZlckNhbnZhc2VzW2ldLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAvL3IuZGF0YS5jYW52YXNDb250YWluZXIuYXBwZW5kQ2hpbGQoci5kYXRhLmJ1ZmZlckNhbnZhc2VzW2ldKTtcbiAgfVxuXG4gIHIucGF0aHNFbmFibGVkID0gdHJ1ZTtcblxuICByLmRhdGEuZWxlVHhyQ2FjaGUgPSBuZXcgRWxlbWVudFRleHR1cmVDYWNoZShyKTtcbiAgci5kYXRhLmx5clR4ckNhY2hlID0gbmV3IExheWVyZWRUZXh0dXJlQ2FjaGUociwgci5kYXRhLmVsZVR4ckNhY2hlKTtcblxuICByLm9uVXBkYXRlRWxlQ2FsY3MoZnVuY3Rpb24gaW52YWxpZGF0ZVRleHR1cmVDYWNoZXMod2lsbERyYXcsIGVsZXMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgdmFyIHJzID0gZWxlLl9wcml2YXRlLnJzdHlsZTtcbiAgICAgIHZhciBkZSA9IHJzLmRpcnR5RXZlbnRzO1xuXG4gICAgICBpZiAoZWxlLmlzTm9kZSgpICYmIGRlICYmIGRlLmxlbmd0aCA9PT0gMSAmJiBkZVsncG9zaXRpb24nXSkge1xuICAgICAgICAvLyB0aGVuIGtlZXAgY2FjaGVkIGVsZSB0ZXh0dXJlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByLmRhdGEuZWxlVHhyQ2FjaGUuaW52YWxpZGF0ZUVsZW1lbnQoZWxlKTtcblxuICAgICAgICAvLyBOQiB0aGlzIGJsb2NrIG9mIGNvZGUgc2hvdWxkIG5vdCBiZSBwb3J0ZWQgdG8gMy4zICh1bnN0YWJsZSBicmFuY2gpLlxuICAgICAgICAvLyAtIFRoaXMgY2hlY2sgaXMgdW5uZWNjZXNhcnkgaW4gMy4zIGFzIGNhY2hlcyB3aWxsIGJlIHN0b3JlZCB3aXRob3V0IHJlc3BlY3QgdG8gb3BhY2l0eS5cbiAgICAgICAgLy8gLSBUaGlzIGZpeCBtYXkgcmVzdWx0IGluIGxvd2VyZWQgcGVyZm9ybWFuY2UgZm9yIGNvbXBvdW5kIGdyYXBocy5cbiAgICAgICAgLy8gLSBSZWYgOiBPcGFjaXR5IG9mIGNoaWxkIG5vZGUgaXMgbm90IHVwZGF0ZWQgZm9yIGNlcnRhaW4gem9vbSBsZXZlbHMgYWZ0ZXIgcGFyZW50IG9wYWNpdHkgaXMgb3ZlcnJpZGVuICMyMDc4XG4gICAgICAgIGlmIChlbGUuaXNQYXJlbnQoKSAmJiBkZVsnc3R5bGUnXSkge1xuICAgICAgICAgIHZhciBvcDEgPSBycy5wcmV2UGFyZW50T3BhY2l0eTtcbiAgICAgICAgICB2YXIgb3AyID0gZWxlLnBzdHlsZSgnb3BhY2l0eScpLnBmVmFsdWU7XG5cbiAgICAgICAgICBycy5wcmV2UGFyZW50T3BhY2l0eSA9IG9wMjtcblxuICAgICAgICAgIGlmIChvcDEgIT09IG9wMikge1xuICAgICAgICAgICAgdmFyIGRlc2NzID0gZWxlLmRlc2NlbmRhbnRzKCk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZGVzY3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgci5kYXRhLmVsZVR4ckNhY2hlLmludmFsaWRhdGVFbGVtZW50KGRlc2NzW2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICByLmRhdGEubHlyVHhyQ2FjaGUuaW52YWxpZGF0ZUVsZW1lbnRzKGVsZXMpO1xuICAgIH1cbiAgfSk7XG59XG5cbkNScC5yZWRyYXdIaW50ID0gZnVuY3Rpb24gKGdyb3VwLCBib29sKSB7XG4gIHZhciByID0gdGhpcztcblxuICBzd2l0Y2ggKGdyb3VwKSB7XG4gICAgY2FzZSAnZWxlcyc6XG4gICAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbQ1JwLk5PREVdID0gYm9vbDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2RyYWcnOlxuICAgICAgci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W0NScC5EUkFHXSA9IGJvb2w7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W0NScC5TRUxFQ1RfQk9YXSA9IGJvb2w7XG4gICAgICBicmVhaztcbiAgfVxufTtcblxuLy8gd2hldGhlciB0byB1c2UgUGF0aDJEIGNhY2hpbmcgZm9yIGRyYXdpbmdcbnZhciBwYXRoc0ltcGxkID0gdHlwZW9mIFBhdGgyRCAhPT0gJ3VuZGVmaW5lZCc7XG5cbkNScC5wYXRoMmRFbmFibGVkID0gZnVuY3Rpb24gKG9uKSB7XG4gIGlmIChvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHRoaXMucGF0aHNFbmFibGVkO1xuICB9XG5cbiAgdGhpcy5wYXRoc0VuYWJsZWQgPSBvbiA/IHRydWUgOiBmYWxzZTtcbn07XG5cbkNScC51c2VQYXRocyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHBhdGhzSW1wbGQgJiYgdGhpcy5wYXRoc0VuYWJsZWQ7XG59O1xuXG5bX193ZWJwYWNrX3JlcXVpcmVfXygxMjYpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyNyksIF9fd2VicGFja19yZXF1aXJlX18oMTI4KSwgX193ZWJwYWNrX3JlcXVpcmVfXygxMjkpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzMCksIF9fd2VicGFja19yZXF1aXJlX18oMTMxKSwgX193ZWJwYWNrX3JlcXVpcmVfXygxMzIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzMyksIF9fd2VicGFja19yZXF1aXJlX18oMTM0KSwgX193ZWJwYWNrX3JlcXVpcmVfXygxMzUpXS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wcykge1xuICB1dGlsLmV4dGVuZChDUnAsIHByb3BzKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENSO1xuXG4vKioqLyB9KSxcbi8qIDEyNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgbWF0aCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG52YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG52YXIgSGVhcCA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG52YXIgZGVmcyA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuXG52YXIgbWluVHhySCA9IDI1OyAvLyB0aGUgc2l6ZSBvZiB0aGUgdGV4dHVyZSBjYWNoZSBmb3Igc21hbGwgaGVpZ2h0IGVsZXMgKHNwZWNpYWwgY2FzZSlcbnZhciB0eHJTdGVwSCA9IDUwOyAvLyB0aGUgbWluIHNpemUgb2YgdGhlIHJlZ3VsYXIgY2FjaGUsIGFuZCB0aGUgc2l6ZSBpdCBpbmNyZWFzZXMgd2l0aCBlYWNoIHN0ZXAgdXBcbnZhciBtaW5MdmwgPSAtNDsgLy8gd2hlbiBzY2FsaW5nIHNtYWxsZXIgdGhhbiB0aGF0IHdlIGRvbid0IG5lZWQgdG8gcmUtcmVuZGVyXG52YXIgbWF4THZsID0gMjsgLy8gd2hlbiBsYXJnZXIgdGhhbiB0aGlzIHNjYWxlIGp1c3QgcmVuZGVyIGRpcmVjdGx5IChjYWNoaW5nIGlzIG5vdCBoZWxwZnVsKVxudmFyIG1heFpvb20gPSAzLjk5OyAvLyBiZXlvbmQgdGhpcyB6b29tIGxldmVsLCBsYXllcmVkIHRleHR1cmVzIGFyZSBub3QgdXNlZFxudmFyIGVsZVR4clNwYWNpbmcgPSA4OyAvLyBzcGFjaW5nIGJldHdlZW4gZWxlbWVudHMgb24gdGV4dHVyZXMgdG8gYXZvaWQgYmxpdHRpbmcgb3ZlcmxhcHNcbnZhciBkZWZUeHJXaWR0aCA9IDEwMjQ7IC8vIGRlZmF1bHQvbWluaW11bSB0ZXh0dXJlIHdpZHRoXG52YXIgbWF4VHhyVyA9IDEwMjQ7IC8vIHRoZSBtYXhpbXVtIHdpZHRoIG9mIGEgdGV4dHVyZVxudmFyIG1heFR4ckggPSAxMDI0OyAvLyB0aGUgbWF4aW11bSBoZWlnaHQgb2YgYSB0ZXh0dXJlXG52YXIgbWluVXRpbGl0eSA9IDAuNTsgLy8gaWYgdXNhZ2Ugb2YgdGV4dHVyZSBpcyBsZXNzIHRoYW4gdGhpcywgaXQgaXMgcmV0aXJlZFxudmFyIG1heEZ1bGxuZXNzID0gMC44OyAvLyBmdWxsbmVzcyBvZiB0ZXh0dXJlIGFmdGVyIHdoaWNoIHF1ZXVlIHJlbW92YWwgaXMgY2hlY2tlZFxudmFyIG1heEZ1bGxuZXNzQ2hlY2tzID0gMTA7IC8vIGRlcXVldWVkIGFmdGVyIHRoaXMgbWFueSBjaGVja3NcbnZhciBhbGxvd0VkZ2VUeHJDYWNoaW5nID0gZmFsc2U7IC8vIHdoZXRoZXIgZWRnZXMgY2FuIGJlIGNhY2hlZCBhcyB0ZXh0dXJlcyAoVE9ETyBtYXliZSBiZXR0ZXIgb24gaWYgd2ViZ2wgc3VwcG9ydGVkPylcbnZhciBhbGxvd1BhcmVudFR4ckNhY2hpbmcgPSBmYWxzZTsgLy8gd2hldGhlciBwYXJlbnQgbm9kZXMgY2FuIGJlIGNhY2hlZCBhcyB0ZXh0dXJlcyAoVE9ETyBtYXliZSBiZXR0ZXIgb24gaWYgd2ViZ2wgc3VwcG9ydGVkPylcbnZhciBkZXFDb3N0ID0gMC4xNTsgLy8gJSBvZiBhZGQnbCByZW5kZXJpbmcgY29zdCBhbGxvd2VkIGZvciBkZXF1ZXVpbmcgZWxlIGNhY2hlcyBlYWNoIGZyYW1lXG52YXIgZGVxQXZnQ29zdCA9IDAuMTsgLy8gJSBvZiBhZGQnbCByZW5kZXJpbmcgY29zdCBjb21wYXJlZCB0byBhdmVyYWdlIG92ZXJhbGwgcmVkcmF3IHRpbWVcbnZhciBkZXFOb0RyYXdDb3N0ID0gMC45OyAvLyAlIG9mIGF2ZyBmcmFtZSB0aW1lIHRoYXQgY2FuIGJlIHVzZWQgZm9yIGRlcXVldWVpbmcgd2hlbiBub3QgZHJhd2luZ1xudmFyIGRlcUZhc3RDb3N0ID0gMC45OyAvLyAlIG9mIGZyYW1lIHRpbWUgdG8gYmUgdXNlZCB3aGVuID42MGZwc1xudmFyIGRlcVJlZHJhd1RocmVzaG9sZCA9IDEwMDsgLy8gdGltZSB0byBiYXRjaCByZWRyYXdzIHRvZ2V0aGVyIGZyb20gZGVxdWV1ZWluZyB0byBhbGxvdyBtb3JlIGRlcXVldWVpbmcgY2FsY3MgdG8gaGFwcGVuIGluIHRoZSBtZWFud2hpbGVcbnZhciBtYXhEZXFTaXplID0gMTsgLy8gbnVtYmVyIG9mIGVsZXMgdG8gZGVxdWV1ZSBhbmQgcmVuZGVyIGF0IGhpZ2hlciB0ZXh0dXJlIGluIGVhY2ggYmF0Y2hcblxudmFyIGdldFR4clJlYXNvbnMgPSB7XG4gIGRlcXVldWU6ICdkZXF1ZXVlJyxcbiAgZG93bnNjYWxlOiAnZG93bnNjYWxlJyxcbiAgaGlnaFF1YWxpdHk6ICdoaWdoUXVhbGl0eSdcbn07XG5cbnZhciBFbGVtZW50VGV4dHVyZUNhY2hlID0gZnVuY3Rpb24gRWxlbWVudFRleHR1cmVDYWNoZShyZW5kZXJlcikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgc2VsZi5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICBzZWxmLm9uRGVxdWV1ZXMgPSBbXTtcblxuICBzZWxmLnNldHVwRGVxdWV1ZWluZygpO1xufTtcblxudmFyIEVUQ3AgPSBFbGVtZW50VGV4dHVyZUNhY2hlLnByb3RvdHlwZTtcblxuRVRDcC5yZWFzb25zID0gZ2V0VHhyUmVhc29ucztcblxuLy8gdGhlIGxpc3Qgb2YgdGV4dHVyZXMgaW4gd2hpY2ggbmV3IHN1YnRleHR1cmVzIGZvciBlbGVtZW50cyBjYW4gYmUgcGxhY2VkXG5FVENwLmdldFRleHR1cmVRdWV1ZSA9IGZ1bmN0aW9uICh0eHJIKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2VsZi5lbGVJbWdDYWNoZXMgPSBzZWxmLmVsZUltZ0NhY2hlcyB8fCB7fTtcblxuICByZXR1cm4gc2VsZi5lbGVJbWdDYWNoZXNbdHhySF0gPSBzZWxmLmVsZUltZ0NhY2hlc1t0eHJIXSB8fCBbXTtcbn07XG5cbi8vIHRoZSBsaXN0IG9mIHVzdXNlZCB0ZXh0dXJlcyB3aGljaCBjYW4gYmUgcmVjeWNsZWQgKGluIHVzZSBpbiB0ZXh0dXJlIHF1ZXVlKVxuRVRDcC5nZXRSZXRpcmVkVGV4dHVyZVF1ZXVlID0gZnVuY3Rpb24gKHR4ckgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHZhciBydHh0clFzID0gc2VsZi5lbGVJbWdDYWNoZXMucmV0aXJlZCA9IHNlbGYuZWxlSW1nQ2FjaGVzLnJldGlyZWQgfHwge307XG4gIHZhciBydHh0clEgPSBydHh0clFzW3R4ckhdID0gcnR4dHJRc1t0eHJIXSB8fCBbXTtcblxuICByZXR1cm4gcnR4dHJRO1xufTtcblxuLy8gcXVldWUgb2YgZWxlbWVudCBkcmF3IHJlcXVlc3RzIGF0IGRpZmZlcmVudCBzY2FsZSBsZXZlbHNcbkVUQ3AuZ2V0RWxlbWVudFF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdmFyIHEgPSBzZWxmLmVsZUNhY2hlUXVldWUgPSBzZWxmLmVsZUNhY2hlUXVldWUgfHwgbmV3IEhlYXAoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYi5yZXFzIC0gYS5yZXFzO1xuICB9KTtcblxuICByZXR1cm4gcTtcbn07XG5cbi8vIHF1ZXVlIG9mIGVsZW1lbnQgZHJhdyByZXF1ZXN0cyBhdCBkaWZmZXJlbnQgc2NhbGUgbGV2ZWxzIChlbGVtZW50IGlkIGxvb2t1cClcbkVUQ3AuZ2V0RWxlbWVudElkVG9RdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHZhciBpZDJxID0gc2VsZi5lbGVJZFRvQ2FjaGVRdWV1ZSA9IHNlbGYuZWxlSWRUb0NhY2hlUXVldWUgfHwge307XG5cbiAgcmV0dXJuIGlkMnE7XG59O1xuXG5FVENwLmdldEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlLCBiYiwgcHhSYXRpbywgbHZsLCByZWFzb24pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgciA9IHRoaXMucmVuZGVyZXI7XG4gIHZhciBycyA9IGVsZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgdmFyIHpvb20gPSByLmN5Lnpvb20oKTtcblxuICBpZiAoYmIudyA9PT0gMCB8fCBiYi5oID09PSAwIHx8ICFlbGUudmlzaWJsZSgpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAobHZsID09IG51bGwpIHtcbiAgICBsdmwgPSBNYXRoLmNlaWwobWF0aC5sb2cyKHpvb20gKiBweFJhdGlvKSk7XG4gIH1cblxuICBpZiAobHZsIDwgbWluTHZsKSB7XG4gICAgbHZsID0gbWluTHZsO1xuICB9IGVsc2UgaWYgKHpvb20gPj0gbWF4Wm9vbSB8fCBsdmwgPiBtYXhMdmwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBzY2FsZSA9IE1hdGgucG93KDIsIGx2bCk7XG4gIHZhciBlbGVTY2FsZWRIID0gYmIuaCAqIHNjYWxlO1xuICB2YXIgZWxlU2NhbGVkVyA9IGJiLncgKiBzY2FsZTtcbiAgdmFyIGNhY2hlcyA9IHJzLmltZ0NhY2hlcyA9IHJzLmltZ0NhY2hlcyB8fCB7fTtcbiAgdmFyIGVsZUNhY2hlID0gY2FjaGVzW2x2bF07XG5cbiAgaWYgKGVsZUNhY2hlKSB7XG4gICAgcmV0dXJuIGVsZUNhY2hlO1xuICB9XG5cbiAgdmFyIHR4ckg7IC8vIHdoaWNoIHRleHR1cmUgaGVpZ2h0IHRoaXMgZWxlIGJlbG9uZ3MgdG9cblxuICBpZiAoZWxlU2NhbGVkSCA8PSBtaW5UeHJIKSB7XG4gICAgdHhySCA9IG1pblR4ckg7XG4gIH0gZWxzZSBpZiAoZWxlU2NhbGVkSCA8PSB0eHJTdGVwSCkge1xuICAgIHR4ckggPSB0eHJTdGVwSDtcbiAgfSBlbHNlIHtcbiAgICB0eHJIID0gTWF0aC5jZWlsKGVsZVNjYWxlZEggLyB0eHJTdGVwSCkgKiB0eHJTdGVwSDtcbiAgfVxuXG4gIGlmIChlbGVTY2FsZWRIID4gbWF4VHhySCB8fCBlbGVTY2FsZWRXID4gbWF4VHhyVyB8fCAhYWxsb3dFZGdlVHhyQ2FjaGluZyAmJiBlbGUuaXNFZGdlKCkgfHwgIWFsbG93UGFyZW50VHhyQ2FjaGluZyAmJiBlbGUuaXNQYXJlbnQoKSkge1xuICAgIHJldHVybiBudWxsOyAvLyBjYWNoaW5nIGxhcmdlIGVsZW1lbnRzIGlzIG5vdCBlZmZpY2llbnRcbiAgfVxuXG4gIHZhciB0eHJRID0gc2VsZi5nZXRUZXh0dXJlUXVldWUodHhySCk7XG5cbiAgLy8gZmlyc3QgdHJ5IHRoZSBzZWNvbmQgbGFzdCBvbmUgaW4gY2FzZSBpdCBoYXMgc3BhY2UgYXQgdGhlIGVuZFxuICB2YXIgdHhyID0gdHhyUVt0eHJRLmxlbmd0aCAtIDJdO1xuXG4gIHZhciBhZGROZXdUeHIgPSBmdW5jdGlvbiBhZGROZXdUeHIoKSB7XG4gICAgcmV0dXJuIHNlbGYucmVjeWNsZVRleHR1cmUodHhySCwgZWxlU2NhbGVkVykgfHwgc2VsZi5hZGRUZXh0dXJlKHR4ckgsIGVsZVNjYWxlZFcpO1xuICB9O1xuXG4gIC8vIHRyeSB0aGUgbGFzdCBvbmUgaWYgdGhlcmUgaXMgbm8gc2Vjb25kIGxhc3Qgb25lXG4gIGlmICghdHhyKSB7XG4gICAgdHhyID0gdHhyUVt0eHJRLmxlbmd0aCAtIDFdO1xuICB9XG5cbiAgLy8gaWYgdGhlIGxhc3Qgb25lIGRvZXNuJ3QgZXhpc3QsIHdlIG5lZWQgYSBmaXJzdCBvbmVcbiAgaWYgKCF0eHIpIHtcbiAgICB0eHIgPSBhZGROZXdUeHIoKTtcbiAgfVxuXG4gIC8vIGlmIHRoZXJlJ3Mgbm8gcm9vbSBpbiB0aGUgY3VycmVudCB0ZXh0dXJlLCB3ZSBuZWVkIGEgbmV3IG9uZVxuICBpZiAodHhyLndpZHRoIC0gdHhyLnVzZWRXaWR0aCA8IGVsZVNjYWxlZFcpIHtcbiAgICB0eHIgPSBhZGROZXdUeHIoKTtcbiAgfVxuXG4gIHZhciBzY2FsZWRMYWJlbFNob3duID0gci5lbGVUZXh0QmlnZ2VyVGhhbk1pbihlbGUsIHNjYWxlKTtcbiAgdmFyIHNjYWxhYmxlRnJvbSA9IGZ1bmN0aW9uIHNjYWxhYmxlRnJvbShvdGhlckNhY2hlKSB7XG4gICAgcmV0dXJuIG90aGVyQ2FjaGUgJiYgb3RoZXJDYWNoZS5zY2FsZWRMYWJlbFNob3duID09PSBzY2FsZWRMYWJlbFNob3duO1xuICB9O1xuXG4gIHZhciBkZXFpbmcgPSByZWFzb24gJiYgcmVhc29uID09PSBnZXRUeHJSZWFzb25zLmRlcXVldWU7XG4gIHZhciBoaWdoUXVhbGl0eVJlcSA9IHJlYXNvbiAmJiByZWFzb24gPT09IGdldFR4clJlYXNvbnMuaGlnaFF1YWxpdHk7XG4gIHZhciBkb3duc2NhbGVSZXEgPSByZWFzb24gJiYgcmVhc29uID09PSBnZXRUeHJSZWFzb25zLmRvd25zY2FsZTtcblxuICB2YXIgaGlnaGVyQ2FjaGU7IC8vIHRoZSBuZWFyZXN0IGNhY2hlIHdpdGggYSBoaWdoZXIgbGV2ZWxcbiAgZm9yICh2YXIgbCA9IGx2bCArIDE7IGwgPD0gbWF4THZsOyBsKyspIHtcbiAgICB2YXIgYyA9IGNhY2hlc1tsXTtcblxuICAgIGlmIChjKSB7XG4gICAgICBoaWdoZXJDYWNoZSA9IGM7YnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIG9uZVVwQ2FjaGUgPSBoaWdoZXJDYWNoZSAmJiBoaWdoZXJDYWNoZS5sZXZlbCA9PT0gbHZsICsgMSA/IGhpZ2hlckNhY2hlIDogbnVsbDtcblxuICB2YXIgZG93bnNjYWxlID0gZnVuY3Rpb24gZG93bnNjYWxlKCkge1xuICAgIHR4ci5jb250ZXh0LmRyYXdJbWFnZShvbmVVcENhY2hlLnRleHR1cmUuY2FudmFzLCBvbmVVcENhY2hlLngsIDAsIG9uZVVwQ2FjaGUud2lkdGgsIG9uZVVwQ2FjaGUuaGVpZ2h0LCB0eHIudXNlZFdpZHRoLCAwLCBlbGVTY2FsZWRXLCBlbGVTY2FsZWRIKTtcbiAgfTtcblxuICAvLyByZXNldCBlbGUgYXJlYSBpbiB0ZXh0dXJlXG4gIHR4ci5jb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgdHhyLmNvbnRleHQuY2xlYXJSZWN0KHR4ci51c2VkV2lkdGgsIDAsIGVsZVNjYWxlZFcsIHR4ckgpO1xuXG4gIGlmIChzY2FsYWJsZUZyb20ob25lVXBDYWNoZSkpIHtcbiAgICAvLyB0aGVuIHdlIGNhbiByZWxhdGl2ZWx5IGNoZWFwbHkgcmVzY2FsZSB0aGUgZXhpc3RpbmcgaW1hZ2Ugdy9vIHJlcmVuZGVyaW5nXG4gICAgZG93bnNjYWxlKCk7XG4gIH0gZWxzZSBpZiAoc2NhbGFibGVGcm9tKGhpZ2hlckNhY2hlKSkge1xuICAgIC8vIHRoZW4gdXNlIHRoZSBoaWdoZXIgY2FjaGUgZm9yIG5vdyBhbmQgcXVldWUgdGhlIG5leHQgbGV2ZWwgZG93blxuICAgIC8vIHRvIGNoZWFwbHkgc2NhbGUgdG93YXJkcyB0aGUgc21hbGxlciBsZXZlbFxuXG4gICAgaWYgKGhpZ2hRdWFsaXR5UmVxKSB7XG4gICAgICBmb3IgKHZhciBsID0gaGlnaGVyQ2FjaGUubGV2ZWw7IGwgPiBsdmw7IGwtLSkge1xuICAgICAgICBvbmVVcENhY2hlID0gc2VsZi5nZXRFbGVtZW50KGVsZSwgYmIsIHB4UmF0aW8sIGwsIGdldFR4clJlYXNvbnMuZG93bnNjYWxlKTtcbiAgICAgIH1cblxuICAgICAgZG93bnNjYWxlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYucXVldWVFbGVtZW50KGVsZSwgaGlnaGVyQ2FjaGUubGV2ZWwgLSAxKTtcblxuICAgICAgcmV0dXJuIGhpZ2hlckNhY2hlO1xuICAgIH1cbiAgfSBlbHNlIHtcblxuICAgIHZhciBsb3dlckNhY2hlOyAvLyB0aGUgbmVhcmVzdCBjYWNoZSB3aXRoIGEgbG93ZXIgbGV2ZWxcbiAgICBpZiAoIWRlcWluZyAmJiAhaGlnaFF1YWxpdHlSZXEgJiYgIWRvd25zY2FsZVJlcSkge1xuICAgICAgZm9yICh2YXIgbCA9IGx2bCAtIDE7IGwgPj0gbWluTHZsOyBsLS0pIHtcbiAgICAgICAgdmFyIGMgPSBjYWNoZXNbbF07XG5cbiAgICAgICAgaWYgKGMpIHtcbiAgICAgICAgICBsb3dlckNhY2hlID0gYzticmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzY2FsYWJsZUZyb20obG93ZXJDYWNoZSkpIHtcbiAgICAgIC8vIHRoZW4gdXNlIHRoZSBsb3dlciBxdWFsaXR5IGNhY2hlIGZvciBub3cgYW5kIHF1ZXVlIHRoZSBiZXR0ZXIgb25lIGZvciBsYXRlclxuXG4gICAgICBzZWxmLnF1ZXVlRWxlbWVudChlbGUsIGx2bCk7XG5cbiAgICAgIHJldHVybiBsb3dlckNhY2hlO1xuICAgIH1cblxuICAgIHR4ci5jb250ZXh0LnRyYW5zbGF0ZSh0eHIudXNlZFdpZHRoLCAwKTtcbiAgICB0eHIuY29udGV4dC5zY2FsZShzY2FsZSwgc2NhbGUpO1xuXG4gICAgci5kcmF3RWxlbWVudCh0eHIuY29udGV4dCwgZWxlLCBiYiwgc2NhbGVkTGFiZWxTaG93bik7XG5cbiAgICB0eHIuY29udGV4dC5zY2FsZSgxIC8gc2NhbGUsIDEgLyBzY2FsZSk7XG4gICAgdHhyLmNvbnRleHQudHJhbnNsYXRlKC10eHIudXNlZFdpZHRoLCAwKTtcbiAgfVxuXG4gIGVsZUNhY2hlID0gY2FjaGVzW2x2bF0gPSB7XG4gICAgZWxlOiBlbGUsXG4gICAgeDogdHhyLnVzZWRXaWR0aCxcbiAgICB0ZXh0dXJlOiB0eHIsXG4gICAgbGV2ZWw6IGx2bCxcbiAgICBzY2FsZTogc2NhbGUsXG4gICAgd2lkdGg6IGVsZVNjYWxlZFcsXG4gICAgaGVpZ2h0OiBlbGVTY2FsZWRILFxuICAgIHNjYWxlZExhYmVsU2hvd246IHNjYWxlZExhYmVsU2hvd25cbiAgfTtcblxuICB0eHIudXNlZFdpZHRoICs9IE1hdGguY2VpbChlbGVTY2FsZWRXICsgZWxlVHhyU3BhY2luZyk7XG5cbiAgdHhyLmVsZUNhY2hlcy5wdXNoKGVsZUNhY2hlKTtcblxuICBzZWxmLmNoZWNrVGV4dHVyZUZ1bGxuZXNzKHR4cik7XG5cbiAgcmV0dXJuIGVsZUNhY2hlO1xufTtcblxuRVRDcC5pbnZhbGlkYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChlbGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgY2FjaGVzID0gZWxlLl9wcml2YXRlLnJzY3JhdGNoLmltZ0NhY2hlcztcblxuICBpZiAoY2FjaGVzKSB7XG4gICAgZm9yICh2YXIgbHZsID0gbWluTHZsOyBsdmwgPD0gbWF4THZsOyBsdmwrKykge1xuICAgICAgdmFyIGNhY2hlID0gY2FjaGVzW2x2bF07XG5cbiAgICAgIGlmIChjYWNoZSkge1xuICAgICAgICB2YXIgdHhyID0gY2FjaGUudGV4dHVyZTtcblxuICAgICAgICAvLyByZW1vdmUgc3BhY2UgZnJvbSB0aGUgdGV4dHVyZSBpdCBiZWxvbmdzIHRvXG4gICAgICAgIHR4ci5pbnZhbGlkYXRlZFdpZHRoICs9IGNhY2hlLndpZHRoO1xuXG4gICAgICAgIC8vIHJlbW92ZSByZWZzIHdpdGggdGhlIGVsZW1lbnRcbiAgICAgICAgY2FjaGVzW2x2bF0gPSBudWxsO1xuICAgICAgICB1dGlsLnJlbW92ZUZyb21BcnJheSh0eHIuZWxlQ2FjaGVzLCBjYWNoZSk7XG5cbiAgICAgICAgLy8gcmVtb3ZlIGZyb20gcXVldWUgc2luY2UgdGhlIG9sZCByZXEgd2FzIGZvciB0aGUgb2xkIHN0YXRlXG4gICAgICAgIHNlbGYucmVtb3ZlRnJvbVF1ZXVlKGVsZSk7XG5cbiAgICAgICAgLy8gbWlnaHQgaGF2ZSB0byByZW1vdmUgdGhlIGVudGlyZSB0ZXh0dXJlIGlmIGl0J3Mgbm90IGVmZmljaWVudGx5IHVzaW5nIGl0cyBzcGFjZVxuICAgICAgICBzZWxmLmNoZWNrVGV4dHVyZVV0aWxpdHkodHhyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbkVUQ3AuY2hlY2tUZXh0dXJlVXRpbGl0eSA9IGZ1bmN0aW9uICh0eHIpIHtcbiAgLy8gaW52YWxpZGF0ZSBhbGwgZW50cmllcyBpbiB0aGUgY2FjaGUgaWYgdGhlIGNhY2hlIHNpemUgaXMgc21hbGxcbiAgaWYgKHR4ci5pbnZhbGlkYXRlZFdpZHRoID49IG1pblV0aWxpdHkgKiB0eHIud2lkdGgpIHtcbiAgICB0aGlzLnJldGlyZVRleHR1cmUodHhyKTtcbiAgfVxufTtcblxuRVRDcC5jaGVja1RleHR1cmVGdWxsbmVzcyA9IGZ1bmN0aW9uICh0eHIpIHtcbiAgLy8gaWYgdGV4dHVyZSBoYXMgYmVlbiBtb3N0bHkgZmlsbGVkIGFuZCBwYXNzZWQgb3ZlciBzZXZlcmFsIHRpbWVzLCByZW1vdmVcbiAgLy8gaXQgZnJvbSB0aGUgcXVldWUgc28gd2UgZG9uJ3QgbmVlZCB0byB3YXN0ZSB0aW1lIGxvb2tpbmcgYXQgaXQgdG8gcHV0IG5ldyB0aGluZ3NcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB0eHJRID0gc2VsZi5nZXRUZXh0dXJlUXVldWUodHhyLmhlaWdodCk7XG5cbiAgaWYgKHR4ci51c2VkV2lkdGggLyB0eHIud2lkdGggPiBtYXhGdWxsbmVzcyAmJiB0eHIuZnVsbG5lc3NDaGVja3MgPj0gbWF4RnVsbG5lc3NDaGVja3MpIHtcbiAgICB1dGlsLnJlbW92ZUZyb21BcnJheSh0eHJRLCB0eHIpO1xuICB9IGVsc2Uge1xuICAgIHR4ci5mdWxsbmVzc0NoZWNrcysrO1xuICB9XG59O1xuXG5FVENwLnJldGlyZVRleHR1cmUgPSBmdW5jdGlvbiAodHhyKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHR4ckggPSB0eHIuaGVpZ2h0O1xuICB2YXIgdHhyUSA9IHNlbGYuZ2V0VGV4dHVyZVF1ZXVlKHR4ckgpO1xuXG4gIC8vIHJldGlyZSB0aGUgdGV4dHVyZSBmcm9tIHRoZSBhY3RpdmUgLyBzZWFyY2hhYmxlIHF1ZXVlOlxuXG4gIHV0aWwucmVtb3ZlRnJvbUFycmF5KHR4clEsIHR4cik7XG5cbiAgdHhyLnJldGlyZWQgPSB0cnVlO1xuXG4gIC8vIHJlbW92ZSB0aGUgcmVmcyBmcm9tIHRoZSBlbGVzIHRvIHRoZSBjYWNoZXM6XG5cbiAgdmFyIGVsZUNhY2hlcyA9IHR4ci5lbGVDYWNoZXM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVDYWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlQ2FjaGUgPSBlbGVDYWNoZXNbaV07XG4gICAgdmFyIGVsZSA9IGVsZUNhY2hlLmVsZTtcbiAgICB2YXIgbHZsID0gZWxlQ2FjaGUubGV2ZWw7XG4gICAgdmFyIGltZ0NhY2hlcyA9IGVsZS5fcHJpdmF0ZS5yc2NyYXRjaC5pbWdDYWNoZXM7XG5cbiAgICBpZiAoaW1nQ2FjaGVzKSB7XG4gICAgICBpbWdDYWNoZXNbbHZsXSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgdXRpbC5jbGVhckFycmF5KGVsZUNhY2hlcyk7XG5cbiAgLy8gYWRkIHRoZSB0ZXh0dXJlIHRvIGEgcmV0aXJlZCBxdWV1ZSBzbyBpdCBjYW4gYmUgcmVjeWNsZWQgaW4gZnV0dXJlOlxuXG4gIHZhciBydHh0clEgPSBzZWxmLmdldFJldGlyZWRUZXh0dXJlUXVldWUodHhySCk7XG5cbiAgcnR4dHJRLnB1c2godHhyKTtcbn07XG5cbkVUQ3AuYWRkVGV4dHVyZSA9IGZ1bmN0aW9uICh0eHJILCBtaW5XKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHR4clEgPSBzZWxmLmdldFRleHR1cmVRdWV1ZSh0eHJIKTtcbiAgdmFyIHR4ciA9IHt9O1xuXG4gIHR4clEucHVzaCh0eHIpO1xuXG4gIHR4ci5lbGVDYWNoZXMgPSBbXTtcblxuICB0eHIuaGVpZ2h0ID0gdHhySDtcbiAgdHhyLndpZHRoID0gTWF0aC5tYXgoZGVmVHhyV2lkdGgsIG1pblcpO1xuICB0eHIudXNlZFdpZHRoID0gMDtcbiAgdHhyLmludmFsaWRhdGVkV2lkdGggPSAwO1xuICB0eHIuZnVsbG5lc3NDaGVja3MgPSAwO1xuXG4gIHR4ci5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICB0eHIuY2FudmFzLndpZHRoID0gdHhyLndpZHRoO1xuICB0eHIuY2FudmFzLmhlaWdodCA9IHR4ci5oZWlnaHQ7XG5cbiAgdHhyLmNvbnRleHQgPSB0eHIuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgcmV0dXJuIHR4cjtcbn07XG5cbkVUQ3AucmVjeWNsZVRleHR1cmUgPSBmdW5jdGlvbiAodHhySCwgbWluVykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB0eHJRID0gc2VsZi5nZXRUZXh0dXJlUXVldWUodHhySCk7XG4gIHZhciBydHh0clEgPSBzZWxmLmdldFJldGlyZWRUZXh0dXJlUXVldWUodHhySCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBydHh0clEubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdHhyID0gcnR4dHJRW2ldO1xuXG4gICAgaWYgKHR4ci53aWR0aCA+PSBtaW5XKSB7XG4gICAgICB0eHIucmV0aXJlZCA9IGZhbHNlO1xuXG4gICAgICB0eHIudXNlZFdpZHRoID0gMDtcbiAgICAgIHR4ci5pbnZhbGlkYXRlZFdpZHRoID0gMDtcbiAgICAgIHR4ci5mdWxsbmVzc0NoZWNrcyA9IDA7XG5cbiAgICAgIHV0aWwuY2xlYXJBcnJheSh0eHIuZWxlQ2FjaGVzKTtcblxuICAgICAgdHhyLmNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgdHhyLmNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHR4ci53aWR0aCwgdHhyLmhlaWdodCk7XG5cbiAgICAgIHV0aWwucmVtb3ZlRnJvbUFycmF5KHJ0eHRyUSwgdHhyKTtcbiAgICAgIHR4clEucHVzaCh0eHIpO1xuXG4gICAgICByZXR1cm4gdHhyO1xuICAgIH1cbiAgfVxufTtcblxuRVRDcC5xdWV1ZUVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlLCBsdmwpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcSA9IHNlbGYuZ2V0RWxlbWVudFF1ZXVlKCk7XG4gIHZhciBpZDJxID0gc2VsZi5nZXRFbGVtZW50SWRUb1F1ZXVlKCk7XG4gIHZhciBpZCA9IGVsZS5pZCgpO1xuICB2YXIgZXhpc3RpbmdSZXEgPSBpZDJxW2lkXTtcblxuICBpZiAoZXhpc3RpbmdSZXEpIHtcbiAgICAvLyB1c2UgdGhlIG1heCBsdmwgYi9jIGluIGJldHdlZW4gbHZscyBhcmUgY2hlYXAgdG8gbWFrZVxuICAgIGV4aXN0aW5nUmVxLmxldmVsID0gTWF0aC5tYXgoZXhpc3RpbmdSZXEubGV2ZWwsIGx2bCk7XG4gICAgZXhpc3RpbmdSZXEucmVxcysrO1xuXG4gICAgcS51cGRhdGVJdGVtKGV4aXN0aW5nUmVxKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcmVxID0ge1xuICAgICAgZWxlOiBlbGUsXG4gICAgICBsZXZlbDogbHZsLFxuICAgICAgcmVxczogMVxuICAgIH07XG5cbiAgICBxLnB1c2gocmVxKTtcblxuICAgIGlkMnFbaWRdID0gcmVxO1xuICB9XG59O1xuXG5FVENwLmRlcXVldWUgPSBmdW5jdGlvbiAocHhSYXRpbyAvKiwgZXh0ZW50Ki8pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcSA9IHNlbGYuZ2V0RWxlbWVudFF1ZXVlKCk7XG4gIHZhciBpZDJxID0gc2VsZi5nZXRFbGVtZW50SWRUb1F1ZXVlKCk7XG4gIHZhciBkZXF1ZXVlZCA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWF4RGVxU2l6ZTsgaSsrKSB7XG4gICAgaWYgKHEuc2l6ZSgpID4gMCkge1xuICAgICAgdmFyIHJlcSA9IHEucG9wKCk7XG4gICAgICB2YXIgZWxlID0gcmVxLmVsZTtcbiAgICAgIHZhciBjYWNoZXMgPSBlbGUuX3ByaXZhdGUucnNjcmF0Y2guaW1nQ2FjaGVzO1xuXG4gICAgICAvLyBkZXF1ZXVlaW5nIGlzbid0IG5lY2Vzc2FyeSB3aGVuIGFuIGV4aXN0aW5nIGNhY2hlIGV4aXN0c1xuICAgICAgaWYgKGNhY2hlc1tyZXEubGV2ZWxdICE9IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlkMnFbZWxlLmlkKCldID0gbnVsbDtcblxuICAgICAgZGVxdWV1ZWQucHVzaChyZXEpO1xuXG4gICAgICB2YXIgYmIgPSBlbGUuYm91bmRpbmdCb3goKTtcblxuICAgICAgc2VsZi5nZXRFbGVtZW50KGVsZSwgYmIsIHB4UmF0aW8sIHJlcS5sZXZlbCwgZ2V0VHhyUmVhc29ucy5kZXF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRlcXVldWVkO1xufTtcblxuRVRDcC5yZW1vdmVGcm9tUXVldWUgPSBmdW5jdGlvbiAoZWxlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHEgPSBzZWxmLmdldEVsZW1lbnRRdWV1ZSgpO1xuICB2YXIgaWQycSA9IHNlbGYuZ2V0RWxlbWVudElkVG9RdWV1ZSgpO1xuICB2YXIgcmVxID0gaWQycVtlbGUuaWQoKV07XG5cbiAgaWYgKHJlcSAhPSBudWxsKSB7XG4gICAgLy8gYnJpbmcgdG8gZnJvbnQgb2YgcXVldWVcbiAgICByZXEucmVxcyA9IHV0aWwuTUFYX0lOVDtcbiAgICBxLnVwZGF0ZUl0ZW0ocmVxKTtcblxuICAgIHEucG9wKCk7IC8vIHJlbW92ZSBmcm9tIHF1ZXVlXG5cbiAgICBpZDJxW2VsZS5pZCgpXSA9IG51bGw7IC8vIHJlbW92ZSBmcm9tIGxvb2t1cCBtYXBcbiAgfVxufTtcblxuRVRDcC5vbkRlcXVldWUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgdGhpcy5vbkRlcXVldWVzLnB1c2goZm4pO1xufTtcbkVUQ3Aub2ZmRGVxdWV1ZSA9IGZ1bmN0aW9uIChmbikge1xuICB1dGlsLnJlbW92ZUZyb21BcnJheSh0aGlzLm9uRGVxdWV1ZXMsIGZuKTtcbn07XG5cbkVUQ3Auc2V0dXBEZXF1ZXVlaW5nID0gZGVmcy5zZXR1cERlcXVldWVpbmcoe1xuICBkZXFSZWRyYXdUaHJlc2hvbGQ6IGRlcVJlZHJhd1RocmVzaG9sZCxcbiAgZGVxQ29zdDogZGVxQ29zdCxcbiAgZGVxQXZnQ29zdDogZGVxQXZnQ29zdCxcbiAgZGVxTm9EcmF3Q29zdDogZGVxTm9EcmF3Q29zdCxcbiAgZGVxRmFzdENvc3Q6IGRlcUZhc3RDb3N0LFxuICBkZXE6IGZ1bmN0aW9uIGRlcShzZWxmLCBweFJhdGlvLCBleHRlbnQpIHtcbiAgICByZXR1cm4gc2VsZi5kZXF1ZXVlKHB4UmF0aW8sIGV4dGVudCk7XG4gIH0sXG4gIG9uRGVxZDogZnVuY3Rpb24gb25EZXFkKHNlbGYsIGRlcWQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYub25EZXF1ZXVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGZuID0gc2VsZi5vbkRlcXVldWVzW2ldO1xuXG4gICAgICBmbihkZXFkKTtcbiAgICB9XG4gIH0sXG4gIHNob3VsZFJlZHJhdzogZnVuY3Rpb24gc2hvdWxkUmVkcmF3KHNlbGYsIGRlcWQsIHB4UmF0aW8sIGV4dGVudCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVxZC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGJiID0gZGVxZFtpXS5lbGUuYm91bmRpbmdCb3goKTtcblxuICAgICAgaWYgKG1hdGguYm91bmRpbmdCb3hlc0ludGVyc2VjdChiYiwgZXh0ZW50KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG4gIHByaW9yaXR5OiBmdW5jdGlvbiBwcmlvcml0eShzZWxmKSB7XG4gICAgcmV0dXJuIHNlbGYucmVuZGVyZXIuYmVmb3JlUmVuZGVyUHJpb3JpdGllcy5lbGVUeHJEZXE7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVsZW1lbnRUZXh0dXJlQ2FjaGU7XG5cbi8qKiovIH0pLFxuLyogMTI1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbnZhciBtYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbnZhciBIZWFwID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcbnZhciBpcyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgZGVmcyA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuXG52YXIgZGVmTnVtTGF5ZXJzID0gMTsgLy8gZGVmYXVsdCBudW1iZXIgb2YgbGF5ZXJzIHRvIHVzZVxudmFyIG1pbkx2bCA9IC00OyAvLyB3aGVuIHNjYWxpbmcgc21hbGxlciB0aGFuIHRoYXQgd2UgZG9uJ3QgbmVlZCB0byByZS1yZW5kZXJcbnZhciBtYXhMdmwgPSAyOyAvLyB3aGVuIGxhcmdlciB0aGFuIHRoaXMgc2NhbGUganVzdCByZW5kZXIgZGlyZWN0bHkgKGNhY2hpbmcgaXMgbm90IGhlbHBmdWwpXG52YXIgbWF4Wm9vbSA9IDMuOTk7IC8vIGJleW9uZCB0aGlzIHpvb20gbGV2ZWwsIGxheWVyZWQgdGV4dHVyZXMgYXJlIG5vdCB1c2VkXG52YXIgZGVxUmVkcmF3VGhyZXNob2xkID0gNTA7IC8vIHRpbWUgdG8gYmF0Y2ggcmVkcmF3cyB0b2dldGhlciBmcm9tIGRlcXVldWVpbmcgdG8gYWxsb3cgbW9yZSBkZXF1ZXVlaW5nIGNhbGNzIHRvIGhhcHBlbiBpbiB0aGUgbWVhbndoaWxlXG52YXIgcmVmaW5lRWxlRGVib3VuY2VUaW1lID0gNTA7IC8vIHRpbWUgdG8gZGVib3VuY2Ugc2hhcnBlciBlbGUgdGV4dHVyZSB1cGRhdGVzXG52YXIgZGlzYWJsZUVsZUltZ1Ntb290aGluZyA9IHRydWU7IC8vIHdoZW4gZHJhd2luZyBlbGVzIG9uIGxheWVycyBmcm9tIGFuIGVsZSBjYWNoZSA7IGNyaXNwZXIgYW5kIG1vcmUgcGVyZm9ybWFudCB3aGVuIHRydWVcbnZhciBkZXFDb3N0ID0gMC4xNTsgLy8gJSBvZiBhZGQnbCByZW5kZXJpbmcgY29zdCBhbGxvd2VkIGZvciBkZXF1ZXVpbmcgZWxlIGNhY2hlcyBlYWNoIGZyYW1lXG52YXIgZGVxQXZnQ29zdCA9IDAuMTsgLy8gJSBvZiBhZGQnbCByZW5kZXJpbmcgY29zdCBjb21wYXJlZCB0byBhdmVyYWdlIG92ZXJhbGwgcmVkcmF3IHRpbWVcbnZhciBkZXFOb0RyYXdDb3N0ID0gMC45OyAvLyAlIG9mIGF2ZyBmcmFtZSB0aW1lIHRoYXQgY2FuIGJlIHVzZWQgZm9yIGRlcXVldWVpbmcgd2hlbiBub3QgZHJhd2luZ1xudmFyIGRlcUZhc3RDb3N0ID0gMC45OyAvLyAlIG9mIGZyYW1lIHRpbWUgdG8gYmUgdXNlZCB3aGVuID42MGZwc1xudmFyIG1heERlcVNpemUgPSAxOyAvLyBudW1iZXIgb2YgZWxlcyB0byBkZXF1ZXVlIGFuZCByZW5kZXIgYXQgaGlnaGVyIHRleHR1cmUgaW4gZWFjaCBiYXRjaFxudmFyIGludmFsaWRUaHJlc2hvbGQgPSAyNTA7IC8vIHRpbWUgdGhyZXNob2xkIGZvciBkaXNhYmxpbmcgYi9jIG9mIGludmFsaWRhdGlvbnNcbnZhciBtYXhMYXllckFyZWEgPSA0MDAwICogNDAwMDsgLy8gbGF5ZXJzIGNhbid0IGJlIGJpZ2dlciB0aGFuIHRoaXNcbnZhciBhbHdheXNRdWV1ZSA9IHRydWU7IC8vIG5ldmVyIGRyYXcgYWxsIHRoZSBsYXllcnMgaW4gYSBsZXZlbCBvbiBhIGZyYW1lOyBkcmF3IGRpcmVjdGx5IHVudGlsIGFsbCBkZXF1ZXVlZFxudmFyIHVzZUhpZ2hRdWFsaXR5RWxlVHhyUmVxcyA9IHRydWU7IC8vIHdoZXRoZXIgdG8gdXNlIGhpZ2ggcXVhbGl0eSBlbGUgdHhyIHJlcXVlc3RzIChnZW5lcmFsbHkgZmFzdGVyIGFuZCBjaGVhcGVyIGluIHRoZSBsb25ndGVybSlcblxudmFyIHVzZUVsZVR4ckNhY2hpbmcgPSB0cnVlOyAvLyB3aGV0aGVyIHRvIHVzZSBpbmRpdmlkdWFsIGVsZSB0ZXh0dXJlIGNhY2hpbmcgdW5kZXJuZWF0aCB0aGlzIGNhY2hlXG5cbi8vIHZhciBsb2cgPSBmdW5jdGlvbigpeyBjb25zb2xlLmxvZy5hcHBseSggY29uc29sZSwgYXJndW1lbnRzICk7IH07XG5cbnZhciBMYXllcmVkVGV4dHVyZUNhY2hlID0gZnVuY3Rpb24gTGF5ZXJlZFRleHR1cmVDYWNoZShyZW5kZXJlciwgZWxlVHhyQ2FjaGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHZhciByID0gc2VsZi5yZW5kZXJlciA9IHJlbmRlcmVyO1xuXG4gIHNlbGYubGF5ZXJzQnlMZXZlbCA9IHt9OyAvLyBlLmcuIDIgPT4gWyBsYXllcjEsIGxheWVyMiwgLi4uLCBsYXllck4gXVxuXG4gIHNlbGYuZmlyc3RHZXQgPSB0cnVlO1xuXG4gIHNlbGYubGFzdEludmFsaWRhdGlvblRpbWUgPSB1dGlsLnBlcmZvcm1hbmNlTm93KCkgLSAyICogaW52YWxpZFRocmVzaG9sZDtcblxuICBzZWxmLnNraXBwaW5nID0gZmFsc2U7XG5cbiAgci5iZWZvcmVSZW5kZXIoZnVuY3Rpb24gKHdpbGxEcmF3LCBub3cpIHtcbiAgICBpZiAobm93IC0gc2VsZi5sYXN0SW52YWxpZGF0aW9uVGltZSA8PSBpbnZhbGlkVGhyZXNob2xkKSB7XG4gICAgICBzZWxmLnNraXBwaW5nID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5za2lwcGluZyA9IGZhbHNlO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHFTb3J0ID0gZnVuY3Rpb24gcVNvcnQoYSwgYikge1xuICAgIHJldHVybiBiLnJlcXMgLSBhLnJlcXM7XG4gIH07XG5cbiAgc2VsZi5sYXllcnNRdWV1ZSA9IG5ldyBIZWFwKHFTb3J0KTtcblxuICBzZWxmLmVsZVR4ckNhY2hlID0gZWxlVHhyQ2FjaGU7XG5cbiAgc2VsZi5zZXR1cEVsZUNhY2hlSW52YWxpZGF0aW9uKCk7XG5cbiAgc2VsZi5zZXR1cERlcXVldWVpbmcoKTtcbn07XG5cbnZhciBMVENwID0gTGF5ZXJlZFRleHR1cmVDYWNoZS5wcm90b3R5cGU7XG5cbnZhciBsYXllcklkUG9vbCA9IDA7XG52YXIgTUFYX0lOVCA9IE1hdGgucG93KDIsIDUzKSAtIDE7XG5cbkxUQ3AubWFrZUxheWVyID0gZnVuY3Rpb24gKGJiLCBsdmwpIHtcbiAgdmFyIHNjYWxlID0gTWF0aC5wb3coMiwgbHZsKTtcblxuICB2YXIgdyA9IE1hdGguY2VpbChiYi53ICogc2NhbGUpO1xuICB2YXIgaCA9IE1hdGguY2VpbChiYi5oICogc2NhbGUpO1xuXG4gIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gIGNhbnZhcy53aWR0aCA9IHc7XG4gIGNhbnZhcy5oZWlnaHQgPSBoO1xuXG4gIHZhciBsYXllciA9IHtcbiAgICBpZDogbGF5ZXJJZFBvb2wgPSArK2xheWVySWRQb29sICUgTUFYX0lOVCxcbiAgICBiYjogYmIsXG4gICAgbGV2ZWw6IGx2bCxcbiAgICB3aWR0aDogdyxcbiAgICBoZWlnaHQ6IGgsXG4gICAgY2FudmFzOiBjYW52YXMsXG4gICAgY29udGV4dDogY2FudmFzLmdldENvbnRleHQoJzJkJyksXG4gICAgZWxlczogW10sXG4gICAgZWxlc1F1ZXVlOiBbXSxcbiAgICByZXFzOiAwXG4gIH07XG5cbiAgLy8gbG9nKCdtYWtlIGxheWVyICVzIHdpdGggdyAlcyBhbmQgaCAlcyBhbmQgbHZsICVzJywgbGF5ZXIuaWQsIGxheWVyLndpZHRoLCBsYXllci5oZWlnaHQsIGxheWVyLmxldmVsKTtcblxuICB2YXIgY3h0ID0gbGF5ZXIuY29udGV4dDtcbiAgdmFyIGR4ID0gLWxheWVyLmJiLngxO1xuICB2YXIgZHkgPSAtbGF5ZXIuYmIueTE7XG5cbiAgLy8gZG8gdGhlIHRyYW5zZm9ybSBvbiBjcmVhdGlvbiB0byBzYXZlIGN5Y2xlcyAoaXQncyB0aGUgc2FtZSBmb3IgYWxsIGVsZXMpXG4gIGN4dC5zY2FsZShzY2FsZSwgc2NhbGUpO1xuICBjeHQudHJhbnNsYXRlKGR4LCBkeSk7XG5cbiAgcmV0dXJuIGxheWVyO1xufTtcblxuTFRDcC5nZXRMYXllcnMgPSBmdW5jdGlvbiAoZWxlcywgcHhSYXRpbywgbHZsKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHIgPSBzZWxmLnJlbmRlcmVyO1xuICB2YXIgY3kgPSByLmN5O1xuICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgdmFyIGZpcnN0R2V0ID0gc2VsZi5maXJzdEdldDtcblxuICBzZWxmLmZpcnN0R2V0ID0gZmFsc2U7XG5cbiAgLy8gbG9nKCctLVxcbmdldCBsYXllcnMgd2l0aCAlcyBlbGVzJywgZWxlcy5sZW5ndGgpO1xuICAvL2xvZyBlbGVzLm1hcChmdW5jdGlvbihlbGUpeyByZXR1cm4gZWxlLmlkKCkgfSkgKTtcblxuICBpZiAobHZsID09IG51bGwpIHtcbiAgICBsdmwgPSBNYXRoLmNlaWwobWF0aC5sb2cyKHpvb20gKiBweFJhdGlvKSk7XG5cbiAgICBpZiAobHZsIDwgbWluTHZsKSB7XG4gICAgICBsdmwgPSBtaW5Mdmw7XG4gICAgfSBlbHNlIGlmICh6b29tID49IG1heFpvb20gfHwgbHZsID4gbWF4THZsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBzZWxmLnZhbGlkYXRlTGF5ZXJzRWxlc09yZGVyaW5nKGx2bCwgZWxlcyk7XG5cbiAgdmFyIGxheWVyc0J5THZsID0gc2VsZi5sYXllcnNCeUxldmVsO1xuICB2YXIgc2NhbGUgPSBNYXRoLnBvdygyLCBsdmwpO1xuICB2YXIgbGF5ZXJzID0gbGF5ZXJzQnlMdmxbbHZsXSA9IGxheWVyc0J5THZsW2x2bF0gfHwgW107XG4gIHZhciBiYjtcblxuICB2YXIgbHZsQ29tcGxldGUgPSBzZWxmLmxldmVsSXNDb21wbGV0ZShsdmwsIGVsZXMpO1xuICB2YXIgdG1wTGF5ZXJzO1xuXG4gIHZhciBjaGVja1RlbXBMZXZlbHMgPSBmdW5jdGlvbiBjaGVja1RlbXBMZXZlbHMoKSB7XG4gICAgdmFyIGNhblVzZUFzVG1wTHZsID0gZnVuY3Rpb24gY2FuVXNlQXNUbXBMdmwobCkge1xuICAgICAgc2VsZi52YWxpZGF0ZUxheWVyc0VsZXNPcmRlcmluZyhsLCBlbGVzKTtcblxuICAgICAgaWYgKHNlbGYubGV2ZWxJc0NvbXBsZXRlKGwsIGVsZXMpKSB7XG4gICAgICAgIHRtcExheWVycyA9IGxheWVyc0J5THZsW2xdO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGNoZWNrTHZscyA9IGZ1bmN0aW9uIGNoZWNrTHZscyhkaXIpIHtcbiAgICAgIGlmICh0bXBMYXllcnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBsID0gbHZsICsgZGlyOyBtaW5MdmwgPD0gbCAmJiBsIDw9IG1heEx2bDsgbCArPSBkaXIpIHtcbiAgICAgICAgaWYgKGNhblVzZUFzVG1wTHZsKGwpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY2hlY2tMdmxzKCsxKTtcbiAgICBjaGVja0x2bHMoLTEpO1xuXG4gICAgLy8gcmVtb3ZlIHRoZSBpbnZhbGlkIGxheWVyczsgdGhleSB3aWxsIGJlIHJlcGxhY2VkIGFzIG5lZWRlZCBsYXRlciBpbiB0aGlzIGZ1bmN0aW9uXG4gICAgZm9yICh2YXIgaSA9IGxheWVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGxheWVyID0gbGF5ZXJzW2ldO1xuXG4gICAgICBpZiAobGF5ZXIuaW52YWxpZCkge1xuICAgICAgICB1dGlsLnJlbW92ZUZyb21BcnJheShsYXllcnMsIGxheWVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgaWYgKCFsdmxDb21wbGV0ZSkge1xuICAgIC8vIGlmIHRoZSBjdXJyZW50IGxldmVsIGlzIGluY29tcGxldGUsIHRoZW4gdXNlIHRoZSBjbG9zZXN0LCBiZXN0IHF1YWxpdHkgbGF5ZXJzZXQgdGVtcG9yYXJpbHlcbiAgICAvLyBhbmQgbGF0ZXIgcXVldWUgdGhlIGN1cnJlbnQgbGF5ZXJzZXQgc28gd2UgY2FuIGdldCB0aGUgcHJvcGVyIHF1YWxpdHkgbGV2ZWwgc29vblxuXG4gICAgY2hlY2tUZW1wTGV2ZWxzKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbG9nKCdsZXZlbCBjb21wbGV0ZSwgdXNpbmcgZXhpc3RpbmcgbGF5ZXJzXFxuLS0nKTtcbiAgICByZXR1cm4gbGF5ZXJzO1xuICB9XG5cbiAgdmFyIGdldEJiID0gZnVuY3Rpb24gZ2V0QmIoKSB7XG4gICAgaWYgKCFiYikge1xuICAgICAgYmIgPSBtYXRoLm1ha2VCb3VuZGluZ0JveCgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbWF0aC51cGRhdGVCb3VuZGluZ0JveChiYiwgZWxlc1tpXS5ib3VuZGluZ0JveCgpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYmI7XG4gIH07XG5cbiAgdmFyIG1ha2VMYXllciA9IGZ1bmN0aW9uIG1ha2VMYXllcihvcHRzKSB7XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgICB2YXIgYWZ0ZXIgPSBvcHRzLmFmdGVyO1xuXG4gICAgZ2V0QmIoKTtcblxuICAgIHZhciBhcmVhID0gYmIudyAqIHNjYWxlICogKGJiLmggKiBzY2FsZSk7XG5cbiAgICBpZiAoYXJlYSA+IG1heExheWVyQXJlYSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGxheWVyID0gc2VsZi5tYWtlTGF5ZXIoYmIsIGx2bCk7XG5cbiAgICBpZiAoYWZ0ZXIgIT0gbnVsbCkge1xuICAgICAgdmFyIGluZGV4ID0gbGF5ZXJzLmluZGV4T2YoYWZ0ZXIpICsgMTtcblxuICAgICAgbGF5ZXJzLnNwbGljZShpbmRleCwgMCwgbGF5ZXIpO1xuICAgIH0gZWxzZSBpZiAob3B0cy5pbnNlcnQgPT09IHVuZGVmaW5lZCB8fCBvcHRzLmluc2VydCkge1xuICAgICAgLy8gbm8gYWZ0ZXIgc3BlY2lmaWVkID0+IGZpcnN0IGxheWVyIG1hZGUgc28gcHV0IGF0IHN0YXJ0XG4gICAgICBsYXllcnMudW5zaGlmdChsYXllcik7XG4gICAgfVxuXG4gICAgLy8gaWYoIHRtcExheWVycyApe1xuICAgIC8vc2VsZi5xdWV1ZUxheWVyKCBsYXllciApO1xuICAgIC8vIH1cblxuICAgIHJldHVybiBsYXllcjtcbiAgfTtcblxuICBpZiAoc2VsZi5za2lwcGluZyAmJiAhZmlyc3RHZXQpIHtcbiAgICAvLyBsb2coJ3NraXAgbGF5ZXJzJyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBsb2coJ2RvIGxheWVycycpO1xuXG4gIHZhciBsYXllciA9IG51bGw7XG4gIHZhciBtYXhFbGVzUGVyTGF5ZXIgPSBlbGVzLmxlbmd0aCAvIGRlZk51bUxheWVycztcbiAgdmFyIGFsbG93TGF6eVF1ZXVlaW5nID0gYWx3YXlzUXVldWUgJiYgIWZpcnN0R2V0O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgIHZhciBycyA9IGVsZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICB2YXIgY2FjaGVzID0gcnMuaW1nTGF5ZXJDYWNoZXMgPSBycy5pbWdMYXllckNhY2hlcyB8fCB7fTtcblxuICAgIC8vIGxvZygnbG9vayBhdCBlbGUnLCBlbGUuaWQoKSk7XG5cbiAgICB2YXIgZXhpc3RpbmdMYXllciA9IGNhY2hlc1tsdmxdO1xuXG4gICAgaWYgKGV4aXN0aW5nTGF5ZXIpIHtcbiAgICAgIC8vIHJldXNlIGxheWVyIGZvciBsYXRlciBlbGVzXG4gICAgICAvLyBsb2coJ3JldXNlIGxheWVyIGZvcicsIGVsZS5pZCgpKTtcbiAgICAgIGxheWVyID0gZXhpc3RpbmdMYXllcjtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICghbGF5ZXIgfHwgbGF5ZXIuZWxlcy5sZW5ndGggPj0gbWF4RWxlc1BlckxheWVyIHx8ICFtYXRoLmJvdW5kaW5nQm94SW5Cb3VuZGluZ0JveChsYXllci5iYiwgZWxlLmJvdW5kaW5nQm94KCkpKSB7XG4gICAgICAvLyBsb2coJ21ha2UgbmV3IGxheWVyIGZvciBlbGUgJXMnLCBlbGUuaWQoKSk7XG5cbiAgICAgIGxheWVyID0gbWFrZUxheWVyKHsgaW5zZXJ0OiB0cnVlLCBhZnRlcjogbGF5ZXIgfSk7XG5cbiAgICAgIC8vIGlmIG5vdyBsYXllciBjYW4gYmUgYnVpbHQgdGhlbiB3ZSBjYW4ndCB1c2UgbGF5ZXJzIGF0IHRoaXMgbGV2ZWxcbiAgICAgIGlmICghbGF5ZXIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIGxvZygnbmV3IGxheWVyIHdpdGggaWQgJXMnLCBsYXllci5pZCk7XG4gICAgfVxuXG4gICAgaWYgKHRtcExheWVycyB8fCBhbGxvd0xhenlRdWV1ZWluZykge1xuICAgICAgLy8gbG9nKCdxdWV1ZSBlbGUgJXMgaW4gbGF5ZXIgJXMnLCBlbGUuaWQoKSwgbGF5ZXIuaWQpO1xuICAgICAgc2VsZi5xdWV1ZUxheWVyKGxheWVyLCBlbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBsb2coJ2RyYXcgZWxlICVzIGluIGxheWVyICVzJywgZWxlLmlkKCksIGxheWVyLmlkKTtcbiAgICAgIHNlbGYuZHJhd0VsZUluTGF5ZXIobGF5ZXIsIGVsZSwgbHZsLCBweFJhdGlvKTtcbiAgICB9XG5cbiAgICBsYXllci5lbGVzLnB1c2goZWxlKTtcblxuICAgIGNhY2hlc1tsdmxdID0gbGF5ZXI7XG4gIH1cblxuICAvLyBsb2coJy0tJyk7XG5cbiAgaWYgKHRtcExheWVycykge1xuICAgIC8vIHRoZW4gd2Ugb25seSBxdWV1ZWQgdGhlIGN1cnJlbnQgbGF5ZXJzZXQgYW5kIGNhbid0IGRyYXcgaXQgeWV0XG4gICAgcmV0dXJuIHRtcExheWVycztcbiAgfVxuXG4gIGlmIChhbGxvd0xhenlRdWV1ZWluZykge1xuICAgIC8vIGxvZygnbGF6eSBxdWV1ZSBsZXZlbCcsIGx2bCk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gbGF5ZXJzO1xufTtcblxuLy8gYSBsYXllciBtYXkgd2FudCB0byB1c2UgYW4gZWxlIGNhY2hlIG9mIGEgaGlnaGVyIGxldmVsIHRvIGF2b2lkIGJsdXJyaW5lc3Ncbi8vIHNvIHRoZSBsYXllciBsZXZlbCBtaWdodCBub3QgZXF1YWwgdGhlIGVsZSBsZXZlbFxuTFRDcC5nZXRFbGVMZXZlbEZvckxheWVyTGV2ZWwgPSBmdW5jdGlvbiAobHZsLCBweFJhdGlvKSB7XG4gIHJldHVybiBsdmw7XG59O1xuXG5mdW5jdGlvbiBpbWdTbW9vdGhpbmcoY29udGV4dCwgYm9vbCkge1xuICBpZiAoY29udGV4dC5pbWFnZVNtb290aGluZ0VuYWJsZWQgIT0gbnVsbCkge1xuICAgIGNvbnRleHQuaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gYm9vbDtcbiAgfSBlbHNlIHtcbiAgICBjb250ZXh0LndlYmtpdEltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGJvb2w7XG4gICAgY29udGV4dC5tb3pJbWFnZVNtb290aGluZ0VuYWJsZWQgPSBib29sO1xuICAgIGNvbnRleHQubXNJbWFnZVNtb290aGluZ0VuYWJsZWQgPSBib29sO1xuICB9XG59XG5cbkxUQ3AuZHJhd0VsZUluTGF5ZXIgPSBmdW5jdGlvbiAobGF5ZXIsIGVsZSwgbHZsLCBweFJhdGlvKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHIgPSB0aGlzLnJlbmRlcmVyO1xuICB2YXIgY29udGV4dCA9IGxheWVyLmNvbnRleHQ7XG4gIHZhciBiYiA9IGVsZS5ib3VuZGluZ0JveCgpO1xuXG4gIGlmIChiYi53ID09PSAwIHx8IGJiLmggPT09IDAgfHwgIWVsZS52aXNpYmxlKCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZWxlQ2FjaGUgPSBzZWxmLmVsZVR4ckNhY2hlO1xuICB2YXIgcmVhc29uID0gdXNlSGlnaFF1YWxpdHlFbGVUeHJSZXFzID8gZWxlQ2FjaGUucmVhc29ucy5oaWdoUXVhbGl0eSA6IHVuZGVmaW5lZDtcblxuICBsdmwgPSBzZWxmLmdldEVsZUxldmVsRm9yTGF5ZXJMZXZlbChsdmwsIHB4UmF0aW8pO1xuXG4gIHZhciBjYWNoZSA9IHVzZUVsZVR4ckNhY2hpbmcgPyBlbGVDYWNoZS5nZXRFbGVtZW50KGVsZSwgYmIsIG51bGwsIGx2bCwgcmVhc29uKSA6IG51bGw7XG5cbiAgaWYgKGNhY2hlKSB7XG4gICAgaWYgKGRpc2FibGVFbGVJbWdTbW9vdGhpbmcpIHtcbiAgICAgIGltZ1Ntb290aGluZyhjb250ZXh0LCBmYWxzZSk7XG4gICAgfVxuXG4gICAgY29udGV4dC5kcmF3SW1hZ2UoY2FjaGUudGV4dHVyZS5jYW52YXMsIGNhY2hlLngsIDAsIGNhY2hlLndpZHRoLCBjYWNoZS5oZWlnaHQsIGJiLngxLCBiYi55MSwgYmIudywgYmIuaCk7XG5cbiAgICBpZiAoZGlzYWJsZUVsZUltZ1Ntb290aGluZykge1xuICAgICAgaW1nU21vb3RoaW5nKGNvbnRleHQsIHRydWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBpZiB0aGUgZWxlbWVudCBpcyBub3QgY2FjaGVhYmxlLCB0aGVuIGRyYXcgZGlyZWN0bHlcbiAgICByLmRyYXdFbGVtZW50KGNvbnRleHQsIGVsZSk7XG4gIH1cbn07XG5cbkxUQ3AubGV2ZWxJc0NvbXBsZXRlID0gZnVuY3Rpb24gKGx2bCwgZWxlcykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBsYXllcnMgPSBzZWxmLmxheWVyc0J5TGV2ZWxbbHZsXTtcblxuICBpZiAoIWxheWVycyB8fCBsYXllcnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIG51bUVsZXNJbkxheWVycyA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbGF5ZXIgPSBsYXllcnNbaV07XG5cbiAgICAvLyBpZiB0aGVyZSBhcmUgYW55IGVsZXMgbmVlZGVkIHRvIGJlIGRyYXduIHlldCwgdGhlIGxldmVsIGlzIG5vdCBjb21wbGV0ZVxuICAgIGlmIChsYXllci5yZXFzID4gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGlmIHRoZSBsYXllciBpcyBpbnZhbGlkLCB0aGUgbGV2ZWwgaXMgbm90IGNvbXBsZXRlXG4gICAgaWYgKGxheWVyLmludmFsaWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBudW1FbGVzSW5MYXllcnMgKz0gbGF5ZXIuZWxlcy5sZW5ndGg7XG4gIH1cblxuICAvLyB3ZSBzaG91bGQgaGF2ZSBleGFjdGx5IHRoZSBudW1iZXIgb2YgZWxlcyBwYXNzZWQgaW4gdG8gYmUgY29tcGxldGVcbiAgaWYgKG51bUVsZXNJbkxheWVycyAhPT0gZWxlcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkxUQ3AudmFsaWRhdGVMYXllcnNFbGVzT3JkZXJpbmcgPSBmdW5jdGlvbiAobHZsLCBlbGVzKSB7XG4gIHZhciBsYXllcnMgPSB0aGlzLmxheWVyc0J5TGV2ZWxbbHZsXTtcblxuICBpZiAoIWxheWVycykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGlmIGluIGEgbGF5ZXIgdGhlIGVsZXMgYXJlIG5vdCBpbiB0aGUgc2FtZSBvcmRlciwgdGhlbiB0aGUgbGF5ZXIgaXMgaW52YWxpZFxuICAvLyAoaS5lLiB0aGVyZSBpcyBhbiBlbGUgaW4gYmV0d2VlbiB0aGUgZWxlcyBpbiB0aGUgbGF5ZXIpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbGF5ZXIgPSBsYXllcnNbaV07XG4gICAgdmFyIG9mZnNldCA9IC0xO1xuXG4gICAgLy8gZmluZCB0aGUgb2Zmc2V0XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBlbGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICBpZiAobGF5ZXIuZWxlc1swXSA9PT0gZWxlc1tqXSkge1xuICAgICAgICBvZmZzZXQgPSBqO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgLy8gdGhlbiB0aGUgbGF5ZXIgaGFzIG5vbmV4aXN0YW50IGVsZW1lbnRzIGFuZCBpcyBpbnZhbGlkXG4gICAgICB0aGlzLmludmFsaWRhdGVMYXllcihsYXllcik7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyB0aGUgZWxlcyBpbiB0aGUgbGF5ZXIgbXVzdCBiZSBpbiB0aGUgc2FtZSBjb250aW51b3VzIG9yZGVyLCBlbHNlIHRoZSBsYXllciBpcyBpbnZhbGlkXG5cbiAgICB2YXIgbyA9IG9mZnNldDtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGF5ZXIuZWxlcy5sZW5ndGg7IGorKykge1xuICAgICAgaWYgKGxheWVyLmVsZXNbal0gIT09IGVsZXNbbyArIGpdKSB7XG4gICAgICAgIC8vIGxvZygnaW52YWxpZGF0ZSBiYXNlZCBvbiBvcmRlcmluZycsIGxheWVyLmlkKTtcblxuICAgICAgICB0aGlzLmludmFsaWRhdGVMYXllcihsYXllcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuTFRDcC51cGRhdGVFbGVtZW50c0luTGF5ZXJzID0gZnVuY3Rpb24gKGVsZXMsIHVwZGF0ZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBpc0VsZXMgPSBpcy5lbGVtZW50KGVsZXNbMF0pO1xuXG4gIC8vIGNvbGxlY3QgdWRwYXRlZCBlbGVtZW50cyAoY2FzY2FkZWQgZnJvbSB0aGUgbGF5ZXJzKSBhbmQgdXBkYXRlIGVhY2hcbiAgLy8gbGF5ZXIgaXRzZWxmIGFsb25nIHRoZSB3YXlcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHJlcSA9IGlzRWxlcyA/IG51bGwgOiBlbGVzW2ldO1xuICAgIHZhciBlbGUgPSBpc0VsZXMgPyBlbGVzW2ldIDogZWxlc1tpXS5lbGU7XG4gICAgdmFyIHJzID0gZWxlLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgIHZhciBjYWNoZXMgPSBycy5pbWdMYXllckNhY2hlcyA9IHJzLmltZ0xheWVyQ2FjaGVzIHx8IHt9O1xuXG4gICAgZm9yICh2YXIgbCA9IG1pbkx2bDsgbCA8PSBtYXhMdmw7IGwrKykge1xuICAgICAgdmFyIGxheWVyID0gY2FjaGVzW2xdO1xuXG4gICAgICBpZiAoIWxheWVyKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiB1cGRhdGUgaXMgYSByZXF1ZXN0IGZyb20gdGhlIGVsZSBjYWNoZSwgdGhlbiBpdCBhZmZlY3RzIG9ubHlcbiAgICAgIC8vIHRoZSBtYXRjaGluZyBsZXZlbFxuICAgICAgaWYgKHJlcSAmJiBzZWxmLmdldEVsZUxldmVsRm9yTGF5ZXJMZXZlbChsYXllci5sZXZlbCkgIT09IHJlcS5sZXZlbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlKGxheWVyLCBlbGUsIHJlcSk7XG4gICAgfVxuICB9XG59O1xuXG5MVENwLmhhdmVMYXllcnMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGhhdmVMYXllcnMgPSBmYWxzZTtcblxuICBmb3IgKHZhciBsID0gbWluTHZsOyBsIDw9IG1heEx2bDsgbCsrKSB7XG4gICAgdmFyIGxheWVycyA9IHNlbGYubGF5ZXJzQnlMZXZlbFtsXTtcblxuICAgIGlmIChsYXllcnMgJiYgbGF5ZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIGhhdmVMYXllcnMgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGhhdmVMYXllcnM7XG59O1xuXG5MVENwLmludmFsaWRhdGVFbGVtZW50cyA9IGZ1bmN0aW9uIChlbGVzKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBzZWxmLmxhc3RJbnZhbGlkYXRpb25UaW1lID0gdXRpbC5wZXJmb3JtYW5jZU5vdygpO1xuXG4gIC8vIGxvZygndXBkYXRlIGludmFsaWRhdGUgbGF5ZXIgdGltZSBmcm9tIGVsZXMnKTtcblxuICBpZiAoZWxlcy5sZW5ndGggPT09IDAgfHwgIXNlbGYuaGF2ZUxheWVycygpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc2VsZi51cGRhdGVFbGVtZW50c0luTGF5ZXJzKGVsZXMsIGZ1bmN0aW9uIGludmFsQXNzb2NMYXllcnMobGF5ZXIsIGVsZSwgcmVxKSB7XG4gICAgc2VsZi5pbnZhbGlkYXRlTGF5ZXIobGF5ZXIpO1xuICB9KTtcbn07XG5cbkxUQ3AuaW52YWxpZGF0ZUxheWVyID0gZnVuY3Rpb24gKGxheWVyKSB7XG4gIC8vIGxvZygndXBkYXRlIGludmFsaWRhdGUgbGF5ZXIgdGltZScpO1xuXG4gIHRoaXMubGFzdEludmFsaWRhdGlvblRpbWUgPSB1dGlsLnBlcmZvcm1hbmNlTm93KCk7XG5cbiAgaWYgKGxheWVyLmludmFsaWQpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gc2F2ZSBjeWNsZXNcblxuICB2YXIgbHZsID0gbGF5ZXIubGV2ZWw7XG4gIHZhciBlbGVzID0gbGF5ZXIuZWxlcztcbiAgdmFyIGxheWVycyA9IHRoaXMubGF5ZXJzQnlMZXZlbFtsdmxdO1xuXG4gIC8vIGxvZygnaW52YWxpZGF0ZSBsYXllcicsIGxheWVyLmlkICk7XG5cbiAgdXRpbC5yZW1vdmVGcm9tQXJyYXkobGF5ZXJzLCBsYXllcik7XG4gIC8vIGxheWVyLmVsZXMgPSBbXTtcblxuICBsYXllci5lbGVzUXVldWUgPSBbXTtcblxuICBsYXllci5pbnZhbGlkID0gdHJ1ZTtcblxuICBpZiAobGF5ZXIucmVwbGFjZW1lbnQpIHtcbiAgICBsYXllci5yZXBsYWNlbWVudC5pbnZhbGlkID0gdHJ1ZTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjYWNoZXMgPSBlbGVzW2ldLl9wcml2YXRlLnJzY3JhdGNoLmltZ0xheWVyQ2FjaGVzO1xuXG4gICAgaWYgKGNhY2hlcykge1xuICAgICAgY2FjaGVzW2x2bF0gPSBudWxsO1xuICAgIH1cbiAgfVxufTtcblxuTFRDcC5yZWZpbmVFbGVtZW50VGV4dHVyZXMgPSBmdW5jdGlvbiAoZWxlcykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgLy8gbG9nKCdyZWZpbmUnLCBlbGVzLmxlbmd0aCk7XG5cbiAgc2VsZi51cGRhdGVFbGVtZW50c0luTGF5ZXJzKGVsZXMsIGZ1bmN0aW9uIHJlZmluZUVhY2hFbGUobGF5ZXIsIGVsZSwgcmVxKSB7XG4gICAgdmFyIHJMeXIgPSBsYXllci5yZXBsYWNlbWVudDtcblxuICAgIGlmICghckx5cikge1xuICAgICAgckx5ciA9IGxheWVyLnJlcGxhY2VtZW50ID0gc2VsZi5tYWtlTGF5ZXIobGF5ZXIuYmIsIGxheWVyLmxldmVsKTtcbiAgICAgIHJMeXIucmVwbGFjZXMgPSBsYXllcjtcbiAgICAgIHJMeXIuZWxlcyA9IGxheWVyLmVsZXM7XG5cbiAgICAgIC8vIGxvZygnbWFrZSByZXBsYWNlbWVudCBsYXllciAlcyBmb3IgJXMgd2l0aCBsZXZlbCAlcycsIHJMeXIuaWQsIGxheWVyLmlkLCByTHlyLmxldmVsKTtcbiAgICB9XG5cbiAgICBpZiAoIXJMeXIucmVxcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByTHlyLmVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2VsZi5xdWV1ZUxheWVyKHJMeXIsIHJMeXIuZWxlc1tpXSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGxvZygncXVldWUgcmVwbGFjZW1lbnQgbGF5ZXIgcmVmaW5lbWVudCcsIHJMeXIuaWQpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5MVENwLnNldHVwRWxlQ2FjaGVJbnZhbGlkYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGVsZURlcXMgPSBbXTtcblxuICBpZiAoIXVzZUVsZVR4ckNhY2hpbmcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdXBkYXRlZEVsZXNJbkxheWVycyA9IHV0aWwuZGVib3VuY2UoZnVuY3Rpb24gKCkge1xuICAgIHNlbGYucmVmaW5lRWxlbWVudFRleHR1cmVzKGVsZURlcXMpO1xuXG4gICAgZWxlRGVxcyA9IFtdO1xuICB9LCByZWZpbmVFbGVEZWJvdW5jZVRpbWUpO1xuXG4gIHNlbGYuZWxlVHhyQ2FjaGUub25EZXF1ZXVlKGZ1bmN0aW9uIChyZXFzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXFzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBlbGVEZXFzLnB1c2gocmVxc1tpXSk7XG4gICAgfVxuXG4gICAgdXBkYXRlZEVsZXNJbkxheWVycygpO1xuICB9KTtcbn07XG5cbkxUQ3AucXVldWVMYXllciA9IGZ1bmN0aW9uIChsYXllciwgZWxlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHEgPSBzZWxmLmxheWVyc1F1ZXVlO1xuICB2YXIgZWxlc1EgPSBsYXllci5lbGVzUXVldWU7XG4gIHZhciBoYXNJZCA9IGVsZXNRLmhhc0lkID0gZWxlc1EuaGFzSWQgfHwge307XG5cbiAgLy8gaWYgYSBsYXllciBpcyBnb2luZyB0byBiZSByZXBsYWNlZCwgcXVldWluZyBpcyBhIHdhc3RlIG9mIHRpbWVcbiAgaWYgKGxheWVyLnJlcGxhY2VtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGVsZSkge1xuICAgIGlmIChoYXNJZFtlbGUuaWQoKV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlbGVzUS5wdXNoKGVsZSk7XG4gICAgaGFzSWRbZWxlLmlkKCldID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChsYXllci5yZXFzKSB7XG4gICAgbGF5ZXIucmVxcysrO1xuXG4gICAgcS51cGRhdGVJdGVtKGxheWVyKTtcbiAgfSBlbHNlIHtcbiAgICBsYXllci5yZXFzID0gMTtcblxuICAgIHEucHVzaChsYXllcik7XG4gIH1cbn07XG5cbkxUQ3AuZGVxdWV1ZSA9IGZ1bmN0aW9uIChweFJhdGlvKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHEgPSBzZWxmLmxheWVyc1F1ZXVlO1xuICB2YXIgZGVxZCA9IFtdO1xuICB2YXIgZWxlRGVxcyA9IDA7XG5cbiAgd2hpbGUgKGVsZURlcXMgPCBtYXhEZXFTaXplKSB7XG4gICAgaWYgKHEuc2l6ZSgpID09PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgbGF5ZXIgPSBxLnBlZWsoKTtcblxuICAgIC8vIGlmIGEgbGF5ZXIgaGFzIGJlZW4gb3Igd2lsbCBiZSByZXBsYWNlZCwgdGhlbiBkb24ndCB3YXN0ZSB0aW1lIHdpdGggaXRcbiAgICBpZiAobGF5ZXIucmVwbGFjZW1lbnQpIHtcbiAgICAgIC8vIGxvZygnbGF5ZXIgJXMgaW4gcXVldWUgc2tpcHBlZCBiL2MgaXQgYWxyZWFkeSBoYXMgYSByZXBsYWNlbWVudCcsIGxheWVyLmlkKTtcbiAgICAgIHEucG9wKCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBpZiB0aGlzIGlzIGEgcmVwbGFjZW1lbnQgbGF5ZXIgdGhhdCBoYXMgYmVlbiBzdXBlcmNlZGVkLCB0aGVuIGZvcmdldCBpdFxuICAgIGlmIChsYXllci5yZXBsYWNlcyAmJiBsYXllciAhPT0gbGF5ZXIucmVwbGFjZXMucmVwbGFjZW1lbnQpIHtcbiAgICAgIC8vIGxvZygnbGF5ZXIgaXMgbm8gbG9uZ2VyIHRoZSBtb3N0IHVwdG9kYXRlIHJlcGxhY2VtZW50OyBkZXF1ZXVlZCcsIGxheWVyLmlkKVxuICAgICAgcS5wb3AoKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChsYXllci5pbnZhbGlkKSB7XG4gICAgICAvLyBsb2coJ3JlcGxhY2VtZW50IGxheWVyICVzIGlzIGludmFsaWQ7IGRlcXVldWVkJywgbGF5ZXIuaWQpO1xuICAgICAgcS5wb3AoKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBlbGUgPSBsYXllci5lbGVzUXVldWUuc2hpZnQoKTtcblxuICAgIGlmIChlbGUpIHtcbiAgICAgIC8vIGxvZygnZGVxdWV1ZSBsYXllciAlcycsIGxheWVyLmlkKTtcblxuICAgICAgc2VsZi5kcmF3RWxlSW5MYXllcihsYXllciwgZWxlLCBsYXllci5sZXZlbCwgcHhSYXRpbyk7XG5cbiAgICAgIGVsZURlcXMrKztcbiAgICB9XG5cbiAgICBpZiAoZGVxZC5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIHdlIG5lZWQgb25seSBvbmUgZW50cnkgaW4gZGVxZCB0byBxdWV1ZSByZWRyYXdpbmcgZXRjXG4gICAgICBkZXFkLnB1c2godHJ1ZSk7XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlIGxheWVyIGhhcyBhbGwgaXRzIGVsZXMgZG9uZSwgdGhlbiByZW1vdmUgZnJvbSB0aGUgcXVldWVcbiAgICBpZiAobGF5ZXIuZWxlc1F1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcS5wb3AoKTtcblxuICAgICAgbGF5ZXIucmVxcyA9IDA7XG5cbiAgICAgIC8vIGxvZygnZGVxdWV1ZSBvZiBsYXllciAlcyBjb21wbGV0ZScsIGxheWVyLmlkKTtcblxuICAgICAgLy8gd2hlbiBhIHJlcGxhY2VtZW50IGxheWVyIGlzIGRlcXVldWVkLCBpdCByZXBsYWNlcyB0aGUgb2xkIGxheWVyIGluIHRoZSBsZXZlbFxuICAgICAgaWYgKGxheWVyLnJlcGxhY2VzKSB7XG4gICAgICAgIHNlbGYuYXBwbHlMYXllclJlcGxhY2VtZW50KGxheWVyKTtcbiAgICAgIH1cblxuICAgICAgc2VsZi5yZXF1ZXN0UmVkcmF3KCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRlcWQ7XG59O1xuXG5MVENwLmFwcGx5TGF5ZXJSZXBsYWNlbWVudCA9IGZ1bmN0aW9uIChsYXllcikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBsYXllcnNJbkxldmVsID0gc2VsZi5sYXllcnNCeUxldmVsW2xheWVyLmxldmVsXTtcbiAgdmFyIHJlcGxhY2VkID0gbGF5ZXIucmVwbGFjZXM7XG4gIHZhciBpbmRleCA9IGxheWVyc0luTGV2ZWwuaW5kZXhPZihyZXBsYWNlZCk7XG5cbiAgLy8gaWYgdGhlIHJlcGxhY2VkIGxheWVyIGlzIG5vdCBpbiB0aGUgYWN0aXZlIGxpc3QgZm9yIHRoZSBsZXZlbCwgdGhlbiByZXBsYWNpbmdcbiAgLy8gcmVmcyB3b3VsZCBiZSBhIG1pc3Rha2UgKGkuZS4gb3ZlcndyaXRpbmcgdGhlIHRydWUgYWN0aXZlIGxheWVyKVxuICBpZiAoaW5kZXggPCAwIHx8IHJlcGxhY2VkLmludmFsaWQpIHtcbiAgICAvLyBsb2coJ3JlcGxhY2VtZW50IGxheWVyIHdvdWxkIGhhdmUgbm8gZWZmZWN0JywgbGF5ZXIuaWQpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxheWVyc0luTGV2ZWxbaW5kZXhdID0gbGF5ZXI7IC8vIHJlcGxhY2UgbGV2ZWwgcmVmXG5cbiAgLy8gcmVwbGFjZSByZWZzIGluIGVsZXNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXllci5lbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIF9wID0gbGF5ZXIuZWxlc1tpXS5fcHJpdmF0ZTtcbiAgICB2YXIgY2FjaGUgPSBfcC5pbWdMYXllckNhY2hlcyA9IF9wLmltZ0xheWVyQ2FjaGVzIHx8IHt9O1xuXG4gICAgaWYgKGNhY2hlKSB7XG4gICAgICBjYWNoZVtsYXllci5sZXZlbF0gPSBsYXllcjtcbiAgICB9XG4gIH1cblxuICAvLyBsb2coJ2FwcGx5IHJlcGxhY2VtZW50IGxheWVyICVzIG92ZXIgJXMnLCBsYXllci5pZCwgcmVwbGFjZWQuaWQpO1xuXG4gIHNlbGYucmVxdWVzdFJlZHJhdygpO1xufTtcblxuTFRDcC5yZXF1ZXN0UmVkcmF3ID0gdXRpbC5kZWJvdW5jZShmdW5jdGlvbiAoKSB7XG4gIHZhciByID0gdGhpcy5yZW5kZXJlcjtcblxuICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgci5yZWRyYXdIaW50KCdkcmFnJywgdHJ1ZSk7XG4gIHIucmVkcmF3KCk7XG59LCAxMDApO1xuXG5MVENwLnNldHVwRGVxdWV1ZWluZyA9IGRlZnMuc2V0dXBEZXF1ZXVlaW5nKHtcbiAgZGVxUmVkcmF3VGhyZXNob2xkOiBkZXFSZWRyYXdUaHJlc2hvbGQsXG4gIGRlcUNvc3Q6IGRlcUNvc3QsXG4gIGRlcUF2Z0Nvc3Q6IGRlcUF2Z0Nvc3QsXG4gIGRlcU5vRHJhd0Nvc3Q6IGRlcU5vRHJhd0Nvc3QsXG4gIGRlcUZhc3RDb3N0OiBkZXFGYXN0Q29zdCxcbiAgZGVxOiBmdW5jdGlvbiBkZXEoc2VsZiwgcHhSYXRpbykge1xuICAgIHJldHVybiBzZWxmLmRlcXVldWUocHhSYXRpbyk7XG4gIH0sXG4gIG9uRGVxZDogdXRpbC5ub29wLFxuICBzaG91bGRSZWRyYXc6IHV0aWwudHJ1ZWlmeSxcbiAgcHJpb3JpdHk6IGZ1bmN0aW9uIHByaW9yaXR5KHNlbGYpIHtcbiAgICByZXR1cm4gc2VsZi5yZW5kZXJlci5iZWZvcmVSZW5kZXJQcmlvcml0aWVzLmx5clR4ckRlcTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTGF5ZXJlZFRleHR1cmVDYWNoZTtcblxuLyoqKi8gfSksXG4vKiAxMjYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIENScCA9IHt9O1xuXG52YXIgaW1wbDtcblxuQ1JwLmFycm93U2hhcGVJbXBsID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIChpbXBsIHx8IChpbXBsID0ge1xuICAgICdwb2x5Z29uJzogZnVuY3Rpb24gcG9seWdvbihjb250ZXh0LCBwb2ludHMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwdCA9IHBvaW50c1tpXTtcblxuICAgICAgICBjb250ZXh0LmxpbmVUbyhwdC54LCBwdC55KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgJ3RyaWFuZ2xlLWJhY2tjdXJ2ZSc6IGZ1bmN0aW9uIHRyaWFuZ2xlQmFja2N1cnZlKGNvbnRleHQsIHBvaW50cywgY29udHJvbFBvaW50KSB7XG4gICAgICB2YXIgZmlyc3RQdDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHB0ID0gcG9pbnRzW2ldO1xuXG4gICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgZmlyc3RQdCA9IHB0O1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5saW5lVG8ocHQueCwgcHQueSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyhjb250cm9sUG9pbnQueCwgY29udHJvbFBvaW50LnksIGZpcnN0UHQueCwgZmlyc3RQdC55KTtcbiAgICB9LFxuXG4gICAgJ3RyaWFuZ2xlLXRlZSc6IGZ1bmN0aW9uIHRyaWFuZ2xlVGVlKGNvbnRleHQsIHRyaWFuZ2xlUG9pbnRzLCB0ZWVQb2ludHMpIHtcbiAgICAgIGlmIChjb250ZXh0LmJlZ2luUGF0aCkge1xuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHJpUHRzID0gdHJpYW5nbGVQb2ludHM7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyaVB0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcHQgPSB0cmlQdHNbaV07XG5cbiAgICAgICAgY29udGV4dC5saW5lVG8ocHQueCwgcHQueSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb250ZXh0LmNsb3NlUGF0aCkge1xuICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29udGV4dC5iZWdpblBhdGgpIHtcbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRlZVB0cyA9IHRlZVBvaW50cztcbiAgICAgIHZhciBmaXJzdFRlZVB0ID0gdGVlUG9pbnRzWzBdO1xuICAgICAgY29udGV4dC5tb3ZlVG8oZmlyc3RUZWVQdC54LCBmaXJzdFRlZVB0LnkpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRlZVB0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcHQgPSB0ZWVQdHNbaV07XG5cbiAgICAgICAgY29udGV4dC5saW5lVG8ocHQueCwgcHQueSk7XG4gICAgICB9XG4gICAgICBpZiAoY29udGV4dC5jbG9zZVBhdGgpIHtcbiAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgJ3RyaWFuZ2xlLWNyb3NzJzogZnVuY3Rpb24gdHJpYW5nbGVDcm9zcyhjb250ZXh0LCB0cmlhbmdsZVBvaW50cywgY3Jvc3NMaW5lUG9pbnRzKSB7XG4gICAgICBpZiAoY29udGV4dC5iZWdpblBhdGgpIHtcbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRyaVB0cyA9IHRyaWFuZ2xlUG9pbnRzO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmlQdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHB0ID0gdHJpUHRzW2ldO1xuXG4gICAgICAgIGNvbnRleHQubGluZVRvKHB0LngsIHB0LnkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29udGV4dC5jbG9zZVBhdGgpIHtcbiAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbnRleHQuYmVnaW5QYXRoKSB7XG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0ZWVQdHMgPSBjcm9zc0xpbmVQb2ludHM7XG4gICAgICB2YXIgZmlyc3RUZWVQdCA9IGNyb3NzTGluZVBvaW50c1swXTtcbiAgICAgIGNvbnRleHQubW92ZVRvKGZpcnN0VGVlUHQueCwgZmlyc3RUZWVQdC55KTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZWVQdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHB0ID0gdGVlUHRzW2ldO1xuXG4gICAgICAgIGNvbnRleHQubGluZVRvKHB0LngsIHB0LnkpO1xuICAgICAgfVxuICAgICAgaWYgKGNvbnRleHQuY2xvc2VQYXRoKSB7XG4gICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgICdjaXJjbGUnOiBmdW5jdGlvbiBjaXJjbGUoY29udGV4dCwgcngsIHJ5LCByKSB7XG4gICAgICBjb250ZXh0LmFyYyhyeCwgcnksIHIsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSk7XG4gICAgfVxuICB9KSlbbmFtZV07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENScDtcblxuLyoqKi8gfSksXG4vKiAxMjcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIG1hdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgQ1JwID0ge307XG5cbkNScC5kcmF3RWxlbWVudCA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGUsIHNoaWZ0VG9PcmlnaW5XaXRoQmIsIHNob3dMYWJlbCkge1xuICB2YXIgciA9IHRoaXM7XG5cbiAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgIHIuZHJhd05vZGUoY29udGV4dCwgZWxlLCBzaGlmdFRvT3JpZ2luV2l0aEJiLCBzaG93TGFiZWwpO1xuICB9IGVsc2Uge1xuICAgIHIuZHJhd0VkZ2UoY29udGV4dCwgZWxlLCBzaGlmdFRvT3JpZ2luV2l0aEJiLCBzaG93TGFiZWwpO1xuICB9XG59O1xuXG5DUnAuZHJhd0NhY2hlZEVsZW1lbnQgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlLCBweFJhdGlvLCBleHRlbnQpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgYmIgPSBlbGUuYm91bmRpbmdCb3goKTtcblxuICBpZiAoYmIudyA9PT0gMCB8fCBiYi5oID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCFleHRlbnQgfHwgbWF0aC5ib3VuZGluZ0JveGVzSW50ZXJzZWN0KGJiLCBleHRlbnQpKSB7XG4gICAgdmFyIGNhY2hlID0gci5kYXRhLmVsZVR4ckNhY2hlLmdldEVsZW1lbnQoZWxlLCBiYiwgcHhSYXRpbyk7XG5cbiAgICBpZiAoY2FjaGUgIT0gbnVsbCkge1xuICAgICAgY29udGV4dC5kcmF3SW1hZ2UoY2FjaGUudGV4dHVyZS5jYW52YXMsIGNhY2hlLngsIDAsIGNhY2hlLndpZHRoLCBjYWNoZS5oZWlnaHQsIGJiLngxLCBiYi55MSwgYmIudywgYmIuaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIHRoZSBlbGVtZW50IGlzIG5vdCBjYWNoZWFibGUsIHRoZW4gZHJhdyBkaXJlY3RseVxuICAgICAgci5kcmF3RWxlbWVudChjb250ZXh0LCBlbGUpO1xuICAgIH1cbiAgfVxufTtcblxuQ1JwLmRyYXdFbGVtZW50cyA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGVzKSB7XG4gIHZhciByID0gdGhpcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlID0gZWxlc1tpXTtcblxuICAgIHIuZHJhd0VsZW1lbnQoY29udGV4dCwgZWxlKTtcbiAgfVxufTtcblxuQ1JwLmRyYXdDYWNoZWRFbGVtZW50cyA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGVzLCBweFJhdGlvLCBleHRlbnQpIHtcbiAgdmFyIHIgPSB0aGlzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuXG4gICAgci5kcmF3Q2FjaGVkRWxlbWVudChjb250ZXh0LCBlbGUsIHB4UmF0aW8sIGV4dGVudCk7XG4gIH1cbn07XG5cbkNScC5kcmF3Q2FjaGVkTm9kZXMgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlcywgcHhSYXRpbywgZXh0ZW50KSB7XG4gIHZhciByID0gdGhpcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlID0gZWxlc1tpXTtcblxuICAgIGlmICghZWxlLmlzTm9kZSgpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByLmRyYXdDYWNoZWRFbGVtZW50KGNvbnRleHQsIGVsZSwgcHhSYXRpbywgZXh0ZW50KTtcbiAgfVxufTtcblxuQ1JwLmRyYXdMYXllcmVkRWxlbWVudHMgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlcywgcHhSYXRpbywgZXh0ZW50KSB7XG4gIHZhciByID0gdGhpcztcblxuICB2YXIgbGF5ZXJzID0gci5kYXRhLmx5clR4ckNhY2hlLmdldExheWVycyhlbGVzLCBweFJhdGlvKTtcblxuICBpZiAobGF5ZXJzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBsYXllciA9IGxheWVyc1tpXTtcbiAgICAgIHZhciBiYiA9IGxheWVyLmJiO1xuXG4gICAgICBpZiAoYmIudyA9PT0gMCB8fCBiYi5oID09PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0LmRyYXdJbWFnZShsYXllci5jYW52YXMsIGJiLngxLCBiYi55MSwgYmIudywgYmIuaCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGZhbGwgYmFjayBvbiBwbGFpbiBjYWNoaW5nIGlmIG5vIGxheWVyc1xuICAgIHIuZHJhd0NhY2hlZEVsZW1lbnRzKGNvbnRleHQsIGVsZXMsIHB4UmF0aW8sIGV4dGVudCk7XG4gIH1cbn07XG5cbkNScC5kcmF3RGVidWdQb2ludHMgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlcykge1xuICB2YXIgZHJhdyA9IGZ1bmN0aW9uIGRyYXcoeCwgeSwgY29sb3IpIHtcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgIGNvbnRleHQuZmlsbFJlY3QoeCAtIDEsIHkgLSAxLCAzLCAzKTtcbiAgfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICB2YXIgcnMgPSBlbGUuX3ByaXZhdGUucnNjcmF0Y2g7XG5cbiAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICB2YXIgcCA9IGVsZS5wb3NpdGlvbigpO1xuXG4gICAgICBkcmF3KHAueCwgcC55LCAnbWFnZW50YScpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcHRzID0gcnMuYWxscHRzO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiArIDEgPCBwdHMubGVuZ3RoOyBqICs9IDIpIHtcbiAgICAgICAgdmFyIHggPSBwdHNbal07XG4gICAgICAgIHZhciB5ID0gcHRzW2ogKyAxXTtcblxuICAgICAgICBkcmF3KHgsIHksICdjeWFuJyk7XG4gICAgICB9XG5cbiAgICAgIGRyYXcocnMubWlkWCwgcnMubWlkWSwgJ3llbGxvdycpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDUnA7XG5cbi8qKiovIH0pLFxuLyogMTI4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBDUnAgPSB7fTtcblxuQ1JwLmRyYXdFZGdlID0gZnVuY3Rpb24gKGNvbnRleHQsIGVkZ2UsIHNoaWZ0VG9PcmlnaW5XaXRoQmIsIGRyYXdMYWJlbCkge1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHZhciB1c2VQYXRocyA9IHIudXNlUGF0aHMoKTtcblxuICBpZiAoIWVkZ2UudmlzaWJsZSgpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gaWYgYmV6aWVyIGN0cmwgcHRzIGNhbiBub3QgYmUgY2FsY3VsYXRlZCwgdGhlbiBkaWVcbiAgaWYgKHJzLmJhZExpbmUgfHwgcnMuYWxscHRzID09IG51bGwgfHwgaXNOYU4ocnMuYWxscHRzWzBdKSkge1xuICAgIC8vIGlzTmFOIGluIGNhc2UgZWRnZSBpcyBpbXBvc3NpYmxlIGFuZCBicm93c2VyIGJ1Z3MgKGUuZy4gc2FmYXJpKVxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBiYiA9IHZvaWQgMDtcbiAgaWYgKHNoaWZ0VG9PcmlnaW5XaXRoQmIpIHtcbiAgICBiYiA9IHNoaWZ0VG9PcmlnaW5XaXRoQmI7XG5cbiAgICBjb250ZXh0LnRyYW5zbGF0ZSgtYmIueDEsIC1iYi55MSk7XG4gIH1cblxuICB2YXIgb3ZlcmxheVBhZGRpbmcgPSBlZGdlLnBzdHlsZSgnb3ZlcmxheS1wYWRkaW5nJykucGZWYWx1ZTtcbiAgdmFyIG92ZXJsYXlXaWR0aCA9IDIgKiBvdmVybGF5UGFkZGluZztcbiAgdmFyIG92ZXJsYXlPcGFjaXR5ID0gZWRnZS5wc3R5bGUoJ292ZXJsYXktb3BhY2l0eScpLnZhbHVlO1xuICB2YXIgb3ZlcmxheUNvbG9yID0gZWRnZS5wc3R5bGUoJ292ZXJsYXktY29sb3InKS52YWx1ZTtcbiAgdmFyIGxpbmVDb2xvciA9IGVkZ2UucHN0eWxlKCdsaW5lLWNvbG9yJykudmFsdWU7XG4gIHZhciBvcGFjaXR5ID0gZWRnZS5wc3R5bGUoJ29wYWNpdHknKS52YWx1ZTtcbiAgdmFyIGxpbmVTdHlsZSA9IGVkZ2UucHN0eWxlKCdsaW5lLXN0eWxlJykudmFsdWU7XG4gIHZhciBlZGdlV2lkdGggPSBlZGdlLnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlO1xuXG4gIHZhciBkcmF3TGluZSA9IGZ1bmN0aW9uIGRyYXdMaW5lKCkge1xuICAgIHZhciBzdHJva2VPcGFjaXR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBvcGFjaXR5O1xuXG4gICAgY29udGV4dC5saW5lV2lkdGggPSBlZGdlV2lkdGg7XG4gICAgY29udGV4dC5saW5lQ2FwID0gJ2J1dHQnO1xuXG4gICAgci5zdHJva2VTdHlsZShjb250ZXh0LCBsaW5lQ29sb3JbMF0sIGxpbmVDb2xvclsxXSwgbGluZUNvbG9yWzJdLCBzdHJva2VPcGFjaXR5KTtcblxuICAgIHIuZHJhd0VkZ2VQYXRoKGVkZ2UsIGNvbnRleHQsIHJzLmFsbHB0cywgbGluZVN0eWxlKTtcbiAgfTtcblxuICB2YXIgZHJhd092ZXJsYXkgPSBmdW5jdGlvbiBkcmF3T3ZlcmxheSgpIHtcbiAgICB2YXIgc3Ryb2tlT3BhY2l0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogb3ZlcmxheU9wYWNpdHk7XG5cbiAgICBjb250ZXh0LmxpbmVXaWR0aCA9IG92ZXJsYXlXaWR0aDtcblxuICAgIGlmIChycy5lZGdlVHlwZSA9PT0gJ3NlbGYnICYmICF1c2VQYXRocykge1xuICAgICAgY29udGV4dC5saW5lQ2FwID0gJ2J1dHQnO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LmxpbmVDYXAgPSAncm91bmQnO1xuICAgIH1cblxuICAgIHIuc3Ryb2tlU3R5bGUoY29udGV4dCwgb3ZlcmxheUNvbG9yWzBdLCBvdmVybGF5Q29sb3JbMV0sIG92ZXJsYXlDb2xvclsyXSwgc3Ryb2tlT3BhY2l0eSk7XG5cbiAgICByLmRyYXdFZGdlUGF0aChlZGdlLCBjb250ZXh0LCBycy5hbGxwdHMsICdzb2xpZCcpO1xuICB9O1xuXG4gIHZhciBkcmF3QXJyb3dzID0gZnVuY3Rpb24gZHJhd0Fycm93cygpIHtcbiAgICB2YXIgYXJyb3dPcGFjaXR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBvcGFjaXR5O1xuXG4gICAgci5kcmF3QXJyb3doZWFkcyhjb250ZXh0LCBlZGdlLCBhcnJvd09wYWNpdHkpO1xuICB9O1xuXG4gIHZhciBkcmF3VGV4dCA9IGZ1bmN0aW9uIGRyYXdUZXh0KCkge1xuICAgIHIuZHJhd0VsZW1lbnRUZXh0KGNvbnRleHQsIGVkZ2UsIGRyYXdMYWJlbCk7XG4gIH07XG5cbiAgY29udGV4dC5saW5lSm9pbiA9ICdyb3VuZCc7XG5cbiAgdmFyIGdob3N0ID0gZWRnZS5wc3R5bGUoJ2dob3N0JykudmFsdWUgPT09ICd5ZXMnO1xuXG4gIGlmIChnaG9zdCkge1xuICAgIHZhciBneCA9IGVkZ2UucHN0eWxlKCdnaG9zdC1vZmZzZXQteCcpLnBmVmFsdWU7XG4gICAgdmFyIGd5ID0gZWRnZS5wc3R5bGUoJ2dob3N0LW9mZnNldC15JykucGZWYWx1ZTtcbiAgICB2YXIgZ2hvc3RPcGFjaXR5ID0gZWRnZS5wc3R5bGUoJ2dob3N0LW9wYWNpdHknKS52YWx1ZTtcbiAgICB2YXIgZWZmZWN0aXZlR2hvc3RPcGFjaXR5ID0gb3BhY2l0eSAqIGdob3N0T3BhY2l0eTtcblxuICAgIGNvbnRleHQudHJhbnNsYXRlKGd4LCBneSk7XG5cbiAgICBkcmF3TGluZShlZmZlY3RpdmVHaG9zdE9wYWNpdHkpO1xuICAgIGRyYXdBcnJvd3MoZWZmZWN0aXZlR2hvc3RPcGFjaXR5KTtcblxuICAgIGNvbnRleHQudHJhbnNsYXRlKC1neCwgLWd5KTtcbiAgfVxuXG4gIGRyYXdMaW5lKCk7XG4gIGRyYXdBcnJvd3MoKTtcbiAgZHJhd092ZXJsYXkoKTtcbiAgZHJhd1RleHQoKTtcblxuICBpZiAoc2hpZnRUb09yaWdpbldpdGhCYikge1xuICAgIGNvbnRleHQudHJhbnNsYXRlKGJiLngxLCBiYi55MSk7XG4gIH1cbn07XG5cbkNScC5kcmF3RWRnZVBhdGggPSBmdW5jdGlvbiAoZWRnZSwgY29udGV4dCwgcHRzLCB0eXBlKSB7XG4gIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHZhciBjYW52YXNDeHQgPSBjb250ZXh0O1xuICB2YXIgcGF0aCA9IHZvaWQgMDtcbiAgdmFyIHBhdGhDYWNoZUhpdCA9IGZhbHNlO1xuICB2YXIgdXNlUGF0aHMgPSB0aGlzLnVzZVBhdGhzKCk7XG5cbiAgaWYgKHVzZVBhdGhzKSB7XG4gICAgdmFyIHBhdGhDYWNoZUtleSA9IHB0cy5qb2luKCckJyk7XG4gICAgdmFyIGtleU1hdGNoZXMgPSBycy5wYXRoQ2FjaGVLZXkgJiYgcnMucGF0aENhY2hlS2V5ID09PSBwYXRoQ2FjaGVLZXk7XG5cbiAgICBpZiAoa2V5TWF0Y2hlcykge1xuICAgICAgcGF0aCA9IGNvbnRleHQgPSBycy5wYXRoQ2FjaGU7XG4gICAgICBwYXRoQ2FjaGVIaXQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRoID0gY29udGV4dCA9IG5ldyBQYXRoMkQoKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgICAgcnMucGF0aENhY2hlS2V5ID0gcGF0aENhY2hlS2V5O1xuICAgICAgcnMucGF0aENhY2hlID0gcGF0aDtcbiAgICB9XG4gIH1cblxuICBpZiAoY2FudmFzQ3h0LnNldExpbmVEYXNoKSB7XG4gICAgLy8gZm9yIHZlcnkgb3V0b2ZkYXRlIGJyb3dzZXJzXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdkb3R0ZWQnOlxuICAgICAgICBjYW52YXNDeHQuc2V0TGluZURhc2goWzEsIDFdKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2Rhc2hlZCc6XG4gICAgICAgIGNhbnZhc0N4dC5zZXRMaW5lRGFzaChbNiwgM10pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnc29saWQnOlxuICAgICAgICBjYW52YXNDeHQuc2V0TGluZURhc2goW10pO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoIXBhdGhDYWNoZUhpdCAmJiAhcnMuYmFkTGluZSkge1xuICAgIGlmIChjb250ZXh0LmJlZ2luUGF0aCkge1xuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICB9XG4gICAgY29udGV4dC5tb3ZlVG8ocHRzWzBdLCBwdHNbMV0pO1xuXG4gICAgc3dpdGNoIChycy5lZGdlVHlwZSkge1xuICAgICAgY2FzZSAnYmV6aWVyJzpcbiAgICAgIGNhc2UgJ3NlbGYnOlxuICAgICAgY2FzZSAnY29tcG91bmQnOlxuICAgICAgY2FzZSAnbXVsdGliZXppZXInOlxuICAgICAgICBmb3IgKHZhciBpID0gMjsgaSArIDMgPCBwdHMubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8ocHRzW2ldLCBwdHNbaSArIDFdLCBwdHNbaSArIDJdLCBwdHNbaSArIDNdKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnc3RyYWlnaHQnOlxuICAgICAgY2FzZSAnc2VnbWVudHMnOlxuICAgICAgY2FzZSAnaGF5c3RhY2snOlxuICAgICAgICBmb3IgKHZhciBfaSA9IDI7IF9pICsgMSA8IHB0cy5sZW5ndGg7IF9pICs9IDIpIHtcbiAgICAgICAgICBjb250ZXh0LmxpbmVUbyhwdHNbX2ldLCBwdHNbX2kgKyAxXSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgY29udGV4dCA9IGNhbnZhc0N4dDtcbiAgaWYgKHVzZVBhdGhzKSB7XG4gICAgY29udGV4dC5zdHJva2UocGF0aCk7XG4gIH0gZWxzZSB7XG4gICAgY29udGV4dC5zdHJva2UoKTtcbiAgfVxuXG4gIC8vIHJlc2V0IGFueSBsaW5lIGRhc2hlc1xuICBpZiAoY29udGV4dC5zZXRMaW5lRGFzaCkge1xuICAgIC8vIGZvciB2ZXJ5IG91dG9mZGF0ZSBicm93c2Vyc1xuICAgIGNvbnRleHQuc2V0TGluZURhc2goW10pO1xuICB9XG59O1xuXG5DUnAuZHJhd0Fycm93aGVhZHMgPSBmdW5jdGlvbiAoY29udGV4dCwgZWRnZSwgb3BhY2l0eSkge1xuICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICB2YXIgaXNIYXlzdGFjayA9IHJzLmVkZ2VUeXBlID09PSAnaGF5c3RhY2snO1xuXG4gIGlmICghaXNIYXlzdGFjaykge1xuICAgIHRoaXMuZHJhd0Fycm93aGVhZChjb250ZXh0LCBlZGdlLCAnc291cmNlJywgcnMuYXJyb3dTdGFydFgsIHJzLmFycm93U3RhcnRZLCBycy5zcmNBcnJvd0FuZ2xlLCBvcGFjaXR5KTtcbiAgfVxuXG4gIHRoaXMuZHJhd0Fycm93aGVhZChjb250ZXh0LCBlZGdlLCAnbWlkLXRhcmdldCcsIHJzLm1pZFgsIHJzLm1pZFksIHJzLm1pZHRndEFycm93QW5nbGUsIG9wYWNpdHkpO1xuXG4gIHRoaXMuZHJhd0Fycm93aGVhZChjb250ZXh0LCBlZGdlLCAnbWlkLXNvdXJjZScsIHJzLm1pZFgsIHJzLm1pZFksIHJzLm1pZHNyY0Fycm93QW5nbGUsIG9wYWNpdHkpO1xuXG4gIGlmICghaXNIYXlzdGFjaykge1xuICAgIHRoaXMuZHJhd0Fycm93aGVhZChjb250ZXh0LCBlZGdlLCAndGFyZ2V0JywgcnMuYXJyb3dFbmRYLCBycy5hcnJvd0VuZFksIHJzLnRndEFycm93QW5nbGUsIG9wYWNpdHkpO1xuICB9XG59O1xuXG5DUnAuZHJhd0Fycm93aGVhZCA9IGZ1bmN0aW9uIChjb250ZXh0LCBlZGdlLCBwcmVmaXgsIHgsIHksIGFuZ2xlLCBvcGFjaXR5KSB7XG4gIGlmIChpc05hTih4KSB8fCB4ID09IG51bGwgfHwgaXNOYU4oeSkgfHwgeSA9PSBudWxsIHx8IGlzTmFOKGFuZ2xlKSB8fCBhbmdsZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgYXJyb3dTaGFwZSA9IGVkZ2UucHN0eWxlKHByZWZpeCArICctYXJyb3ctc2hhcGUnKS52YWx1ZTtcbiAgaWYgKGFycm93U2hhcGUgPT09ICdub25lJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBhcnJvd0NsZWFyRmlsbCA9IGVkZ2UucHN0eWxlKHByZWZpeCArICctYXJyb3ctZmlsbCcpLnZhbHVlID09PSAnaG9sbG93JyA/ICdib3RoJyA6ICdmaWxsZWQnO1xuICB2YXIgYXJyb3dGaWxsID0gZWRnZS5wc3R5bGUocHJlZml4ICsgJy1hcnJvdy1maWxsJykudmFsdWU7XG4gIHZhciBlZGdlV2lkdGggPSBlZGdlLnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlO1xuICB2YXIgZWRnZU9wYWNpdHkgPSBlZGdlLnBzdHlsZSgnb3BhY2l0eScpLnZhbHVlO1xuXG4gIGlmIChvcGFjaXR5ID09PSB1bmRlZmluZWQpIHtcbiAgICBvcGFjaXR5ID0gZWRnZU9wYWNpdHk7XG4gIH1cblxuICB2YXIgZ2NvID0gY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb247XG5cbiAgaWYgKG9wYWNpdHkgIT09IDEgfHwgYXJyb3dGaWxsID09PSAnaG9sbG93Jykge1xuICAgIC8vIHRoZW4gZXh0cmEgY2xlYXIgaXMgbmVlZGVkXG4gICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24tb3V0JztcblxuICAgIHNlbGYuZmlsbFN0eWxlKGNvbnRleHQsIDI1NSwgMjU1LCAyNTUsIDEpO1xuICAgIHNlbGYuc3Ryb2tlU3R5bGUoY29udGV4dCwgMjU1LCAyNTUsIDI1NSwgMSk7XG5cbiAgICBzZWxmLmRyYXdBcnJvd1NoYXBlKGVkZ2UsIHByZWZpeCwgY29udGV4dCwgYXJyb3dDbGVhckZpbGwsIGVkZ2VXaWR0aCwgYXJyb3dTaGFwZSwgeCwgeSwgYW5nbGUpO1xuXG4gICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBnY287XG4gIH0gLy8gb3RoZXJ3aXNlLCB0aGUgb3BhcXVlIGFycm93IGNsZWFycyBpdCBmb3IgZnJlZSA6KVxuXG4gIHZhciBjb2xvciA9IGVkZ2UucHN0eWxlKHByZWZpeCArICctYXJyb3ctY29sb3InKS52YWx1ZTtcbiAgc2VsZi5maWxsU3R5bGUoY29udGV4dCwgY29sb3JbMF0sIGNvbG9yWzFdLCBjb2xvclsyXSwgb3BhY2l0eSk7XG4gIHNlbGYuc3Ryb2tlU3R5bGUoY29udGV4dCwgY29sb3JbMF0sIGNvbG9yWzFdLCBjb2xvclsyXSwgb3BhY2l0eSk7XG5cbiAgc2VsZi5kcmF3QXJyb3dTaGFwZShlZGdlLCBwcmVmaXgsIGNvbnRleHQsIGFycm93RmlsbCwgZWRnZVdpZHRoLCBhcnJvd1NoYXBlLCB4LCB5LCBhbmdsZSk7XG59O1xuXG5DUnAuZHJhd0Fycm93U2hhcGUgPSBmdW5jdGlvbiAoZWRnZSwgYXJyb3dUeXBlLCBjb250ZXh0LCBmaWxsLCBlZGdlV2lkdGgsIHNoYXBlLCB4LCB5LCBhbmdsZSkge1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciB1c2VQYXRocyA9IHRoaXMudXNlUGF0aHMoKTtcbiAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgdmFyIHBhdGhDYWNoZUhpdCA9IGZhbHNlO1xuICB2YXIgcGF0aCA9IHZvaWQgMDtcbiAgdmFyIGNhbnZhc0NvbnRleHQgPSBjb250ZXh0O1xuICB2YXIgdHJhbnNsYXRpb24gPSB7IHg6IHgsIHk6IHkgfTtcbiAgdmFyIHNjYWxlID0gZWRnZS5wc3R5bGUoJ2Fycm93LXNjYWxlJykudmFsdWU7XG4gIHZhciBzaXplID0gdGhpcy5nZXRBcnJvd1dpZHRoKGVkZ2VXaWR0aCwgc2NhbGUpO1xuICB2YXIgc2hhcGVJbXBsID0gci5hcnJvd1NoYXBlc1tzaGFwZV07XG5cbiAgaWYgKHVzZVBhdGhzKSB7XG4gICAgdmFyIHBhdGhDYWNoZUtleSA9IHNpemUgKyAnJCcgKyBzaGFwZSArICckJyArIGFuZ2xlICsgJyQnICsgeCArICckJyArIHk7XG4gICAgcnMuYXJyb3dQYXRoQ2FjaGVLZXkgPSBycy5hcnJvd1BhdGhDYWNoZUtleSB8fCB7fTtcbiAgICBycy5hcnJvd1BhdGhDYWNoZSA9IHJzLmFycm93UGF0aENhY2hlIHx8IHt9O1xuXG4gICAgdmFyIGFscmVhZHlDYWNoZWQgPSBycy5hcnJvd1BhdGhDYWNoZUtleVthcnJvd1R5cGVdID09PSBwYXRoQ2FjaGVLZXk7XG4gICAgaWYgKGFscmVhZHlDYWNoZWQpIHtcbiAgICAgIHBhdGggPSBjb250ZXh0ID0gcnMuYXJyb3dQYXRoQ2FjaGVbYXJyb3dUeXBlXTtcbiAgICAgIHBhdGhDYWNoZUhpdCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGggPSBjb250ZXh0ID0gbmV3IFBhdGgyRCgpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgICBycy5hcnJvd1BhdGhDYWNoZUtleVthcnJvd1R5cGVdID0gcGF0aENhY2hlS2V5O1xuICAgICAgcnMuYXJyb3dQYXRoQ2FjaGVbYXJyb3dUeXBlXSA9IHBhdGg7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNvbnRleHQuYmVnaW5QYXRoKSB7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgfVxuXG4gIGlmICghcGF0aENhY2hlSGl0KSB7XG4gICAgc2hhcGVJbXBsLmRyYXcoY29udGV4dCwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uLCBlZGdlV2lkdGgpO1xuICB9XG5cbiAgaWYgKCFzaGFwZUltcGwubGVhdmVQYXRoT3BlbiAmJiBjb250ZXh0LmNsb3NlUGF0aCkge1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH1cblxuICBjb250ZXh0ID0gY2FudmFzQ29udGV4dDtcblxuICBpZiAoZmlsbCA9PT0gJ2ZpbGxlZCcgfHwgZmlsbCA9PT0gJ2JvdGgnKSB7XG4gICAgaWYgKHVzZVBhdGhzKSB7XG4gICAgICBjb250ZXh0LmZpbGwocGF0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChmaWxsID09PSAnaG9sbG93JyB8fCBmaWxsID09PSAnYm90aCcpIHtcbiAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHNoYXBlSW1wbC5tYXRjaEVkZ2VXaWR0aCA/IGVkZ2VXaWR0aCA6IDE7XG4gICAgY29udGV4dC5saW5lSm9pbiA9ICdtaXRlcic7XG5cbiAgICBpZiAodXNlUGF0aHMpIHtcbiAgICAgIGNvbnRleHQuc3Ryb2tlKHBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDUnA7XG5cbi8qKiovIH0pLFxuLyogMTI5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBDUnAgPSB7fTtcblxuQ1JwLnNhZmVEcmF3SW1hZ2UgPSBmdW5jdGlvbiAoY29udGV4dCwgaW1nLCBpeCwgaXksIGl3LCBpaCwgeCwgeSwgdywgaCkge1xuICB2YXIgciA9IHRoaXM7XG5cbiAgLy8gZGV0ZWN0IHByb2JsZW1hdGljIGNhc2VzIGZvciBvbGQgYnJvd3NlcnMgd2l0aCBiYWQgaW1hZ2VzIChjaGVhcGVyIHRoYW4gdHJ5LWNhdGNoKVxuICBpZiAoaXcgPD0gMCB8fCBpaCA8PSAwIHx8IHcgPD0gMCB8fCBoIDw9IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb250ZXh0LmRyYXdJbWFnZShpbWcsIGl4LCBpeSwgaXcsIGloLCB4LCB5LCB3LCBoKTtcbn07XG5cbkNScC5kcmF3SW5zY3JpYmVkSW1hZ2UgPSBmdW5jdGlvbiAoY29udGV4dCwgaW1nLCBub2RlLCBpbmRleCwgbm9kZU9wYWNpdHkpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgcG9zID0gbm9kZS5wb3NpdGlvbigpO1xuICB2YXIgbm9kZVggPSBwb3MueDtcbiAgdmFyIG5vZGVZID0gcG9zLnk7XG4gIHZhciBzdHlsZU9iaiA9IG5vZGUuY3koKS5zdHlsZSgpO1xuICB2YXIgZ2V0SW5kZXhlZFN0eWxlID0gc3R5bGVPYmouZ2V0SW5kZXhlZFN0eWxlLmJpbmQoc3R5bGVPYmopO1xuICB2YXIgZml0ID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLWZpdCcsICd2YWx1ZScsIGluZGV4KTtcbiAgdmFyIHJlcGVhdCA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1yZXBlYXQnLCAndmFsdWUnLCBpbmRleCk7XG4gIHZhciBub2RlVyA9IG5vZGUud2lkdGgoKTtcbiAgdmFyIG5vZGVIID0gbm9kZS5oZWlnaHQoKTtcbiAgdmFyIHBhZGRpbmdYMiA9IG5vZGUucGFkZGluZygpICogMjtcbiAgdmFyIG5vZGVUVyA9IG5vZGVXICsgKGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC13aWR0aC1yZWxhdGl2ZS10bycsICd2YWx1ZScsIGluZGV4KSA9PT0gJ2lubmVyJyA/IDAgOiBwYWRkaW5nWDIpO1xuICB2YXIgbm9kZVRIID0gbm9kZUggKyAoZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLWhlaWdodC1yZWxhdGl2ZS10bycsICd2YWx1ZScsIGluZGV4KSA9PT0gJ2lubmVyJyA/IDAgOiBwYWRkaW5nWDIpO1xuICB2YXIgcnMgPSBub2RlLl9wcml2YXRlLnJzY3JhdGNoO1xuICB2YXIgY2xpcCA9IG5vZGUucHN0eWxlKCdiYWNrZ3JvdW5kLWNsaXAnKS52YWx1ZTtcbiAgdmFyIHNob3VsZENsaXAgPSBjbGlwID09PSAnbm9kZSc7XG4gIHZhciBpbWdPcGFjaXR5ID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLWltYWdlLW9wYWNpdHknLCAndmFsdWUnLCBpbmRleCkgKiBub2RlT3BhY2l0eTtcblxuICB2YXIgaW1nVyA9IGltZy53aWR0aCB8fCBpbWcuY2FjaGVkVztcbiAgdmFyIGltZ0ggPSBpbWcuaGVpZ2h0IHx8IGltZy5jYWNoZWRIO1xuXG4gIC8vIHdvcmthcm91bmQgZm9yIGJyb2tlbiBicm93c2VycyBsaWtlIGllXG4gIGlmIChudWxsID09IGltZ1cgfHwgbnVsbCA9PSBpbWdIKSB7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpbWcpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbiAgICBpbWdXID0gaW1nLmNhY2hlZFcgPSBpbWcud2lkdGggfHwgaW1nLm9mZnNldFdpZHRoO1xuICAgIGltZ0ggPSBpbWcuY2FjaGVkSCA9IGltZy5oZWlnaHQgfHwgaW1nLm9mZnNldEhlaWdodDtcblxuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoaW1nKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICB9XG5cbiAgdmFyIHcgPSBpbWdXO1xuICB2YXIgaCA9IGltZ0g7XG5cbiAgaWYgKGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC13aWR0aCcsICd2YWx1ZScsIGluZGV4KSAhPT0gJ2F1dG8nKSB7XG4gICAgaWYgKGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC13aWR0aCcsICd1bml0cycsIGluZGV4KSA9PT0gJyUnKSB7XG4gICAgICB3ID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLXdpZHRoJywgJ3BmVmFsdWUnLCBpbmRleCkgKiBub2RlVFc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHcgPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtd2lkdGgnLCAncGZWYWx1ZScsIGluZGV4KTtcbiAgICB9XG4gIH1cblxuICBpZiAoZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLWhlaWdodCcsICd2YWx1ZScsIGluZGV4KSAhPT0gJ2F1dG8nKSB7XG4gICAgaWYgKGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1oZWlnaHQnLCAndW5pdHMnLCBpbmRleCkgPT09ICclJykge1xuICAgICAgaCA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1oZWlnaHQnLCAncGZWYWx1ZScsIGluZGV4KSAqIG5vZGVUSDtcbiAgICB9IGVsc2Uge1xuICAgICAgaCA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1oZWlnaHQnLCAncGZWYWx1ZScsIGluZGV4KTtcbiAgICB9XG4gIH1cblxuICBpZiAodyA9PT0gMCB8fCBoID09PSAwKSB7XG4gICAgcmV0dXJuOyAvLyBubyBwb2ludCBpbiBkcmF3aW5nIGVtcHR5IGltYWdlIChhbmQgY2hyb21lIGlzIGJyb2tlbiBpbiB0aGlzIGNhc2UpXG4gIH1cblxuICBpZiAoZml0ID09PSAnY29udGFpbicpIHtcbiAgICB2YXIgc2NhbGUgPSBNYXRoLm1pbihub2RlVFcgLyB3LCBub2RlVEggLyBoKTtcblxuICAgIHcgKj0gc2NhbGU7XG4gICAgaCAqPSBzY2FsZTtcbiAgfSBlbHNlIGlmIChmaXQgPT09ICdjb3ZlcicpIHtcbiAgICB2YXIgc2NhbGUgPSBNYXRoLm1heChub2RlVFcgLyB3LCBub2RlVEggLyBoKTtcblxuICAgIHcgKj0gc2NhbGU7XG4gICAgaCAqPSBzY2FsZTtcbiAgfVxuXG4gIHZhciB4ID0gbm9kZVggLSBub2RlVFcgLyAyOyAvLyBsZWZ0XG4gIGlmIChnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtcG9zaXRpb24teCcsICd1bml0cycsIGluZGV4KSA9PT0gJyUnKSB7XG4gICAgeCArPSAobm9kZVRXIC0gdykgKiBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtcG9zaXRpb24teCcsICdwZlZhbHVlJywgaW5kZXgpO1xuICB9IGVsc2Uge1xuICAgIHggKz0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXgnLCAncGZWYWx1ZScsIGluZGV4KTtcbiAgfVxuXG4gIHZhciB5ID0gbm9kZVkgLSBub2RlVEggLyAyOyAvLyB0b3BcbiAgaWYgKGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1wb3NpdGlvbi15JywgJ3VuaXRzJywgaW5kZXgpID09PSAnJScpIHtcbiAgICB5ICs9IChub2RlVEggLSBoKSAqIGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1wb3NpdGlvbi15JywgJ3BmVmFsdWUnLCBpbmRleCk7XG4gIH0gZWxzZSB7XG4gICAgeSArPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtcG9zaXRpb24teScsICdwZlZhbHVlJywgaW5kZXgpO1xuICB9XG5cbiAgaWYgKHJzLnBhdGhDYWNoZSkge1xuICAgIHggLT0gbm9kZVg7XG4gICAgeSAtPSBub2RlWTtcblxuICAgIG5vZGVYID0gMDtcbiAgICBub2RlWSA9IDA7XG4gIH1cblxuICB2YXIgZ0FscGhhID0gY29udGV4dC5nbG9iYWxBbHBoYTtcblxuICBjb250ZXh0Lmdsb2JhbEFscGhhID0gaW1nT3BhY2l0eTtcblxuICBpZiAocmVwZWF0ID09PSAnbm8tcmVwZWF0Jykge1xuXG4gICAgaWYgKHNob3VsZENsaXApIHtcbiAgICAgIGNvbnRleHQuc2F2ZSgpO1xuXG4gICAgICBpZiAocnMucGF0aENhY2hlKSB7XG4gICAgICAgIGNvbnRleHQuY2xpcChycy5wYXRoQ2FjaGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgci5ub2RlU2hhcGVzW3IuZ2V0Tm9kZVNoYXBlKG5vZGUpXS5kcmF3KGNvbnRleHQsIG5vZGVYLCBub2RlWSwgbm9kZVRXLCBub2RlVEgpO1xuXG4gICAgICAgIGNvbnRleHQuY2xpcCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHIuc2FmZURyYXdJbWFnZShjb250ZXh0LCBpbWcsIDAsIDAsIGltZ1csIGltZ0gsIHgsIHksIHcsIGgpO1xuXG4gICAgaWYgKHNob3VsZENsaXApIHtcbiAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgcGF0dGVybiA9IGNvbnRleHQuY3JlYXRlUGF0dGVybihpbWcsIHJlcGVhdCk7XG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBwYXR0ZXJuO1xuXG4gICAgci5ub2RlU2hhcGVzW3IuZ2V0Tm9kZVNoYXBlKG5vZGUpXS5kcmF3KGNvbnRleHQsIG5vZGVYLCBub2RlWSwgbm9kZVRXLCBub2RlVEgpO1xuXG4gICAgY29udGV4dC50cmFuc2xhdGUoeCwgeSk7XG4gICAgY29udGV4dC5maWxsKCk7XG4gICAgY29udGV4dC50cmFuc2xhdGUoLXgsIC15KTtcbiAgfVxuXG4gIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBnQWxwaGE7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENScDtcblxuLyoqKi8gfSksXG4vKiAxMzAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xudmFyIG1hdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgQ1JwID0ge307XG5cbkNScC5lbGVUZXh0QmlnZ2VyVGhhbk1pbiA9IGZ1bmN0aW9uIChlbGUsIHNjYWxlKSB7XG4gIGlmICghc2NhbGUpIHtcbiAgICB2YXIgem9vbSA9IGVsZS5jeSgpLnpvb20oKTtcbiAgICB2YXIgcHhSYXRpbyA9IHRoaXMuZ2V0UGl4ZWxSYXRpbygpO1xuICAgIHZhciBsdmwgPSBNYXRoLmNlaWwobWF0aC5sb2cyKHpvb20gKiBweFJhdGlvKSk7IC8vIHRoZSBlZmZlY3RpdmUgdGV4dHVyZSBsZXZlbFxuXG4gICAgc2NhbGUgPSBNYXRoLnBvdygyLCBsdmwpO1xuICB9XG5cbiAgdmFyIGNvbXB1dGVkU2l6ZSA9IGVsZS5wc3R5bGUoJ2ZvbnQtc2l6ZScpLnBmVmFsdWUgKiBzY2FsZTtcbiAgdmFyIG1pblNpemUgPSBlbGUucHN0eWxlKCdtaW4tem9vbWVkLWZvbnQtc2l6ZScpLnBmVmFsdWU7XG5cbiAgaWYgKGNvbXB1dGVkU2l6ZSA8IG1pblNpemUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkNScC5kcmF3RWxlbWVudFRleHQgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlLCBmb3JjZSkge1xuICB2YXIgciA9IHRoaXM7XG5cbiAgaWYgKGZvcmNlID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoIXIuZWxlVGV4dEJpZ2dlclRoYW5NaW4oZWxlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoIWZvcmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgIHZhciBsYWJlbCA9IGVsZS5wc3R5bGUoJ2xhYmVsJyk7XG5cbiAgICBpZiAoIWxhYmVsIHx8ICFsYWJlbC52YWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0ZXh0SGFsaWduID0gZWxlLnBzdHlsZSgndGV4dC1oYWxpZ24nKS5zdHJWYWx1ZTtcbiAgICB2YXIgdGV4dFZhbGlnbiA9IGVsZS5wc3R5bGUoJ3RleHQtdmFsaWduJykuc3RyVmFsdWU7XG5cbiAgICBzd2l0Y2ggKHRleHRIYWxpZ24pIHtcbiAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICBjb250ZXh0LnRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgIGNvbnRleHQudGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gZS5nLiBjZW50ZXJcbiAgICAgICAgY29udGV4dC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICB9XG5cbiAgICBjb250ZXh0LnRleHRCYXNlbGluZSA9ICdib3R0b20nO1xuICB9IGVsc2Uge1xuICAgIHZhciBsYWJlbCA9IGVsZS5wc3R5bGUoJ2xhYmVsJyk7XG4gICAgdmFyIHNyY0xhYmVsID0gZWxlLnBzdHlsZSgnc291cmNlLWxhYmVsJyk7XG4gICAgdmFyIHRndExhYmVsID0gZWxlLnBzdHlsZSgndGFyZ2V0LWxhYmVsJyk7XG5cbiAgICBpZiAoKCFsYWJlbCB8fCAhbGFiZWwudmFsdWUpICYmICghc3JjTGFiZWwgfHwgIXNyY0xhYmVsLnZhbHVlKSAmJiAoIXRndExhYmVsIHx8ICF0Z3RMYWJlbC52YWx1ZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb250ZXh0LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgIGNvbnRleHQudGV4dEJhc2VsaW5lID0gJ2JvdHRvbSc7XG4gIH1cblxuICByLmRyYXdUZXh0KGNvbnRleHQsIGVsZSk7XG5cbiAgaWYgKGVsZS5pc0VkZ2UoKSkge1xuICAgIHIuZHJhd1RleHQoY29udGV4dCwgZWxlLCAnc291cmNlJyk7XG5cbiAgICByLmRyYXdUZXh0KGNvbnRleHQsIGVsZSwgJ3RhcmdldCcpO1xuICB9XG59O1xuXG5DUnAuZHJhd05vZGVUZXh0ID0gQ1JwLmRyYXdFZGdlVGV4dCA9IENScC5kcmF3RWxlbWVudFRleHQ7XG5cbkNScC5nZXRGb250Q2FjaGUgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICB2YXIgY2FjaGU7XG5cbiAgdGhpcy5mb250Q2FjaGVzID0gdGhpcy5mb250Q2FjaGVzIHx8IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5mb250Q2FjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY2FjaGUgPSB0aGlzLmZvbnRDYWNoZXNbaV07XG5cbiAgICBpZiAoY2FjaGUuY29udGV4dCA9PT0gY29udGV4dCkge1xuICAgICAgcmV0dXJuIGNhY2hlO1xuICAgIH1cbiAgfVxuXG4gIGNhY2hlID0ge1xuICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgfTtcbiAgdGhpcy5mb250Q2FjaGVzLnB1c2goY2FjaGUpO1xuXG4gIHJldHVybiBjYWNoZTtcbn07XG5cbi8vIHNldCB1cCBjYW52YXMgY29udGV4dCB3aXRoIGZvbnRcbi8vIHJldHVybnMgdHJhbnNmb3JtZWQgdGV4dCBzdHJpbmdcbkNScC5zZXR1cFRleHRTdHlsZSA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGUpIHtcbiAgLy8gRm9udCBzdHlsZVxuICB2YXIgcGFyZW50T3BhY2l0eSA9IGVsZS5lZmZlY3RpdmVPcGFjaXR5KCk7XG4gIHZhciBsYWJlbFN0eWxlID0gZWxlLnBzdHlsZSgnZm9udC1zdHlsZScpLnN0clZhbHVlO1xuICB2YXIgbGFiZWxTaXplID0gZWxlLnBzdHlsZSgnZm9udC1zaXplJykucGZWYWx1ZSArICdweCc7XG4gIHZhciBsYWJlbEZhbWlseSA9IGVsZS5wc3R5bGUoJ2ZvbnQtZmFtaWx5Jykuc3RyVmFsdWU7XG4gIHZhciBsYWJlbFdlaWdodCA9IGVsZS5wc3R5bGUoJ2ZvbnQtd2VpZ2h0Jykuc3RyVmFsdWU7XG4gIHZhciBvcGFjaXR5ID0gZWxlLnBzdHlsZSgndGV4dC1vcGFjaXR5JykudmFsdWUgKiBlbGUucHN0eWxlKCdvcGFjaXR5JykudmFsdWUgKiBwYXJlbnRPcGFjaXR5O1xuICB2YXIgb3V0bGluZU9wYWNpdHkgPSBlbGUucHN0eWxlKCd0ZXh0LW91dGxpbmUtb3BhY2l0eScpLnZhbHVlICogb3BhY2l0eTtcbiAgdmFyIGNvbG9yID0gZWxlLnBzdHlsZSgnY29sb3InKS52YWx1ZTtcbiAgdmFyIG91dGxpbmVDb2xvciA9IGVsZS5wc3R5bGUoJ3RleHQtb3V0bGluZS1jb2xvcicpLnZhbHVlO1xuXG4gIHZhciBmb250Q2FjaGVLZXkgPSBlbGUuX3ByaXZhdGUuZm9udEtleTtcbiAgdmFyIGNhY2hlID0gdGhpcy5nZXRGb250Q2FjaGUoY29udGV4dCk7XG5cbiAgaWYgKGNhY2hlLmtleSAhPT0gZm9udENhY2hlS2V5KSB7XG4gICAgY29udGV4dC5mb250ID0gbGFiZWxTdHlsZSArICcgJyArIGxhYmVsV2VpZ2h0ICsgJyAnICsgbGFiZWxTaXplICsgJyAnICsgbGFiZWxGYW1pbHk7XG5cbiAgICBjYWNoZS5rZXkgPSBmb250Q2FjaGVLZXk7XG4gIH1cblxuICAvLyBDYWxjdWxhdGUgdGV4dCBkcmF3IHBvc2l0aW9uIGJhc2VkIG9uIHRleHQgYWxpZ25tZW50XG5cbiAgLy8gc28gdGV4dCBvdXRsaW5lcyBhcmVuJ3QgamFnZ2VkXG4gIGNvbnRleHQubGluZUpvaW4gPSAncm91bmQnO1xuXG4gIHRoaXMuZmlsbFN0eWxlKGNvbnRleHQsIGNvbG9yWzBdLCBjb2xvclsxXSwgY29sb3JbMl0sIG9wYWNpdHkpO1xuXG4gIHRoaXMuc3Ryb2tlU3R5bGUoY29udGV4dCwgb3V0bGluZUNvbG9yWzBdLCBvdXRsaW5lQ29sb3JbMV0sIG91dGxpbmVDb2xvclsyXSwgb3V0bGluZU9wYWNpdHkpO1xufTtcblxuZnVuY3Rpb24gcm91bmRSZWN0KGN0eCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzKSB7XG4gIHZhciByYWRpdXMgPSByYWRpdXMgfHwgNTtcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHgubW92ZVRvKHggKyByYWRpdXMsIHkpO1xuICBjdHgubGluZVRvKHggKyB3aWR0aCAtIHJhZGl1cywgeSk7XG4gIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSwgeCArIHdpZHRoLCB5ICsgcmFkaXVzKTtcbiAgY3R4LmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLSByYWRpdXMpO1xuICBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQsIHggKyB3aWR0aCAtIHJhZGl1cywgeSArIGhlaWdodCk7XG4gIGN0eC5saW5lVG8oeCArIHJhZGl1cywgeSArIGhlaWdodCk7XG4gIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHkgKyBoZWlnaHQsIHgsIHkgKyBoZWlnaHQgLSByYWRpdXMpO1xuICBjdHgubGluZVRvKHgsIHkgKyByYWRpdXMpO1xuICBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5LCB4ICsgcmFkaXVzLCB5KTtcbiAgY3R4LmNsb3NlUGF0aCgpO1xuICBjdHguZmlsbCgpO1xufVxuXG4vLyBEcmF3IHRleHRcbkNScC5kcmF3VGV4dCA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGUsIHByZWZpeCkge1xuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciByc2NyYXRjaCA9IF9wLnJzY3JhdGNoO1xuICB2YXIgcGFyZW50T3BhY2l0eSA9IGVsZS5lZmZlY3RpdmVPcGFjaXR5KCk7XG4gIGlmIChwYXJlbnRPcGFjaXR5ID09PSAwIHx8IGVsZS5wc3R5bGUoJ3RleHQtb3BhY2l0eScpLnZhbHVlID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHRleHRYID0gdXRpbC5nZXRQcmVmaXhlZFByb3BlcnR5KHJzY3JhdGNoLCAnbGFiZWxYJywgcHJlZml4KTtcbiAgdmFyIHRleHRZID0gdXRpbC5nZXRQcmVmaXhlZFByb3BlcnR5KHJzY3JhdGNoLCAnbGFiZWxZJywgcHJlZml4KTtcbiAgdmFyIHRleHQgPSB0aGlzLmdldExhYmVsVGV4dChlbGUsIHByZWZpeCk7XG5cbiAgaWYgKHRleHQgIT0gbnVsbCAmJiB0ZXh0ICE9PSAnJyAmJiAhaXNOYU4odGV4dFgpICYmICFpc05hTih0ZXh0WSkpIHtcbiAgICB0aGlzLnNldHVwVGV4dFN0eWxlKGNvbnRleHQsIGVsZSk7XG5cbiAgICB2YXIgcGRhc2ggPSBwcmVmaXggPyBwcmVmaXggKyAnLScgOiAnJztcbiAgICB2YXIgdGV4dFcgPSB1dGlsLmdldFByZWZpeGVkUHJvcGVydHkocnNjcmF0Y2gsICdsYWJlbFdpZHRoJywgcHJlZml4KTtcbiAgICB2YXIgdGV4dEggPSB1dGlsLmdldFByZWZpeGVkUHJvcGVydHkocnNjcmF0Y2gsICdsYWJlbEhlaWdodCcsIHByZWZpeCk7XG4gICAgdmFyIHRleHRBbmdsZSA9IHV0aWwuZ2V0UHJlZml4ZWRQcm9wZXJ0eShyc2NyYXRjaCwgJ2xhYmVsQW5nbGUnLCBwcmVmaXgpO1xuICAgIHZhciBtYXJnaW5YID0gZWxlLnBzdHlsZShwZGFzaCArICd0ZXh0LW1hcmdpbi14JykucGZWYWx1ZTtcbiAgICB2YXIgbWFyZ2luWSA9IGVsZS5wc3R5bGUocGRhc2ggKyAndGV4dC1tYXJnaW4teScpLnBmVmFsdWU7XG5cbiAgICB2YXIgaXNFZGdlID0gZWxlLmlzRWRnZSgpO1xuICAgIHZhciBpc05vZGUgPSBlbGUuaXNOb2RlKCk7XG5cbiAgICB2YXIgaGFsaWduID0gZWxlLnBzdHlsZSgndGV4dC1oYWxpZ24nKS52YWx1ZTtcbiAgICB2YXIgdmFsaWduID0gZWxlLnBzdHlsZSgndGV4dC12YWxpZ24nKS52YWx1ZTtcblxuICAgIGlmIChpc0VkZ2UpIHtcbiAgICAgIGhhbGlnbiA9ICdjZW50ZXInO1xuICAgICAgdmFsaWduID0gJ2NlbnRlcic7XG4gICAgfVxuXG4gICAgdGV4dFggKz0gbWFyZ2luWDtcbiAgICB0ZXh0WSArPSBtYXJnaW5ZO1xuXG4gICAgdmFyIHJvdGF0aW9uID0gZWxlLnBzdHlsZShwZGFzaCArICd0ZXh0LXJvdGF0aW9uJyk7XG4gICAgdmFyIHRoZXRhO1xuXG4gICAgaWYgKHJvdGF0aW9uLnN0clZhbHVlID09PSAnYXV0b3JvdGF0ZScpIHtcbiAgICAgIHRoZXRhID0gaXNFZGdlID8gdGV4dEFuZ2xlIDogMDtcbiAgICB9IGVsc2UgaWYgKHJvdGF0aW9uLnN0clZhbHVlID09PSAnbm9uZScpIHtcbiAgICAgIHRoZXRhID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhldGEgPSByb3RhdGlvbi5wZlZhbHVlO1xuICAgIH1cblxuICAgIGlmICh0aGV0YSAhPT0gMCkge1xuICAgICAgdmFyIG9yZ1RleHRYID0gdGV4dFg7XG4gICAgICB2YXIgb3JnVGV4dFkgPSB0ZXh0WTtcblxuICAgICAgY29udGV4dC50cmFuc2xhdGUob3JnVGV4dFgsIG9yZ1RleHRZKTtcbiAgICAgIGNvbnRleHQucm90YXRlKHRoZXRhKTtcblxuICAgICAgdGV4dFggPSAwO1xuICAgICAgdGV4dFkgPSAwO1xuICAgIH1cblxuICAgIHN3aXRjaCAodmFsaWduKSB7XG4gICAgICBjYXNlICd0b3AnOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgIHRleHRZICs9IHRleHRIIC8gMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICB0ZXh0WSArPSB0ZXh0SDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIGJhY2tncm91bmRPcGFjaXR5ID0gZWxlLnBzdHlsZSgndGV4dC1iYWNrZ3JvdW5kLW9wYWNpdHknKS52YWx1ZTtcbiAgICB2YXIgYm9yZGVyT3BhY2l0eSA9IGVsZS5wc3R5bGUoJ3RleHQtYm9yZGVyLW9wYWNpdHknKS52YWx1ZTtcbiAgICB2YXIgdGV4dEJvcmRlcldpZHRoID0gZWxlLnBzdHlsZSgndGV4dC1ib3JkZXItd2lkdGgnKS5wZlZhbHVlO1xuICAgIHZhciBiYWNrZ3JvdW5kUGFkZGluZyA9IGVsZS5wc3R5bGUoJ3RleHQtYmFja2dyb3VuZC1wYWRkaW5nJykucGZWYWx1ZTtcblxuICAgIGlmIChiYWNrZ3JvdW5kT3BhY2l0eSA+IDAgfHwgdGV4dEJvcmRlcldpZHRoID4gMCAmJiBib3JkZXJPcGFjaXR5ID4gMCkge1xuICAgICAgdmFyIGJnWCA9IHRleHRYIC0gYmFja2dyb3VuZFBhZGRpbmc7XG5cbiAgICAgIHN3aXRjaCAoaGFsaWduKSB7XG4gICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgIGJnWCAtPSB0ZXh0VztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICBiZ1ggLT0gdGV4dFcgLyAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHZhciBiZ1kgPSB0ZXh0WSAtIHRleHRIIC0gYmFja2dyb3VuZFBhZGRpbmc7XG4gICAgICB2YXIgYmdXID0gdGV4dFcgKyAyICogYmFja2dyb3VuZFBhZGRpbmc7XG4gICAgICB2YXIgYmdIID0gdGV4dEggKyAyICogYmFja2dyb3VuZFBhZGRpbmc7XG5cbiAgICAgIGlmIChiYWNrZ3JvdW5kT3BhY2l0eSA+IDApIHtcbiAgICAgICAgdmFyIHRleHRGaWxsID0gY29udGV4dC5maWxsU3R5bGU7XG4gICAgICAgIHZhciB0ZXh0QmFja2dyb3VuZENvbG9yID0gZWxlLnBzdHlsZSgndGV4dC1iYWNrZ3JvdW5kLWNvbG9yJykudmFsdWU7XG5cbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAncmdiYSgnICsgdGV4dEJhY2tncm91bmRDb2xvclswXSArICcsJyArIHRleHRCYWNrZ3JvdW5kQ29sb3JbMV0gKyAnLCcgKyB0ZXh0QmFja2dyb3VuZENvbG9yWzJdICsgJywnICsgYmFja2dyb3VuZE9wYWNpdHkgKiBwYXJlbnRPcGFjaXR5ICsgJyknO1xuICAgICAgICB2YXIgc3R5bGVTaGFwZSA9IGVsZS5wc3R5bGUoJ3RleHQtYmFja2dyb3VuZC1zaGFwZScpLnN0clZhbHVlO1xuICAgICAgICBpZiAoc3R5bGVTaGFwZSA9PSAncm91bmRyZWN0YW5nbGUnKSB7XG4gICAgICAgICAgcm91bmRSZWN0KGNvbnRleHQsIGJnWCwgYmdZLCBiZ1csIGJnSCwgMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGV4dC5maWxsUmVjdChiZ1gsIGJnWSwgYmdXLCBiZ0gpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gdGV4dEZpbGw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0ZXh0Qm9yZGVyV2lkdGggPiAwICYmIGJvcmRlck9wYWNpdHkgPiAwKSB7XG4gICAgICAgIHZhciB0ZXh0U3Ryb2tlID0gY29udGV4dC5zdHJva2VTdHlsZTtcbiAgICAgICAgdmFyIHRleHRMaW5lV2lkdGggPSBjb250ZXh0LmxpbmVXaWR0aDtcbiAgICAgICAgdmFyIHRleHRCb3JkZXJDb2xvciA9IGVsZS5wc3R5bGUoJ3RleHQtYm9yZGVyLWNvbG9yJykudmFsdWU7XG4gICAgICAgIHZhciB0ZXh0Qm9yZGVyU3R5bGUgPSBlbGUucHN0eWxlKCd0ZXh0LWJvcmRlci1zdHlsZScpLnZhbHVlO1xuXG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAncmdiYSgnICsgdGV4dEJvcmRlckNvbG9yWzBdICsgJywnICsgdGV4dEJvcmRlckNvbG9yWzFdICsgJywnICsgdGV4dEJvcmRlckNvbG9yWzJdICsgJywnICsgYm9yZGVyT3BhY2l0eSAqIHBhcmVudE9wYWNpdHkgKyAnKSc7XG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gdGV4dEJvcmRlcldpZHRoO1xuXG4gICAgICAgIGlmIChjb250ZXh0LnNldExpbmVEYXNoKSB7XG4gICAgICAgICAgLy8gZm9yIHZlcnkgb3V0b2ZkYXRlIGJyb3dzZXJzXG4gICAgICAgICAgc3dpdGNoICh0ZXh0Qm9yZGVyU3R5bGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2RvdHRlZCc6XG4gICAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goWzEsIDFdKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkYXNoZWQnOlxuICAgICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFs0LCAyXSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZG91YmxlJzpcbiAgICAgICAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSB0ZXh0Qm9yZGVyV2lkdGggLyA0OyAvLyA1MCUgcmVzZXJ2ZWQgZm9yIHdoaXRlIGJldHdlZW4gdGhlIHR3byBib3JkZXJzXG4gICAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goW10pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NvbGlkJzpcbiAgICAgICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChbXSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQuc3Ryb2tlUmVjdChiZ1gsIGJnWSwgYmdXLCBiZ0gpO1xuXG4gICAgICAgIGlmICh0ZXh0Qm9yZGVyU3R5bGUgPT09ICdkb3VibGUnKSB7XG4gICAgICAgICAgdmFyIHdoaXRlV2lkdGggPSB0ZXh0Qm9yZGVyV2lkdGggLyAyO1xuXG4gICAgICAgICAgY29udGV4dC5zdHJva2VSZWN0KGJnWCArIHdoaXRlV2lkdGgsIGJnWSArIHdoaXRlV2lkdGgsIGJnVyAtIHdoaXRlV2lkdGggKiAyLCBiZ0ggLSB3aGl0ZVdpZHRoICogMik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dC5zZXRMaW5lRGFzaCkge1xuICAgICAgICAgIC8vIGZvciB2ZXJ5IG91dG9mZGF0ZSBicm93c2Vyc1xuICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goW10pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gdGV4dExpbmVXaWR0aDtcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHRleHRTdHJva2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxpbmVXaWR0aCA9IDIgKiBlbGUucHN0eWxlKCd0ZXh0LW91dGxpbmUtd2lkdGgnKS5wZlZhbHVlOyAvLyAqMiBiL2MgdGhlIHN0cm9rZSBpcyBkcmF3biBjZW50cmVkIG9uIHRoZSBtaWRkbGVcblxuICAgIGlmIChsaW5lV2lkdGggPiAwKSB7XG4gICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICB9XG5cbiAgICBpZiAoZWxlLnBzdHlsZSgndGV4dC13cmFwJykudmFsdWUgPT09ICd3cmFwJykge1xuICAgICAgdmFyIGxpbmVzID0gdXRpbC5nZXRQcmVmaXhlZFByb3BlcnR5KHJzY3JhdGNoLCAnbGFiZWxXcmFwQ2FjaGVkTGluZXMnLCBwcmVmaXgpO1xuICAgICAgdmFyIGxpbmVIZWlnaHQgPSB0ZXh0SCAvIGxpbmVzLmxlbmd0aDtcblxuICAgICAgc3dpdGNoICh2YWxpZ24pIHtcbiAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICB0ZXh0WSAtPSAobGluZXMubGVuZ3RoIC0gMSkgKiBsaW5lSGVpZ2h0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgIHRleHRZIC09IChsaW5lcy5sZW5ndGggLSAxKSAqIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgbGluZXMubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgaWYgKGxpbmVXaWR0aCA+IDApIHtcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZVRleHQobGluZXNbbF0sIHRleHRYLCB0ZXh0WSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0LmZpbGxUZXh0KGxpbmVzW2xdLCB0ZXh0WCwgdGV4dFkpO1xuXG4gICAgICAgIHRleHRZICs9IGxpbmVIZWlnaHQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChsaW5lV2lkdGggPiAwKSB7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlVGV4dCh0ZXh0LCB0ZXh0WCwgdGV4dFkpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0LmZpbGxUZXh0KHRleHQsIHRleHRYLCB0ZXh0WSk7XG4gICAgfVxuXG4gICAgaWYgKHRoZXRhICE9PSAwKSB7XG4gICAgICBjb250ZXh0LnJvdGF0ZSgtdGhldGEpO1xuICAgICAgY29udGV4dC50cmFuc2xhdGUoLW9yZ1RleHRYLCAtb3JnVGV4dFkpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDUnA7XG5cbi8qKiovIH0pLFxuLyogMTMxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qIGdsb2JhbCBQYXRoMkQgKi9cblxudmFyIGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIENScCA9IHt9O1xuXG5DUnAuZHJhd05vZGUgPSBmdW5jdGlvbiAoY29udGV4dCwgbm9kZSwgc2hpZnRUb09yaWdpbldpdGhCYiwgZHJhd0xhYmVsKSB7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIG5vZGVXaWR0aCA9IHZvaWQgMCxcbiAgICAgIG5vZGVIZWlnaHQgPSB2b2lkIDA7XG4gIHZhciBfcCA9IG5vZGUuX3ByaXZhdGU7XG4gIHZhciBycyA9IF9wLnJzY3JhdGNoO1xuICB2YXIgcG9zID0gbm9kZS5wb3NpdGlvbigpO1xuXG4gIGlmICghaXMubnVtYmVyKHBvcy54KSB8fCAhaXMubnVtYmVyKHBvcy55KSkge1xuICAgIHJldHVybjsgLy8gY2FuJ3QgZHJhdyBub2RlIHdpdGggdW5kZWZpbmVkIHBvc2l0aW9uXG4gIH1cblxuICBpZiAoIW5vZGUudmlzaWJsZSgpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHBhcmVudE9wYWNpdHkgPSBub2RlLmVmZmVjdGl2ZU9wYWNpdHkoKTtcblxuICB2YXIgdXNlUGF0aHMgPSByLnVzZVBhdGhzKCk7XG4gIHZhciBwYXRoID0gdm9pZCAwO1xuICB2YXIgcGF0aENhY2hlSGl0ID0gZmFsc2U7XG5cbiAgdmFyIHBhZGRpbmcgPSBub2RlLnBhZGRpbmcoKTtcblxuICBub2RlV2lkdGggPSBub2RlLndpZHRoKCkgKyAyICogcGFkZGluZztcbiAgbm9kZUhlaWdodCA9IG5vZGUuaGVpZ2h0KCkgKyAyICogcGFkZGluZztcblxuICAvL1xuICAvLyBzZXR1cCBzaGlmdFxuXG4gIHZhciBiYiA9IHZvaWQgMDtcbiAgaWYgKHNoaWZ0VG9PcmlnaW5XaXRoQmIpIHtcbiAgICBiYiA9IHNoaWZ0VG9PcmlnaW5XaXRoQmI7XG5cbiAgICBjb250ZXh0LnRyYW5zbGF0ZSgtYmIueDEsIC1iYi55MSk7XG4gIH1cblxuICAvL1xuICAvLyBsb2FkIGJnIGltYWdlXG5cbiAgdmFyIGJnSW1nUHJvcCA9IG5vZGUucHN0eWxlKCdiYWNrZ3JvdW5kLWltYWdlJyk7XG4gIHZhciB1cmxzID0gYmdJbWdQcm9wLnZhbHVlO1xuICB2YXIgdXJsRGVmaW5lZCA9IG5ldyBBcnJheSh1cmxzLmxlbmd0aCk7XG4gIHZhciBpbWFnZSA9IG5ldyBBcnJheSh1cmxzLmxlbmd0aCk7XG4gIHZhciBudW1JbWFnZXMgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHVybHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdXJsID0gdXJsc1tpXTtcbiAgICB2YXIgZGVmZCA9IHVybERlZmluZWRbaV0gPSB1cmwgIT0gbnVsbCAmJiB1cmwgIT09ICdub25lJztcblxuICAgIGlmIChkZWZkKSB7XG4gICAgICB2YXIgYmdJbWdDcm9zc09yaWdpbiA9IG5vZGUuY3koKS5zdHlsZSgpLmdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1pbWFnZS1jcm9zc29yaWdpbicsICd2YWx1ZScsIGkpO1xuXG4gICAgICBudW1JbWFnZXMrKztcblxuICAgICAgLy8gZ2V0IGltYWdlLCBhbmQgaWYgbm90IGxvYWRlZCB0aGVuIGFzayB0byByZWRyYXcgd2hlbiBsYXRlciBsb2FkZWRcbiAgICAgIGltYWdlW2ldID0gci5nZXRDYWNoZWRJbWFnZSh1cmwsIGJnSW1nQ3Jvc3NPcmlnaW4sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbm9kZS5lbWl0QW5kTm90aWZ5KCdiYWNrZ3JvdW5kJyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvL1xuICAvLyBzZXR1cCBzdHlsZXNcblxuICB2YXIgZGFya25lc3MgPSBub2RlLnBzdHlsZSgnYmFja2dyb3VuZC1ibGFja2VuJykudmFsdWU7XG4gIHZhciBib3JkZXJXaWR0aCA9IG5vZGUucHN0eWxlKCdib3JkZXItd2lkdGgnKS5wZlZhbHVlO1xuICB2YXIgYmdDb2xvciA9IG5vZGUucHN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJykudmFsdWU7XG4gIHZhciBiZ09wYWNpdHkgPSBub2RlLnBzdHlsZSgnYmFja2dyb3VuZC1vcGFjaXR5JykudmFsdWUgKiBwYXJlbnRPcGFjaXR5O1xuICB2YXIgYm9yZGVyQ29sb3IgPSBub2RlLnBzdHlsZSgnYm9yZGVyLWNvbG9yJykudmFsdWU7XG4gIHZhciBib3JkZXJTdHlsZSA9IG5vZGUucHN0eWxlKCdib3JkZXItc3R5bGUnKS52YWx1ZTtcbiAgdmFyIGJvcmRlck9wYWNpdHkgPSBub2RlLnBzdHlsZSgnYm9yZGVyLW9wYWNpdHknKS52YWx1ZSAqIHBhcmVudE9wYWNpdHk7XG5cbiAgY29udGV4dC5saW5lSm9pbiA9ICdtaXRlcic7IC8vIHNvIGJvcmRlcnMgYXJlIHNxdWFyZSB3aXRoIHRoZSBub2RlIHNoYXBlXG5cbiAgdmFyIHNldHVwU2hhcGVDb2xvciA9IGZ1bmN0aW9uIHNldHVwU2hhcGVDb2xvcigpIHtcbiAgICB2YXIgYmdPcHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGJnT3BhY2l0eTtcblxuICAgIHIuZmlsbFN0eWxlKGNvbnRleHQsIGJnQ29sb3JbMF0sIGJnQ29sb3JbMV0sIGJnQ29sb3JbMl0sIGJnT3B5KTtcbiAgfTtcblxuICB2YXIgc2V0dXBCb3JkZXJDb2xvciA9IGZ1bmN0aW9uIHNldHVwQm9yZGVyQ29sb3IoKSB7XG4gICAgdmFyIGJkck9weSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogYm9yZGVyT3BhY2l0eTtcblxuICAgIHIuc3Ryb2tlU3R5bGUoY29udGV4dCwgYm9yZGVyQ29sb3JbMF0sIGJvcmRlckNvbG9yWzFdLCBib3JkZXJDb2xvclsyXSwgYmRyT3B5KTtcbiAgfTtcblxuICAvL1xuICAvLyBzZXR1cCBzaGFwZVxuXG4gIHZhciBzdHlsZVNoYXBlID0gbm9kZS5wc3R5bGUoJ3NoYXBlJykuc3RyVmFsdWU7XG4gIHZhciBzaGFwZVB0cyA9IG5vZGUucHN0eWxlKCdzaGFwZS1wb2x5Z29uLXBvaW50cycpLnBmVmFsdWU7XG5cbiAgaWYgKHVzZVBhdGhzKSB7XG4gICAgdmFyIHBhdGhDYWNoZUtleSA9IHN0eWxlU2hhcGUgKyAnJCcgKyBub2RlV2lkdGggKyAnJCcgKyBub2RlSGVpZ2h0ICsgKHN0eWxlU2hhcGUgPT09ICdwb2x5Z29uJyA/ICckJyArIHNoYXBlUHRzLmpvaW4oJyQnKSA6ICcnKTtcblxuICAgIGNvbnRleHQudHJhbnNsYXRlKHBvcy54LCBwb3MueSk7XG5cbiAgICBpZiAocnMucGF0aENhY2hlS2V5ID09PSBwYXRoQ2FjaGVLZXkpIHtcbiAgICAgIHBhdGggPSBycy5wYXRoQ2FjaGU7XG4gICAgICBwYXRoQ2FjaGVIaXQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRoID0gbmV3IFBhdGgyRCgpO1xuICAgICAgcnMucGF0aENhY2hlS2V5ID0gcGF0aENhY2hlS2V5O1xuICAgICAgcnMucGF0aENhY2hlID0gcGF0aDtcbiAgICB9XG4gIH1cblxuICB2YXIgZHJhd1NoYXBlID0gZnVuY3Rpb24gZHJhd1NoYXBlKCkge1xuICAgIGlmICghcGF0aENhY2hlSGl0KSB7XG5cbiAgICAgIHZhciBucG9zID0gcG9zO1xuXG4gICAgICBpZiAodXNlUGF0aHMpIHtcbiAgICAgICAgbnBvcyA9IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgci5ub2RlU2hhcGVzW3IuZ2V0Tm9kZVNoYXBlKG5vZGUpXS5kcmF3KHBhdGggfHwgY29udGV4dCwgbnBvcy54LCBucG9zLnksIG5vZGVXaWR0aCwgbm9kZUhlaWdodCk7XG4gICAgfVxuXG4gICAgaWYgKHVzZVBhdGhzKSB7XG4gICAgICBjb250ZXh0LmZpbGwocGF0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgZHJhd0ltYWdlcyA9IGZ1bmN0aW9uIGRyYXdJbWFnZXMoKSB7XG4gICAgdmFyIG5vZGVPcGFjaXR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBwYXJlbnRPcGFjaXR5O1xuXG4gICAgdmFyIHByZXZCZ2luZyA9IF9wLmJhY2tncm91bmRpbmc7XG4gICAgdmFyIHRvdGFsQ29tcGxldGVkID0gMDtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBpbWFnZS5sZW5ndGg7IF9pKyspIHtcbiAgICAgIGlmICh1cmxEZWZpbmVkW19pXSAmJiBpbWFnZVtfaV0uY29tcGxldGUgJiYgIWltYWdlW19pXS5lcnJvcikge1xuICAgICAgICB0b3RhbENvbXBsZXRlZCsrO1xuICAgICAgICByLmRyYXdJbnNjcmliZWRJbWFnZShjb250ZXh0LCBpbWFnZVtfaV0sIG5vZGUsIF9pLCBub2RlT3BhY2l0eSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX3AuYmFja2dyb3VuZGluZyA9ICEodG90YWxDb21wbGV0ZWQgPT09IG51bUltYWdlcyk7XG4gICAgaWYgKHByZXZCZ2luZyAhPT0gX3AuYmFja2dyb3VuZGluZykge1xuICAgICAgLy8gdXBkYXRlIHN0eWxlIGIvYyA6YmFja2dyb3VuZGluZyBzdGF0ZSBjaGFuZ2VkXG4gICAgICBub2RlLnVwZGF0ZVN0eWxlKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGRyYXdQaWUgPSBmdW5jdGlvbiBkcmF3UGllKCkge1xuICAgIHZhciByZWRyYXdTaGFwZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG4gICAgdmFyIHBpZU9wYWNpdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHBhcmVudE9wYWNpdHk7XG5cbiAgICBpZiAoci5oYXNQaWUobm9kZSkpIHtcbiAgICAgIHIuZHJhd1BpZShjb250ZXh0LCBub2RlLCBwaWVPcGFjaXR5KTtcblxuICAgICAgLy8gcmVkcmF3L3Jlc3RvcmUgcGF0aCBpZiBzdGVwcyBhZnRlciBwaWUgbmVlZCBpdFxuICAgICAgaWYgKHJlZHJhd1NoYXBlKSB7XG5cbiAgICAgICAgaWYgKCF1c2VQYXRocykge1xuICAgICAgICAgIHIubm9kZVNoYXBlc1tyLmdldE5vZGVTaGFwZShub2RlKV0uZHJhdyhjb250ZXh0LCBwb3MueCwgcG9zLnksIG5vZGVXaWR0aCwgbm9kZUhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIGRhcmtlbiA9IGZ1bmN0aW9uIGRhcmtlbigpIHtcbiAgICB2YXIgZGFya2VuT3BhY2l0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogcGFyZW50T3BhY2l0eTtcblxuICAgIHZhciBvcGFjaXR5ID0gKGRhcmtuZXNzID4gMCA/IGRhcmtuZXNzIDogLWRhcmtuZXNzKSAqIGRhcmtlbk9wYWNpdHk7XG4gICAgdmFyIGMgPSBkYXJrbmVzcyA+IDAgPyAwIDogMjU1O1xuXG4gICAgaWYgKGRhcmtuZXNzICE9PSAwKSB7XG4gICAgICByLmZpbGxTdHlsZShjb250ZXh0LCBjLCBjLCBjLCBvcGFjaXR5KTtcblxuICAgICAgaWYgKHVzZVBhdGhzKSB7XG4gICAgICAgIGNvbnRleHQuZmlsbChwYXRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgZHJhd0JvcmRlciA9IGZ1bmN0aW9uIGRyYXdCb3JkZXIoKSB7XG4gICAgaWYgKGJvcmRlcldpZHRoID4gMCkge1xuXG4gICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGJvcmRlcldpZHRoO1xuICAgICAgY29udGV4dC5saW5lQ2FwID0gJ2J1dHQnO1xuXG4gICAgICBpZiAoY29udGV4dC5zZXRMaW5lRGFzaCkge1xuICAgICAgICAvLyBmb3IgdmVyeSBvdXRvZmRhdGUgYnJvd3NlcnNcbiAgICAgICAgc3dpdGNoIChib3JkZXJTdHlsZSkge1xuICAgICAgICAgIGNhc2UgJ2RvdHRlZCc6XG4gICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFsxLCAxXSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2Rhc2hlZCc6XG4gICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFs0LCAyXSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3NvbGlkJzpcbiAgICAgICAgICBjYXNlICdkb3VibGUnOlxuICAgICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChbXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodXNlUGF0aHMpIHtcbiAgICAgICAgY29udGV4dC5zdHJva2UocGF0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYm9yZGVyU3R5bGUgPT09ICdkb3VibGUnKSB7XG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gYm9yZGVyV2lkdGggLyAzO1xuXG4gICAgICAgIHZhciBnY28gPSBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbjtcbiAgICAgICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24tb3V0JztcblxuICAgICAgICBpZiAodXNlUGF0aHMpIHtcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZShwYXRoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBnY287XG4gICAgICB9XG5cbiAgICAgIC8vIHJlc2V0IGluIGNhc2Ugd2UgY2hhbmdlZCB0aGUgYm9yZGVyIHN0eWxlXG4gICAgICBpZiAoY29udGV4dC5zZXRMaW5lRGFzaCkge1xuICAgICAgICAvLyBmb3IgdmVyeSBvdXRvZmRhdGUgYnJvd3NlcnNcbiAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChbXSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBkcmF3T3ZlcmxheSA9IGZ1bmN0aW9uIGRyYXdPdmVybGF5KCkge1xuICAgIHZhciBvdmVybGF5UGFkZGluZyA9IG5vZGUucHN0eWxlKCdvdmVybGF5LXBhZGRpbmcnKS5wZlZhbHVlO1xuICAgIHZhciBvdmVybGF5T3BhY2l0eSA9IG5vZGUucHN0eWxlKCdvdmVybGF5LW9wYWNpdHknKS52YWx1ZTtcbiAgICB2YXIgb3ZlcmxheUNvbG9yID0gbm9kZS5wc3R5bGUoJ292ZXJsYXktY29sb3InKS52YWx1ZTtcblxuICAgIGlmIChvdmVybGF5T3BhY2l0eSA+IDApIHtcbiAgICAgIHIuZmlsbFN0eWxlKGNvbnRleHQsIG92ZXJsYXlDb2xvclswXSwgb3ZlcmxheUNvbG9yWzFdLCBvdmVybGF5Q29sb3JbMl0sIG92ZXJsYXlPcGFjaXR5KTtcblxuICAgICAgci5ub2RlU2hhcGVzWydyb3VuZHJlY3RhbmdsZSddLmRyYXcoY29udGV4dCwgcG9zLngsIHBvcy55LCBub2RlV2lkdGggKyBvdmVybGF5UGFkZGluZyAqIDIsIG5vZGVIZWlnaHQgKyBvdmVybGF5UGFkZGluZyAqIDIpO1xuXG4gICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGRyYXdUZXh0ID0gZnVuY3Rpb24gZHJhd1RleHQoKSB7XG4gICAgci5kcmF3RWxlbWVudFRleHQoY29udGV4dCwgbm9kZSwgZHJhd0xhYmVsKTtcbiAgfTtcblxuICB2YXIgZ2hvc3QgPSBub2RlLnBzdHlsZSgnZ2hvc3QnKS52YWx1ZSA9PT0gJ3llcyc7XG5cbiAgaWYgKGdob3N0KSB7XG4gICAgdmFyIGd4ID0gbm9kZS5wc3R5bGUoJ2dob3N0LW9mZnNldC14JykucGZWYWx1ZTtcbiAgICB2YXIgZ3kgPSBub2RlLnBzdHlsZSgnZ2hvc3Qtb2Zmc2V0LXknKS5wZlZhbHVlO1xuICAgIHZhciBnaG9zdE9wYWNpdHkgPSBub2RlLnBzdHlsZSgnZ2hvc3Qtb3BhY2l0eScpLnZhbHVlO1xuICAgIHZhciBlZmZHaG9zdE9wYWNpdHkgPSBnaG9zdE9wYWNpdHkgKiBwYXJlbnRPcGFjaXR5O1xuXG4gICAgY29udGV4dC50cmFuc2xhdGUoZ3gsIGd5KTtcblxuICAgIHNldHVwU2hhcGVDb2xvcihnaG9zdE9wYWNpdHkgKiBiZ09wYWNpdHkpO1xuICAgIGRyYXdTaGFwZSgpO1xuICAgIGRyYXdJbWFnZXMoZWZmR2hvc3RPcGFjaXR5KTtcbiAgICBkcmF3UGllKGRhcmtuZXNzICE9PSAwIHx8IGJvcmRlcldpZHRoICE9PSAwKTtcbiAgICBkYXJrZW4oZWZmR2hvc3RPcGFjaXR5KTtcbiAgICBzZXR1cEJvcmRlckNvbG9yKGdob3N0T3BhY2l0eSAqIGJvcmRlck9wYWNpdHkpO1xuICAgIGRyYXdCb3JkZXIoKTtcblxuICAgIGNvbnRleHQudHJhbnNsYXRlKC1neCwgLWd5KTtcbiAgfVxuXG4gIHNldHVwU2hhcGVDb2xvcigpO1xuICBkcmF3U2hhcGUoKTtcbiAgZHJhd0ltYWdlcygpO1xuICBkcmF3UGllKGRhcmtuZXNzICE9PSAwIHx8IGJvcmRlcldpZHRoICE9PSAwKTtcbiAgZGFya2VuKCk7XG4gIHNldHVwQm9yZGVyQ29sb3IoKTtcbiAgZHJhd0JvcmRlcigpO1xuXG4gIGlmICh1c2VQYXRocykge1xuICAgIGNvbnRleHQudHJhbnNsYXRlKC1wb3MueCwgLXBvcy55KTtcbiAgfVxuXG4gIGRyYXdUZXh0KCk7XG4gIGRyYXdPdmVybGF5KCk7XG5cbiAgLy9cbiAgLy8gY2xlYW4gdXAgc2hpZnRcblxuICBpZiAoc2hpZnRUb09yaWdpbldpdGhCYikge1xuICAgIGNvbnRleHQudHJhbnNsYXRlKGJiLngxLCBiYi55MSk7XG4gIH1cbn07XG5cbi8vIGRvZXMgdGhlIG5vZGUgaGF2ZSBhdCBsZWFzdCBvbmUgcGllIHBpZWNlP1xuQ1JwLmhhc1BpZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIG5vZGUgPSBub2RlWzBdOyAvLyBlbnN1cmUgZWxlIHJlZlxuXG4gIHJldHVybiBub2RlLl9wcml2YXRlLmhhc1BpZTtcbn07XG5cbkNScC5kcmF3UGllID0gZnVuY3Rpb24gKGNvbnRleHQsIG5vZGUsIG5vZGVPcGFjaXR5LCBwb3MpIHtcbiAgbm9kZSA9IG5vZGVbMF07IC8vIGVuc3VyZSBlbGUgcmVmXG4gIHBvcyA9IHBvcyB8fCBub2RlLnBvc2l0aW9uKCk7XG5cbiAgdmFyIGN5U3R5bGUgPSBub2RlLmN5KCkuc3R5bGUoKTtcbiAgdmFyIHBpZVNpemUgPSBub2RlLnBzdHlsZSgncGllLXNpemUnKTtcbiAgdmFyIHggPSBwb3MueDtcbiAgdmFyIHkgPSBwb3MueTtcbiAgdmFyIG5vZGVXID0gbm9kZS53aWR0aCgpO1xuICB2YXIgbm9kZUggPSBub2RlLmhlaWdodCgpO1xuICB2YXIgcmFkaXVzID0gTWF0aC5taW4obm9kZVcsIG5vZGVIKSAvIDI7IC8vIG11c3QgZml0IGluIG5vZGVcbiAgdmFyIGxhc3RQZXJjZW50ID0gMDsgLy8gd2hhdCAlIHRvIGNvbnRpbnVlIGRyYXdpbmcgcGllIHNsaWNlcyBmcm9tIG9uIFswLCAxXVxuICB2YXIgdXNlUGF0aHMgPSB0aGlzLnVzZVBhdGhzKCk7XG5cbiAgaWYgKHVzZVBhdGhzKSB7XG4gICAgeCA9IDA7XG4gICAgeSA9IDA7XG4gIH1cblxuICBpZiAocGllU2l6ZS51bml0cyA9PT0gJyUnKSB7XG4gICAgcmFkaXVzID0gcmFkaXVzICogcGllU2l6ZS5wZlZhbHVlO1xuICB9IGVsc2UgaWYgKHBpZVNpemUucGZWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmFkaXVzID0gcGllU2l6ZS5wZlZhbHVlIC8gMjtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAxOyBpIDw9IGN5U3R5bGUucGllQmFja2dyb3VuZE47IGkrKykge1xuICAgIC8vIDEuLk5cbiAgICB2YXIgc2l6ZSA9IG5vZGUucHN0eWxlKCdwaWUtJyArIGkgKyAnLWJhY2tncm91bmQtc2l6ZScpLnZhbHVlO1xuICAgIHZhciBjb2xvciA9IG5vZGUucHN0eWxlKCdwaWUtJyArIGkgKyAnLWJhY2tncm91bmQtY29sb3InKS52YWx1ZTtcbiAgICB2YXIgb3BhY2l0eSA9IG5vZGUucHN0eWxlKCdwaWUtJyArIGkgKyAnLWJhY2tncm91bmQtb3BhY2l0eScpLnZhbHVlICogbm9kZU9wYWNpdHk7XG4gICAgdmFyIHBlcmNlbnQgPSBzaXplIC8gMTAwOyAvLyBtYXAgaW50ZWdlciByYW5nZSBbMCwgMTAwXSB0byBbMCwgMV1cblxuICAgIC8vIHBlcmNlbnQgY2FuJ3QgcHVzaCBiZXlvbmQgMVxuICAgIGlmIChwZXJjZW50ICsgbGFzdFBlcmNlbnQgPiAxKSB7XG4gICAgICBwZXJjZW50ID0gMSAtIGxhc3RQZXJjZW50O1xuICAgIH1cblxuICAgIHZhciBhbmdsZVN0YXJ0ID0gMS41ICogTWF0aC5QSSArIDIgKiBNYXRoLlBJICogbGFzdFBlcmNlbnQ7IC8vIHN0YXJ0IGF0IDEyIG8nY2xvY2sgYW5kIGdvIGNsb2Nrd2lzZVxuICAgIHZhciBhbmdsZURlbHRhID0gMiAqIE1hdGguUEkgKiBwZXJjZW50O1xuICAgIHZhciBhbmdsZUVuZCA9IGFuZ2xlU3RhcnQgKyBhbmdsZURlbHRhO1xuXG4gICAgLy8gaWdub3JlIGlmXG4gICAgLy8gLSB6ZXJvIHNpemVcbiAgICAvLyAtIHdlJ3JlIGFscmVhZHkgYmV5b25kIHRoZSBmdWxsIGNpcmNsZVxuICAgIC8vIC0gYWRkaW5nIHRoZSBjdXJyZW50IHNsaWNlIHdvdWxkIGdvIGJleW9uZCB0aGUgZnVsbCBjaXJjbGVcbiAgICBpZiAoc2l6ZSA9PT0gMCB8fCBsYXN0UGVyY2VudCA+PSAxIHx8IGxhc3RQZXJjZW50ICsgcGVyY2VudCA+IDEpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5tb3ZlVG8oeCwgeSk7XG4gICAgY29udGV4dC5hcmMoeCwgeSwgcmFkaXVzLCBhbmdsZVN0YXJ0LCBhbmdsZUVuZCk7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcblxuICAgIHRoaXMuZmlsbFN0eWxlKGNvbnRleHQsIGNvbG9yWzBdLCBjb2xvclsxXSwgY29sb3JbMl0sIG9wYWNpdHkpO1xuXG4gICAgY29udGV4dC5maWxsKCk7XG5cbiAgICBsYXN0UGVyY2VudCArPSBwZXJjZW50O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENScDtcblxuLyoqKi8gfSksXG4vKiAxMzIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIENScCA9IHt9O1xuXG52YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBtb3Rpb25CbHVyRGVsYXkgPSAxMDA7XG5cbi8vIHZhciBpc0ZpcmVmb3ggPSB0eXBlb2YgSW5zdGFsbFRyaWdnZXIgIT09ICd1bmRlZmluZWQnO1xuXG5DUnAuZ2V0UGl4ZWxSYXRpbyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNvbnRleHQgPSB0aGlzLmRhdGEuY29udGV4dHNbMF07XG5cbiAgaWYgKHRoaXMuZm9yY2VkUGl4ZWxSYXRpbyAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yY2VkUGl4ZWxSYXRpbztcbiAgfVxuXG4gIHZhciBiYWNraW5nU3RvcmUgPSBjb250ZXh0LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY29udGV4dC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGNvbnRleHQubW96QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjb250ZXh0Lm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjb250ZXh0Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGNvbnRleHQuYmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCAxO1xuXG4gIHJldHVybiAod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSkgLyBiYWNraW5nU3RvcmU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbn07XG5cbkNScC5wYWludENhY2hlID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgdmFyIGNhY2hlcyA9IHRoaXMucGFpbnRDYWNoZXMgPSB0aGlzLnBhaW50Q2FjaGVzIHx8IFtdO1xuICB2YXIgbmVlZFRvQ3JlYXRlQ2FjaGUgPSB0cnVlO1xuICB2YXIgY2FjaGU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjYWNoZSA9IGNhY2hlc1tpXTtcblxuICAgIGlmIChjYWNoZS5jb250ZXh0ID09PSBjb250ZXh0KSB7XG4gICAgICBuZWVkVG9DcmVhdGVDYWNoZSA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKG5lZWRUb0NyZWF0ZUNhY2hlKSB7XG4gICAgY2FjaGUgPSB7XG4gICAgICBjb250ZXh0OiBjb250ZXh0XG4gICAgfTtcbiAgICBjYWNoZXMucHVzaChjYWNoZSk7XG4gIH1cblxuICByZXR1cm4gY2FjaGU7XG59O1xuXG5DUnAuZmlsbFN0eWxlID0gZnVuY3Rpb24gKGNvbnRleHQsIHIsIGcsIGIsIGEpIHtcbiAgY29udGV4dC5maWxsU3R5bGUgPSAncmdiYSgnICsgciArICcsJyArIGcgKyAnLCcgKyBiICsgJywnICsgYSArICcpJztcblxuICAvLyB0dXJuIG9mZiBmb3Igbm93LCBzZWVtcyBjb250ZXh0IGRvZXMgaXRzIG93biBjYWNoaW5nXG5cbiAgLy8gdmFyIGNhY2hlID0gdGhpcy5wYWludENhY2hlKGNvbnRleHQpO1xuXG4gIC8vIHZhciBmaWxsU3R5bGUgPSAncmdiYSgnICsgciArICcsJyArIGcgKyAnLCcgKyBiICsgJywnICsgYSArICcpJztcblxuICAvLyBpZiggY2FjaGUuZmlsbFN0eWxlICE9PSBmaWxsU3R5bGUgKXtcbiAgLy8gICBjb250ZXh0LmZpbGxTdHlsZSA9IGNhY2hlLmZpbGxTdHlsZSA9IGZpbGxTdHlsZTtcbiAgLy8gfVxufTtcblxuQ1JwLnN0cm9rZVN0eWxlID0gZnVuY3Rpb24gKGNvbnRleHQsIHIsIGcsIGIsIGEpIHtcbiAgY29udGV4dC5zdHJva2VTdHlsZSA9ICdyZ2JhKCcgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnLCcgKyBhICsgJyknO1xuXG4gIC8vIHR1cm4gb2ZmIGZvciBub3csIHNlZW1zIGNvbnRleHQgZG9lcyBpdHMgb3duIGNhY2hpbmdcblxuICAvLyB2YXIgY2FjaGUgPSB0aGlzLnBhaW50Q2FjaGUoY29udGV4dCk7XG5cbiAgLy8gdmFyIHN0cm9rZVN0eWxlID0gJ3JnYmEoJyArIHIgKyAnLCcgKyBnICsgJywnICsgYiArICcsJyArIGEgKyAnKSc7XG5cbiAgLy8gaWYoIGNhY2hlLnN0cm9rZVN0eWxlICE9PSBzdHJva2VTdHlsZSApe1xuICAvLyAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjYWNoZS5zdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlO1xuICAvLyB9XG59O1xuXG4vLyBSZXNpemUgY2FudmFzXG5DUnAubWF0Y2hDYW52YXNTaXplID0gZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBkYXRhID0gci5kYXRhO1xuICB2YXIgYmIgPSByLmZpbmRDb250YWluZXJDbGllbnRDb29yZHMoKTtcbiAgdmFyIHdpZHRoID0gYmJbMl07XG4gIHZhciBoZWlnaHQgPSBiYlszXTtcbiAgdmFyIHBpeGVsUmF0aW8gPSByLmdldFBpeGVsUmF0aW8oKTtcbiAgdmFyIG1iUHhSYXRpbyA9IHIubW90aW9uQmx1clB4UmF0aW87XG5cbiAgaWYgKGNvbnRhaW5lciA9PT0gci5kYXRhLmJ1ZmZlckNhbnZhc2VzW3IuTU9USU9OQkxVUl9CVUZGRVJfTk9ERV0gfHwgY29udGFpbmVyID09PSByLmRhdGEuYnVmZmVyQ2FudmFzZXNbci5NT1RJT05CTFVSX0JVRkZFUl9EUkFHXSkge1xuICAgIHBpeGVsUmF0aW8gPSBtYlB4UmF0aW87XG4gIH1cblxuICB2YXIgY2FudmFzV2lkdGggPSB3aWR0aCAqIHBpeGVsUmF0aW87XG4gIHZhciBjYW52YXNIZWlnaHQgPSBoZWlnaHQgKiBwaXhlbFJhdGlvO1xuICB2YXIgY2FudmFzO1xuXG4gIGlmIChjYW52YXNXaWR0aCA9PT0gci5jYW52YXNXaWR0aCAmJiBjYW52YXNIZWlnaHQgPT09IHIuY2FudmFzSGVpZ2h0KSB7XG4gICAgcmV0dXJuOyAvLyBzYXZlIGN5Y2xlcyBpZiBzYW1lXG4gIH1cblxuICByLmZvbnRDYWNoZXMgPSBudWxsOyAvLyByZXNpemluZyByZXNldHMgdGhlIHN0eWxlXG5cbiAgdmFyIGNhbnZhc0NvbnRhaW5lciA9IGRhdGEuY2FudmFzQ29udGFpbmVyO1xuICBjYW52YXNDb250YWluZXIuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gIGNhbnZhc0NvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgci5DQU5WQVNfTEFZRVJTOyBpKyspIHtcbiAgICBjYW52YXMgPSBkYXRhLmNhbnZhc2VzW2ldO1xuXG4gICAgY2FudmFzLndpZHRoID0gY2FudmFzV2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGNhbnZhc0hlaWdodDtcblxuICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgci5CVUZGRVJfQ09VTlQ7IGkrKykge1xuICAgIGNhbnZhcyA9IGRhdGEuYnVmZmVyQ2FudmFzZXNbaV07XG5cbiAgICBjYW52YXMud2lkdGggPSBjYW52YXNXaWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzSGVpZ2h0O1xuXG4gICAgY2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICB9XG5cbiAgci50ZXh0dXJlTXVsdCA9IDE7XG4gIGlmIChwaXhlbFJhdGlvIDw9IDEpIHtcbiAgICBjYW52YXMgPSBkYXRhLmJ1ZmZlckNhbnZhc2VzW3IuVEVYVFVSRV9CVUZGRVJdO1xuXG4gICAgci50ZXh0dXJlTXVsdCA9IDI7XG4gICAgY2FudmFzLndpZHRoID0gY2FudmFzV2lkdGggKiByLnRleHR1cmVNdWx0O1xuICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXNIZWlnaHQgKiByLnRleHR1cmVNdWx0O1xuICB9XG5cbiAgci5jYW52YXNXaWR0aCA9IGNhbnZhc1dpZHRoO1xuICByLmNhbnZhc0hlaWdodCA9IGNhbnZhc0hlaWdodDtcbn07XG5cbkNScC5yZW5kZXJUbyA9IGZ1bmN0aW9uIChjeHQsIHpvb20sIHBhbiwgcHhSYXRpbykge1xuICB0aGlzLnJlbmRlcih7XG4gICAgZm9yY2VkQ29udGV4dDogY3h0LFxuICAgIGZvcmNlZFpvb206IHpvb20sXG4gICAgZm9yY2VkUGFuOiBwYW4sXG4gICAgZHJhd0FsbExheWVyczogdHJ1ZSxcbiAgICBmb3JjZWRQeFJhdGlvOiBweFJhdGlvXG4gIH0pO1xufTtcblxuQ1JwLnJlbmRlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHV0aWwuc3RhdGljRW1wdHlPYmplY3QoKTtcblxuICB2YXIgZm9yY2VkQ29udGV4dCA9IG9wdGlvbnMuZm9yY2VkQ29udGV4dDtcbiAgdmFyIGRyYXdBbGxMYXllcnMgPSBvcHRpb25zLmRyYXdBbGxMYXllcnM7XG4gIHZhciBkcmF3T25seU5vZGVMYXllciA9IG9wdGlvbnMuZHJhd09ubHlOb2RlTGF5ZXI7XG4gIHZhciBmb3JjZWRab29tID0gb3B0aW9ucy5mb3JjZWRab29tO1xuICB2YXIgZm9yY2VkUGFuID0gb3B0aW9ucy5mb3JjZWRQYW47XG4gIHZhciByID0gdGhpcztcbiAgdmFyIHBpeGVsUmF0aW8gPSBvcHRpb25zLmZvcmNlZFB4UmF0aW8gPT09IHVuZGVmaW5lZCA/IHRoaXMuZ2V0UGl4ZWxSYXRpbygpIDogb3B0aW9ucy5mb3JjZWRQeFJhdGlvO1xuICB2YXIgY3kgPSByLmN5O3ZhciBkYXRhID0gci5kYXRhO1xuICB2YXIgbmVlZERyYXcgPSBkYXRhLmNhbnZhc05lZWRzUmVkcmF3O1xuICB2YXIgdGV4dHVyZURyYXcgPSByLnRleHR1cmVPblZpZXdwb3J0ICYmICFmb3JjZWRDb250ZXh0ICYmIChyLnBpbmNoaW5nIHx8IHIuaG92ZXJEYXRhLmRyYWdnaW5nIHx8IHIuc3dpcGVQYW5uaW5nIHx8IHIuZGF0YS53aGVlbFpvb21pbmcpO1xuICB2YXIgbW90aW9uQmx1ciA9IG9wdGlvbnMubW90aW9uQmx1ciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tb3Rpb25CbHVyIDogci5tb3Rpb25CbHVyO1xuICB2YXIgbWJQeFJhdGlvID0gci5tb3Rpb25CbHVyUHhSYXRpbztcbiAgdmFyIGhhc0NvbXBvdW5kTm9kZXMgPSBjeS5oYXNDb21wb3VuZE5vZGVzKCk7XG4gIHZhciBpbk5vZGVEcmFnR2VzdHVyZSA9IHIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcztcbiAgdmFyIGluQm94U2VsZWN0aW9uID0gci5ob3ZlckRhdGEuc2VsZWN0aW5nIHx8IHIudG91Y2hEYXRhLnNlbGVjdGluZyA/IHRydWUgOiBmYWxzZTtcbiAgbW90aW9uQmx1ciA9IG1vdGlvbkJsdXIgJiYgIWZvcmNlZENvbnRleHQgJiYgci5tb3Rpb25CbHVyRW5hYmxlZCAmJiAhaW5Cb3hTZWxlY3Rpb247XG4gIHZhciBtb3Rpb25CbHVyRmFkZUVmZmVjdCA9IG1vdGlvbkJsdXI7XG5cbiAgaWYgKCFmb3JjZWRDb250ZXh0KSB7XG4gICAgaWYgKHIucHJldlB4UmF0aW8gIT09IHBpeGVsUmF0aW8pIHtcbiAgICAgIHIuaW52YWxpZGF0ZUNvbnRhaW5lckNsaWVudENvb3Jkc0NhY2hlKCk7XG4gICAgICByLm1hdGNoQ2FudmFzU2l6ZShyLmNvbnRhaW5lcik7XG5cbiAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgci5yZWRyYXdIaW50KCdkcmFnJywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgci5wcmV2UHhSYXRpbyA9IHBpeGVsUmF0aW87XG4gIH1cblxuICBpZiAoIWZvcmNlZENvbnRleHQgJiYgci5tb3Rpb25CbHVyVGltZW91dCkge1xuICAgIGNsZWFyVGltZW91dChyLm1vdGlvbkJsdXJUaW1lb3V0KTtcbiAgfVxuXG4gIGlmIChtb3Rpb25CbHVyKSB7XG4gICAgaWYgKHIubWJGcmFtZXMgPT0gbnVsbCkge1xuICAgICAgci5tYkZyYW1lcyA9IDA7XG4gICAgfVxuXG4gICAgci5tYkZyYW1lcysrO1xuXG4gICAgaWYgKHIubWJGcmFtZXMgPCAzKSB7XG4gICAgICAvLyBuZWVkIHNldmVyYWwgZnJhbWVzIGJlZm9yZSBldmVuIGhpZ2ggcXVhbGl0eSBtb3Rpb25ibHVyXG4gICAgICBtb3Rpb25CbHVyRmFkZUVmZmVjdCA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGdvIHRvIGxvd2VyIHF1YWxpdHkgYmx1cnJ5IGZyYW1lcyB3aGVuIHNldmVyYWwgbS9iIGZyYW1lcyBoYXZlIGJlZW4gcmVuZGVyZWQgKGF2b2lkcyBmbGFzaGluZylcbiAgICBpZiAoci5tYkZyYW1lcyA+IHIubWluTWJMb3dRdWFsRnJhbWVzKSB7XG4gICAgICAvL3IuZnVsbFF1YWxpdHlNYiA9IGZhbHNlO1xuICAgICAgci5tb3Rpb25CbHVyUHhSYXRpbyA9IHIubWJQeFJCbHVycnk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHIuY2xlYXJpbmdNb3Rpb25CbHVyKSB7XG4gICAgci5tb3Rpb25CbHVyUHhSYXRpbyA9IDE7XG4gIH1cblxuICAvLyBiL2MgZHJhd1RvQ29udGV4dCgpIG1heSBiZSBhc3luYyB3LnIudC4gcmVkcmF3KCksIGtlZXAgdHJhY2sgb2YgbGFzdCB0ZXh0dXJlIGZyYW1lXG4gIC8vIGJlY2F1c2UgYSByb2d1ZSBhc3luYyB0ZXh0dXJlIGZyYW1lIHdvdWxkIGNsZWFyIG5lZWREcmF3XG4gIGlmIChyLnRleHR1cmVEcmF3TGFzdEZyYW1lICYmICF0ZXh0dXJlRHJhdykge1xuICAgIG5lZWREcmF3W3IuTk9ERV0gPSB0cnVlO1xuICAgIG5lZWREcmF3W3IuU0VMRUNUX0JPWF0gPSB0cnVlO1xuICB9XG5cbiAgdmFyIGNvcmVTdHlsZSA9IGN5LnN0eWxlKCkuX3ByaXZhdGUuY29yZVN0eWxlO1xuXG4gIHZhciB6b29tID0gY3kuem9vbSgpO1xuICB2YXIgZWZmZWN0aXZlWm9vbSA9IGZvcmNlZFpvb20gIT09IHVuZGVmaW5lZCA/IGZvcmNlZFpvb20gOiB6b29tO1xuICB2YXIgcGFuID0gY3kucGFuKCk7XG4gIHZhciBlZmZlY3RpdmVQYW4gPSB7XG4gICAgeDogcGFuLngsXG4gICAgeTogcGFuLnlcbiAgfTtcblxuICB2YXIgdnAgPSB7XG4gICAgem9vbTogem9vbSxcbiAgICBwYW46IHtcbiAgICAgIHg6IHBhbi54LFxuICAgICAgeTogcGFuLnlcbiAgICB9XG4gIH07XG4gIHZhciBwcmV2VnAgPSByLnByZXZWaWV3cG9ydDtcbiAgdmFyIHZpZXdwb3J0SXNEaWZmID0gcHJldlZwID09PSB1bmRlZmluZWQgfHwgdnAuem9vbSAhPT0gcHJldlZwLnpvb20gfHwgdnAucGFuLnggIT09IHByZXZWcC5wYW4ueCB8fCB2cC5wYW4ueSAhPT0gcHJldlZwLnBhbi55O1xuXG4gIC8vIHdlIHdhbnQgdGhlIGxvdyBxdWFsaXR5IG1vdGlvbmJsdXIgb25seSB3aGVuIHRoZSB2aWV3cG9ydCBpcyBiZWluZyBtYW5pcHVsYXRlZCBldGMgKHdoZXJlIGl0J3Mgbm90IG5vdGljZWQpXG4gIGlmICghdmlld3BvcnRJc0RpZmYgJiYgIShpbk5vZGVEcmFnR2VzdHVyZSAmJiAhaGFzQ29tcG91bmROb2RlcykpIHtcbiAgICByLm1vdGlvbkJsdXJQeFJhdGlvID0gMTtcbiAgfVxuXG4gIGlmIChmb3JjZWRQYW4pIHtcbiAgICBlZmZlY3RpdmVQYW4gPSBmb3JjZWRQYW47XG4gIH1cblxuICAvLyBhcHBseSBwaXhlbCByYXRpb1xuXG4gIGVmZmVjdGl2ZVpvb20gKj0gcGl4ZWxSYXRpbztcbiAgZWZmZWN0aXZlUGFuLnggKj0gcGl4ZWxSYXRpbztcbiAgZWZmZWN0aXZlUGFuLnkgKj0gcGl4ZWxSYXRpbztcblxuICB2YXIgZWxlcyA9IHIuZ2V0Q2FjaGVkWlNvcnRlZEVsZXMoKTtcblxuICBmdW5jdGlvbiBtYmNsZWFyKGNvbnRleHQsIHgsIHksIHcsIGgpIHtcbiAgICB2YXIgZ2NvID0gY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb247XG5cbiAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1vdXQnO1xuICAgIHIuZmlsbFN0eWxlKGNvbnRleHQsIDI1NSwgMjU1LCAyNTUsIHIubW90aW9uQmx1clRyYW5zcGFyZW5jeSk7XG4gICAgY29udGV4dC5maWxsUmVjdCh4LCB5LCB3LCBoKTtcblxuICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gZ2NvO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0Q29udGV4dFRyYW5zZm9ybShjb250ZXh0LCBjbGVhcikge1xuICAgIHZhciBlUGFuLCBlWm9vbSwgdywgaDtcblxuICAgIGlmICghci5jbGVhcmluZ01vdGlvbkJsdXIgJiYgKGNvbnRleHQgPT09IGRhdGEuYnVmZmVyQ29udGV4dHNbci5NT1RJT05CTFVSX0JVRkZFUl9OT0RFXSB8fCBjb250ZXh0ID09PSBkYXRhLmJ1ZmZlckNvbnRleHRzW3IuTU9USU9OQkxVUl9CVUZGRVJfRFJBR10pKSB7XG4gICAgICBlUGFuID0ge1xuICAgICAgICB4OiBwYW4ueCAqIG1iUHhSYXRpbyxcbiAgICAgICAgeTogcGFuLnkgKiBtYlB4UmF0aW9cbiAgICAgIH07XG5cbiAgICAgIGVab29tID0gem9vbSAqIG1iUHhSYXRpbztcblxuICAgICAgdyA9IHIuY2FudmFzV2lkdGggKiBtYlB4UmF0aW87XG4gICAgICBoID0gci5jYW52YXNIZWlnaHQgKiBtYlB4UmF0aW87XG4gICAgfSBlbHNlIHtcbiAgICAgIGVQYW4gPSBlZmZlY3RpdmVQYW47XG4gICAgICBlWm9vbSA9IGVmZmVjdGl2ZVpvb207XG5cbiAgICAgIHcgPSByLmNhbnZhc1dpZHRoO1xuICAgICAgaCA9IHIuY2FudmFzSGVpZ2h0O1xuICAgIH1cblxuICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuXG4gICAgaWYgKGNsZWFyID09PSAnbW90aW9uQmx1cicpIHtcbiAgICAgIG1iY2xlYXIoY29udGV4dCwgMCwgMCwgdywgaCk7XG4gICAgfSBlbHNlIGlmICghZm9yY2VkQ29udGV4dCAmJiAoY2xlYXIgPT09IHVuZGVmaW5lZCB8fCBjbGVhcikpIHtcbiAgICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHcsIGgpO1xuICAgIH1cblxuICAgIGlmICghZHJhd0FsbExheWVycykge1xuICAgICAgY29udGV4dC50cmFuc2xhdGUoZVBhbi54LCBlUGFuLnkpO1xuICAgICAgY29udGV4dC5zY2FsZShlWm9vbSwgZVpvb20pO1xuICAgIH1cbiAgICBpZiAoZm9yY2VkUGFuKSB7XG4gICAgICBjb250ZXh0LnRyYW5zbGF0ZShmb3JjZWRQYW4ueCwgZm9yY2VkUGFuLnkpO1xuICAgIH1cbiAgICBpZiAoZm9yY2VkWm9vbSkge1xuICAgICAgY29udGV4dC5zY2FsZShmb3JjZWRab29tLCBmb3JjZWRab29tKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXRleHR1cmVEcmF3KSB7XG4gICAgci50ZXh0dXJlRHJhd0xhc3RGcmFtZSA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHRleHR1cmVEcmF3KSB7XG4gICAgci50ZXh0dXJlRHJhd0xhc3RGcmFtZSA9IHRydWU7XG5cbiAgICB2YXIgYmI7XG5cbiAgICBpZiAoIXIudGV4dHVyZUNhY2hlKSB7XG4gICAgICByLnRleHR1cmVDYWNoZSA9IHt9O1xuXG4gICAgICBiYiA9IHIudGV4dHVyZUNhY2hlLmJiID0gY3kubXV0YWJsZUVsZW1lbnRzKCkuYm91bmRpbmdCb3goKTtcblxuICAgICAgci50ZXh0dXJlQ2FjaGUudGV4dHVyZSA9IHIuZGF0YS5idWZmZXJDYW52YXNlc1tyLlRFWFRVUkVfQlVGRkVSXTtcblxuICAgICAgdmFyIGN4dCA9IHIuZGF0YS5idWZmZXJDb250ZXh0c1tyLlRFWFRVUkVfQlVGRkVSXTtcblxuICAgICAgY3h0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgIGN4dC5jbGVhclJlY3QoMCwgMCwgci5jYW52YXNXaWR0aCAqIHIudGV4dHVyZU11bHQsIHIuY2FudmFzSGVpZ2h0ICogci50ZXh0dXJlTXVsdCk7XG5cbiAgICAgIHIucmVuZGVyKHtcbiAgICAgICAgZm9yY2VkQ29udGV4dDogY3h0LFxuICAgICAgICBkcmF3T25seU5vZGVMYXllcjogdHJ1ZSxcbiAgICAgICAgZm9yY2VkUHhSYXRpbzogcGl4ZWxSYXRpbyAqIHIudGV4dHVyZU11bHRcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgdnAgPSByLnRleHR1cmVDYWNoZS52aWV3cG9ydCA9IHtcbiAgICAgICAgem9vbTogY3kuem9vbSgpLFxuICAgICAgICBwYW46IGN5LnBhbigpLFxuICAgICAgICB3aWR0aDogci5jYW52YXNXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiByLmNhbnZhc0hlaWdodFxuICAgICAgfTtcblxuICAgICAgdnAubXBhbiA9IHtcbiAgICAgICAgeDogKDAgLSB2cC5wYW4ueCkgLyB2cC56b29tLFxuICAgICAgICB5OiAoMCAtIHZwLnBhbi55KSAvIHZwLnpvb21cbiAgICAgIH07XG4gICAgfVxuXG4gICAgbmVlZERyYXdbci5EUkFHXSA9IGZhbHNlO1xuICAgIG5lZWREcmF3W3IuTk9ERV0gPSBmYWxzZTtcblxuICAgIHZhciBjb250ZXh0ID0gZGF0YS5jb250ZXh0c1tyLk5PREVdO1xuXG4gICAgdmFyIHRleHR1cmUgPSByLnRleHR1cmVDYWNoZS50ZXh0dXJlO1xuICAgIHZhciB2cCA9IHIudGV4dHVyZUNhY2hlLnZpZXdwb3J0O1xuICAgIGJiID0gci50ZXh0dXJlQ2FjaGUuYmI7XG5cbiAgICBjb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcblxuICAgIGlmIChtb3Rpb25CbHVyKSB7XG4gICAgICBtYmNsZWFyKGNvbnRleHQsIDAsIDAsIHZwLndpZHRoLCB2cC5oZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB2cC53aWR0aCwgdnAuaGVpZ2h0KTtcbiAgICB9XG5cbiAgICB2YXIgb3V0c2lkZUJnQ29sb3IgPSBjb3JlU3R5bGVbJ291dHNpZGUtdGV4dHVyZS1iZy1jb2xvciddLnZhbHVlO1xuICAgIHZhciBvdXRzaWRlQmdPcGFjaXR5ID0gY29yZVN0eWxlWydvdXRzaWRlLXRleHR1cmUtYmctb3BhY2l0eSddLnZhbHVlO1xuICAgIHIuZmlsbFN0eWxlKGNvbnRleHQsIG91dHNpZGVCZ0NvbG9yWzBdLCBvdXRzaWRlQmdDb2xvclsxXSwgb3V0c2lkZUJnQ29sb3JbMl0sIG91dHNpZGVCZ09wYWNpdHkpO1xuICAgIGNvbnRleHQuZmlsbFJlY3QoMCwgMCwgdnAud2lkdGgsIHZwLmhlaWdodCk7XG5cbiAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcblxuICAgIHNldENvbnRleHRUcmFuc2Zvcm0oY29udGV4dCwgZmFsc2UpO1xuXG4gICAgY29udGV4dC5jbGVhclJlY3QodnAubXBhbi54LCB2cC5tcGFuLnksIHZwLndpZHRoIC8gdnAuem9vbSAvIHBpeGVsUmF0aW8sIHZwLmhlaWdodCAvIHZwLnpvb20gLyBwaXhlbFJhdGlvKTtcbiAgICBjb250ZXh0LmRyYXdJbWFnZSh0ZXh0dXJlLCB2cC5tcGFuLngsIHZwLm1wYW4ueSwgdnAud2lkdGggLyB2cC56b29tIC8gcGl4ZWxSYXRpbywgdnAuaGVpZ2h0IC8gdnAuem9vbSAvIHBpeGVsUmF0aW8pO1xuICB9IGVsc2UgaWYgKHIudGV4dHVyZU9uVmlld3BvcnQgJiYgIWZvcmNlZENvbnRleHQpIHtcbiAgICAvLyBjbGVhciB0aGUgY2FjaGUgc2luY2Ugd2UgZG9uJ3QgbmVlZCBpdFxuICAgIHIudGV4dHVyZUNhY2hlID0gbnVsbDtcbiAgfVxuXG4gIHZhciBleHRlbnQgPSBjeS5leHRlbnQoKTtcbiAgdmFyIHZwTWFuaXAgPSByLnBpbmNoaW5nIHx8IHIuaG92ZXJEYXRhLmRyYWdnaW5nIHx8IHIuc3dpcGVQYW5uaW5nIHx8IHIuZGF0YS53aGVlbFpvb21pbmcgfHwgci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzO1xuICB2YXIgaGlkZUVkZ2VzID0gci5oaWRlRWRnZXNPblZpZXdwb3J0ICYmIHZwTWFuaXA7XG5cbiAgdmFyIG5lZWRNYkNsZWFyID0gW107XG5cbiAgbmVlZE1iQ2xlYXJbci5OT0RFXSA9ICFuZWVkRHJhd1tyLk5PREVdICYmIG1vdGlvbkJsdXIgJiYgIXIuY2xlYXJlZEZvck1vdGlvbkJsdXJbci5OT0RFXSB8fCByLmNsZWFyaW5nTW90aW9uQmx1cjtcbiAgaWYgKG5lZWRNYkNsZWFyW3IuTk9ERV0pIHtcbiAgICByLmNsZWFyZWRGb3JNb3Rpb25CbHVyW3IuTk9ERV0gPSB0cnVlO1xuICB9XG5cbiAgbmVlZE1iQ2xlYXJbci5EUkFHXSA9ICFuZWVkRHJhd1tyLkRSQUddICYmIG1vdGlvbkJsdXIgJiYgIXIuY2xlYXJlZEZvck1vdGlvbkJsdXJbci5EUkFHXSB8fCByLmNsZWFyaW5nTW90aW9uQmx1cjtcbiAgaWYgKG5lZWRNYkNsZWFyW3IuRFJBR10pIHtcbiAgICByLmNsZWFyZWRGb3JNb3Rpb25CbHVyW3IuRFJBR10gPSB0cnVlO1xuICB9XG5cbiAgaWYgKG5lZWREcmF3W3IuTk9ERV0gfHwgZHJhd0FsbExheWVycyB8fCBkcmF3T25seU5vZGVMYXllciB8fCBuZWVkTWJDbGVhcltyLk5PREVdKSB7XG4gICAgdmFyIHVzZUJ1ZmZlciA9IG1vdGlvbkJsdXIgJiYgIW5lZWRNYkNsZWFyW3IuTk9ERV0gJiYgbWJQeFJhdGlvICE9PSAxO1xuICAgIHZhciBjb250ZXh0ID0gZm9yY2VkQ29udGV4dCB8fCAodXNlQnVmZmVyID8gci5kYXRhLmJ1ZmZlckNvbnRleHRzW3IuTU9USU9OQkxVUl9CVUZGRVJfTk9ERV0gOiBkYXRhLmNvbnRleHRzW3IuTk9ERV0pO1xuICAgIHZhciBjbGVhciA9IG1vdGlvbkJsdXIgJiYgIXVzZUJ1ZmZlciA/ICdtb3Rpb25CbHVyJyA6IHVuZGVmaW5lZDtcblxuICAgIHNldENvbnRleHRUcmFuc2Zvcm0oY29udGV4dCwgY2xlYXIpO1xuXG4gICAgaWYgKGhpZGVFZGdlcykge1xuICAgICAgci5kcmF3Q2FjaGVkTm9kZXMoY29udGV4dCwgZWxlcy5ub25kcmFnLCBwaXhlbFJhdGlvLCBleHRlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByLmRyYXdMYXllcmVkRWxlbWVudHMoY29udGV4dCwgZWxlcy5ub25kcmFnLCBwaXhlbFJhdGlvLCBleHRlbnQpO1xuICAgIH1cblxuICAgIGlmIChyLmRlYnVnKSB7XG4gICAgICByLmRyYXdEZWJ1Z1BvaW50cyhjb250ZXh0LCBlbGVzLm5vbmRyYWcpO1xuICAgIH1cblxuICAgIGlmICghZHJhd0FsbExheWVycyAmJiAhbW90aW9uQmx1cikge1xuICAgICAgbmVlZERyYXdbci5OT0RFXSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghZHJhd09ubHlOb2RlTGF5ZXIgJiYgKG5lZWREcmF3W3IuRFJBR10gfHwgZHJhd0FsbExheWVycyB8fCBuZWVkTWJDbGVhcltyLkRSQUddKSkge1xuICAgIHZhciB1c2VCdWZmZXIgPSBtb3Rpb25CbHVyICYmICFuZWVkTWJDbGVhcltyLkRSQUddICYmIG1iUHhSYXRpbyAhPT0gMTtcbiAgICB2YXIgY29udGV4dCA9IGZvcmNlZENvbnRleHQgfHwgKHVzZUJ1ZmZlciA/IHIuZGF0YS5idWZmZXJDb250ZXh0c1tyLk1PVElPTkJMVVJfQlVGRkVSX0RSQUddIDogZGF0YS5jb250ZXh0c1tyLkRSQUddKTtcblxuICAgIHNldENvbnRleHRUcmFuc2Zvcm0oY29udGV4dCwgbW90aW9uQmx1ciAmJiAhdXNlQnVmZmVyID8gJ21vdGlvbkJsdXInIDogdW5kZWZpbmVkKTtcblxuICAgIGlmIChoaWRlRWRnZXMpIHtcbiAgICAgIHIuZHJhd0NhY2hlZE5vZGVzKGNvbnRleHQsIGVsZXMuZHJhZywgcGl4ZWxSYXRpbywgZXh0ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgci5kcmF3Q2FjaGVkRWxlbWVudHMoY29udGV4dCwgZWxlcy5kcmFnLCBwaXhlbFJhdGlvLCBleHRlbnQpO1xuICAgIH1cblxuICAgIGlmIChyLmRlYnVnKSB7XG4gICAgICByLmRyYXdEZWJ1Z1BvaW50cyhjb250ZXh0LCBlbGVzLmRyYWcpO1xuICAgIH1cblxuICAgIGlmICghZHJhd0FsbExheWVycyAmJiAhbW90aW9uQmx1cikge1xuICAgICAgbmVlZERyYXdbci5EUkFHXSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChyLnNob3dGcHMgfHwgIWRyYXdPbmx5Tm9kZUxheWVyICYmIG5lZWREcmF3W3IuU0VMRUNUX0JPWF0gJiYgIWRyYXdBbGxMYXllcnMpIHtcbiAgICB2YXIgY29udGV4dCA9IGZvcmNlZENvbnRleHQgfHwgZGF0YS5jb250ZXh0c1tyLlNFTEVDVF9CT1hdO1xuXG4gICAgc2V0Q29udGV4dFRyYW5zZm9ybShjb250ZXh0KTtcblxuICAgIGlmIChyLnNlbGVjdGlvbls0XSA9PSAxICYmIChyLmhvdmVyRGF0YS5zZWxlY3RpbmcgfHwgci50b3VjaERhdGEuc2VsZWN0aW5nKSkge1xuICAgICAgdmFyIHpvb20gPSByLmN5Lnpvb20oKTtcbiAgICAgIHZhciBib3JkZXJXaWR0aCA9IGNvcmVTdHlsZVsnc2VsZWN0aW9uLWJveC1ib3JkZXItd2lkdGgnXS52YWx1ZSAvIHpvb207XG5cbiAgICAgIGNvbnRleHQubGluZVdpZHRoID0gYm9yZGVyV2lkdGg7XG4gICAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICdyZ2JhKCcgKyBjb3JlU3R5bGVbJ3NlbGVjdGlvbi1ib3gtY29sb3InXS52YWx1ZVswXSArICcsJyArIGNvcmVTdHlsZVsnc2VsZWN0aW9uLWJveC1jb2xvciddLnZhbHVlWzFdICsgJywnICsgY29yZVN0eWxlWydzZWxlY3Rpb24tYm94LWNvbG9yJ10udmFsdWVbMl0gKyAnLCcgKyBjb3JlU3R5bGVbJ3NlbGVjdGlvbi1ib3gtb3BhY2l0eSddLnZhbHVlICsgJyknO1xuXG4gICAgICBjb250ZXh0LmZpbGxSZWN0KHIuc2VsZWN0aW9uWzBdLCByLnNlbGVjdGlvblsxXSwgci5zZWxlY3Rpb25bMl0gLSByLnNlbGVjdGlvblswXSwgci5zZWxlY3Rpb25bM10gLSByLnNlbGVjdGlvblsxXSk7XG5cbiAgICAgIGlmIChib3JkZXJXaWR0aCA+IDApIHtcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9ICdyZ2JhKCcgKyBjb3JlU3R5bGVbJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLWNvbG9yJ10udmFsdWVbMF0gKyAnLCcgKyBjb3JlU3R5bGVbJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLWNvbG9yJ10udmFsdWVbMV0gKyAnLCcgKyBjb3JlU3R5bGVbJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLWNvbG9yJ10udmFsdWVbMl0gKyAnLCcgKyBjb3JlU3R5bGVbJ3NlbGVjdGlvbi1ib3gtb3BhY2l0eSddLnZhbHVlICsgJyknO1xuXG4gICAgICAgIGNvbnRleHQuc3Ryb2tlUmVjdChyLnNlbGVjdGlvblswXSwgci5zZWxlY3Rpb25bMV0sIHIuc2VsZWN0aW9uWzJdIC0gci5zZWxlY3Rpb25bMF0sIHIuc2VsZWN0aW9uWzNdIC0gci5zZWxlY3Rpb25bMV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkYXRhLmJnQWN0aXZlUG9zaXN0aW9uICYmICFyLmhvdmVyRGF0YS5zZWxlY3RpbmcpIHtcbiAgICAgIHZhciB6b29tID0gci5jeS56b29tKCk7XG4gICAgICB2YXIgcG9zID0gZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbjtcblxuICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAncmdiYSgnICsgY29yZVN0eWxlWydhY3RpdmUtYmctY29sb3InXS52YWx1ZVswXSArICcsJyArIGNvcmVTdHlsZVsnYWN0aXZlLWJnLWNvbG9yJ10udmFsdWVbMV0gKyAnLCcgKyBjb3JlU3R5bGVbJ2FjdGl2ZS1iZy1jb2xvciddLnZhbHVlWzJdICsgJywnICsgY29yZVN0eWxlWydhY3RpdmUtYmctb3BhY2l0eSddLnZhbHVlICsgJyknO1xuXG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgY29udGV4dC5hcmMocG9zLngsIHBvcy55LCBjb3JlU3R5bGVbJ2FjdGl2ZS1iZy1zaXplJ10ucGZWYWx1ZSAvIHpvb20sIDAsIDIgKiBNYXRoLlBJKTtcbiAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgIH1cblxuICAgIHZhciB0aW1lVG9SZW5kZXIgPSByLmxhc3RSZWRyYXdUaW1lO1xuICAgIGlmIChyLnNob3dGcHMgJiYgdGltZVRvUmVuZGVyKSB7XG4gICAgICB0aW1lVG9SZW5kZXIgPSBNYXRoLnJvdW5kKHRpbWVUb1JlbmRlcik7XG4gICAgICB2YXIgZnBzID0gTWF0aC5yb3VuZCgxMDAwIC8gdGltZVRvUmVuZGVyKTtcblxuICAgICAgY29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG5cbiAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJ3JnYmEoMjU1LCAwLCAwLCAwLjc1KSc7XG4gICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gJ3JnYmEoMjU1LCAwLCAwLCAwLjc1KSc7XG4gICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IDE7XG4gICAgICBjb250ZXh0LmZpbGxUZXh0KCcxIGZyYW1lID0gJyArIHRpbWVUb1JlbmRlciArICcgbXMgPSAnICsgZnBzICsgJyBmcHMnLCAwLCAyMCk7XG5cbiAgICAgIHZhciBtYXhGcHMgPSA2MDtcbiAgICAgIGNvbnRleHQuc3Ryb2tlUmVjdCgwLCAzMCwgMjUwLCAyMCk7XG4gICAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDMwLCAyNTAgKiBNYXRoLm1pbihmcHMgLyBtYXhGcHMsIDEpLCAyMCk7XG4gICAgfVxuXG4gICAgaWYgKCFkcmF3QWxsTGF5ZXJzKSB7XG4gICAgICBuZWVkRHJhd1tyLlNFTEVDVF9CT1hdID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLy8gbW90aW9uYmx1cjogYmxpdCByZW5kZXJlZCBibHVycnkgZnJhbWVzXG4gIGlmIChtb3Rpb25CbHVyICYmIG1iUHhSYXRpbyAhPT0gMSkge1xuICAgIHZhciBjeHROb2RlID0gZGF0YS5jb250ZXh0c1tyLk5PREVdO1xuICAgIHZhciB0eHROb2RlID0gci5kYXRhLmJ1ZmZlckNhbnZhc2VzW3IuTU9USU9OQkxVUl9CVUZGRVJfTk9ERV07XG5cbiAgICB2YXIgY3h0RHJhZyA9IGRhdGEuY29udGV4dHNbci5EUkFHXTtcbiAgICB2YXIgdHh0RHJhZyA9IHIuZGF0YS5idWZmZXJDYW52YXNlc1tyLk1PVElPTkJMVVJfQlVGRkVSX0RSQUddO1xuXG4gICAgdmFyIGRyYXdNb3Rpb25CbHVyID0gZnVuY3Rpb24gZHJhd01vdGlvbkJsdXIoY3h0LCB0eHQsIG5lZWRDbGVhcikge1xuICAgICAgY3h0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcblxuICAgICAgaWYgKG5lZWRDbGVhciB8fCAhbW90aW9uQmx1ckZhZGVFZmZlY3QpIHtcbiAgICAgICAgY3h0LmNsZWFyUmVjdCgwLCAwLCByLmNhbnZhc1dpZHRoLCByLmNhbnZhc0hlaWdodCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYmNsZWFyKGN4dCwgMCwgMCwgci5jYW52YXNXaWR0aCwgci5jYW52YXNIZWlnaHQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHhyID0gbWJQeFJhdGlvO1xuXG4gICAgICBjeHQuZHJhd0ltYWdlKHR4dCwgLy8gaW1nXG4gICAgICAwLCAwLCAvLyBzeCwgc3lcbiAgICAgIHIuY2FudmFzV2lkdGggKiBweHIsIHIuY2FudmFzSGVpZ2h0ICogcHhyLCAvLyBzdywgc2hcbiAgICAgIDAsIDAsIC8vIHgsIHlcbiAgICAgIHIuY2FudmFzV2lkdGgsIHIuY2FudmFzSGVpZ2h0IC8vIHcsIGhcbiAgICAgICk7XG4gICAgfTtcblxuICAgIGlmIChuZWVkRHJhd1tyLk5PREVdIHx8IG5lZWRNYkNsZWFyW3IuTk9ERV0pIHtcbiAgICAgIGRyYXdNb3Rpb25CbHVyKGN4dE5vZGUsIHR4dE5vZGUsIG5lZWRNYkNsZWFyW3IuTk9ERV0pO1xuICAgICAgbmVlZERyYXdbci5OT0RFXSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChuZWVkRHJhd1tyLkRSQUddIHx8IG5lZWRNYkNsZWFyW3IuRFJBR10pIHtcbiAgICAgIGRyYXdNb3Rpb25CbHVyKGN4dERyYWcsIHR4dERyYWcsIG5lZWRNYkNsZWFyW3IuRFJBR10pO1xuICAgICAgbmVlZERyYXdbci5EUkFHXSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHIucHJldlZpZXdwb3J0ID0gdnA7XG5cbiAgaWYgKHIuY2xlYXJpbmdNb3Rpb25CbHVyKSB7XG4gICAgci5jbGVhcmluZ01vdGlvbkJsdXIgPSBmYWxzZTtcbiAgICByLm1vdGlvbkJsdXJDbGVhcmVkID0gdHJ1ZTtcbiAgICByLm1vdGlvbkJsdXIgPSB0cnVlO1xuICB9XG5cbiAgaWYgKG1vdGlvbkJsdXIpIHtcbiAgICByLm1vdGlvbkJsdXJUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICByLm1vdGlvbkJsdXJUaW1lb3V0ID0gbnVsbDtcblxuICAgICAgci5jbGVhcmVkRm9yTW90aW9uQmx1cltyLk5PREVdID0gZmFsc2U7XG4gICAgICByLmNsZWFyZWRGb3JNb3Rpb25CbHVyW3IuRFJBR10gPSBmYWxzZTtcbiAgICAgIHIubW90aW9uQmx1ciA9IGZhbHNlO1xuICAgICAgci5jbGVhcmluZ01vdGlvbkJsdXIgPSAhdGV4dHVyZURyYXc7XG4gICAgICByLm1iRnJhbWVzID0gMDtcblxuICAgICAgbmVlZERyYXdbci5OT0RFXSA9IHRydWU7XG4gICAgICBuZWVkRHJhd1tyLkRSQUddID0gdHJ1ZTtcblxuICAgICAgci5yZWRyYXcoKTtcbiAgICB9LCBtb3Rpb25CbHVyRGVsYXkpO1xuICB9XG5cbiAgaWYgKCFmb3JjZWRDb250ZXh0KSB7XG4gICAgY3kuZW1pdCgncmVuZGVyJyk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ1JwO1xuXG4vKioqLyB9KSxcbi8qIDEzMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgbWF0aCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBDUnAgPSB7fTtcblxuLy8gQE8gUG9seWdvbiBkcmF3aW5nXG5DUnAuZHJhd1BvbHlnb25QYXRoID0gZnVuY3Rpb24gKGNvbnRleHQsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHBvaW50cykge1xuXG4gIHZhciBoYWxmVyA9IHdpZHRoIC8gMjtcbiAgdmFyIGhhbGZIID0gaGVpZ2h0IC8gMjtcblxuICBpZiAoY29udGV4dC5iZWdpblBhdGgpIHtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICB9XG5cbiAgY29udGV4dC5tb3ZlVG8oeCArIGhhbGZXICogcG9pbnRzWzBdLCB5ICsgaGFsZkggKiBwb2ludHNbMV0pO1xuXG4gIGZvciAodmFyIGkgPSAxOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgIGNvbnRleHQubGluZVRvKHggKyBoYWxmVyAqIHBvaW50c1tpICogMl0sIHkgKyBoYWxmSCAqIHBvaW50c1tpICogMiArIDFdKTtcbiAgfVxuXG4gIGNvbnRleHQuY2xvc2VQYXRoKCk7XG59O1xuXG4vLyBSb3VuZCByZWN0YW5nbGUgZHJhd2luZ1xuQ1JwLmRyYXdSb3VuZFJlY3RhbmdsZVBhdGggPSBmdW5jdGlvbiAoY29udGV4dCwgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuXG4gIHZhciBoYWxmV2lkdGggPSB3aWR0aCAvIDI7XG4gIHZhciBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMjtcbiAgdmFyIGNvcm5lclJhZGl1cyA9IG1hdGguZ2V0Um91bmRSZWN0YW5nbGVSYWRpdXMod2lkdGgsIGhlaWdodCk7XG5cbiAgaWYgKGNvbnRleHQuYmVnaW5QYXRoKSB7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgfVxuXG4gIC8vIFN0YXJ0IGF0IHRvcCBtaWRkbGVcbiAgY29udGV4dC5tb3ZlVG8oeCwgeSAtIGhhbGZIZWlnaHQpO1xuICAvLyBBcmMgZnJvbSBtaWRkbGUgdG9wIHRvIHJpZ2h0IHNpZGVcbiAgY29udGV4dC5hcmNUbyh4ICsgaGFsZldpZHRoLCB5IC0gaGFsZkhlaWdodCwgeCArIGhhbGZXaWR0aCwgeSwgY29ybmVyUmFkaXVzKTtcbiAgLy8gQXJjIGZyb20gcmlnaHQgc2lkZSB0byBib3R0b21cbiAgY29udGV4dC5hcmNUbyh4ICsgaGFsZldpZHRoLCB5ICsgaGFsZkhlaWdodCwgeCwgeSArIGhhbGZIZWlnaHQsIGNvcm5lclJhZGl1cyk7XG4gIC8vIEFyYyBmcm9tIGJvdHRvbSB0byBsZWZ0IHNpZGVcbiAgY29udGV4dC5hcmNUbyh4IC0gaGFsZldpZHRoLCB5ICsgaGFsZkhlaWdodCwgeCAtIGhhbGZXaWR0aCwgeSwgY29ybmVyUmFkaXVzKTtcbiAgLy8gQXJjIGZyb20gbGVmdCBzaWRlIHRvIHRvcEJvcmRlclxuICBjb250ZXh0LmFyY1RvKHggLSBoYWxmV2lkdGgsIHkgLSBoYWxmSGVpZ2h0LCB4LCB5IC0gaGFsZkhlaWdodCwgY29ybmVyUmFkaXVzKTtcbiAgLy8gSm9pbiBsaW5lXG4gIGNvbnRleHQubGluZVRvKHgsIHkgLSBoYWxmSGVpZ2h0KTtcblxuICBjb250ZXh0LmNsb3NlUGF0aCgpO1xufTtcblxuQ1JwLmRyYXdCb3R0b21Sb3VuZFJlY3RhbmdsZVBhdGggPSBmdW5jdGlvbiAoY29udGV4dCwgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuXG4gIHZhciBoYWxmV2lkdGggPSB3aWR0aCAvIDI7XG4gIHZhciBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMjtcbiAgdmFyIGNvcm5lclJhZGl1cyA9IG1hdGguZ2V0Um91bmRSZWN0YW5nbGVSYWRpdXMod2lkdGgsIGhlaWdodCk7XG5cbiAgaWYgKGNvbnRleHQuYmVnaW5QYXRoKSB7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgfVxuXG4gIC8vIFN0YXJ0IGF0IHRvcCBtaWRkbGVcbiAgY29udGV4dC5tb3ZlVG8oeCwgeSAtIGhhbGZIZWlnaHQpO1xuICBjb250ZXh0LmxpbmVUbyh4ICsgaGFsZldpZHRoLCB5IC0gaGFsZkhlaWdodCk7XG4gIGNvbnRleHQubGluZVRvKHggKyBoYWxmV2lkdGgsIHkpO1xuXG4gIGNvbnRleHQuYXJjVG8oeCArIGhhbGZXaWR0aCwgeSArIGhhbGZIZWlnaHQsIHgsIHkgKyBoYWxmSGVpZ2h0LCBjb3JuZXJSYWRpdXMpO1xuICBjb250ZXh0LmFyY1RvKHggLSBoYWxmV2lkdGgsIHkgKyBoYWxmSGVpZ2h0LCB4IC0gaGFsZldpZHRoLCB5LCBjb3JuZXJSYWRpdXMpO1xuXG4gIGNvbnRleHQubGluZVRvKHggLSBoYWxmV2lkdGgsIHkgLSBoYWxmSGVpZ2h0KTtcbiAgY29udGV4dC5saW5lVG8oeCwgeSAtIGhhbGZIZWlnaHQpO1xuXG4gIGNvbnRleHQuY2xvc2VQYXRoKCk7XG59O1xuXG5DUnAuZHJhd0N1dFJlY3RhbmdsZVBhdGggPSBmdW5jdGlvbiAoY29udGV4dCwgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuXG4gIHZhciBoYWxmV2lkdGggPSB3aWR0aCAvIDI7XG4gIHZhciBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMjtcbiAgdmFyIGNvcm5lckxlbmd0aCA9IG1hdGguZ2V0Q3V0UmVjdGFuZ2xlQ29ybmVyTGVuZ3RoKCk7XG5cbiAgaWYgKGNvbnRleHQuYmVnaW5QYXRoKSB7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgfVxuXG4gIGNvbnRleHQubW92ZVRvKHggLSBoYWxmV2lkdGggKyBjb3JuZXJMZW5ndGgsIHkgLSBoYWxmSGVpZ2h0KTtcblxuICBjb250ZXh0LmxpbmVUbyh4ICsgaGFsZldpZHRoIC0gY29ybmVyTGVuZ3RoLCB5IC0gaGFsZkhlaWdodCk7XG4gIGNvbnRleHQubGluZVRvKHggKyBoYWxmV2lkdGgsIHkgLSBoYWxmSGVpZ2h0ICsgY29ybmVyTGVuZ3RoKTtcbiAgY29udGV4dC5saW5lVG8oeCArIGhhbGZXaWR0aCwgeSArIGhhbGZIZWlnaHQgLSBjb3JuZXJMZW5ndGgpO1xuICBjb250ZXh0LmxpbmVUbyh4ICsgaGFsZldpZHRoIC0gY29ybmVyTGVuZ3RoLCB5ICsgaGFsZkhlaWdodCk7XG4gIGNvbnRleHQubGluZVRvKHggLSBoYWxmV2lkdGggKyBjb3JuZXJMZW5ndGgsIHkgKyBoYWxmSGVpZ2h0KTtcbiAgY29udGV4dC5saW5lVG8oeCAtIGhhbGZXaWR0aCwgeSArIGhhbGZIZWlnaHQgLSBjb3JuZXJMZW5ndGgpO1xuICBjb250ZXh0LmxpbmVUbyh4IC0gaGFsZldpZHRoLCB5IC0gaGFsZkhlaWdodCArIGNvcm5lckxlbmd0aCk7XG5cbiAgY29udGV4dC5jbG9zZVBhdGgoKTtcbn07XG5cbkNScC5kcmF3QmFycmVsUGF0aCA9IGZ1bmN0aW9uIChjb250ZXh0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG5cbiAgdmFyIGhhbGZXaWR0aCA9IHdpZHRoIC8gMjtcbiAgdmFyIGhhbGZIZWlnaHQgPSBoZWlnaHQgLyAyO1xuXG4gIHZhciB4QmVnaW4gPSB4IC0gaGFsZldpZHRoO1xuICB2YXIgeEVuZCA9IHggKyBoYWxmV2lkdGg7XG4gIHZhciB5QmVnaW4gPSB5IC0gaGFsZkhlaWdodDtcbiAgdmFyIHlFbmQgPSB5ICsgaGFsZkhlaWdodDtcblxuICB2YXIgYmFycmVsQ3VydmVDb25zdGFudHMgPSBtYXRoLmdldEJhcnJlbEN1cnZlQ29uc3RhbnRzKHdpZHRoLCBoZWlnaHQpO1xuICB2YXIgd09mZnNldCA9IGJhcnJlbEN1cnZlQ29uc3RhbnRzLndpZHRoT2Zmc2V0O1xuICB2YXIgaE9mZnNldCA9IGJhcnJlbEN1cnZlQ29uc3RhbnRzLmhlaWdodE9mZnNldDtcbiAgdmFyIGN0cmxQdFhPZmZzZXQgPSBiYXJyZWxDdXJ2ZUNvbnN0YW50cy5jdHJsUHRPZmZzZXRQY3QgKiB3T2Zmc2V0O1xuXG4gIGlmIChjb250ZXh0LmJlZ2luUGF0aCkge1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIH1cblxuICBjb250ZXh0Lm1vdmVUbyh4QmVnaW4sIHlCZWdpbiArIGhPZmZzZXQpO1xuXG4gIGNvbnRleHQubGluZVRvKHhCZWdpbiwgeUVuZCAtIGhPZmZzZXQpO1xuICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oeEJlZ2luICsgY3RybFB0WE9mZnNldCwgeUVuZCwgeEJlZ2luICsgd09mZnNldCwgeUVuZCk7XG5cbiAgY29udGV4dC5saW5lVG8oeEVuZCAtIHdPZmZzZXQsIHlFbmQpO1xuICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oeEVuZCAtIGN0cmxQdFhPZmZzZXQsIHlFbmQsIHhFbmQsIHlFbmQgLSBoT2Zmc2V0KTtcblxuICBjb250ZXh0LmxpbmVUbyh4RW5kLCB5QmVnaW4gKyBoT2Zmc2V0KTtcbiAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHhFbmQgLSBjdHJsUHRYT2Zmc2V0LCB5QmVnaW4sIHhFbmQgLSB3T2Zmc2V0LCB5QmVnaW4pO1xuXG4gIGNvbnRleHQubGluZVRvKHhCZWdpbiArIHdPZmZzZXQsIHlCZWdpbik7XG4gIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyh4QmVnaW4gKyBjdHJsUHRYT2Zmc2V0LCB5QmVnaW4sIHhCZWdpbiwgeUJlZ2luICsgaE9mZnNldCk7XG5cbiAgY29udGV4dC5jbG9zZVBhdGgoKTtcbn07XG5cbnZhciBzaW4wID0gTWF0aC5zaW4oMCk7XG52YXIgY29zMCA9IE1hdGguY29zKDApO1xuXG52YXIgc2luID0ge307XG52YXIgY29zID0ge307XG5cbnZhciBlbGxpcHNlU3RlcFNpemUgPSBNYXRoLlBJIC8gNDA7XG5cbmZvciAodmFyIGkgPSAwICogTWF0aC5QSTsgaSA8IDIgKiBNYXRoLlBJOyBpICs9IGVsbGlwc2VTdGVwU2l6ZSkge1xuICBzaW5baV0gPSBNYXRoLnNpbihpKTtcbiAgY29zW2ldID0gTWF0aC5jb3MoaSk7XG59XG5cbkNScC5kcmF3RWxsaXBzZVBhdGggPSBmdW5jdGlvbiAoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCkge1xuICBpZiAoY29udGV4dC5iZWdpblBhdGgpIHtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICB9XG5cbiAgaWYgKGNvbnRleHQuZWxsaXBzZSkge1xuICAgIGNvbnRleHQuZWxsaXBzZShjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIsIDAsIDAsIDIgKiBNYXRoLlBJKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgeFBvcywgeVBvcztcbiAgICB2YXIgcncgPSB3aWR0aCAvIDI7XG4gICAgdmFyIHJoID0gaGVpZ2h0IC8gMjtcbiAgICBmb3IgKHZhciBpID0gMCAqIE1hdGguUEk7IGkgPCAyICogTWF0aC5QSTsgaSArPSBlbGxpcHNlU3RlcFNpemUpIHtcbiAgICAgIHhQb3MgPSBjZW50ZXJYIC0gcncgKiBzaW5baV0gKiBzaW4wICsgcncgKiBjb3NbaV0gKiBjb3MwO1xuICAgICAgeVBvcyA9IGNlbnRlclkgKyByaCAqIGNvc1tpXSAqIHNpbjAgKyByaCAqIHNpbltpXSAqIGNvczA7XG5cbiAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIGNvbnRleHQubW92ZVRvKHhQb3MsIHlQb3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC5saW5lVG8oeFBvcywgeVBvcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29udGV4dC5jbG9zZVBhdGgoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ1JwO1xuXG4vKioqLyB9KSxcbi8qIDEzNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgQ1JwID0ge307XG5cbkNScC5jcmVhdGVCdWZmZXIgPSBmdW5jdGlvbiAodywgaCkge1xuICB2YXIgYnVmZmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgYnVmZmVyLndpZHRoID0gdztcbiAgYnVmZmVyLmhlaWdodCA9IGg7XG5cbiAgcmV0dXJuIFtidWZmZXIsIGJ1ZmZlci5nZXRDb250ZXh0KCcyZCcpXTtcbn07XG5cbkNScC5idWZmZXJDYW52YXNJbWFnZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBjeSA9IHRoaXMuY3k7XG4gIHZhciBlbGVzID0gY3kubXV0YWJsZUVsZW1lbnRzKCk7XG4gIHZhciBiYiA9IGVsZXMuYm91bmRpbmdCb3goKTtcbiAgdmFyIGN0clJlY3QgPSB0aGlzLmZpbmRDb250YWluZXJDbGllbnRDb29yZHMoKTtcbiAgdmFyIHdpZHRoID0gb3B0aW9ucy5mdWxsID8gTWF0aC5jZWlsKGJiLncpIDogY3RyUmVjdFsyXTtcbiAgdmFyIGhlaWdodCA9IG9wdGlvbnMuZnVsbCA/IE1hdGguY2VpbChiYi5oKSA6IGN0clJlY3RbM107XG4gIHZhciBzcGVjZE1heERpbXMgPSBpcy5udW1iZXIob3B0aW9ucy5tYXhXaWR0aCkgfHwgaXMubnVtYmVyKG9wdGlvbnMubWF4SGVpZ2h0KTtcbiAgdmFyIHB4UmF0aW8gPSB0aGlzLmdldFBpeGVsUmF0aW8oKTtcbiAgdmFyIHNjYWxlID0gMTtcblxuICBpZiAob3B0aW9ucy5zY2FsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgd2lkdGggKj0gb3B0aW9ucy5zY2FsZTtcbiAgICBoZWlnaHQgKj0gb3B0aW9ucy5zY2FsZTtcblxuICAgIHNjYWxlID0gb3B0aW9ucy5zY2FsZTtcbiAgfSBlbHNlIGlmIChzcGVjZE1heERpbXMpIHtcbiAgICB2YXIgbWF4U2NhbGVXID0gSW5maW5pdHk7XG4gICAgdmFyIG1heFNjYWxlSCA9IEluZmluaXR5O1xuXG4gICAgaWYgKGlzLm51bWJlcihvcHRpb25zLm1heFdpZHRoKSkge1xuICAgICAgbWF4U2NhbGVXID0gc2NhbGUgKiBvcHRpb25zLm1heFdpZHRoIC8gd2lkdGg7XG4gICAgfVxuXG4gICAgaWYgKGlzLm51bWJlcihvcHRpb25zLm1heEhlaWdodCkpIHtcbiAgICAgIG1heFNjYWxlSCA9IHNjYWxlICogb3B0aW9ucy5tYXhIZWlnaHQgLyBoZWlnaHQ7XG4gICAgfVxuXG4gICAgc2NhbGUgPSBNYXRoLm1pbihtYXhTY2FsZVcsIG1heFNjYWxlSCk7XG5cbiAgICB3aWR0aCAqPSBzY2FsZTtcbiAgICBoZWlnaHQgKj0gc2NhbGU7XG4gIH1cblxuICBpZiAoIXNwZWNkTWF4RGltcykge1xuICAgIHdpZHRoICo9IHB4UmF0aW87XG4gICAgaGVpZ2h0ICo9IHB4UmF0aW87XG4gICAgc2NhbGUgKj0gcHhSYXRpbztcbiAgfVxuXG4gIHZhciBidWZmQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICBidWZmQ2FudmFzLndpZHRoID0gd2lkdGg7XG4gIGJ1ZmZDYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gIGJ1ZmZDYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gIGJ1ZmZDYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcblxuICB2YXIgYnVmZkN4dCA9IGJ1ZmZDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAvLyBSYXN0ZXJpemUgdGhlIGxheWVycywgYnV0IG9ubHkgaWYgY29udGFpbmVyIGhhcyBub256ZXJvIHNpemVcbiAgaWYgKHdpZHRoID4gMCAmJiBoZWlnaHQgPiAwKSB7XG5cbiAgICBidWZmQ3h0LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgIGJ1ZmZDeHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ3NvdXJjZS1vdmVyJztcblxuICAgIHZhciB6c29ydGVkRWxlcyA9IHRoaXMuZ2V0Q2FjaGVkWlNvcnRlZEVsZXMoKTtcblxuICAgIGlmIChvcHRpb25zLmZ1bGwpIHtcbiAgICAgIC8vIGRyYXcgdGhlIGZ1bGwgYm91bmRzIG9mIHRoZSBncmFwaFxuICAgICAgYnVmZkN4dC50cmFuc2xhdGUoLWJiLngxICogc2NhbGUsIC1iYi55MSAqIHNjYWxlKTtcbiAgICAgIGJ1ZmZDeHQuc2NhbGUoc2NhbGUsIHNjYWxlKTtcblxuICAgICAgdGhpcy5kcmF3RWxlbWVudHMoYnVmZkN4dCwgenNvcnRlZEVsZXMpO1xuXG4gICAgICBidWZmQ3h0LnNjYWxlKDEgLyBzY2FsZSwgMSAvIHNjYWxlKTtcbiAgICAgIGJ1ZmZDeHQudHJhbnNsYXRlKGJiLngxICogc2NhbGUsIGJiLnkxICogc2NhbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBkcmF3IHRoZSBjdXJyZW50IHZpZXdcbiAgICAgIHZhciBwYW4gPSBjeS5wYW4oKTtcblxuICAgICAgdmFyIHRyYW5zbGF0aW9uID0ge1xuICAgICAgICB4OiBwYW4ueCAqIHNjYWxlLFxuICAgICAgICB5OiBwYW4ueSAqIHNjYWxlXG4gICAgICB9O1xuXG4gICAgICBzY2FsZSAqPSBjeS56b29tKCk7XG5cbiAgICAgIGJ1ZmZDeHQudHJhbnNsYXRlKHRyYW5zbGF0aW9uLngsIHRyYW5zbGF0aW9uLnkpO1xuICAgICAgYnVmZkN4dC5zY2FsZShzY2FsZSwgc2NhbGUpO1xuXG4gICAgICB0aGlzLmRyYXdFbGVtZW50cyhidWZmQ3h0LCB6c29ydGVkRWxlcyk7XG5cbiAgICAgIGJ1ZmZDeHQuc2NhbGUoMSAvIHNjYWxlLCAxIC8gc2NhbGUpO1xuICAgICAgYnVmZkN4dC50cmFuc2xhdGUoLXRyYW5zbGF0aW9uLngsIC10cmFuc2xhdGlvbi55KTtcbiAgICB9XG5cbiAgICAvLyBuZWVkIHRvIGZpbGwgYmcgYXQgZW5kIGxpa2UgdGhpcyBpbiBvcmRlciB0byBmaWxsIGNsZWFyZWQgdHJhbnNwYXJlbnQgcGl4ZWxzIGluIGpwZ3NcbiAgICBpZiAob3B0aW9ucy5iZykge1xuICAgICAgYnVmZkN4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24tb3Zlcic7XG5cbiAgICAgIGJ1ZmZDeHQuZmlsbFN0eWxlID0gb3B0aW9ucy5iZztcbiAgICAgIGJ1ZmZDeHQucmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGJ1ZmZDeHQuZmlsbCgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWZmQ2FudmFzO1xufTtcblxuZnVuY3Rpb24gYjY0VG9CbG9iKGI2NCwgbWltZVR5cGUpIHtcbiAgdmFyIGJ5dGVzID0gYXRvYihiNjQpO1xuICB2YXIgYnVmZiA9IG5ldyBBcnJheUJ1ZmZlcihieXRlcy5sZW5ndGgpO1xuICB2YXIgYnVmZlVpbnQ4ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZik7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgIGJ1ZmZVaW50OFtpXSA9IGJ5dGVzLmNoYXJDb2RlQXQoaSk7XG4gIH1cblxuICByZXR1cm4gbmV3IEJsb2IoW2J1ZmZdLCB7IHR5cGU6IG1pbWVUeXBlIH0pO1xufVxuXG5mdW5jdGlvbiBiNjRVcmlUb0I2NChiNjR1cmkpIHtcbiAgdmFyIGkgPSBiNjR1cmkuaW5kZXhPZignLCcpO1xuXG4gIHJldHVybiBiNjR1cmkuc3Vic3RyKGkgKyAxKTtcbn07XG5cbmZ1bmN0aW9uIG91dHB1dChvcHRpb25zLCBjYW52YXMsIG1pbWVUeXBlKSB7XG4gIHZhciBiNjRVcmkgPSBjYW52YXMudG9EYXRhVVJMKG1pbWVUeXBlLCBvcHRpb25zLnF1YWxpdHkpO1xuXG4gIHN3aXRjaCAob3B0aW9ucy5vdXRwdXQpIHtcbiAgICBjYXNlICdibG9iJzpcbiAgICAgIHJldHVybiBiNjRUb0Jsb2IoYjY0VXJpVG9CNjQoYjY0VXJpKSwgbWltZVR5cGUpO1xuXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldHVybiBiNjRVcmlUb0I2NChiNjRVcmkpO1xuXG4gICAgY2FzZSAnYmFzZTY0dXJpJzpcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGI2NFVyaTtcbiAgfVxufVxuXG5DUnAucG5nID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG91dHB1dChvcHRpb25zLCB0aGlzLmJ1ZmZlckNhbnZhc0ltYWdlKG9wdGlvbnMpLCAnaW1hZ2UvcG5nJyk7XG59O1xuXG5DUnAuanBnID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG91dHB1dChvcHRpb25zLCB0aGlzLmJ1ZmZlckNhbnZhc0ltYWdlKG9wdGlvbnMpLCAnaW1hZ2UvanBlZycpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDUnA7XG5cbi8qKiovIH0pLFxuLyogMTM1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBDUnAgPSB7fTtcblxuQ1JwLm5vZGVTaGFwZUltcGwgPSBmdW5jdGlvbiAobmFtZSwgY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgcG9pbnRzKSB7XG4gIHN3aXRjaCAobmFtZSkge1xuICAgIGNhc2UgJ2VsbGlwc2UnOlxuICAgICAgcmV0dXJuIHRoaXMuZHJhd0VsbGlwc2VQYXRoKGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpO1xuICAgIGNhc2UgJ3BvbHlnb24nOlxuICAgICAgcmV0dXJuIHRoaXMuZHJhd1BvbHlnb25QYXRoKGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIHBvaW50cyk7XG4gICAgY2FzZSAncm91bmRyZWN0YW5nbGUnOlxuICAgICAgcmV0dXJuIHRoaXMuZHJhd1JvdW5kUmVjdGFuZ2xlUGF0aChjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBjYXNlICdjdXRyZWN0YW5nbGUnOlxuICAgICAgcmV0dXJuIHRoaXMuZHJhd0N1dFJlY3RhbmdsZVBhdGgoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCk7XG4gICAgY2FzZSAnYm90dG9tcm91bmRyZWN0YW5nbGUnOlxuICAgICAgcmV0dXJuIHRoaXMuZHJhd0JvdHRvbVJvdW5kUmVjdGFuZ2xlUGF0aChjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBjYXNlICdiYXJyZWwnOlxuICAgICAgcmV0dXJuIHRoaXMuZHJhd0JhcnJlbFBhdGgoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ1JwO1xuXG4vKioqLyB9KSxcbi8qIDEzNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xudmFyIFN0eWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XG5cbi8vIGEgZHVtbXkgc3R5bGVzaGVldCBvYmplY3QgdGhhdCBkb2Vzbid0IG5lZWQgYSByZWZlcmVuY2UgdG8gdGhlIGNvcmVcbi8vICh1c2VmdWwgZm9yIGluaXQpXG52YXIgU3R5bGVzaGVldCA9IGZ1bmN0aW9uIFN0eWxlc2hlZXQoKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTdHlsZXNoZWV0KSkge1xuICAgIHJldHVybiBuZXcgU3R5bGVzaGVldCgpO1xuICB9XG5cbiAgdGhpcy5sZW5ndGggPSAwO1xufTtcblxudmFyIHNoZWV0Zm4gPSBTdHlsZXNoZWV0LnByb3RvdHlwZTtcblxuc2hlZXRmbi5pbnN0YW5jZVN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICdzdHlsZXNoZWV0Jztcbn07XG5cbi8vIGp1c3Qgc3RvcmUgdGhlIHNlbGVjdG9yIHRvIGJlIHBhcnNlZCBsYXRlclxuc2hlZXRmbi5zZWxlY3RvciA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICB2YXIgaSA9IHRoaXMubGVuZ3RoKys7XG5cbiAgdGhpc1tpXSA9IHtcbiAgICBzZWxlY3Rvcjogc2VsZWN0b3IsXG4gICAgcHJvcGVydGllczogW11cbiAgfTtcblxuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbi8vIGp1c3Qgc3RvcmUgdGhlIHByb3BlcnR5IHRvIGJlIHBhcnNlZCBsYXRlclxuc2hlZXRmbi5jc3MgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgdmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7XG5cbiAgaWYgKGlzLnN0cmluZyhuYW1lKSkge1xuICAgIHRoaXNbaV0ucHJvcGVydGllcy5wdXNoKHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogdmFsdWVcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChpcy5wbGFpbk9iamVjdChuYW1lKSkge1xuICAgIHZhciBtYXAgPSBuYW1lO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBTdHlsZS5wcm9wZXJ0aWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgcHJvcCA9IFN0eWxlLnByb3BlcnRpZXNbal07XG4gICAgICB2YXIgbWFwVmFsID0gbWFwW3Byb3AubmFtZV07XG5cbiAgICAgIGlmIChtYXBWYWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBhbHNvIHRyeSBjYW1lbCBjYXNlIG5hbWVcbiAgICAgICAgbWFwVmFsID0gbWFwW3V0aWwuZGFzaDJjYW1lbChwcm9wLm5hbWUpXTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1hcFZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBfbmFtZSA9IHByb3AubmFtZTtcbiAgICAgICAgdmFyIF92YWx1ZSA9IG1hcFZhbDtcblxuICAgICAgICB0aGlzW2ldLnByb3BlcnRpZXMucHVzaCh7XG4gICAgICAgICAgbmFtZTogX25hbWUsXG4gICAgICAgICAgdmFsdWU6IF92YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbnNoZWV0Zm4uc3R5bGUgPSBzaGVldGZuLmNzcztcblxuLy8gZ2VuZXJhdGUgYSByZWFsIHN0eWxlIG9iamVjdCBmcm9tIHRoZSBkdW1teSBzdHlsZXNoZWV0XG5zaGVldGZuLmdlbmVyYXRlU3R5bGUgPSBmdW5jdGlvbiAoY3kpIHtcbiAgdmFyIHN0eWxlID0gbmV3IFN0eWxlKGN5KTtcblxuICByZXR1cm4gdGhpcy5hcHBlbmRUb1N0eWxlKHN0eWxlKTtcbn07XG5cbi8vIGFwcGVuZCBhIGR1bW15IHN0eWxlc2hlZXQgb2JqZWN0IG9uIGEgcmVhbCBzdHlsZSBvYmplY3RcbnNoZWV0Zm4uYXBwZW5kVG9TdHlsZSA9IGZ1bmN0aW9uIChzdHlsZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY29udGV4dCA9IHRoaXNbaV07XG4gICAgdmFyIHNlbGVjdG9yID0gY29udGV4dC5zZWxlY3RvcjtcbiAgICB2YXIgcHJvcHMgPSBjb250ZXh0LnByb3BlcnRpZXM7XG5cbiAgICBzdHlsZS5zZWxlY3RvcihzZWxlY3Rvcik7IC8vIGFwcGx5IHNlbGVjdG9yXG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHByb3BzLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgcHJvcCA9IHByb3BzW2pdO1xuXG4gICAgICBzdHlsZS5jc3MocHJvcC5uYW1lLCBwcm9wLnZhbHVlKTsgLy8gYXBwbHkgcHJvcGVydHlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3R5bGU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0eWxlc2hlZXQ7XG5cbi8qKiovIH0pLFxuLyogMTM3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gXCIzLjIuMjBcIjtcblxuLyoqKi8gfSlcbi8qKioqKiovIF0pO1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY3l0b3NjYXBlL2Rpc3QvY3l0b3NjYXBlLmNqcy5qc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cblxuLyoqIFVzZWQgYXMgdGhlIGBUeXBlRXJyb3JgIG1lc3NhZ2UgZm9yIFwiRnVuY3Rpb25zXCIgbWV0aG9kcy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE5BTiA9IDAgLyAwO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuICovXG52YXIgcmVUcmltID0gL15cXHMrfFxccyskL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbnZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxuICAgIG5hdGl2ZU1pbiA9IE1hdGgubWluO1xuXG4vKipcbiAqIEdldHMgdGhlIHRpbWVzdGFtcCBvZiB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZVxuICogdGhlIFVuaXggZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IERhdGVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVzdGFtcC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5kZWZlcihmdW5jdGlvbihzdGFtcCkge1xuICogICBjb25zb2xlLmxvZyhfLm5vdygpIC0gc3RhbXApO1xuICogfSwgXy5ub3coKSk7XG4gKiAvLyA9PiBMb2dzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgZm9yIHRoZSBkZWZlcnJlZCBpbnZvY2F0aW9uLlxuICovXG52YXIgbm93ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiByb290LkRhdGUubm93KCk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdGhhdCBkZWxheXMgaW52b2tpbmcgYGZ1bmNgIHVudGlsIGFmdGVyIGB3YWl0YFxuICogbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gd2FzXG4gKiBpbnZva2VkLiBUaGUgZGVib3VuY2VkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYCBtZXRob2QgdG8gY2FuY2VsXG4gKiBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0byBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS5cbiAqIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZVxuICogbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZFxuICogd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbi4gU3Vic2VxdWVudFxuICogY2FsbHMgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2BcbiAqIGludm9jYXRpb24uXG4gKlxuICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb25cbiAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAqXG4gKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAqXG4gKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8uZGVib3VuY2VgIGFuZCBgXy50aHJvdHRsZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPWZhbHNlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhXYWl0XVxuICogIFRoZSBtYXhpbXVtIHRpbWUgYGZ1bmNgIGlzIGFsbG93ZWQgdG8gYmUgZGVsYXllZCBiZWZvcmUgaXQncyBpbnZva2VkLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWJvdW5jZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEF2b2lkIGNvc3RseSBjYWxjdWxhdGlvbnMgd2hpbGUgdGhlIHdpbmRvdyBzaXplIGlzIGluIGZsdXguXG4gKiBqUXVlcnkod2luZG93KS5vbigncmVzaXplJywgXy5kZWJvdW5jZShjYWxjdWxhdGVMYXlvdXQsIDE1MCkpO1xuICpcbiAqIC8vIEludm9rZSBgc2VuZE1haWxgIHdoZW4gY2xpY2tlZCwgZGVib3VuY2luZyBzdWJzZXF1ZW50IGNhbGxzLlxuICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIF8uZGVib3VuY2Uoc2VuZE1haWwsIDMwMCwge1xuICogICAnbGVhZGluZyc6IHRydWUsXG4gKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gKiB9KSk7XG4gKlxuICogLy8gRW5zdXJlIGBiYXRjaExvZ2AgaXMgaW52b2tlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxscy5cbiAqIHZhciBkZWJvdW5jZWQgPSBfLmRlYm91bmNlKGJhdGNoTG9nLCAyNTAsIHsgJ21heFdhaXQnOiAxMDAwIH0pO1xuICogdmFyIHNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZSgnL3N0cmVhbScpO1xuICogalF1ZXJ5KHNvdXJjZSkub24oJ21lc3NhZ2UnLCBkZWJvdW5jZWQpO1xuICpcbiAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgZGVib3VuY2VkIGludm9jYXRpb24uXG4gKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCBkZWJvdW5jZWQuY2FuY2VsKTtcbiAqL1xuZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICB2YXIgbGFzdEFyZ3MsXG4gICAgICBsYXN0VGhpcyxcbiAgICAgIG1heFdhaXQsXG4gICAgICByZXN1bHQsXG4gICAgICB0aW1lcklkLFxuICAgICAgbGFzdENhbGxUaW1lLFxuICAgICAgbGFzdEludm9rZVRpbWUgPSAwLFxuICAgICAgbGVhZGluZyA9IGZhbHNlLFxuICAgICAgbWF4aW5nID0gZmFsc2UsXG4gICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgd2FpdCA9IHRvTnVtYmVyKHdhaXQpIHx8IDA7XG4gIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgIGxlYWRpbmcgPSAhIW9wdGlvbnMubGVhZGluZztcbiAgICBtYXhpbmcgPSAnbWF4V2FpdCcgaW4gb3B0aW9ucztcbiAgICBtYXhXYWl0ID0gbWF4aW5nID8gbmF0aXZlTWF4KHRvTnVtYmVyKG9wdGlvbnMubWF4V2FpdCkgfHwgMCwgd2FpdCkgOiBtYXhXYWl0O1xuICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VGdW5jKHRpbWUpIHtcbiAgICB2YXIgYXJncyA9IGxhc3RBcmdzLFxuICAgICAgICB0aGlzQXJnID0gbGFzdFRoaXM7XG5cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBsZWFkaW5nRWRnZSh0aW1lKSB7XG4gICAgLy8gUmVzZXQgYW55IGBtYXhXYWl0YCB0aW1lci5cbiAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgLy8gU3RhcnQgdGhlIHRpbWVyIGZvciB0aGUgdHJhaWxpbmcgZWRnZS5cbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIC8vIEludm9rZSB0aGUgbGVhZGluZyBlZGdlLlxuICAgIHJldHVybiBsZWFkaW5nID8gaW52b2tlRnVuYyh0aW1lKSA6IHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbWFpbmluZ1dhaXQodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWUsXG4gICAgICAgIHJlc3VsdCA9IHdhaXQgLSB0aW1lU2luY2VMYXN0Q2FsbDtcblxuICAgIHJldHVybiBtYXhpbmcgPyBuYXRpdmVNaW4ocmVzdWx0LCBtYXhXYWl0IC0gdGltZVNpbmNlTGFzdEludm9rZSkgOiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRJbnZva2UodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWU7XG5cbiAgICAvLyBFaXRoZXIgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCwgYWN0aXZpdHkgaGFzIHN0b3BwZWQgYW5kIHdlJ3JlIGF0IHRoZVxuICAgIC8vIHRyYWlsaW5nIGVkZ2UsIHRoZSBzeXN0ZW0gdGltZSBoYXMgZ29uZSBiYWNrd2FyZHMgYW5kIHdlJ3JlIHRyZWF0aW5nXG4gICAgLy8gaXQgYXMgdGhlIHRyYWlsaW5nIGVkZ2UsIG9yIHdlJ3ZlIGhpdCB0aGUgYG1heFdhaXRgIGxpbWl0LlxuICAgIHJldHVybiAobGFzdENhbGxUaW1lID09PSB1bmRlZmluZWQgfHwgKHRpbWVTaW5jZUxhc3RDYWxsID49IHdhaXQpIHx8XG4gICAgICAodGltZVNpbmNlTGFzdENhbGwgPCAwKSB8fCAobWF4aW5nICYmIHRpbWVTaW5jZUxhc3RJbnZva2UgPj0gbWF4V2FpdCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGltZXJFeHBpcmVkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCk7XG4gICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xuICAgICAgcmV0dXJuIHRyYWlsaW5nRWRnZSh0aW1lKTtcbiAgICB9XG4gICAgLy8gUmVzdGFydCB0aGUgdGltZXIuXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCByZW1haW5pbmdXYWl0KHRpbWUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYWlsaW5nRWRnZSh0aW1lKSB7XG4gICAgdGltZXJJZCA9IHVuZGVmaW5lZDtcblxuICAgIC8vIE9ubHkgaW52b2tlIGlmIHdlIGhhdmUgYGxhc3RBcmdzYCB3aGljaCBtZWFucyBgZnVuY2AgaGFzIGJlZW5cbiAgICAvLyBkZWJvdW5jZWQgYXQgbGVhc3Qgb25jZS5cbiAgICBpZiAodHJhaWxpbmcgJiYgbGFzdEFyZ3MpIHtcbiAgICAgIHJldHVybiBpbnZva2VGdW5jKHRpbWUpO1xuICAgIH1cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgaWYgKHRpbWVySWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgIH1cbiAgICBsYXN0SW52b2tlVGltZSA9IDA7XG4gICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICByZXR1cm4gdGltZXJJZCA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogdHJhaWxpbmdFZGdlKG5vdygpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICB2YXIgdGltZSA9IG5vdygpLFxuICAgICAgICBpc0ludm9raW5nID0gc2hvdWxkSW52b2tlKHRpbWUpO1xuXG4gICAgbGFzdEFyZ3MgPSBhcmd1bWVudHM7XG4gICAgbGFzdFRoaXMgPSB0aGlzO1xuICAgIGxhc3RDYWxsVGltZSA9IHRpbWU7XG5cbiAgICBpZiAoaXNJbnZva2luZykge1xuICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbGVhZGluZ0VkZ2UobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXhpbmcpIHtcbiAgICAgICAgLy8gSGFuZGxlIGludm9jYXRpb25zIGluIGEgdGlnaHQgbG9vcC5cbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgcmV0dXJuIGludm9rZUZ1bmMobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcbiAgcmV0dXJuIGRlYm91bmNlZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9OdW1iZXIoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAqIC8vID0+IEluZmluaXR5XG4gKlxuICogXy50b051bWJlcignMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIE5BTjtcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICB9XG4gIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZVRyaW0sICcnKTtcbiAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG4gICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGVib3VuY2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2guZGVib3VuY2UvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9oZWFwJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9oZWFwL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS44LjBcbihmdW5jdGlvbigpIHtcbiAgdmFyIEhlYXAsIGRlZmF1bHRDbXAsIGZsb29yLCBoZWFwaWZ5LCBoZWFwcG9wLCBoZWFwcHVzaCwgaGVhcHB1c2hwb3AsIGhlYXByZXBsYWNlLCBpbnNvcnQsIG1pbiwgbmxhcmdlc3QsIG5zbWFsbGVzdCwgdXBkYXRlSXRlbSwgX3NpZnRkb3duLCBfc2lmdHVwO1xuXG4gIGZsb29yID0gTWF0aC5mbG9vciwgbWluID0gTWF0aC5taW47XG5cblxuICAvKlxuICBEZWZhdWx0IGNvbXBhcmlzb24gZnVuY3Rpb24gdG8gYmUgdXNlZFxuICAgKi9cblxuICBkZWZhdWx0Q21wID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIGlmICh4IDwgeSkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBpZiAoeCA+IHkpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfTtcblxuXG4gIC8qXG4gIEluc2VydCBpdGVtIHggaW4gbGlzdCBhLCBhbmQga2VlcCBpdCBzb3J0ZWQgYXNzdW1pbmcgYSBpcyBzb3J0ZWQuXG4gIFxuICBJZiB4IGlzIGFscmVhZHkgaW4gYSwgaW5zZXJ0IGl0IHRvIHRoZSByaWdodCBvZiB0aGUgcmlnaHRtb3N0IHguXG4gIFxuICBPcHRpb25hbCBhcmdzIGxvIChkZWZhdWx0IDApIGFuZCBoaSAoZGVmYXVsdCBhLmxlbmd0aCkgYm91bmQgdGhlIHNsaWNlXG4gIG9mIGEgdG8gYmUgc2VhcmNoZWQuXG4gICAqL1xuXG4gIGluc29ydCA9IGZ1bmN0aW9uKGEsIHgsIGxvLCBoaSwgY21wKSB7XG4gICAgdmFyIG1pZDtcbiAgICBpZiAobG8gPT0gbnVsbCkge1xuICAgICAgbG8gPSAwO1xuICAgIH1cbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIGlmIChsbyA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbG8gbXVzdCBiZSBub24tbmVnYXRpdmUnKTtcbiAgICB9XG4gICAgaWYgKGhpID09IG51bGwpIHtcbiAgICAgIGhpID0gYS5sZW5ndGg7XG4gICAgfVxuICAgIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgICBtaWQgPSBmbG9vcigobG8gKyBoaSkgLyAyKTtcbiAgICAgIGlmIChjbXAoeCwgYVttaWRdKSA8IDApIHtcbiAgICAgICAgaGkgPSBtaWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsbyA9IG1pZCArIDE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoW10uc3BsaWNlLmFwcGx5KGEsIFtsbywgbG8gLSBsb10uY29uY2F0KHgpKSwgeCk7XG4gIH07XG5cblxuICAvKlxuICBQdXNoIGl0ZW0gb250byBoZWFwLCBtYWludGFpbmluZyB0aGUgaGVhcCBpbnZhcmlhbnQuXG4gICAqL1xuXG4gIGhlYXBwdXNoID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGNtcCkge1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgYXJyYXkucHVzaChpdGVtKTtcbiAgICByZXR1cm4gX3NpZnRkb3duKGFycmF5LCAwLCBhcnJheS5sZW5ndGggLSAxLCBjbXApO1xuICB9O1xuXG5cbiAgLypcbiAgUG9wIHRoZSBzbWFsbGVzdCBpdGVtIG9mZiB0aGUgaGVhcCwgbWFpbnRhaW5pbmcgdGhlIGhlYXAgaW52YXJpYW50LlxuICAgKi9cblxuICBoZWFwcG9wID0gZnVuY3Rpb24oYXJyYXksIGNtcCkge1xuICAgIHZhciBsYXN0ZWx0LCByZXR1cm5pdGVtO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgbGFzdGVsdCA9IGFycmF5LnBvcCgpO1xuICAgIGlmIChhcnJheS5sZW5ndGgpIHtcbiAgICAgIHJldHVybml0ZW0gPSBhcnJheVswXTtcbiAgICAgIGFycmF5WzBdID0gbGFzdGVsdDtcbiAgICAgIF9zaWZ0dXAoYXJyYXksIDAsIGNtcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybml0ZW0gPSBsYXN0ZWx0O1xuICAgIH1cbiAgICByZXR1cm4gcmV0dXJuaXRlbTtcbiAgfTtcblxuXG4gIC8qXG4gIFBvcCBhbmQgcmV0dXJuIHRoZSBjdXJyZW50IHNtYWxsZXN0IHZhbHVlLCBhbmQgYWRkIHRoZSBuZXcgaXRlbS5cbiAgXG4gIFRoaXMgaXMgbW9yZSBlZmZpY2llbnQgdGhhbiBoZWFwcG9wKCkgZm9sbG93ZWQgYnkgaGVhcHB1c2goKSwgYW5kIGNhbiBiZVxuICBtb3JlIGFwcHJvcHJpYXRlIHdoZW4gdXNpbmcgYSBmaXhlZCBzaXplIGhlYXAuIE5vdGUgdGhhdCB0aGUgdmFsdWVcbiAgcmV0dXJuZWQgbWF5IGJlIGxhcmdlciB0aGFuIGl0ZW0hIFRoYXQgY29uc3RyYWlucyByZWFzb25hYmxlIHVzZSBvZlxuICB0aGlzIHJvdXRpbmUgdW5sZXNzIHdyaXR0ZW4gYXMgcGFydCBvZiBhIGNvbmRpdGlvbmFsIHJlcGxhY2VtZW50OlxuICAgICAgaWYgaXRlbSA+IGFycmF5WzBdXG4gICAgICAgIGl0ZW0gPSBoZWFwcmVwbGFjZShhcnJheSwgaXRlbSlcbiAgICovXG5cbiAgaGVhcHJlcGxhY2UgPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgY21wKSB7XG4gICAgdmFyIHJldHVybml0ZW07XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICByZXR1cm5pdGVtID0gYXJyYXlbMF07XG4gICAgYXJyYXlbMF0gPSBpdGVtO1xuICAgIF9zaWZ0dXAoYXJyYXksIDAsIGNtcCk7XG4gICAgcmV0dXJuIHJldHVybml0ZW07XG4gIH07XG5cblxuICAvKlxuICBGYXN0IHZlcnNpb24gb2YgYSBoZWFwcHVzaCBmb2xsb3dlZCBieSBhIGhlYXBwb3AuXG4gICAqL1xuXG4gIGhlYXBwdXNocG9wID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGNtcCkge1xuICAgIHZhciBfcmVmO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgaWYgKGFycmF5Lmxlbmd0aCAmJiBjbXAoYXJyYXlbMF0sIGl0ZW0pIDwgMCkge1xuICAgICAgX3JlZiA9IFthcnJheVswXSwgaXRlbV0sIGl0ZW0gPSBfcmVmWzBdLCBhcnJheVswXSA9IF9yZWZbMV07XG4gICAgICBfc2lmdHVwKGFycmF5LCAwLCBjbXApO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbTtcbiAgfTtcblxuXG4gIC8qXG4gIFRyYW5zZm9ybSBsaXN0IGludG8gYSBoZWFwLCBpbi1wbGFjZSwgaW4gTyhhcnJheS5sZW5ndGgpIHRpbWUuXG4gICAqL1xuXG4gIGhlYXBpZnkgPSBmdW5jdGlvbihhcnJheSwgY21wKSB7XG4gICAgdmFyIGksIF9pLCBfaiwgX2xlbiwgX3JlZiwgX3JlZjEsIF9yZXN1bHRzLCBfcmVzdWx0czE7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBfcmVmMSA9IChmdW5jdGlvbigpIHtcbiAgICAgIF9yZXN1bHRzMSA9IFtdO1xuICAgICAgZm9yICh2YXIgX2ogPSAwLCBfcmVmID0gZmxvb3IoYXJyYXkubGVuZ3RoIC8gMik7IDAgPD0gX3JlZiA/IF9qIDwgX3JlZiA6IF9qID4gX3JlZjsgMCA8PSBfcmVmID8gX2orKyA6IF9qLS0peyBfcmVzdWx0czEucHVzaChfaik7IH1cbiAgICAgIHJldHVybiBfcmVzdWx0czE7XG4gICAgfSkuYXBwbHkodGhpcykucmV2ZXJzZSgpO1xuICAgIF9yZXN1bHRzID0gW107XG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgaSA9IF9yZWYxW19pXTtcbiAgICAgIF9yZXN1bHRzLnB1c2goX3NpZnR1cChhcnJheSwgaSwgY21wKSk7XG4gICAgfVxuICAgIHJldHVybiBfcmVzdWx0cztcbiAgfTtcblxuXG4gIC8qXG4gIFVwZGF0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGdpdmVuIGl0ZW0gaW4gdGhlIGhlYXAuXG4gIFRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIGNhbGxlZCBldmVyeSB0aW1lIHRoZSBpdGVtIGlzIGJlaW5nIG1vZGlmaWVkLlxuICAgKi9cblxuICB1cGRhdGVJdGVtID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGNtcCkge1xuICAgIHZhciBwb3M7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBwb3MgPSBhcnJheS5pbmRleE9mKGl0ZW0pO1xuICAgIGlmIChwb3MgPT09IC0xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIF9zaWZ0ZG93bihhcnJheSwgMCwgcG9zLCBjbXApO1xuICAgIHJldHVybiBfc2lmdHVwKGFycmF5LCBwb3MsIGNtcCk7XG4gIH07XG5cblxuICAvKlxuICBGaW5kIHRoZSBuIGxhcmdlc3QgZWxlbWVudHMgaW4gYSBkYXRhc2V0LlxuICAgKi9cblxuICBubGFyZ2VzdCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBjbXApIHtcbiAgICB2YXIgZWxlbSwgcmVzdWx0LCBfaSwgX2xlbiwgX3JlZjtcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIHJlc3VsdCA9IGFycmF5LnNsaWNlKDAsIG4pO1xuICAgIGlmICghcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaGVhcGlmeShyZXN1bHQsIGNtcCk7XG4gICAgX3JlZiA9IGFycmF5LnNsaWNlKG4pO1xuICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgZWxlbSA9IF9yZWZbX2ldO1xuICAgICAgaGVhcHB1c2hwb3AocmVzdWx0LCBlbGVtLCBjbXApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LnNvcnQoY21wKS5yZXZlcnNlKCk7XG4gIH07XG5cblxuICAvKlxuICBGaW5kIHRoZSBuIHNtYWxsZXN0IGVsZW1lbnRzIGluIGEgZGF0YXNldC5cbiAgICovXG5cbiAgbnNtYWxsZXN0ID0gZnVuY3Rpb24oYXJyYXksIG4sIGNtcCkge1xuICAgIHZhciBlbGVtLCBpLCBsb3MsIHJlc3VsdCwgX2ksIF9qLCBfbGVuLCBfcmVmLCBfcmVmMSwgX3Jlc3VsdHM7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBpZiAobiAqIDEwIDw9IGFycmF5Lmxlbmd0aCkge1xuICAgICAgcmVzdWx0ID0gYXJyYXkuc2xpY2UoMCwgbikuc29ydChjbXApO1xuICAgICAgaWYgKCFyZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBsb3MgPSByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdO1xuICAgICAgX3JlZiA9IGFycmF5LnNsaWNlKG4pO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIGVsZW0gPSBfcmVmW19pXTtcbiAgICAgICAgaWYgKGNtcChlbGVtLCBsb3MpIDwgMCkge1xuICAgICAgICAgIGluc29ydChyZXN1bHQsIGVsZW0sIDAsIG51bGwsIGNtcCk7XG4gICAgICAgICAgcmVzdWx0LnBvcCgpO1xuICAgICAgICAgIGxvcyA9IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGhlYXBpZnkoYXJyYXksIGNtcCk7XG4gICAgX3Jlc3VsdHMgPSBbXTtcbiAgICBmb3IgKGkgPSBfaiA9IDAsIF9yZWYxID0gbWluKG4sIGFycmF5Lmxlbmd0aCk7IDAgPD0gX3JlZjEgPyBfaiA8IF9yZWYxIDogX2ogPiBfcmVmMTsgaSA9IDAgPD0gX3JlZjEgPyArK19qIDogLS1faikge1xuICAgICAgX3Jlc3VsdHMucHVzaChoZWFwcG9wKGFycmF5LCBjbXApKTtcbiAgICB9XG4gICAgcmV0dXJuIF9yZXN1bHRzO1xuICB9O1xuXG4gIF9zaWZ0ZG93biA9IGZ1bmN0aW9uKGFycmF5LCBzdGFydHBvcywgcG9zLCBjbXApIHtcbiAgICB2YXIgbmV3aXRlbSwgcGFyZW50LCBwYXJlbnRwb3M7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBuZXdpdGVtID0gYXJyYXlbcG9zXTtcbiAgICB3aGlsZSAocG9zID4gc3RhcnRwb3MpIHtcbiAgICAgIHBhcmVudHBvcyA9IChwb3MgLSAxKSA+PiAxO1xuICAgICAgcGFyZW50ID0gYXJyYXlbcGFyZW50cG9zXTtcbiAgICAgIGlmIChjbXAobmV3aXRlbSwgcGFyZW50KSA8IDApIHtcbiAgICAgICAgYXJyYXlbcG9zXSA9IHBhcmVudDtcbiAgICAgICAgcG9zID0gcGFyZW50cG9zO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXlbcG9zXSA9IG5ld2l0ZW07XG4gIH07XG5cbiAgX3NpZnR1cCA9IGZ1bmN0aW9uKGFycmF5LCBwb3MsIGNtcCkge1xuICAgIHZhciBjaGlsZHBvcywgZW5kcG9zLCBuZXdpdGVtLCByaWdodHBvcywgc3RhcnRwb3M7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBlbmRwb3MgPSBhcnJheS5sZW5ndGg7XG4gICAgc3RhcnRwb3MgPSBwb3M7XG4gICAgbmV3aXRlbSA9IGFycmF5W3Bvc107XG4gICAgY2hpbGRwb3MgPSAyICogcG9zICsgMTtcbiAgICB3aGlsZSAoY2hpbGRwb3MgPCBlbmRwb3MpIHtcbiAgICAgIHJpZ2h0cG9zID0gY2hpbGRwb3MgKyAxO1xuICAgICAgaWYgKHJpZ2h0cG9zIDwgZW5kcG9zICYmICEoY21wKGFycmF5W2NoaWxkcG9zXSwgYXJyYXlbcmlnaHRwb3NdKSA8IDApKSB7XG4gICAgICAgIGNoaWxkcG9zID0gcmlnaHRwb3M7XG4gICAgICB9XG4gICAgICBhcnJheVtwb3NdID0gYXJyYXlbY2hpbGRwb3NdO1xuICAgICAgcG9zID0gY2hpbGRwb3M7XG4gICAgICBjaGlsZHBvcyA9IDIgKiBwb3MgKyAxO1xuICAgIH1cbiAgICBhcnJheVtwb3NdID0gbmV3aXRlbTtcbiAgICByZXR1cm4gX3NpZnRkb3duKGFycmF5LCBzdGFydHBvcywgcG9zLCBjbXApO1xuICB9O1xuXG4gIEhlYXAgPSAoZnVuY3Rpb24oKSB7XG4gICAgSGVhcC5wdXNoID0gaGVhcHB1c2g7XG5cbiAgICBIZWFwLnBvcCA9IGhlYXBwb3A7XG5cbiAgICBIZWFwLnJlcGxhY2UgPSBoZWFwcmVwbGFjZTtcblxuICAgIEhlYXAucHVzaHBvcCA9IGhlYXBwdXNocG9wO1xuXG4gICAgSGVhcC5oZWFwaWZ5ID0gaGVhcGlmeTtcblxuICAgIEhlYXAudXBkYXRlSXRlbSA9IHVwZGF0ZUl0ZW07XG5cbiAgICBIZWFwLm5sYXJnZXN0ID0gbmxhcmdlc3Q7XG5cbiAgICBIZWFwLm5zbWFsbGVzdCA9IG5zbWFsbGVzdDtcblxuICAgIGZ1bmN0aW9uIEhlYXAoY21wKSB7XG4gICAgICB0aGlzLmNtcCA9IGNtcCAhPSBudWxsID8gY21wIDogZGVmYXVsdENtcDtcbiAgICAgIHRoaXMubm9kZXMgPSBbXTtcbiAgICB9XG5cbiAgICBIZWFwLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIGhlYXBwdXNoKHRoaXMubm9kZXMsIHgsIHRoaXMuY21wKTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaGVhcHBvcCh0aGlzLm5vZGVzLCB0aGlzLmNtcCk7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVzWzBdO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVzLmluZGV4T2YoeCkgIT09IC0xO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIGhlYXByZXBsYWNlKHRoaXMubm9kZXMsIHgsIHRoaXMuY21wKTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUucHVzaHBvcCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBoZWFwcHVzaHBvcCh0aGlzLm5vZGVzLCB4LCB0aGlzLmNtcCk7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLmhlYXBpZnkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBoZWFwaWZ5KHRoaXMubm9kZXMsIHRoaXMuY21wKTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUudXBkYXRlSXRlbSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB1cGRhdGVJdGVtKHRoaXMubm9kZXMsIHgsIHRoaXMuY21wKTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVzID0gW107XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2Rlcy5sZW5ndGggPT09IDA7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVzLmxlbmd0aDtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBoZWFwO1xuICAgICAgaGVhcCA9IG5ldyBIZWFwKCk7XG4gICAgICBoZWFwLm5vZGVzID0gdGhpcy5ub2Rlcy5zbGljZSgwKTtcbiAgICAgIHJldHVybiBoZWFwO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2Rlcy5zbGljZSgwKTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUuaW5zZXJ0ID0gSGVhcC5wcm90b3R5cGUucHVzaDtcblxuICAgIEhlYXAucHJvdG90eXBlLnRvcCA9IEhlYXAucHJvdG90eXBlLnBlZWs7XG5cbiAgICBIZWFwLnByb3RvdHlwZS5mcm9udCA9IEhlYXAucHJvdG90eXBlLnBlZWs7XG5cbiAgICBIZWFwLnByb3RvdHlwZS5oYXMgPSBIZWFwLnByb3RvdHlwZS5jb250YWlucztcblxuICAgIEhlYXAucHJvdG90eXBlLmNvcHkgPSBIZWFwLnByb3RvdHlwZS5jbG9uZTtcblxuICAgIHJldHVybiBIZWFwO1xuXG4gIH0pKCk7XG5cbiAgKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICByZXR1cm4gZGVmaW5lKFtdLCBmYWN0b3J5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcm9vdC5IZWFwID0gZmFjdG9yeSgpO1xuICAgIH1cbiAgfSkodGhpcywgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIEhlYXA7XG4gIH0pO1xuXG59KS5jYWxsKHRoaXMpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvaGVhcC9saWIvaGVhcC5qc1xuLy8gbW9kdWxlIGlkID0gMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IG1vanMgZnJvbSAnbW8tanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBNby5qcyBwYXJ0eSBwb3BwZXIgYW5pbWF0aW9uLlxuICogaHR0cHM6Ly9jb2RlcGVuLmlvL2pvaGFubW91Y2hldC9wZW4vcXBqYXZFXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9ICBzZWxlY3RvciAtIERPTSBzZWxlY3RvciB0byBhdHRhY2ggdGhlIGFuaW1hdGlvbiB0b1xuICovXG5mdW5jdGlvbiBwYXJ0eVBvcHBlcihzZWxlY3Rvcikge1xuICBjb25zdCBjb2xvcnMgPSBbXG4gICAgJyNiZWE0ZmYnLFxuICAgICcjZmViNTM1JyxcbiAgICAnI2ZmNmU4MycsXG4gICAgJyM1OGNhZmUnLFxuICBdXG5cbiAgY29uc3QgdG9yc2FkZUJ1cnN0ID0gbmV3IG1vanMuQnVyc3Qoe1xuICAgIHBhcmVudDogc2VsZWN0b3IsXG4gICAgcmFkaXVzOiB7MCA6ICdyYW5kKDUwLCAxMDApJ30sXG4gICAgY291bnQ6ICdyYW5kKDE4LCAyMiknLFxuICAgIGRlZ3JlZTogMzAsXG4gICAgY2hpbGRyZW46IHtcbiAgICAgIHNoYXBlOiAnemlnemFnJyxcbiAgICAgIHBvaW50czogJ3JhbmQoNCwgNiknLFxuICAgICAgcmFkaXVzOiA0MCxcbiAgICAgIHJhZGl1c1k6IDMwLFxuICAgICAgc3Ryb2tlTGluZWNhcDogJ3JvdW5kJyxcbiAgICAgIHN0cm9rZVdpZHRoOiA4LFxuICAgICAgZmlsbDogJ25vbmUnLFxuICAgICAgc3Ryb2tlOiBjb2xvcnMsXG4gICAgICBhbmdsZTogezA6ICdyYW5kKC03MjAsIDcyMCknfSxcbiAgICAgIGlzU3dpcmw6IHRydWUsXG4gICAgICBzd2lybFNpemU6ICdyYW5kKDEwLCAyMCknLFxuICAgICAgc3dpcmxGcmVxdWVuY3k6ICdyYW5kKDEsIDMpJyxcbiAgICAgIGRpcmVjdGlvbjogWy0xLCAxXSxcbiAgICAgIGRlZ3JlZVNoaWZ0OiAncmFuZCgtMTUsIDE1KScsXG4gICAgICBkdXJhdGlvbjogMjAwMCxcbiAgICAgIGVhc2luZzogJ2N1YmljLm91dCcsXG4gICAgICBwYXRoU2NhbGU6ICdzdGFnZ2VyKC4yKScsXG4gICAgfVxuICB9KTtcblxuICBjb25zdCBiZW50QnVyc3QgPSBuZXcgbW9qcy5CdXJzdCh7XG4gICAgcGFyZW50OiBzZWxlY3RvcixcbiAgICByYWRpdXM6IHswIDogJ3JhbmQoNTAsIDEwMCknfSxcbiAgICBjb3VudDogJ3JhbmQoMTgsIDIyKScsXG4gICAgZGVncmVlOiAzMCxcbiAgICBjaGlsZHJlbjoge1xuICAgICAgc2hhcGU6ICdjdXJ2ZScsXG4gICAgICByYWRpdXM6ICdyYW5kKDI1LCAzNSknLFxuICAgICAgcmFkaXVzWTogMTUsXG4gICAgICBzdHJva2VMaW5lY2FwOiAncm91bmQnLFxuICAgICAgc3Ryb2tlV2lkdGg6IDgsXG4gICAgICBmaWxsOiAnbm9uZScsXG4gICAgICBzdHJva2U6IGNvbG9ycyxcbiAgICAgIGFuZ2xlOiB7MDogJ3JhbmQoLTcyMCwgNzIwKSd9LFxuICAgICAgaXNTd2lybDogdHJ1ZSxcbiAgICAgIHN3aXJsU2l6ZTogJ3JhbmQoMTAsIDIwKScsXG4gICAgICBzd2lybEZyZXF1ZW5jeTogJ3JhbmQoMSwgMyknLFxuICAgICAgZGlyZWN0aW9uOiBbLTEsIDFdLFxuICAgICAgZGVncmVlU2hpZnQ6ICdyYW5kKC0xNSwgMTUpJyxcbiAgICAgIGR1cmF0aW9uOiAyMDAwLFxuICAgICAgZWFzaW5nOiAnY3ViaWMub3V0JyxcbiAgICAgIHBhdGhTY2FsZTogJ3N0YWdnZXIoLjIpJyxcbiAgICB9XG4gIH0pO1xuXG4gIGNvbnN0IGZsYWtlQnVyc3QgPSBuZXcgbW9qcy5CdXJzdCh7XG4gICAgcGFyZW50OiBzZWxlY3RvcixcbiAgICByYWRpdXM6IHswIDogJ3JhbmQoNTAsIDEwMCknfSxcbiAgICBjb3VudDogJ3JhbmQoMTgsIDIyKScsXG4gICAgZGVncmVlOiAzMCxcbiAgICBjaGlsZHJlbjoge1xuICAgICAgc2hhcGU6J2NpcmNsZScsXG4gICAgICByYWRpdXM6ICdyYW5kKDUsIDEwKScsXG4gICAgICBmaWxsOiBjb2xvcnMsXG4gICAgICBpc1N3aXJsOiB0cnVlLFxuICAgICAgc3dpcmxTaXplOiAncmFuZCgxMCwgMjApJyxcbiAgICAgIHN3aXJsRnJlcXVlbmN5OiAncmFuZCgxLCAzKScsXG4gICAgICBkaXJlY3Rpb246IFstMSwgMV0sXG4gICAgICBkZWdyZWVTaGlmdDogJ3JhbmQoLTE1LCAxNSknLFxuICAgICAgZHVyYXRpb246IDIwMDAsXG4gICAgICBlYXNpbmc6ICdjdWJpYy5vdXQnLFxuICAgICAgcGF0aFNjYWxlOiAnc3RhZ2dlciguMiknLFxuICAgIH1cbiAgfSk7XG5cbiAgdG9yc2FkZUJ1cnN0LnBsYXkoKVxuICBiZW50QnVyc3QucGxheSgpXG4gIGZsYWtlQnVyc3QucGxheSgpXG59O1xuXG5pZiAoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnBhcnR5LXBvcHBlci1lZmZlY3RzJykpXG4gIHNldFRpbWVvdXQoKCkgPT4gcGFydHlQb3BwZXIoJy5wYXJ0eS1wb3BwZXItZWZmZWN0cycpLCA0MDApO1xuXG5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcucGFydHktcG9wcGVyLWVtb2ppJykuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgcGFydHlQb3BwZXIoJy5wYXJ0eS1wb3BwZXItZWZmZWN0cycpXG4gIH0pO1xufSlcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9hc3NldHMvamF2YXNjcmlwdHMvcGFydHktcG9wcGVyLmpzIiwiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoXCJtb2pzXCIsIFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIm1vanNcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wibW9qc1wiXSA9IGZhY3RvcnkoKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9LFxuLyoqKioqKi8gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bG9hZGVkOiBmYWxzZVxuLyoqKioqKi8gXHRcdH07XG5cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG5cblxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJidWlsZC9cIjtcblxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24obW9kdWxlKSB7J3VzZSBzdHJpY3QnO1xuXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cblx0dmFyIF90eXBlb2YyID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxuXHR2YXIgX3R5cGVvZjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90eXBlb2YyKTtcblxuXHR2YXIgX2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcxKTtcblxuXHR2YXIgX2gyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaCk7XG5cblx0dmFyIF9zaGFwZXNNYXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcyKTtcblxuXHR2YXIgX3NoYXBlc01hcDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zaGFwZXNNYXApO1xuXG5cdHZhciBfc2hhcGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk0KTtcblxuXHR2YXIgX3NoYXBlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NoYXBlKTtcblxuXHR2YXIgX3NoYXBlU3dpcmwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExNyk7XG5cblx0dmFyIF9zaGFwZVN3aXJsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NoYXBlU3dpcmwpO1xuXG5cdHZhciBfYnVyc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExOCk7XG5cblx0dmFyIF9idXJzdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9idXJzdCk7XG5cblx0dmFyIF9odG1sID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTkpO1xuXG5cdHZhciBfaHRtbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9odG1sKTtcblxuXHR2YXIgX3N0YWdnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyNyk7XG5cblx0dmFyIF9zdGFnZ2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N0YWdnZXIpO1xuXG5cdHZhciBfc3ByaXRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTI4KTtcblxuXHR2YXIgX3Nwcml0ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3ByaXRlcik7XG5cblx0dmFyIF9tb3Rpb25QYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMjkpO1xuXG5cdHZhciBfbW90aW9uUGF0aDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tb3Rpb25QYXRoKTtcblxuXHR2YXIgX3R3ZWVuID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDEpO1xuXG5cdHZhciBfdHdlZW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHdlZW4pO1xuXG5cdHZhciBfdGltZWxpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExMCk7XG5cblx0dmFyIF90aW1lbGluZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90aW1lbGluZSk7XG5cblx0dmFyIF90d2VlbmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDIpO1xuXG5cdHZhciBfdHdlZW5lcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90d2VlbmVyKTtcblxuXHR2YXIgX3R3ZWVuYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTAwKTtcblxuXHR2YXIgX3R3ZWVuYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90d2VlbmFibGUpO1xuXG5cdHZhciBfdGhlbmFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk5KTtcblxuXHR2YXIgX3RoZW5hYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RoZW5hYmxlKTtcblxuXHR2YXIgX3R1bmFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExNik7XG5cblx0dmFyIF90dW5hYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R1bmFibGUpO1xuXG5cdHZhciBfZGVsdGEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyNik7XG5cblx0dmFyIF9kZWx0YTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZWx0YSk7XG5cblx0dmFyIF9kZWx0YXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyNSk7XG5cblx0dmFyIF9kZWx0YXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVsdGFzKTtcblxuXHR2YXIgX21vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oODQpO1xuXG5cdHZhciBfbW9kdWxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21vZHVsZSk7XG5cblx0dmFyIF9lYXNpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwNSk7XG5cblx0dmFyIF9lYXNpbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZWFzaW5nKTtcblxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5cdHZhciBtb2pzID0ge1xuXHQgIHJldmlzaW9uOiAnMC4yODguMicsIGlzRGVidWc6IHRydWUsIGhlbHBlcnM6IF9oMi5kZWZhdWx0LFxuXHQgIFNoYXBlOiBfc2hhcGUyLmRlZmF1bHQsIFNoYXBlU3dpcmw6IF9zaGFwZVN3aXJsMi5kZWZhdWx0LCBCdXJzdDogX2J1cnN0Mi5kZWZhdWx0LCBIdG1sOiBfaHRtbDIuZGVmYXVsdCwgc3RhZ2dlcjogX3N0YWdnZXIyLmRlZmF1bHQsIFNwcml0ZXI6IF9zcHJpdGVyMi5kZWZhdWx0LCBNb3Rpb25QYXRoOiBfbW90aW9uUGF0aDIuZGVmYXVsdCxcblx0ICBUd2VlbjogX3R3ZWVuMi5kZWZhdWx0LCBUaW1lbGluZTogX3RpbWVsaW5lMi5kZWZhdWx0LCBUd2VlbmFibGU6IF90d2VlbmFibGUyLmRlZmF1bHQsIFRoZW5hYmxlOiBfdGhlbmFibGUyLmRlZmF1bHQsIFR1bmFibGU6IF90dW5hYmxlMi5kZWZhdWx0LCBNb2R1bGU6IF9tb2R1bGUyLmRlZmF1bHQsXG5cdCAgdHdlZW5lcjogX3R3ZWVuZXIyLmRlZmF1bHQsIGVhc2luZzogX2Vhc2luZzIuZGVmYXVsdCwgc2hhcGVzTWFwOiBfc2hhcGVzTWFwMi5kZWZhdWx0LCBfcG9vbDogeyBEZWx0YTogX2RlbHRhMi5kZWZhdWx0LCBEZWx0YXM6IF9kZWx0YXMyLmRlZmF1bHQgfVxuXHR9O1xuXG5cdC8vIGZ1bmN0aW9ucyBhbGlhc1xuXHRtb2pzLmggPSBtb2pzLmhlbHBlcnM7XG5cdG1vanMuZGVsdGEgPSBtb2pzLmguZGVsdGE7XG5cdC8vIGN1c3RvbSBzaGFwZSBhZGQgZnVuY3Rpb24gYW5kIGNsYXNzXG5cdG1vanMuYWRkU2hhcGUgPSBtb2pzLnNoYXBlc01hcC5hZGRTaGFwZTtcblx0bW9qcy5DdXN0b21TaGFwZSA9IG1vanMuc2hhcGVzTWFwLmN1c3RvbTtcblx0Ly8gbW9kdWxlIGFsaWFzXG5cdG1vanMuVHJhbnNpdCA9IG1vanMuU2hhcGU7XG5cdG1vanMuU3dpcmwgPSBtb2pzLlNoYXBlU3dpcmw7XG5cblx0Ly8gVE9ETzpcblx0Lypcblx0ICBIL1YgaW4gcGF0aHNcblxuXHQgIHJhbmQgZm9yIGRpcmVjdGlvblxuXHQgIGJ1cnN0IGNoaWxkcmVuIGFuZ2xlIGFmdGVyIHR1bmVcblx0ICBidXJzdCBwYXRoU2NhbGUgYWZ0ZXIgdHVuZVxuXHQgIHN3aXJsIHRoZW4gaXNzdWVcblx0ICAncmFuZCcgYW5nbGUgZmxpY2sgd2l0aCBgdGhlbmBcblx0ICBub3QgYWJsZSB0byBgcGxheSgpYCBpbiBgb25Db21wbGV0ZWAgY2FsbGJhY2tcblx0ICAtLS1cblx0ICBtb2R1bGUgbmFtZXNcblx0ICBzd2lybHMgaW4gdGhlbiBjaGFpbnMgZm9yIHgveVxuXHQgIHBhcnNlIHJhbmQoc3RhZ2dlcigyMCwgMTApLCAyMCkgdmFsdWVzXG5cdCAgcGVyY2VudGFnZSBmb3IgcmFkaXVzXG5cdCovXG5cblx0Ly8gaXN0YW5idWwgaWdub3JlIG5leHRcblx0aWYgKHRydWUpIHtcblx0ICAhKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbXSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gbW9qcztcblx0ICB9LmFwcGx5KGV4cG9ydHMsIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18pLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cdH1cblx0Ly8gaXN0YW5idWwgaWdub3JlIG5leHRcblx0aWYgKCggZmFsc2UgPyAndW5kZWZpbmVkJyA6ICgwLCBfdHlwZW9mMy5kZWZhdWx0KShtb2R1bGUpKSA9PT0gXCJvYmplY3RcIiAmJiAoMCwgX3R5cGVvZjMuZGVmYXVsdCkobW9kdWxlLmV4cG9ydHMpID09PSBcIm9iamVjdFwiKSB7XG5cdCAgbW9kdWxlLmV4cG9ydHMgPSBtb2pzO1xuXHR9XG5cblx0ZXhwb3J0cy5kZWZhdWx0ID0gbW9qcztcblxuXG5cdHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICh3aW5kb3cubW9qcyA9IG1vanMpO1xuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXygyKShtb2R1bGUpKSlcblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRcdGlmKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XHJcblx0XHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFx0XHRtb2R1bGUucGF0aHMgPSBbXTtcclxuXHRcdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XHJcblx0XHRcdG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBtb2R1bGU7XHJcblx0fVxyXG5cblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuXHR2YXIgX2l0ZXJhdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxuXHR2YXIgX2l0ZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2l0ZXJhdG9yKTtcblxuXHR2YXIgX3N5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oNTUpO1xuXG5cdHZhciBfc3ltYm9sMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N5bWJvbCk7XG5cblx0dmFyIF90eXBlb2YgPSB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBfaXRlcmF0b3IyLmRlZmF1bHQgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBfc3ltYm9sMi5kZWZhdWx0ICYmIG9iaiAhPT0gX3N5bWJvbDIuZGVmYXVsdC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5cdGV4cG9ydHMuZGVmYXVsdCA9IHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgX3R5cGVvZihfaXRlcmF0b3IyLmRlZmF1bHQpID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikge1xuXHQgIHJldHVybiB0eXBlb2Ygb2JqID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yob2JqKTtcblx0fSA6IGZ1bmN0aW9uIChvYmopIHtcblx0ICByZXR1cm4gb2JqICYmIHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBfc3ltYm9sMi5kZWZhdWx0ICYmIG9iaiAhPT0gX3N5bWJvbDIuZGVmYXVsdC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iaiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKG9iaik7XG5cdH07XG5cbi8qKiovIH0pLFxuLyogNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdG1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogX193ZWJwYWNrX3JlcXVpcmVfXyg1KSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG4vKioqLyB9KSxcbi8qIDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDUwKTtcblx0bW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU0KS5mKCdpdGVyYXRvcicpO1xuXG4vKioqLyB9KSxcbi8qIDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdHZhciAkYXQgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KSh0cnVlKTtcblxuXHQvLyAyMS4xLjMuMjcgU3RyaW5nLnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5cdF9fd2VicGFja19yZXF1aXJlX18oMTApKFN0cmluZywgJ1N0cmluZycsIGZ1bmN0aW9uKGl0ZXJhdGVkKXtcblx0ICB0aGlzLl90ID0gU3RyaW5nKGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG5cdCAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcblx0Ly8gMjEuMS41LjIuMSAlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxuXHR9LCBmdW5jdGlvbigpe1xuXHQgIHZhciBPICAgICA9IHRoaXMuX3Rcblx0ICAgICwgaW5kZXggPSB0aGlzLl9pXG5cdCAgICAsIHBvaW50O1xuXHQgIGlmKGluZGV4ID49IE8ubGVuZ3RoKXJldHVybiB7dmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZX07XG5cdCAgcG9pbnQgPSAkYXQoTywgaW5kZXgpO1xuXHQgIHRoaXMuX2kgKz0gcG9pbnQubGVuZ3RoO1xuXHQgIHJldHVybiB7dmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZX07XG5cdH0pO1xuXG4vKioqLyB9KSxcbi8qIDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgdG9JbnRlZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KVxuXHQgICwgZGVmaW5lZCAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblx0Ly8gdHJ1ZSAgLT4gU3RyaW5nI2F0XG5cdC8vIGZhbHNlIC0+IFN0cmluZyNjb2RlUG9pbnRBdFxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFRPX1NUUklORyl7XG5cdCAgcmV0dXJuIGZ1bmN0aW9uKHRoYXQsIHBvcyl7XG5cdCAgICB2YXIgcyA9IFN0cmluZyhkZWZpbmVkKHRoYXQpKVxuXHQgICAgICAsIGkgPSB0b0ludGVnZXIocG9zKVxuXHQgICAgICAsIGwgPSBzLmxlbmd0aFxuXHQgICAgICAsIGEsIGI7XG5cdCAgICBpZihpIDwgMCB8fCBpID49IGwpcmV0dXJuIFRPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuXHQgICAgYSA9IHMuY2hhckNvZGVBdChpKTtcblx0ICAgIHJldHVybiBhIDwgMHhkODAwIHx8IGEgPiAweGRiZmYgfHwgaSArIDEgPT09IGwgfHwgKGIgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBiID4gMHhkZmZmXG5cdCAgICAgID8gVE9fU1RSSU5HID8gcy5jaGFyQXQoaSkgOiBhXG5cdCAgICAgIDogVE9fU1RSSU5HID8gcy5zbGljZShpLCBpICsgMikgOiAoYSAtIDB4ZDgwMCA8PCAxMCkgKyAoYiAtIDB4ZGMwMCkgKyAweDEwMDAwO1xuXHQgIH07XG5cdH07XG5cbi8qKiovIH0pLFxuLyogOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdC8vIDcuMS40IFRvSW50ZWdlclxuXHR2YXIgY2VpbCAgPSBNYXRoLmNlaWxcblx0ICAsIGZsb29yID0gTWF0aC5mbG9vcjtcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG5cdCAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG5cdH07XG5cbi8qKiovIH0pLFxuLyogOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdC8vIDcuMi4xIFJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuXHQgIGlmKGl0ID09IHVuZGVmaW5lZCl0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAgXCIgKyBpdCk7XG5cdCAgcmV0dXJuIGl0O1xuXHR9O1xuXG4vKioqLyB9KSxcbi8qIDEwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHR2YXIgTElCUkFSWSAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKVxuXHQgICwgJGV4cG9ydCAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKVxuXHQgICwgcmVkZWZpbmUgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KVxuXHQgICwgaGlkZSAgICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KVxuXHQgICwgaGFzICAgICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KVxuXHQgICwgSXRlcmF0b3JzICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KVxuXHQgICwgJGl0ZXJDcmVhdGUgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKVxuXHQgICwgc2V0VG9TdHJpbmdUYWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ2KVxuXHQgICwgZ2V0UHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ4KVxuXHQgICwgSVRFUkFUT1IgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3KSgnaXRlcmF0b3InKVxuXHQgICwgQlVHR1kgICAgICAgICAgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSkgLy8gU2FmYXJpIGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxuXHQgICwgRkZfSVRFUkFUT1IgICAgPSAnQEBpdGVyYXRvcidcblx0ICAsIEtFWVMgICAgICAgICAgID0gJ2tleXMnXG5cdCAgLCBWQUxVRVMgICAgICAgICA9ICd2YWx1ZXMnO1xuXG5cdHZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH07XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihCYXNlLCBOQU1FLCBDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpe1xuXHQgICRpdGVyQ3JlYXRlKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcblx0ICB2YXIgZ2V0TWV0aG9kID0gZnVuY3Rpb24oa2luZCl7XG5cdCAgICBpZighQlVHR1kgJiYga2luZCBpbiBwcm90bylyZXR1cm4gcHJvdG9ba2luZF07XG5cdCAgICBzd2l0Y2goa2luZCl7XG5cdCAgICAgIGNhc2UgS0VZUzogcmV0dXJuIGZ1bmN0aW9uIGtleXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcblx0ICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcblx0ICAgIH0gcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcblx0ICB9O1xuXHQgIHZhciBUQUcgICAgICAgID0gTkFNRSArICcgSXRlcmF0b3InXG5cdCAgICAsIERFRl9WQUxVRVMgPSBERUZBVUxUID09IFZBTFVFU1xuXHQgICAgLCBWQUxVRVNfQlVHID0gZmFsc2Vcblx0ICAgICwgcHJvdG8gICAgICA9IEJhc2UucHJvdG90eXBlXG5cdCAgICAsICRuYXRpdmUgICAgPSBwcm90b1tJVEVSQVRPUl0gfHwgcHJvdG9bRkZfSVRFUkFUT1JdIHx8IERFRkFVTFQgJiYgcHJvdG9bREVGQVVMVF1cblx0ICAgICwgJGRlZmF1bHQgICA9ICRuYXRpdmUgfHwgZ2V0TWV0aG9kKERFRkFVTFQpXG5cdCAgICAsICRlbnRyaWVzICAgPSBERUZBVUxUID8gIURFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZCgnZW50cmllcycpIDogdW5kZWZpbmVkXG5cdCAgICAsICRhbnlOYXRpdmUgPSBOQU1FID09ICdBcnJheScgPyBwcm90by5lbnRyaWVzIHx8ICRuYXRpdmUgOiAkbmF0aXZlXG5cdCAgICAsIG1ldGhvZHMsIGtleSwgSXRlcmF0b3JQcm90b3R5cGU7XG5cdCAgLy8gRml4IG5hdGl2ZVxuXHQgIGlmKCRhbnlOYXRpdmUpe1xuXHQgICAgSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZigkYW55TmF0aXZlLmNhbGwobmV3IEJhc2UpKTtcblx0ICAgIGlmKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlKXtcblx0ICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuXHQgICAgICBzZXRUb1N0cmluZ1RhZyhJdGVyYXRvclByb3RvdHlwZSwgVEFHLCB0cnVlKTtcblx0ICAgICAgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzXG5cdCAgICAgIGlmKCFMSUJSQVJZICYmICFoYXMoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SKSloaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG5cdCAgICB9XG5cdCAgfVxuXHQgIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcblx0ICBpZihERUZfVkFMVUVTICYmICRuYXRpdmUgJiYgJG5hdGl2ZS5uYW1lICE9PSBWQUxVRVMpe1xuXHQgICAgVkFMVUVTX0JVRyA9IHRydWU7XG5cdCAgICAkZGVmYXVsdCA9IGZ1bmN0aW9uIHZhbHVlcygpeyByZXR1cm4gJG5hdGl2ZS5jYWxsKHRoaXMpOyB9O1xuXHQgIH1cblx0ICAvLyBEZWZpbmUgaXRlcmF0b3Jcblx0ICBpZigoIUxJQlJBUlkgfHwgRk9SQ0VEKSAmJiAoQlVHR1kgfHwgVkFMVUVTX0JVRyB8fCAhcHJvdG9bSVRFUkFUT1JdKSl7XG5cdCAgICBoaWRlKHByb3RvLCBJVEVSQVRPUiwgJGRlZmF1bHQpO1xuXHQgIH1cblx0ICAvLyBQbHVnIGZvciBsaWJyYXJ5XG5cdCAgSXRlcmF0b3JzW05BTUVdID0gJGRlZmF1bHQ7XG5cdCAgSXRlcmF0b3JzW1RBR10gID0gcmV0dXJuVGhpcztcblx0ICBpZihERUZBVUxUKXtcblx0ICAgIG1ldGhvZHMgPSB7XG5cdCAgICAgIHZhbHVlczogIERFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChWQUxVRVMpLFxuXHQgICAgICBrZXlzOiAgICBJU19TRVQgICAgID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoS0VZUyksXG5cdCAgICAgIGVudHJpZXM6ICRlbnRyaWVzXG5cdCAgICB9O1xuXHQgICAgaWYoRk9SQ0VEKWZvcihrZXkgaW4gbWV0aG9kcyl7XG5cdCAgICAgIGlmKCEoa2V5IGluIHByb3RvKSlyZWRlZmluZShwcm90bywga2V5LCBtZXRob2RzW2tleV0pO1xuXHQgICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcblx0ICB9XG5cdCAgcmV0dXJuIG1ldGhvZHM7XG5cdH07XG5cbi8qKiovIH0pLFxuLyogMTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IHRydWU7XG5cbi8qKiovIH0pLFxuLyogMTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgZ2xvYmFsICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMylcblx0ICAsIGNvcmUgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpXG5cdCAgLCBjdHggICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KVxuXHQgICwgaGlkZSAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNylcblx0ICAsIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG5cdHZhciAkZXhwb3J0ID0gZnVuY3Rpb24odHlwZSwgbmFtZSwgc291cmNlKXtcblx0ICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRlxuXHQgICAgLCBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HXG5cdCAgICAsIElTX1NUQVRJQyA9IHR5cGUgJiAkZXhwb3J0LlNcblx0ICAgICwgSVNfUFJPVE8gID0gdHlwZSAmICRleHBvcnQuUFxuXHQgICAgLCBJU19CSU5EICAgPSB0eXBlICYgJGV4cG9ydC5CXG5cdCAgICAsIElTX1dSQVAgICA9IHR5cGUgJiAkZXhwb3J0Lldcblx0ICAgICwgZXhwb3J0cyAgID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSlcblx0ICAgICwgZXhwUHJvdG8gID0gZXhwb3J0c1tQUk9UT1RZUEVdXG5cdCAgICAsIHRhcmdldCAgICA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSA6IChnbG9iYWxbbmFtZV0gfHwge30pW1BST1RPVFlQRV1cblx0ICAgICwga2V5LCBvd24sIG91dDtcblx0ICBpZihJU19HTE9CQUwpc291cmNlID0gbmFtZTtcblx0ICBmb3Ioa2V5IGluIHNvdXJjZSl7XG5cdCAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcblx0ICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQ7XG5cdCAgICBpZihvd24gJiYga2V5IGluIGV4cG9ydHMpY29udGludWU7XG5cdCAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxuXHQgICAgb3V0ID0gb3duID8gdGFyZ2V0W2tleV0gOiBzb3VyY2Vba2V5XTtcblx0ICAgIC8vIHByZXZlbnQgZ2xvYmFsIHBvbGx1dGlvbiBmb3IgbmFtZXNwYWNlc1xuXHQgICAgZXhwb3J0c1trZXldID0gSVNfR0xPQkFMICYmIHR5cGVvZiB0YXJnZXRba2V5XSAhPSAnZnVuY3Rpb24nID8gc291cmNlW2tleV1cblx0ICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG5cdCAgICA6IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKVxuXHQgICAgLy8gd3JhcCBnbG9iYWwgY29uc3RydWN0b3JzIGZvciBwcmV2ZW50IGNoYW5nZSB0aGVtIGluIGxpYnJhcnlcblx0ICAgIDogSVNfV1JBUCAmJiB0YXJnZXRba2V5XSA9PSBvdXQgPyAoZnVuY3Rpb24oQyl7XG5cdCAgICAgIHZhciBGID0gZnVuY3Rpb24oYSwgYiwgYyl7XG5cdCAgICAgICAgaWYodGhpcyBpbnN0YW5jZW9mIEMpe1xuXHQgICAgICAgICAgc3dpdGNoKGFyZ3VtZW50cy5sZW5ndGgpe1xuXHQgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBuZXcgQztcblx0ICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IEMoYSk7XG5cdCAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIG5ldyBDKGEsIGIpO1xuXHQgICAgICAgICAgfSByZXR1cm4gbmV3IEMoYSwgYiwgYyk7XG5cdCAgICAgICAgfSByZXR1cm4gQy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICB9O1xuXHQgICAgICBGW1BST1RPVFlQRV0gPSBDW1BST1RPVFlQRV07XG5cdCAgICAgIHJldHVybiBGO1xuXHQgICAgLy8gbWFrZSBzdGF0aWMgdmVyc2lvbnMgZm9yIHByb3RvdHlwZSBtZXRob2RzXG5cdCAgICB9KShvdXQpIDogSVNfUFJPVE8gJiYgdHlwZW9mIG91dCA9PSAnZnVuY3Rpb24nID8gY3R4KEZ1bmN0aW9uLmNhbGwsIG91dCkgOiBvdXQ7XG5cdCAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUubWV0aG9kcy4lTkFNRSVcblx0ICAgIGlmKElTX1BST1RPKXtcblx0ICAgICAgKGV4cG9ydHMudmlydHVhbCB8fCAoZXhwb3J0cy52aXJ0dWFsID0ge30pKVtrZXldID0gb3V0O1xuXHQgICAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUucHJvdG90eXBlLiVOQU1FJVxuXHQgICAgICBpZih0eXBlICYgJGV4cG9ydC5SICYmIGV4cFByb3RvICYmICFleHBQcm90b1trZXldKWhpZGUoZXhwUHJvdG8sIGtleSwgb3V0KTtcblx0ICAgIH1cblx0ICB9XG5cdH07XG5cdC8vIHR5cGUgYml0bWFwXG5cdCRleHBvcnQuRiA9IDE7ICAgLy8gZm9yY2VkXG5cdCRleHBvcnQuRyA9IDI7ICAgLy8gZ2xvYmFsXG5cdCRleHBvcnQuUyA9IDQ7ICAgLy8gc3RhdGljXG5cdCRleHBvcnQuUCA9IDg7ICAgLy8gcHJvdG9cblx0JGV4cG9ydC5CID0gMTY7ICAvLyBiaW5kXG5cdCRleHBvcnQuVyA9IDMyOyAgLy8gd3JhcFxuXHQkZXhwb3J0LlUgPSA2NDsgIC8vIHNhZmVcblx0JGV4cG9ydC5SID0gMTI4OyAvLyByZWFsIHByb3RvIG1ldGhvZCBmb3IgYGxpYnJhcnlgIFxuXHRtb2R1bGUuZXhwb3J0cyA9ICRleHBvcnQ7XG5cbi8qKiovIH0pLFxuLyogMTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxuXHR2YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGhcblx0ICA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZiA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cdGlmKHR5cGVvZiBfX2cgPT0gJ251bWJlcicpX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbi8qKiovIH0pLFxuLyogMTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHR2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0ge3ZlcnNpb246ICcyLjQuMCd9O1xuXHRpZih0eXBlb2YgX19lID09ICdudW1iZXInKV9fZSA9IGNvcmU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuLyoqKi8gfSksXG4vKiAxNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xuXHR2YXIgYUZ1bmN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZm4sIHRoYXQsIGxlbmd0aCl7XG5cdCAgYUZ1bmN0aW9uKGZuKTtcblx0ICBpZih0aGF0ID09PSB1bmRlZmluZWQpcmV0dXJuIGZuO1xuXHQgIHN3aXRjaChsZW5ndGgpe1xuXHQgICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24oYSl7XG5cdCAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuXHQgICAgfTtcblx0ICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uKGEsIGIpe1xuXHQgICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcblx0ICAgIH07XG5cdCAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbihhLCBiLCBjKXtcblx0ICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG5cdCAgICB9O1xuXHQgIH1cblx0ICByZXR1cm4gZnVuY3Rpb24oLyogLi4uYXJncyAqLyl7XG5cdCAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcblx0ICB9O1xuXHR9O1xuXG4vKioqLyB9KSxcbi8qIDE2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG5cdCAgaWYodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcblx0ICByZXR1cm4gaXQ7XG5cdH07XG5cbi8qKiovIH0pLFxuLyogMTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgZFAgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpXG5cdCAgLCBjcmVhdGVEZXNjID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNik7XG5cdG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMikgPyBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpe1xuXHQgIHJldHVybiBkUC5mKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG5cdH0gOiBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpe1xuXHQgIG9iamVjdFtrZXldID0gdmFsdWU7XG5cdCAgcmV0dXJuIG9iamVjdDtcblx0fTtcblxuLyoqKi8gfSksXG4vKiAxOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBhbk9iamVjdCAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpXG5cdCAgLCBJRThfRE9NX0RFRklORSA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpXG5cdCAgLCB0b1ByaW1pdGl2ZSAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMjUpXG5cdCAgLCBkUCAgICAgICAgICAgICA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuXHRleHBvcnRzLmYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpe1xuXHQgIGFuT2JqZWN0KE8pO1xuXHQgIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcblx0ICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcblx0ICBpZihJRThfRE9NX0RFRklORSl0cnkge1xuXHQgICAgcmV0dXJuIGRQKE8sIFAsIEF0dHJpYnV0ZXMpO1xuXHQgIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cblx0ICBpZignZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcblx0ICBpZigndmFsdWUnIGluIEF0dHJpYnV0ZXMpT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG5cdCAgcmV0dXJuIE87XG5cdH07XG5cbi8qKiovIH0pLFxuLyogMTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG5cdCAgaWYoIWlzT2JqZWN0KGl0KSl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhbiBvYmplY3QhJyk7XG5cdCAgcmV0dXJuIGl0O1xuXHR9O1xuXG4vKioqLyB9KSxcbi8qIDIwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG5cdCAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcblx0fTtcblxuLyoqKi8gfSksXG4vKiAyMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdG1vZHVsZS5leHBvcnRzID0gIV9fd2VicGFja19yZXF1aXJlX18oMjIpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKShmdW5jdGlvbigpe1xuXHQgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoX193ZWJwYWNrX3JlcXVpcmVfXygyNCkoJ2RpdicpLCAnYScsIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiA3OyB9fSkuYSAhPSA3O1xuXHR9KTtcblxuLyoqKi8gfSksXG4vKiAyMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcblx0bW9kdWxlLmV4cG9ydHMgPSAhX193ZWJwYWNrX3JlcXVpcmVfXygyMykoZnVuY3Rpb24oKXtcblx0ICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiA3OyB9fSkuYSAhPSA3O1xuXHR9KTtcblxuLyoqKi8gfSksXG4vKiAyMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZXhlYyl7XG5cdCAgdHJ5IHtcblx0ICAgIHJldHVybiAhIWV4ZWMoKTtcblx0ICB9IGNhdGNoKGUpe1xuXHQgICAgcmV0dXJuIHRydWU7XG5cdCAgfVxuXHR9O1xuXG4vKioqLyB9KSxcbi8qIDI0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMClcblx0ICAsIGRvY3VtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMykuZG9jdW1lbnRcblx0ICAvLyBpbiBvbGQgSUUgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCdcblx0ICAsIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcblx0ICByZXR1cm4gaXMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xuXHR9O1xuXG4vKioqLyB9KSxcbi8qIDI1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0Ly8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG5cdHZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xuXHQvLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuXHQvLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBTKXtcblx0ICBpZighaXNPYmplY3QoaXQpKXJldHVybiBpdDtcblx0ICB2YXIgZm4sIHZhbDtcblx0ICBpZihTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG5cdCAgaWYodHlwZW9mIChmbiA9IGl0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuXHQgIGlmKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG5cdCAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xuXHR9O1xuXG4vKioqLyB9KSxcbi8qIDI2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihiaXRtYXAsIHZhbHVlKXtcblx0ICByZXR1cm4ge1xuXHQgICAgZW51bWVyYWJsZSAgOiAhKGJpdG1hcCAmIDEpLFxuXHQgICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuXHQgICAgd3JpdGFibGUgICAgOiAhKGJpdG1hcCAmIDQpLFxuXHQgICAgdmFsdWUgICAgICAgOiB2YWx1ZVxuXHQgIH07XG5cdH07XG5cbi8qKiovIH0pLFxuLyogMjcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xuXG4vKioqLyB9KSxcbi8qIDI4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0dmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIGtleSl7XG5cdCAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG5cdH07XG5cbi8qKiovIH0pLFxuLyogMjkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vKioqLyB9KSxcbi8qIDMwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHR2YXIgY3JlYXRlICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKVxuXHQgICwgZGVzY3JpcHRvciAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KVxuXHQgICwgc2V0VG9TdHJpbmdUYWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ2KVxuXHQgICwgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcblxuXHQvLyAyNS4xLjIuMS4xICVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKVxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KShJdGVyYXRvclByb3RvdHlwZSwgX193ZWJwYWNrX3JlcXVpcmVfXyg0NykoJ2l0ZXJhdG9yJyksIGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzOyB9KTtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KXtcblx0ICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHtuZXh0OiBkZXNjcmlwdG9yKDEsIG5leHQpfSk7XG5cdCAgc2V0VG9TdHJpbmdUYWcoQ29uc3RydWN0b3IsIE5BTUUgKyAnIEl0ZXJhdG9yJyk7XG5cdH07XG5cbi8qKiovIH0pLFxuLyogMzEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcblx0dmFyIGFuT2JqZWN0ICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSlcblx0ICAsIGRQcyAgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMilcblx0ICAsIGVudW1CdWdLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NClcblx0ICAsIElFX1BST1RPICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MSkoJ0lFX1BST1RPJylcblx0ICAsIEVtcHR5ICAgICAgID0gZnVuY3Rpb24oKXsgLyogZW1wdHkgKi8gfVxuXHQgICwgUFJPVE9UWVBFICAgPSAncHJvdG90eXBlJztcblxuXHQvLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG5cdHZhciBjcmVhdGVEaWN0ID0gZnVuY3Rpb24oKXtcblx0ICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xuXHQgIHZhciBpZnJhbWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KSgnaWZyYW1lJylcblx0ICAgICwgaSAgICAgID0gZW51bUJ1Z0tleXMubGVuZ3RoXG5cdCAgICAsIGx0ICAgICA9ICc8J1xuXHQgICAgLCBndCAgICAgPSAnPidcblx0ICAgICwgaWZyYW1lRG9jdW1lbnQ7XG5cdCAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cdCAgX193ZWJwYWNrX3JlcXVpcmVfXyg0NSkuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcblx0ICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXG5cdCAgLy8gY3JlYXRlRGljdCA9IGlmcmFtZS5jb250ZW50V2luZG93Lk9iamVjdDtcblx0ICAvLyBodG1sLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG5cdCAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcblx0ICBpZnJhbWVEb2N1bWVudC5vcGVuKCk7XG5cdCAgaWZyYW1lRG9jdW1lbnQud3JpdGUobHQgKyAnc2NyaXB0JyArIGd0ICsgJ2RvY3VtZW50LkY9T2JqZWN0JyArIGx0ICsgJy9zY3JpcHQnICsgZ3QpO1xuXHQgIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG5cdCAgY3JlYXRlRGljdCA9IGlmcmFtZURvY3VtZW50LkY7XG5cdCAgd2hpbGUoaS0tKWRlbGV0ZSBjcmVhdGVEaWN0W1BST1RPVFlQRV1bZW51bUJ1Z0tleXNbaV1dO1xuXHQgIHJldHVybiBjcmVhdGVEaWN0KCk7XG5cdH07XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKXtcblx0ICB2YXIgcmVzdWx0O1xuXHQgIGlmKE8gIT09IG51bGwpe1xuXHQgICAgRW1wdHlbUFJPVE9UWVBFXSA9IGFuT2JqZWN0KE8pO1xuXHQgICAgcmVzdWx0ID0gbmV3IEVtcHR5O1xuXHQgICAgRW1wdHlbUFJPVE9UWVBFXSA9IG51bGw7XG5cdCAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG5cdCAgICByZXN1bHRbSUVfUFJPVE9dID0gTztcblx0ICB9IGVsc2UgcmVzdWx0ID0gY3JlYXRlRGljdCgpO1xuXHQgIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkUHMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcblx0fTtcblxuXG4vKioqLyB9KSxcbi8qIDMyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIGRQICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOClcblx0ICAsIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSlcblx0ICAsIGdldEtleXMgID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKXtcblx0ICBhbk9iamVjdChPKTtcblx0ICB2YXIga2V5cyAgID0gZ2V0S2V5cyhQcm9wZXJ0aWVzKVxuXHQgICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuXHQgICAgLCBpID0gMFxuXHQgICAgLCBQO1xuXHQgIHdoaWxlKGxlbmd0aCA+IGkpZFAuZihPLCBQID0ga2V5c1tpKytdLCBQcm9wZXJ0aWVzW1BdKTtcblx0ICByZXR1cm4gTztcblx0fTtcblxuLyoqKi8gfSksXG4vKiAzMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8vIDE5LjEuMi4xNCAvIDE1LjIuMy4xNCBPYmplY3Qua2V5cyhPKVxuXHR2YXIgJGtleXMgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0KVxuXHQgICwgZW51bUJ1Z0tleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0KTtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTyl7XG5cdCAgcmV0dXJuICRrZXlzKE8sIGVudW1CdWdLZXlzKTtcblx0fTtcblxuLyoqKi8gfSksXG4vKiAzNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBoYXMgICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KVxuXHQgICwgdG9JT2JqZWN0ICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNSlcblx0ICAsIGFycmF5SW5kZXhPZiA9IF9fd2VicGFja19yZXF1aXJlX18oMzgpKGZhbHNlKVxuXHQgICwgSUVfUFJPVE8gICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MSkoJ0lFX1BST1RPJyk7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmplY3QsIG5hbWVzKXtcblx0ICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KG9iamVjdClcblx0ICAgICwgaSAgICAgID0gMFxuXHQgICAgLCByZXN1bHQgPSBbXVxuXHQgICAgLCBrZXk7XG5cdCAgZm9yKGtleSBpbiBPKWlmKGtleSAhPSBJRV9QUk9UTyloYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuXHQgIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcblx0ICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKWlmKGhhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSl7XG5cdCAgICB+YXJyYXlJbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpO1xuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG4vKioqLyB9KSxcbi8qIDM1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0Ly8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG5cdHZhciBJT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNilcblx0ICAsIGRlZmluZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcblx0ICByZXR1cm4gSU9iamVjdChkZWZpbmVkKGl0KSk7XG5cdH07XG5cbi8qKiovIH0pLFxuLyogMzYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xuXHR2YXIgY29mID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNyk7XG5cdG1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbihpdCl7XG5cdCAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xuXHR9O1xuXG4vKioqLyB9KSxcbi8qIDM3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0dmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG5cdCAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcblx0fTtcblxuLyoqKi8gfSksXG4vKiAzOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2Zcblx0Ly8gdHJ1ZSAgLT4gQXJyYXkjaW5jbHVkZXNcblx0dmFyIHRvSU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMzUpXG5cdCAgLCB0b0xlbmd0aCAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM5KVxuXHQgICwgdG9JbmRleCAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MCk7XG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oSVNfSU5DTFVERVMpe1xuXHQgIHJldHVybiBmdW5jdGlvbigkdGhpcywgZWwsIGZyb21JbmRleCl7XG5cdCAgICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KCR0aGlzKVxuXHQgICAgICAsIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKVxuXHQgICAgICAsIGluZGV4ICA9IHRvSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpXG5cdCAgICAgICwgdmFsdWU7XG5cdCAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG5cdCAgICBpZihJU19JTkNMVURFUyAmJiBlbCAhPSBlbCl3aGlsZShsZW5ndGggPiBpbmRleCl7XG5cdCAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcblx0ICAgICAgaWYodmFsdWUgIT0gdmFsdWUpcmV0dXJuIHRydWU7XG5cdCAgICAvLyBBcnJheSN0b0luZGV4IGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG5cdCAgICB9IGVsc2UgZm9yKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKylpZihJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKXtcblx0ICAgICAgaWYoT1tpbmRleF0gPT09IGVsKXJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuXHQgICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuXHQgIH07XG5cdH07XG5cbi8qKiovIH0pLFxuLyogMzkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvLyA3LjEuMTUgVG9MZW5ndGhcblx0dmFyIHRvSW50ZWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oOClcblx0ICAsIG1pbiAgICAgICA9IE1hdGgubWluO1xuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcblx0ICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxuXHR9O1xuXG4vKioqLyB9KSxcbi8qIDQwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIHRvSW50ZWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oOClcblx0ICAsIG1heCAgICAgICA9IE1hdGgubWF4XG5cdCAgLCBtaW4gICAgICAgPSBNYXRoLm1pbjtcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpbmRleCwgbGVuZ3RoKXtcblx0ICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XG5cdCAgcmV0dXJuIGluZGV4IDwgMCA/IG1heChpbmRleCArIGxlbmd0aCwgMCkgOiBtaW4oaW5kZXgsIGxlbmd0aCk7XG5cdH07XG5cbi8qKiovIH0pLFxuLyogNDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgc2hhcmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MikoJ2tleXMnKVxuXHQgICwgdWlkICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Myk7XG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcblx0ICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpO1xuXHR9O1xuXG4vKioqLyB9KSxcbi8qIDQyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpXG5cdCAgLCBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJ1xuXHQgICwgc3RvcmUgID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG5cdCAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB7fSk7XG5cdH07XG5cbi8qKiovIH0pLFxuLyogNDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHR2YXIgaWQgPSAwXG5cdCAgLCBweCA9IE1hdGgucmFuZG9tKCk7XG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcblx0ICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpO1xuXHR9O1xuXG4vKioqLyB9KSxcbi8qIDQ0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0Ly8gSUUgOC0gZG9uJ3QgZW51bSBidWcga2V5c1xuXHRtb2R1bGUuZXhwb3J0cyA9IChcblx0ICAnY29uc3RydWN0b3IsaGFzT3duUHJvcGVydHksaXNQcm90b3R5cGVPZixwcm9wZXJ0eUlzRW51bWVyYWJsZSx0b0xvY2FsZVN0cmluZyx0b1N0cmluZyx2YWx1ZU9mJ1xuXHQpLnNwbGl0KCcsJyk7XG5cbi8qKiovIH0pLFxuLyogNDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpLmRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuLyoqKi8gfSksXG4vKiA0NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBkZWYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KS5mXG5cdCAgLCBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KVxuXHQgICwgVEFHID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NykoJ3RvU3RyaW5nVGFnJyk7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgdGFnLCBzdGF0KXtcblx0ICBpZihpdCAmJiAhaGFzKGl0ID0gc3RhdCA/IGl0IDogaXQucHJvdG90eXBlLCBUQUcpKWRlZihpdCwgVEFHLCB7Y29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogdGFnfSk7XG5cdH07XG5cbi8qKiovIH0pLFxuLyogNDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgc3RvcmUgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNDIpKCd3a3MnKVxuXHQgICwgdWlkICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNDMpXG5cdCAgLCBTeW1ib2wgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMykuU3ltYm9sXG5cdCAgLCBVU0VfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xuXG5cdHZhciAkZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obmFtZSl7XG5cdCAgcmV0dXJuIHN0b3JlW25hbWVdIHx8IChzdG9yZVtuYW1lXSA9XG5cdCAgICBVU0VfU1lNQk9MICYmIFN5bWJvbFtuYW1lXSB8fCAoVVNFX1NZTUJPTCA/IFN5bWJvbCA6IHVpZCkoJ1N5bWJvbC4nICsgbmFtZSkpO1xuXHR9O1xuXG5cdCRleHBvcnRzLnN0b3JlID0gc3RvcmU7XG5cbi8qKiovIH0pLFxuLyogNDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvLyAxOS4xLjIuOSAvIDE1LjIuMy4yIE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxuXHR2YXIgaGFzICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KVxuXHQgICwgdG9PYmplY3QgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5KVxuXHQgICwgSUVfUFJPVE8gICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxKSgnSUVfUFJPVE8nKVxuXHQgICwgT2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG5cdG1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uKE8pe1xuXHQgIE8gPSB0b09iamVjdChPKTtcblx0ICBpZihoYXMoTywgSUVfUFJPVE8pKXJldHVybiBPW0lFX1BST1RPXTtcblx0ICBpZih0eXBlb2YgTy5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIE8gaW5zdGFuY2VvZiBPLmNvbnN0cnVjdG9yKXtcblx0ICAgIHJldHVybiBPLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcblx0ICB9IHJldHVybiBPIGluc3RhbmNlb2YgT2JqZWN0ID8gT2JqZWN0UHJvdG8gOiBudWxsO1xuXHR9O1xuXG4vKioqLyB9KSxcbi8qIDQ5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0Ly8gNy4xLjEzIFRvT2JqZWN0KGFyZ3VtZW50KVxuXHR2YXIgZGVmaW5lZCA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuXHQgIHJldHVybiBPYmplY3QoZGVmaW5lZChpdCkpO1xuXHR9O1xuXG4vKioqLyB9KSxcbi8qIDUwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0X193ZWJwYWNrX3JlcXVpcmVfXyg1MSk7XG5cdHZhciBnbG9iYWwgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMylcblx0ICAsIGhpZGUgICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KVxuXHQgICwgSXRlcmF0b3JzICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpXG5cdCAgLCBUT19TVFJJTkdfVEFHID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NykoJ3RvU3RyaW5nVGFnJyk7XG5cblx0Zm9yKHZhciBjb2xsZWN0aW9ucyA9IFsnTm9kZUxpc3QnLCAnRE9NVG9rZW5MaXN0JywgJ01lZGlhTGlzdCcsICdTdHlsZVNoZWV0TGlzdCcsICdDU1NSdWxlTGlzdCddLCBpID0gMDsgaSA8IDU7IGkrKyl7XG5cdCAgdmFyIE5BTUUgICAgICAgPSBjb2xsZWN0aW9uc1tpXVxuXHQgICAgLCBDb2xsZWN0aW9uID0gZ2xvYmFsW05BTUVdXG5cdCAgICAsIHByb3RvICAgICAgPSBDb2xsZWN0aW9uICYmIENvbGxlY3Rpb24ucHJvdG90eXBlO1xuXHQgIGlmKHByb3RvICYmICFwcm90b1tUT19TVFJJTkdfVEFHXSloaWRlKHByb3RvLCBUT19TVFJJTkdfVEFHLCBOQU1FKTtcblx0ICBJdGVyYXRvcnNbTkFNRV0gPSBJdGVyYXRvcnMuQXJyYXk7XG5cdH1cblxuLyoqKi8gfSksXG4vKiA1MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0dmFyIGFkZFRvVW5zY29wYWJsZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUyKVxuXHQgICwgc3RlcCAgICAgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNTMpXG5cdCAgLCBJdGVyYXRvcnMgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOSlcblx0ICAsIHRvSU9iamVjdCAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1KTtcblxuXHQvLyAyMi4xLjMuNCBBcnJheS5wcm90b3R5cGUuZW50cmllcygpXG5cdC8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUua2V5cygpXG5cdC8vIDIyLjEuMy4yOSBBcnJheS5wcm90b3R5cGUudmFsdWVzKClcblx0Ly8gMjIuMS4zLjMwIEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5cdG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCkoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uKGl0ZXJhdGVkLCBraW5kKXtcblx0ICB0aGlzLl90ID0gdG9JT2JqZWN0KGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG5cdCAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcblx0ICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgLy8ga2luZFxuXHQvLyAyMi4xLjUuMi4xICVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcblx0fSwgZnVuY3Rpb24oKXtcblx0ICB2YXIgTyAgICAgPSB0aGlzLl90XG5cdCAgICAsIGtpbmQgID0gdGhpcy5fa1xuXHQgICAgLCBpbmRleCA9IHRoaXMuX2krKztcblx0ICBpZighTyB8fCBpbmRleCA+PSBPLmxlbmd0aCl7XG5cdCAgICB0aGlzLl90ID0gdW5kZWZpbmVkO1xuXHQgICAgcmV0dXJuIHN0ZXAoMSk7XG5cdCAgfVxuXHQgIGlmKGtpbmQgPT0gJ2tleXMnICApcmV0dXJuIHN0ZXAoMCwgaW5kZXgpO1xuXHQgIGlmKGtpbmQgPT0gJ3ZhbHVlcycpcmV0dXJuIHN0ZXAoMCwgT1tpbmRleF0pO1xuXHQgIHJldHVybiBzdGVwKDAsIFtpbmRleCwgT1tpbmRleF1dKTtcblx0fSwgJ3ZhbHVlcycpO1xuXG5cdC8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJSAoOS40LjQuNiwgOS40LjQuNylcblx0SXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblxuXHRhZGRUb1Vuc2NvcGFibGVzKCdrZXlzJyk7XG5cdGFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuXHRhZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7XG5cbi8qKiovIH0pLFxuLyogNTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCl7IC8qIGVtcHR5ICovIH07XG5cbi8qKiovIH0pLFxuLyogNTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRvbmUsIHZhbHVlKXtcblx0ICByZXR1cm4ge3ZhbHVlOiB2YWx1ZSwgZG9uZTogISFkb25lfTtcblx0fTtcblxuLyoqKi8gfSksXG4vKiA1NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdGV4cG9ydHMuZiA9IF9fd2VicGFja19yZXF1aXJlX18oNDcpO1xuXG4vKioqLyB9KSxcbi8qIDU1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDU2KSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG4vKioqLyB9KSxcbi8qIDU2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0X193ZWJwYWNrX3JlcXVpcmVfXyg1Nyk7XG5cdF9fd2VicGFja19yZXF1aXJlX18oNjgpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDY5KTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXyg3MCk7XG5cdG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCkuU3ltYm9sO1xuXG4vKioqLyB9KSxcbi8qIDU3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHQvLyBFQ01BU2NyaXB0IDYgc3ltYm9scyBzaGltXG5cdHZhciBnbG9iYWwgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpXG5cdCAgLCBoYXMgICAgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpXG5cdCAgLCBERVNDUklQVE9SUyAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpXG5cdCAgLCAkZXhwb3J0ICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpXG5cdCAgLCByZWRlZmluZSAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMjcpXG5cdCAgLCBNRVRBICAgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNTgpLktFWVxuXHQgICwgJGZhaWxzICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKVxuXHQgICwgc2hhcmVkICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyKVxuXHQgICwgc2V0VG9TdHJpbmdUYWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ2KVxuXHQgICwgdWlkICAgICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzKVxuXHQgICwgd2tzICAgICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3KVxuXHQgICwgd2tzRXh0ICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU0KVxuXHQgICwgd2tzRGVmaW5lICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU5KVxuXHQgICwga2V5T2YgICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYwKVxuXHQgICwgZW51bUtleXMgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxKVxuXHQgICwgaXNBcnJheSAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY0KVxuXHQgICwgYW5PYmplY3QgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KVxuXHQgICwgdG9JT2JqZWN0ICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1KVxuXHQgICwgdG9QcmltaXRpdmUgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KVxuXHQgICwgY3JlYXRlRGVzYyAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KVxuXHQgICwgX2NyZWF0ZSAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKVxuXHQgICwgZ09QTkV4dCAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY1KVxuXHQgICwgJEdPUEQgICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY3KVxuXHQgICwgJERQICAgICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KVxuXHQgICwgJGtleXMgICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKVxuXHQgICwgZ09QRCAgICAgICAgICAgPSAkR09QRC5mXG5cdCAgLCBkUCAgICAgICAgICAgICA9ICREUC5mXG5cdCAgLCBnT1BOICAgICAgICAgICA9IGdPUE5FeHQuZlxuXHQgICwgJFN5bWJvbCAgICAgICAgPSBnbG9iYWwuU3ltYm9sXG5cdCAgLCAkSlNPTiAgICAgICAgICA9IGdsb2JhbC5KU09OXG5cdCAgLCBfc3RyaW5naWZ5ICAgICA9ICRKU09OICYmICRKU09OLnN0cmluZ2lmeVxuXHQgICwgUFJPVE9UWVBFICAgICAgPSAncHJvdG90eXBlJ1xuXHQgICwgSElEREVOICAgICAgICAgPSB3a3MoJ19oaWRkZW4nKVxuXHQgICwgVE9fUFJJTUlUSVZFICAgPSB3a3MoJ3RvUHJpbWl0aXZlJylcblx0ICAsIGlzRW51bSAgICAgICAgID0ge30ucHJvcGVydHlJc0VudW1lcmFibGVcblx0ICAsIFN5bWJvbFJlZ2lzdHJ5ID0gc2hhcmVkKCdzeW1ib2wtcmVnaXN0cnknKVxuXHQgICwgQWxsU3ltYm9scyAgICAgPSBzaGFyZWQoJ3N5bWJvbHMnKVxuXHQgICwgT1BTeW1ib2xzICAgICAgPSBzaGFyZWQoJ29wLXN5bWJvbHMnKVxuXHQgICwgT2JqZWN0UHJvdG8gICAgPSBPYmplY3RbUFJPVE9UWVBFXVxuXHQgICwgVVNFX05BVElWRSAgICAgPSB0eXBlb2YgJFN5bWJvbCA9PSAnZnVuY3Rpb24nXG5cdCAgLCBRT2JqZWN0ICAgICAgICA9IGdsb2JhbC5RT2JqZWN0O1xuXHQvLyBEb24ndCB1c2Ugc2V0dGVycyBpbiBRdCBTY3JpcHQsIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xNzNcblx0dmFyIHNldHRlciA9ICFRT2JqZWN0IHx8ICFRT2JqZWN0W1BST1RPVFlQRV0gfHwgIVFPYmplY3RbUFJPVE9UWVBFXS5maW5kQ2hpbGQ7XG5cblx0Ly8gZmFsbGJhY2sgZm9yIG9sZCBBbmRyb2lkLCBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9Njg3XG5cdHZhciBzZXRTeW1ib2xEZXNjID0gREVTQ1JJUFRPUlMgJiYgJGZhaWxzKGZ1bmN0aW9uKCl7XG5cdCAgcmV0dXJuIF9jcmVhdGUoZFAoe30sICdhJywge1xuXHQgICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gZFAodGhpcywgJ2EnLCB7dmFsdWU6IDd9KS5hOyB9XG5cdCAgfSkpLmEgIT0gNztcblx0fSkgPyBmdW5jdGlvbihpdCwga2V5LCBEKXtcblx0ICB2YXIgcHJvdG9EZXNjID0gZ09QRChPYmplY3RQcm90bywga2V5KTtcblx0ICBpZihwcm90b0Rlc2MpZGVsZXRlIE9iamVjdFByb3RvW2tleV07XG5cdCAgZFAoaXQsIGtleSwgRCk7XG5cdCAgaWYocHJvdG9EZXNjICYmIGl0ICE9PSBPYmplY3RQcm90bylkUChPYmplY3RQcm90bywga2V5LCBwcm90b0Rlc2MpO1xuXHR9IDogZFA7XG5cblx0dmFyIHdyYXAgPSBmdW5jdGlvbih0YWcpe1xuXHQgIHZhciBzeW0gPSBBbGxTeW1ib2xzW3RhZ10gPSBfY3JlYXRlKCRTeW1ib2xbUFJPVE9UWVBFXSk7XG5cdCAgc3ltLl9rID0gdGFnO1xuXHQgIHJldHVybiBzeW07XG5cdH07XG5cblx0dmFyIGlzU3ltYm9sID0gVVNFX05BVElWRSAmJiB0eXBlb2YgJFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJyA/IGZ1bmN0aW9uKGl0KXtcblx0ICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xuXHR9IDogZnVuY3Rpb24oaXQpe1xuXHQgIHJldHVybiBpdCBpbnN0YW5jZW9mICRTeW1ib2w7XG5cdH07XG5cblx0dmFyICRkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIEQpe1xuXHQgIGlmKGl0ID09PSBPYmplY3RQcm90bykkZGVmaW5lUHJvcGVydHkoT1BTeW1ib2xzLCBrZXksIEQpO1xuXHQgIGFuT2JqZWN0KGl0KTtcblx0ICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuXHQgIGFuT2JqZWN0KEQpO1xuXHQgIGlmKGhhcyhBbGxTeW1ib2xzLCBrZXkpKXtcblx0ICAgIGlmKCFELmVudW1lcmFibGUpe1xuXHQgICAgICBpZighaGFzKGl0LCBISURERU4pKWRQKGl0LCBISURERU4sIGNyZWF0ZURlc2MoMSwge30pKTtcblx0ICAgICAgaXRbSElEREVOXVtrZXldID0gdHJ1ZTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGlmKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0paXRbSElEREVOXVtrZXldID0gZmFsc2U7XG5cdCAgICAgIEQgPSBfY3JlYXRlKEQsIHtlbnVtZXJhYmxlOiBjcmVhdGVEZXNjKDAsIGZhbHNlKX0pO1xuXHQgICAgfSByZXR1cm4gc2V0U3ltYm9sRGVzYyhpdCwga2V5LCBEKTtcblx0ICB9IHJldHVybiBkUChpdCwga2V5LCBEKTtcblx0fTtcblx0dmFyICRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhpdCwgUCl7XG5cdCAgYW5PYmplY3QoaXQpO1xuXHQgIHZhciBrZXlzID0gZW51bUtleXMoUCA9IHRvSU9iamVjdChQKSlcblx0ICAgICwgaSAgICA9IDBcblx0ICAgICwgbCA9IGtleXMubGVuZ3RoXG5cdCAgICAsIGtleTtcblx0ICB3aGlsZShsID4gaSkkZGVmaW5lUHJvcGVydHkoaXQsIGtleSA9IGtleXNbaSsrXSwgUFtrZXldKTtcblx0ICByZXR1cm4gaXQ7XG5cdH07XG5cdHZhciAkY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGl0LCBQKXtcblx0ICByZXR1cm4gUCA9PT0gdW5kZWZpbmVkID8gX2NyZWF0ZShpdCkgOiAkZGVmaW5lUHJvcGVydGllcyhfY3JlYXRlKGl0KSwgUCk7XG5cdH07XG5cdHZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShrZXkpe1xuXHQgIHZhciBFID0gaXNFbnVtLmNhbGwodGhpcywga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSk7XG5cdCAgaWYodGhpcyA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpcmV0dXJuIGZhbHNlO1xuXHQgIHJldHVybiBFIHx8ICFoYXModGhpcywga2V5KSB8fCAhaGFzKEFsbFN5bWJvbHMsIGtleSkgfHwgaGFzKHRoaXMsIEhJRERFTikgJiYgdGhpc1tISURERU5dW2tleV0gPyBFIDogdHJ1ZTtcblx0fTtcblx0dmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSl7XG5cdCAgaXQgID0gdG9JT2JqZWN0KGl0KTtcblx0ICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuXHQgIGlmKGl0ID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSlyZXR1cm47XG5cdCAgdmFyIEQgPSBnT1BEKGl0LCBrZXkpO1xuXHQgIGlmKEQgJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIShoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSlELmVudW1lcmFibGUgPSB0cnVlO1xuXHQgIHJldHVybiBEO1xuXHR9O1xuXHR2YXIgJGdldE93blByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KXtcblx0ICB2YXIgbmFtZXMgID0gZ09QTih0b0lPYmplY3QoaXQpKVxuXHQgICAgLCByZXN1bHQgPSBbXVxuXHQgICAgLCBpICAgICAgPSAwXG5cdCAgICAsIGtleTtcblx0ICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKXtcblx0ICAgIGlmKCFoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYga2V5ICE9IEhJRERFTiAmJiBrZXkgIT0gTUVUQSlyZXN1bHQucHVzaChrZXkpO1xuXHQgIH0gcmV0dXJuIHJlc3VsdDtcblx0fTtcblx0dmFyICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpe1xuXHQgIHZhciBJU19PUCAgPSBpdCA9PT0gT2JqZWN0UHJvdG9cblx0ICAgICwgbmFtZXMgID0gZ09QTihJU19PUCA/IE9QU3ltYm9scyA6IHRvSU9iamVjdChpdCkpXG5cdCAgICAsIHJlc3VsdCA9IFtdXG5cdCAgICAsIGkgICAgICA9IDBcblx0ICAgICwga2V5O1xuXHQgIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpe1xuXHQgICAgaWYoaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIChJU19PUCA/IGhhcyhPYmplY3RQcm90bywga2V5KSA6IHRydWUpKXJlc3VsdC5wdXNoKEFsbFN5bWJvbHNba2V5XSk7XG5cdCAgfSByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdC8vIDE5LjQuMS4xIFN5bWJvbChbZGVzY3JpcHRpb25dKVxuXHRpZighVVNFX05BVElWRSl7XG5cdCAgJFN5bWJvbCA9IGZ1bmN0aW9uIFN5bWJvbCgpe1xuXHQgICAgaWYodGhpcyBpbnN0YW5jZW9mICRTeW1ib2wpdGhyb3cgVHlwZUVycm9yKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3IhJyk7XG5cdCAgICB2YXIgdGFnID0gdWlkKGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcblx0ICAgIHZhciAkc2V0ID0gZnVuY3Rpb24odmFsdWUpe1xuXHQgICAgICBpZih0aGlzID09PSBPYmplY3RQcm90bykkc2V0LmNhbGwoT1BTeW1ib2xzLCB2YWx1ZSk7XG5cdCAgICAgIGlmKGhhcyh0aGlzLCBISURERU4pICYmIGhhcyh0aGlzW0hJRERFTl0sIHRhZykpdGhpc1tISURERU5dW3RhZ10gPSBmYWxzZTtcblx0ICAgICAgc2V0U3ltYm9sRGVzYyh0aGlzLCB0YWcsIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcblx0ICAgIH07XG5cdCAgICBpZihERVNDUklQVE9SUyAmJiBzZXR0ZXIpc2V0U3ltYm9sRGVzYyhPYmplY3RQcm90bywgdGFnLCB7Y29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6ICRzZXR9KTtcblx0ICAgIHJldHVybiB3cmFwKHRhZyk7XG5cdCAgfTtcblx0ICByZWRlZmluZSgkU3ltYm9sW1BST1RPVFlQRV0sICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCl7XG5cdCAgICByZXR1cm4gdGhpcy5faztcblx0ICB9KTtcblxuXHQgICRHT1BELmYgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXHQgICREUC5mICAgPSAkZGVmaW5lUHJvcGVydHk7XG5cdCAgX193ZWJwYWNrX3JlcXVpcmVfXyg2NikuZiA9IGdPUE5FeHQuZiA9ICRnZXRPd25Qcm9wZXJ0eU5hbWVzO1xuXHQgIF9fd2VicGFja19yZXF1aXJlX18oNjMpLmYgID0gJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXHQgIF9fd2VicGFja19yZXF1aXJlX18oNjIpLmYgPSAkZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG5cdCAgaWYoREVTQ1JJUFRPUlMgJiYgIV9fd2VicGFja19yZXF1aXJlX18oMTEpKXtcblx0ICAgIHJlZGVmaW5lKE9iamVjdFByb3RvLCAncHJvcGVydHlJc0VudW1lcmFibGUnLCAkcHJvcGVydHlJc0VudW1lcmFibGUsIHRydWUpO1xuXHQgIH1cblxuXHQgIHdrc0V4dC5mID0gZnVuY3Rpb24obmFtZSl7XG5cdCAgICByZXR1cm4gd3JhcCh3a3MobmFtZSkpO1xuXHQgIH1cblx0fVxuXG5cdCRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIHtTeW1ib2w6ICRTeW1ib2x9KTtcblxuXHRmb3IodmFyIHN5bWJvbHMgPSAoXG5cdCAgLy8gMTkuNC4yLjIsIDE5LjQuMi4zLCAxOS40LjIuNCwgMTkuNC4yLjYsIDE5LjQuMi44LCAxOS40LjIuOSwgMTkuNC4yLjEwLCAxOS40LjIuMTEsIDE5LjQuMi4xMiwgMTkuNC4yLjEzLCAxOS40LjIuMTRcblx0ICAnaGFzSW5zdGFuY2UsaXNDb25jYXRTcHJlYWRhYmxlLGl0ZXJhdG9yLG1hdGNoLHJlcGxhY2Usc2VhcmNoLHNwZWNpZXMsc3BsaXQsdG9QcmltaXRpdmUsdG9TdHJpbmdUYWcsdW5zY29wYWJsZXMnXG5cdCkuc3BsaXQoJywnKSwgaSA9IDA7IHN5bWJvbHMubGVuZ3RoID4gaTsgKXdrcyhzeW1ib2xzW2krK10pO1xuXG5cdGZvcih2YXIgc3ltYm9scyA9ICRrZXlzKHdrcy5zdG9yZSksIGkgPSAwOyBzeW1ib2xzLmxlbmd0aCA+IGk7ICl3a3NEZWZpbmUoc3ltYm9sc1tpKytdKTtcblxuXHQkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnU3ltYm9sJywge1xuXHQgIC8vIDE5LjQuMi4xIFN5bWJvbC5mb3Ioa2V5KVxuXHQgICdmb3InOiBmdW5jdGlvbihrZXkpe1xuXHQgICAgcmV0dXJuIGhhcyhTeW1ib2xSZWdpc3RyeSwga2V5ICs9ICcnKVxuXHQgICAgICA/IFN5bWJvbFJlZ2lzdHJ5W2tleV1cblx0ICAgICAgOiBTeW1ib2xSZWdpc3RyeVtrZXldID0gJFN5bWJvbChrZXkpO1xuXHQgIH0sXG5cdCAgLy8gMTkuNC4yLjUgU3ltYm9sLmtleUZvcihzeW0pXG5cdCAga2V5Rm9yOiBmdW5jdGlvbiBrZXlGb3Ioa2V5KXtcblx0ICAgIGlmKGlzU3ltYm9sKGtleSkpcmV0dXJuIGtleU9mKFN5bWJvbFJlZ2lzdHJ5LCBrZXkpO1xuXHQgICAgdGhyb3cgVHlwZUVycm9yKGtleSArICcgaXMgbm90IGEgc3ltYm9sIScpO1xuXHQgIH0sXG5cdCAgdXNlU2V0dGVyOiBmdW5jdGlvbigpeyBzZXR0ZXIgPSB0cnVlOyB9LFxuXHQgIHVzZVNpbXBsZTogZnVuY3Rpb24oKXsgc2V0dGVyID0gZmFsc2U7IH1cblx0fSk7XG5cblx0JGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ09iamVjdCcsIHtcblx0ICAvLyAxOS4xLjIuMiBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG5cdCAgY3JlYXRlOiAkY3JlYXRlLFxuXHQgIC8vIDE5LjEuMi40IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuXHQgIGRlZmluZVByb3BlcnR5OiAkZGVmaW5lUHJvcGVydHksXG5cdCAgLy8gMTkuMS4yLjMgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcblx0ICBkZWZpbmVQcm9wZXJ0aWVzOiAkZGVmaW5lUHJvcGVydGllcyxcblx0ICAvLyAxOS4xLjIuNiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApXG5cdCAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuXHQgIC8vIDE5LjEuMi43IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG5cdCAgZ2V0T3duUHJvcGVydHlOYW1lczogJGdldE93blByb3BlcnR5TmFtZXMsXG5cdCAgLy8gMTkuMS4yLjggT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhPKVxuXHQgIGdldE93blByb3BlcnR5U3ltYm9sczogJGdldE93blByb3BlcnR5U3ltYm9sc1xuXHR9KTtcblxuXHQvLyAyNC4zLjIgSlNPTi5zdHJpbmdpZnkodmFsdWUgWywgcmVwbGFjZXIgWywgc3BhY2VdXSlcblx0JEpTT04gJiYgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoIVVTRV9OQVRJVkUgfHwgJGZhaWxzKGZ1bmN0aW9uKCl7XG5cdCAgdmFyIFMgPSAkU3ltYm9sKCk7XG5cdCAgLy8gTVMgRWRnZSBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMge31cblx0ICAvLyBXZWJLaXQgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIG51bGxcblx0ICAvLyBWOCB0aHJvd3Mgb24gYm94ZWQgc3ltYm9sc1xuXHQgIHJldHVybiBfc3RyaW5naWZ5KFtTXSkgIT0gJ1tudWxsXScgfHwgX3N0cmluZ2lmeSh7YTogU30pICE9ICd7fScgfHwgX3N0cmluZ2lmeShPYmplY3QoUykpICE9ICd7fSc7XG5cdH0pKSwgJ0pTT04nLCB7XG5cdCAgc3RyaW5naWZ5OiBmdW5jdGlvbiBzdHJpbmdpZnkoaXQpe1xuXHQgICAgaWYoaXQgPT09IHVuZGVmaW5lZCB8fCBpc1N5bWJvbChpdCkpcmV0dXJuOyAvLyBJRTggcmV0dXJucyBzdHJpbmcgb24gdW5kZWZpbmVkXG5cdCAgICB2YXIgYXJncyA9IFtpdF1cblx0ICAgICAgLCBpICAgID0gMVxuXHQgICAgICAsIHJlcGxhY2VyLCAkcmVwbGFjZXI7XG5cdCAgICB3aGlsZShhcmd1bWVudHMubGVuZ3RoID4gaSlhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuXHQgICAgcmVwbGFjZXIgPSBhcmdzWzFdO1xuXHQgICAgaWYodHlwZW9mIHJlcGxhY2VyID09ICdmdW5jdGlvbicpJHJlcGxhY2VyID0gcmVwbGFjZXI7XG5cdCAgICBpZigkcmVwbGFjZXIgfHwgIWlzQXJyYXkocmVwbGFjZXIpKXJlcGxhY2VyID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSl7XG5cdCAgICAgIGlmKCRyZXBsYWNlcil2YWx1ZSA9ICRyZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuXHQgICAgICBpZighaXNTeW1ib2wodmFsdWUpKXJldHVybiB2YWx1ZTtcblx0ICAgIH07XG5cdCAgICBhcmdzWzFdID0gcmVwbGFjZXI7XG5cdCAgICByZXR1cm4gX3N0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJncyk7XG5cdCAgfVxuXHR9KTtcblxuXHQvLyAxOS40LjMuNCBTeW1ib2wucHJvdG90eXBlW0BAdG9QcmltaXRpdmVdKGhpbnQpXG5cdCRTeW1ib2xbUFJPVE9UWVBFXVtUT19QUklNSVRJVkVdIHx8IF9fd2VicGFja19yZXF1aXJlX18oMTcpKCRTeW1ib2xbUFJPVE9UWVBFXSwgVE9fUFJJTUlUSVZFLCAkU3ltYm9sW1BST1RPVFlQRV0udmFsdWVPZik7XG5cdC8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ11cblx0c2V0VG9TdHJpbmdUYWcoJFN5bWJvbCwgJ1N5bWJvbCcpO1xuXHQvLyAyMC4yLjEuOSBNYXRoW0BAdG9TdHJpbmdUYWddXG5cdHNldFRvU3RyaW5nVGFnKE1hdGgsICdNYXRoJywgdHJ1ZSk7XG5cdC8vIDI0LjMuMyBKU09OW0BAdG9TdHJpbmdUYWddXG5cdHNldFRvU3RyaW5nVGFnKGdsb2JhbC5KU09OLCAnSlNPTicsIHRydWUpO1xuXG4vKioqLyB9KSxcbi8qIDU4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIE1FVEEgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MykoJ21ldGEnKVxuXHQgICwgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKVxuXHQgICwgaGFzICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KVxuXHQgICwgc2V0RGVzYyAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KS5mXG5cdCAgLCBpZCAgICAgICA9IDA7XG5cdHZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGZ1bmN0aW9uKCl7XG5cdCAgcmV0dXJuIHRydWU7XG5cdH07XG5cdHZhciBGUkVFWkUgPSAhX193ZWJwYWNrX3JlcXVpcmVfXygyMykoZnVuY3Rpb24oKXtcblx0ICByZXR1cm4gaXNFeHRlbnNpYmxlKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpO1xuXHR9KTtcblx0dmFyIHNldE1ldGEgPSBmdW5jdGlvbihpdCl7XG5cdCAgc2V0RGVzYyhpdCwgTUVUQSwge3ZhbHVlOiB7XG5cdCAgICBpOiAnTycgKyArK2lkLCAvLyBvYmplY3QgSURcblx0ICAgIHc6IHt9ICAgICAgICAgIC8vIHdlYWsgY29sbGVjdGlvbnMgSURzXG5cdCAgfX0pO1xuXHR9O1xuXHR2YXIgZmFzdEtleSA9IGZ1bmN0aW9uKGl0LCBjcmVhdGUpe1xuXHQgIC8vIHJldHVybiBwcmltaXRpdmUgd2l0aCBwcmVmaXhcblx0ICBpZighaXNPYmplY3QoaXQpKXJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCcgPyBpdCA6ICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgPyAnUycgOiAnUCcpICsgaXQ7XG5cdCAgaWYoIWhhcyhpdCwgTUVUQSkpe1xuXHQgICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3Rcblx0ICAgIGlmKCFpc0V4dGVuc2libGUoaXQpKXJldHVybiAnRic7XG5cdCAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuXHQgICAgaWYoIWNyZWF0ZSlyZXR1cm4gJ0UnO1xuXHQgICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcblx0ICAgIHNldE1ldGEoaXQpO1xuXHQgIC8vIHJldHVybiBvYmplY3QgSURcblx0ICB9IHJldHVybiBpdFtNRVRBXS5pO1xuXHR9O1xuXHR2YXIgZ2V0V2VhayA9IGZ1bmN0aW9uKGl0LCBjcmVhdGUpe1xuXHQgIGlmKCFoYXMoaXQsIE1FVEEpKXtcblx0ICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG5cdCAgICBpZighaXNFeHRlbnNpYmxlKGl0KSlyZXR1cm4gdHJ1ZTtcblx0ICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG5cdCAgICBpZighY3JlYXRlKXJldHVybiBmYWxzZTtcblx0ICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG5cdCAgICBzZXRNZXRhKGl0KTtcblx0ICAvLyByZXR1cm4gaGFzaCB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuXHQgIH0gcmV0dXJuIGl0W01FVEFdLnc7XG5cdH07XG5cdC8vIGFkZCBtZXRhZGF0YSBvbiBmcmVlemUtZmFtaWx5IG1ldGhvZHMgY2FsbGluZ1xuXHR2YXIgb25GcmVlemUgPSBmdW5jdGlvbihpdCl7XG5cdCAgaWYoRlJFRVpFICYmIG1ldGEuTkVFRCAmJiBpc0V4dGVuc2libGUoaXQpICYmICFoYXMoaXQsIE1FVEEpKXNldE1ldGEoaXQpO1xuXHQgIHJldHVybiBpdDtcblx0fTtcblx0dmFyIG1ldGEgPSBtb2R1bGUuZXhwb3J0cyA9IHtcblx0ICBLRVk6ICAgICAgTUVUQSxcblx0ICBORUVEOiAgICAgZmFsc2UsXG5cdCAgZmFzdEtleTogIGZhc3RLZXksXG5cdCAgZ2V0V2VhazogIGdldFdlYWssXG5cdCAgb25GcmVlemU6IG9uRnJlZXplXG5cdH07XG5cbi8qKiovIH0pLFxuLyogNTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgZ2xvYmFsICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKVxuXHQgICwgY29yZSAgICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KVxuXHQgICwgTElCUkFSWSAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKVxuXHQgICwgd2tzRXh0ICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU0KVxuXHQgICwgZGVmaW5lUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KS5mO1xuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG5hbWUpe1xuXHQgIHZhciAkU3ltYm9sID0gY29yZS5TeW1ib2wgfHwgKGNvcmUuU3ltYm9sID0gTElCUkFSWSA/IHt9IDogZ2xvYmFsLlN5bWJvbCB8fCB7fSk7XG5cdCAgaWYobmFtZS5jaGFyQXQoMCkgIT0gJ18nICYmICEobmFtZSBpbiAkU3ltYm9sKSlkZWZpbmVQcm9wZXJ0eSgkU3ltYm9sLCBuYW1lLCB7dmFsdWU6IHdrc0V4dC5mKG5hbWUpfSk7XG5cdH07XG5cbi8qKiovIH0pLFxuLyogNjAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgZ2V0S2V5cyAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMylcblx0ICAsIHRvSU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMzUpO1xuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iamVjdCwgZWwpe1xuXHQgIHZhciBPICAgICAgPSB0b0lPYmplY3Qob2JqZWN0KVxuXHQgICAgLCBrZXlzICAgPSBnZXRLZXlzKE8pXG5cdCAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXG5cdCAgICAsIGluZGV4ICA9IDBcblx0ICAgICwga2V5O1xuXHQgIHdoaWxlKGxlbmd0aCA+IGluZGV4KWlmKE9ba2V5ID0ga2V5c1tpbmRleCsrXV0gPT09IGVsKXJldHVybiBrZXk7XG5cdH07XG5cbi8qKiovIH0pLFxuLyogNjEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvLyBhbGwgZW51bWVyYWJsZSBvYmplY3Qga2V5cywgaW5jbHVkZXMgc3ltYm9sc1xuXHR2YXIgZ2V0S2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpXG5cdCAgLCBnT1BTICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Milcblx0ICAsIHBJRSAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYzKTtcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG5cdCAgdmFyIHJlc3VsdCAgICAgPSBnZXRLZXlzKGl0KVxuXHQgICAgLCBnZXRTeW1ib2xzID0gZ09QUy5mO1xuXHQgIGlmKGdldFN5bWJvbHMpe1xuXHQgICAgdmFyIHN5bWJvbHMgPSBnZXRTeW1ib2xzKGl0KVxuXHQgICAgICAsIGlzRW51bSAgPSBwSUUuZlxuXHQgICAgICAsIGkgICAgICAgPSAwXG5cdCAgICAgICwga2V5O1xuXHQgICAgd2hpbGUoc3ltYm9scy5sZW5ndGggPiBpKWlmKGlzRW51bS5jYWxsKGl0LCBrZXkgPSBzeW1ib2xzW2krK10pKXJlc3VsdC5wdXNoKGtleSk7XG5cdCAgfSByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG4vKioqLyB9KSxcbi8qIDYyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0ZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuLyoqKi8gfSksXG4vKiA2MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdGV4cG9ydHMuZiA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKioqLyB9KSxcbi8qIDY0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0Ly8gNy4yLjIgSXNBcnJheShhcmd1bWVudClcblx0dmFyIGNvZiA9IF9fd2VicGFja19yZXF1aXJlX18oMzcpO1xuXHRtb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmcpe1xuXHQgIHJldHVybiBjb2YoYXJnKSA9PSAnQXJyYXknO1xuXHR9O1xuXG4vKioqLyB9KSxcbi8qIDY1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0Ly8gZmFsbGJhY2sgZm9yIElFMTEgYnVnZ3kgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgd2l0aCBpZnJhbWUgYW5kIHdpbmRvd1xuXHR2YXIgdG9JT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNSlcblx0ICAsIGdPUE4gICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNjYpLmZcblx0ICAsIHRvU3RyaW5nICA9IHt9LnRvU3RyaW5nO1xuXG5cdHZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXG5cdCAgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh3aW5kb3cpIDogW107XG5cblx0dmFyIGdldFdpbmRvd05hbWVzID0gZnVuY3Rpb24oaXQpe1xuXHQgIHRyeSB7XG5cdCAgICByZXR1cm4gZ09QTihpdCk7XG5cdCAgfSBjYXRjaChlKXtcblx0ICAgIHJldHVybiB3aW5kb3dOYW1lcy5zbGljZSgpO1xuXHQgIH1cblx0fTtcblxuXHRtb2R1bGUuZXhwb3J0cy5mID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCl7XG5cdCAgcmV0dXJuIHdpbmRvd05hbWVzICYmIHRvU3RyaW5nLmNhbGwoaXQpID09ICdbb2JqZWN0IFdpbmRvd10nID8gZ2V0V2luZG93TmFtZXMoaXQpIDogZ09QTih0b0lPYmplY3QoaXQpKTtcblx0fTtcblxuXG4vKioqLyB9KSxcbi8qIDY2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0Ly8gMTkuMS4yLjcgLyAxNS4yLjMuNCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxuXHR2YXIgJGtleXMgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpXG5cdCAgLCBoaWRkZW5LZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NCkuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XG5cblx0ZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKXtcblx0ICByZXR1cm4gJGtleXMoTywgaGlkZGVuS2V5cyk7XG5cdH07XG5cbi8qKiovIH0pLFxuLyogNjcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgcElFICAgICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYzKVxuXHQgICwgY3JlYXRlRGVzYyAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KVxuXHQgICwgdG9JT2JqZWN0ICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1KVxuXHQgICwgdG9QcmltaXRpdmUgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KVxuXHQgICwgaGFzICAgICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KVxuXHQgICwgSUU4X0RPTV9ERUZJTkUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKVxuXHQgICwgZ09QRCAgICAgICAgICAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG5cdGV4cG9ydHMuZiA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpID8gZ09QRCA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKXtcblx0ICBPID0gdG9JT2JqZWN0KE8pO1xuXHQgIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcblx0ICBpZihJRThfRE9NX0RFRklORSl0cnkge1xuXHQgICAgcmV0dXJuIGdPUEQoTywgUCk7XG5cdCAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuXHQgIGlmKGhhcyhPLCBQKSlyZXR1cm4gY3JlYXRlRGVzYyghcElFLmYuY2FsbChPLCBQKSwgT1tQXSk7XG5cdH07XG5cbi8qKiovIH0pLFxuLyogNjggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRcblxuLyoqKi8gfSksXG4vKiA2OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdF9fd2VicGFja19yZXF1aXJlX18oNTkpKCdhc3luY0l0ZXJhdG9yJyk7XG5cbi8qKiovIH0pLFxuLyogNzAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDU5KSgnb2JzZXJ2YWJsZScpO1xuXG4vKioqLyB9KSxcbi8qIDcxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0dmFyIEhlbHBlcnMsIGg7XG5cblx0SGVscGVycyA9IChmdW5jdGlvbigpIHtcblx0ICBIZWxwZXJzLnByb3RvdHlwZS5OUyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG5cblx0ICBIZWxwZXJzLnByb3RvdHlwZS5sb2dCYWRnZUNzcyA9ICdiYWNrZ3JvdW5kOiMzQTA4Mzk7Y29sb3I6I0ZGNTEyRjtib3JkZXItcmFkaXVzOjVweDsgcGFkZGluZzogMXB4IDVweCAycHg7IGJvcmRlcjogMXB4IHNvbGlkICNGRjUxMkY7JztcblxuXHQgIEhlbHBlcnMucHJvdG90eXBlLnNob3J0Q29sb3JzID0ge1xuXHQgICAgdHJhbnNwYXJlbnQ6ICdyZ2JhKDAsMCwwLDApJyxcblx0ICAgIG5vbmU6ICdyZ2JhKDAsMCwwLDApJyxcblx0ICAgIGFxdWE6ICdyZ2IoMCwyNTUsMjU1KScsXG5cdCAgICBibGFjazogJ3JnYigwLDAsMCknLFxuXHQgICAgYmx1ZTogJ3JnYigwLDAsMjU1KScsXG5cdCAgICBmdWNoc2lhOiAncmdiKDI1NSwwLDI1NSknLFxuXHQgICAgZ3JheTogJ3JnYigxMjgsMTI4LDEyOCknLFxuXHQgICAgZ3JlZW46ICdyZ2IoMCwxMjgsMCknLFxuXHQgICAgbGltZTogJ3JnYigwLDI1NSwwKScsXG5cdCAgICBtYXJvb246ICdyZ2IoMTI4LDAsMCknLFxuXHQgICAgbmF2eTogJ3JnYigwLDAsMTI4KScsXG5cdCAgICBvbGl2ZTogJ3JnYigxMjgsMTI4LDApJyxcblx0ICAgIHB1cnBsZTogJ3JnYigxMjgsMCwxMjgpJyxcblx0ICAgIHJlZDogJ3JnYigyNTUsMCwwKScsXG5cdCAgICBzaWx2ZXI6ICdyZ2IoMTkyLDE5MiwxOTIpJyxcblx0ICAgIHRlYWw6ICdyZ2IoMCwxMjgsMTI4KScsXG5cdCAgICB3aGl0ZTogJ3JnYigyNTUsMjU1LDI1NSknLFxuXHQgICAgeWVsbG93OiAncmdiKDI1NSwyNTUsMCknLFxuXHQgICAgb3JhbmdlOiAncmdiKDI1NSwxMjgsMCknXG5cdCAgfTtcblxuXHQgIEhlbHBlcnMucHJvdG90eXBlLmNoYWluT3B0aW9uTWFwID0ge307XG5cblx0ICBIZWxwZXJzLnByb3RvdHlwZS5jYWxsYmFja3NNYXAgPSB7XG5cdCAgICBvblJlZnJlc2g6IDEsXG5cdCAgICBvblN0YXJ0OiAxLFxuXHQgICAgb25Db21wbGV0ZTogMSxcblx0ICAgIG9uRmlyc3RVcGRhdGU6IDEsXG5cdCAgICBvblVwZGF0ZTogMSxcblx0ICAgIG9uUHJvZ3Jlc3M6IDEsXG5cdCAgICBvblJlcGVhdFN0YXJ0OiAxLFxuXHQgICAgb25SZXBlYXRDb21wbGV0ZTogMSxcblx0ICAgIG9uUGxheWJhY2tTdGFydDogMSxcblx0ICAgIG9uUGxheWJhY2tQYXVzZTogMSxcblx0ICAgIG9uUGxheWJhY2tTdG9wOiAxLFxuXHQgICAgb25QbGF5YmFja0NvbXBsZXRlOiAxXG5cdCAgfTtcblxuXHQgIEhlbHBlcnMucHJvdG90eXBlLnR3ZWVuT3B0aW9uTWFwID0ge1xuXHQgICAgZHVyYXRpb246IDEsXG5cdCAgICBkZWxheTogMSxcblx0ICAgIHNwZWVkOiAxLFxuXHQgICAgcmVwZWF0OiAxLFxuXHQgICAgZWFzaW5nOiAxLFxuXHQgICAgYmFja3dhcmRFYXNpbmc6IDEsXG5cdCAgICBpc1lveW86IDEsXG5cdCAgICBzaGlmdFRpbWU6IDEsXG5cdCAgICBpc1JldmVyc2VkOiAxLFxuXHQgICAgY2FsbGJhY2tzQ29udGV4dDogMVxuXHQgIH07XG5cblx0ICBIZWxwZXJzLnByb3RvdHlwZS51bml0T3B0aW9uTWFwID0ge1xuXHQgICAgbGVmdDogMSxcblx0ICAgIHRvcDogMSxcblx0ICAgIHg6IDEsXG5cdCAgICB5OiAxLFxuXHQgICAgcng6IDEsXG5cdCAgICByeTogMVxuXHQgIH07XG5cblx0ICBIZWxwZXJzLnByb3RvdHlwZS5SQURfVE9fREVHID0gMTgwIC8gTWF0aC5QSTtcblxuXHQgIGZ1bmN0aW9uIEhlbHBlcnMoKSB7XG5cdCAgICB0aGlzLnZhcnMoKTtcblx0ICB9XG5cblx0ICBIZWxwZXJzLnByb3RvdHlwZS52YXJzID0gZnVuY3Rpb24oKSB7XG5cdCAgICB2YXIgdWE7XG5cdCAgICB0aGlzLnByZWZpeCA9IHRoaXMuZ2V0UHJlZml4KCk7XG5cdCAgICB0aGlzLmdldFJlbUJhc2UoKTtcblx0ICAgIHRoaXMuaXNGRiA9IHRoaXMucHJlZml4Lmxvd2VyY2FzZSA9PT0gJ21veic7XG5cdCAgICB0aGlzLmlzSUUgPSB0aGlzLnByZWZpeC5sb3dlcmNhc2UgPT09ICdtcyc7XG5cdCAgICB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XG5cdCAgICB0aGlzLmlzT2xkT3BlcmEgPSB1YS5tYXRjaCgvcHJlc3RvL2dpbSk7XG5cdCAgICB0aGlzLmlzU2FmYXJpID0gdWEuaW5kZXhPZignU2FmYXJpJykgPiAtMTtcblx0ICAgIHRoaXMuaXNDaHJvbWUgPSB1YS5pbmRleE9mKCdDaHJvbWUnKSA+IC0xO1xuXHQgICAgdGhpcy5pc09wZXJhID0gdWEudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwib3BcIikgPiAtMTtcblx0ICAgIHRoaXMuaXNDaHJvbWUgJiYgdGhpcy5pc1NhZmFyaSAmJiAodGhpcy5pc1NhZmFyaSA9IGZhbHNlKTtcblx0ICAgICh1YS5tYXRjaCgvUGhhbnRvbUpTL2dpbSkpICYmICh0aGlzLmlzU2FmYXJpID0gZmFsc2UpO1xuXHQgICAgdGhpcy5pc0Nocm9tZSAmJiB0aGlzLmlzT3BlcmEgJiYgKHRoaXMuaXNDaHJvbWUgPSBmYWxzZSk7XG5cdCAgICB0aGlzLmlzM2QgPSB0aGlzLmNoZWNrSWYzZCgpO1xuXHQgICAgdGhpcy51bmlxSURzID0gLTE7XG5cdCAgICB0aGlzLmRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHQgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmRpdik7XG5cdCAgICByZXR1cm4gdGhpcy5kZWZhdWx0U3R5bGVzID0gdGhpcy5jb21wdXRlZFN0eWxlKHRoaXMuZGl2KTtcblx0ICB9O1xuXG5cdCAgSGVscGVycy5wcm90b3R5cGUuY2xvbmVPYmogPSBmdW5jdGlvbihvYmosIGV4Y2x1ZGUpIHtcblx0ICAgIHZhciBpLCBrZXksIGtleXMsIG5ld09iajtcblx0ICAgIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuXHQgICAgbmV3T2JqID0ge307XG5cdCAgICBpID0ga2V5cy5sZW5ndGg7XG5cdCAgICB3aGlsZSAoaS0tKSB7XG5cdCAgICAgIGtleSA9IGtleXNbaV07XG5cdCAgICAgIGlmIChleGNsdWRlICE9IG51bGwpIHtcblx0ICAgICAgICBpZiAoIWV4Y2x1ZGVba2V5XSkge1xuXHQgICAgICAgICAgbmV3T2JqW2tleV0gPSBvYmpba2V5XTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgbmV3T2JqW2tleV0gPSBvYmpba2V5XTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIG5ld09iajtcblx0ICB9O1xuXG5cdCAgSGVscGVycy5wcm90b3R5cGUuZXh0ZW5kID0gZnVuY3Rpb24ob2JqVG8sIG9iakZyb20pIHtcblx0ICAgIHZhciBrZXksIHZhbHVlO1xuXHQgICAgZm9yIChrZXkgaW4gb2JqRnJvbSkge1xuXHQgICAgICB2YWx1ZSA9IG9iakZyb21ba2V5XTtcblx0ICAgICAgaWYgKG9ialRvW2tleV0gPT0gbnVsbCkge1xuXHQgICAgICAgIG9ialRvW2tleV0gPSBvYmpGcm9tW2tleV07XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiBvYmpUbztcblx0ICB9O1xuXG5cdCAgSGVscGVycy5wcm90b3R5cGUuZ2V0UmVtQmFzZSA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIGh0bWwsIHN0eWxlO1xuXHQgICAgaHRtbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2h0bWwnKTtcblx0ICAgIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShodG1sKTtcblx0ICAgIHJldHVybiB0aGlzLnJlbUJhc2UgPSBwYXJzZUZsb2F0KHN0eWxlLmZvbnRTaXplKTtcblx0ICB9O1xuXG5cdCAgSGVscGVycy5wcm90b3R5cGUuY2xhbXAgPSBmdW5jdGlvbih2YWx1ZSwgbWluLCBtYXgpIHtcblx0ICAgIGlmICh2YWx1ZSA8IG1pbikge1xuXHQgICAgICByZXR1cm4gbWluO1xuXHQgICAgfSBlbHNlIGlmICh2YWx1ZSA+IG1heCkge1xuXHQgICAgICByZXR1cm4gbWF4O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmV0dXJuIHZhbHVlO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICBIZWxwZXJzLnByb3RvdHlwZS5zZXRQcmVmaXhlZFN0eWxlID0gZnVuY3Rpb24oZWwsIG5hbWUsIHZhbHVlKSB7XG5cdCAgICAobmFtZSA9PT0gJ3RyYW5zZm9ybScpICYmIChlbC5zdHlsZVtcIlwiICsgdGhpcy5wcmVmaXguY3NzICsgbmFtZV0gPSB2YWx1ZSk7XG5cdCAgICByZXR1cm4gZWwuc3R5bGVbbmFtZV0gPSB2YWx1ZTtcblx0ICB9O1xuXG5cdCAgSGVscGVycy5wcm90b3R5cGUuc3R5bGUgPSBmdW5jdGlvbihlbCwgbmFtZSwgdmFsdWUpIHtcblx0ICAgIHZhciBrZXksIGtleXMsIGxlbiwgcmVzdWx0cztcblx0ICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHtcblx0ICAgICAga2V5cyA9IE9iamVjdC5rZXlzKG5hbWUpO1xuXHQgICAgICBsZW4gPSBrZXlzLmxlbmd0aDtcblx0ICAgICAgcmVzdWx0cyA9IFtdO1xuXHQgICAgICB3aGlsZSAobGVuLS0pIHtcblx0ICAgICAgICBrZXkgPSBrZXlzW2xlbl07XG5cdCAgICAgICAgdmFsdWUgPSBuYW1lW2tleV07XG5cdCAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMuc2V0UHJlZml4ZWRTdHlsZShlbCwga2V5LCB2YWx1ZSkpO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiByZXN1bHRzO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuc2V0UHJlZml4ZWRTdHlsZShlbCwgbmFtZSwgdmFsdWUpO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICBIZWxwZXJzLnByb3RvdHlwZS5wcmVwYXJlRm9yTG9nID0gZnVuY3Rpb24oYXJncykge1xuXHQgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShhcmdzKTtcblx0ICAgIGFyZ3MudW5zaGlmdCgnOjonKTtcblx0ICAgIGFyZ3MudW5zaGlmdCh0aGlzLmxvZ0JhZGdlQ3NzKTtcblx0ICAgIGFyZ3MudW5zaGlmdCgnJWNtb8K3anMlYycpO1xuXHQgICAgcmV0dXJuIGFyZ3M7XG5cdCAgfTtcblxuXHQgIEhlbHBlcnMucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uKCkge1xuXHQgICAgaWYgKG1vanMuaXNEZWJ1ZyA9PT0gZmFsc2UpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIHRoaXMucHJlcGFyZUZvckxvZyhhcmd1bWVudHMpKTtcblx0ICB9O1xuXG5cdCAgSGVscGVycy5wcm90b3R5cGUud2FybiA9IGZ1bmN0aW9uKCkge1xuXHQgICAgaWYgKG1vanMuaXNEZWJ1ZyA9PT0gZmFsc2UpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGNvbnNvbGUud2Fybi5hcHBseShjb25zb2xlLCB0aGlzLnByZXBhcmVGb3JMb2coYXJndW1lbnRzKSk7XG5cdCAgfTtcblxuXHQgIEhlbHBlcnMucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24oKSB7XG5cdCAgICBpZiAobW9qcy5pc0RlYnVnID09PSBmYWxzZSkge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICByZXR1cm4gY29uc29sZS5lcnJvci5hcHBseShjb25zb2xlLCB0aGlzLnByZXBhcmVGb3JMb2coYXJndW1lbnRzKSk7XG5cdCAgfTtcblxuXHQgIEhlbHBlcnMucHJvdG90eXBlLnBhcnNlVW5pdCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgICB2YXIgYW1vdW50LCBpc1N0cmljdCwgcmVmLCByZWdleCwgcmV0dXJuVmFsLCB1bml0O1xuXHQgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcblx0ICAgICAgcmV0dXJuIHJldHVyblZhbCA9IHtcblx0ICAgICAgICB1bml0OiAncHgnLFxuXHQgICAgICAgIGlzU3RyaWN0OiBmYWxzZSxcblx0ICAgICAgICB2YWx1ZTogdmFsdWUsXG5cdCAgICAgICAgc3RyaW5nOiB2YWx1ZSA9PT0gMCA/IFwiXCIgKyB2YWx1ZSA6IHZhbHVlICsgXCJweFwiXG5cdCAgICAgIH07XG5cdCAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcblx0ICAgICAgcmVnZXggPSAvcHh8JXxyZW18ZW18ZXh8Y218Y2h8bW18aW58cHR8cGN8dmh8dnd8dm1pbnxkZWcvZ2ltO1xuXHQgICAgICB1bml0ID0gKHJlZiA9IHZhbHVlLm1hdGNoKHJlZ2V4KSkgIT0gbnVsbCA/IHJlZlswXSA6IHZvaWQgMDtcblx0ICAgICAgaXNTdHJpY3QgPSB0cnVlO1xuXHQgICAgICBpZiAoIXVuaXQpIHtcblx0ICAgICAgICB1bml0ID0gJ3B4Jztcblx0ICAgICAgICBpc1N0cmljdCA9IGZhbHNlO1xuXHQgICAgICB9XG5cdCAgICAgIGFtb3VudCA9IHBhcnNlRmxvYXQodmFsdWUpO1xuXHQgICAgICByZXR1cm4gcmV0dXJuVmFsID0ge1xuXHQgICAgICAgIHVuaXQ6IHVuaXQsXG5cdCAgICAgICAgaXNTdHJpY3Q6IGlzU3RyaWN0LFxuXHQgICAgICAgIHZhbHVlOiBhbW91bnQsXG5cdCAgICAgICAgc3RyaW5nOiBhbW91bnQgPT09IDAgPyBcIlwiICsgYW1vdW50IDogXCJcIiArIGFtb3VudCArIHVuaXRcblx0ICAgICAgfTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB2YWx1ZTtcblx0ICB9O1xuXG5cdCAgSGVscGVycy5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKGZ1bmMsIGNvbnRleHQpIHtcblx0ICAgIHZhciBiaW5kQXJncywgd3JhcHBlcjtcblx0ICAgIHdyYXBwZXIgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgdmFyIGFyZ3MsIHVuc2hpZnRBcmdzO1xuXHQgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblx0ICAgICAgdW5zaGlmdEFyZ3MgPSBiaW5kQXJncy5jb25jYXQoYXJncyk7XG5cdCAgICAgIHJldHVybiBmdW5jLmFwcGx5KGNvbnRleHQsIHVuc2hpZnRBcmdzKTtcblx0ICAgIH07XG5cdCAgICBiaW5kQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG5cdCAgICByZXR1cm4gd3JhcHBlcjtcblx0ICB9O1xuXG5cdCAgSGVscGVycy5wcm90b3R5cGUuZ2V0UmFkaWFsUG9pbnQgPSBmdW5jdGlvbihvKSB7XG5cdCAgICB2YXIgcG9pbnQsIHJhZEFuZ2xlLCByYWRpdXNYLCByYWRpdXNZO1xuXHQgICAgaWYgKG8gPT0gbnVsbCkge1xuXHQgICAgICBvID0ge307XG5cdCAgICB9XG5cdCAgICByYWRBbmdsZSA9IChvLmFuZ2xlIC0gOTApICogMC4wMTc0NTMyOTI1MTk5NDMyOTU7XG5cdCAgICByYWRpdXNYID0gby5yYWRpdXNYICE9IG51bGwgPyBvLnJhZGl1c1ggOiBvLnJhZGl1cztcblx0ICAgIHJhZGl1c1kgPSBvLnJhZGl1c1kgIT0gbnVsbCA/IG8ucmFkaXVzWSA6IG8ucmFkaXVzO1xuXHQgICAgcmV0dXJuIHBvaW50ID0ge1xuXHQgICAgICB4OiBvLmNlbnRlci54ICsgKE1hdGguY29zKHJhZEFuZ2xlKSAqIHJhZGl1c1gpLFxuXHQgICAgICB5OiBvLmNlbnRlci55ICsgKE1hdGguc2luKHJhZEFuZ2xlKSAqIHJhZGl1c1kpXG5cdCAgICB9O1xuXHQgIH07XG5cblx0ICBIZWxwZXJzLnByb3RvdHlwZS5nZXRQcmVmaXggPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciBkb20sIHByZSwgc3R5bGVzLCB2O1xuXHQgICAgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBcIlwiKTtcblx0ICAgIHYgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChzdHlsZXMpLmpvaW4oXCJcIikubWF0Y2goLy0obW96fHdlYmtpdHxtcyktLyk7XG5cdCAgICBwcmUgPSAodiB8fCAoc3R5bGVzLk9MaW5rID09PSBcIlwiICYmIFtcIlwiLCBcIm9cIl0pKVsxXTtcblx0ICAgIGRvbSA9IFwiV2ViS2l0fE1venxNU3xPXCIubWF0Y2gobmV3IFJlZ0V4cChcIihcIiArIHByZSArIFwiKVwiLCBcImlcIikpWzFdO1xuXHQgICAgcmV0dXJuIHtcblx0ICAgICAgZG9tOiBkb20sXG5cdCAgICAgIGxvd2VyY2FzZTogcHJlLFxuXHQgICAgICBjc3M6IFwiLVwiICsgcHJlICsgXCItXCIsXG5cdCAgICAgIGpzOiBwcmVbMF0udG9VcHBlckNhc2UoKSArIHByZS5zdWJzdHIoMSlcblx0ICAgIH07XG5cdCAgfTtcblxuXHQgIEhlbHBlcnMucHJvdG90eXBlLnN0clRvQXJyID0gZnVuY3Rpb24oc3RyaW5nKSB7XG5cdCAgICB2YXIgYXJyO1xuXHQgICAgYXJyID0gW107XG5cdCAgICBpZiAodHlwZW9mIHN0cmluZyA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHN0cmluZykpIHtcblx0ICAgICAgYXJyLnB1c2godGhpcy5wYXJzZVVuaXQoc3RyaW5nKSk7XG5cdCAgICAgIHJldHVybiBhcnI7XG5cdCAgICB9XG5cdCAgICBzdHJpbmcudHJpbSgpLnNwbGl0KC9cXHMrL2dpbSkuZm9yRWFjaCgoZnVuY3Rpb24oX3RoaXMpIHtcblx0ICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0cikge1xuXHQgICAgICAgIHJldHVybiBhcnIucHVzaChfdGhpcy5wYXJzZVVuaXQoX3RoaXMucGFyc2VJZlJhbmQoc3RyKSkpO1xuXHQgICAgICB9O1xuXHQgICAgfSkodGhpcykpO1xuXHQgICAgcmV0dXJuIGFycjtcblx0ICB9O1xuXG5cdCAgSGVscGVycy5wcm90b3R5cGUuY2FsY0FyckRlbHRhID0gZnVuY3Rpb24oYXJyMSwgYXJyMikge1xuXHQgICAgdmFyIGRlbHRhLCBpLCBqLCBsZW4xLCBudW07XG5cdCAgICBkZWx0YSA9IFtdO1xuXHQgICAgZm9yIChpID0gaiA9IDAsIGxlbjEgPSBhcnIxLmxlbmd0aDsgaiA8IGxlbjE7IGkgPSArK2opIHtcblx0ICAgICAgbnVtID0gYXJyMVtpXTtcblx0ICAgICAgZGVsdGFbaV0gPSB0aGlzLnBhcnNlVW5pdChcIlwiICsgKGFycjJbaV0udmFsdWUgLSBhcnIxW2ldLnZhbHVlKSArIGFycjJbaV0udW5pdCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gZGVsdGE7XG5cdCAgfTtcblxuXHQgIEhlbHBlcnMucHJvdG90eXBlLmlzQXJyYXkgPSBmdW5jdGlvbih2YXJpYWJsZSkge1xuXHQgICAgcmV0dXJuIHZhcmlhYmxlIGluc3RhbmNlb2YgQXJyYXk7XG5cdCAgfTtcblxuXHQgIEhlbHBlcnMucHJvdG90eXBlLm5vcm1EYXNoQXJyYXlzID0gZnVuY3Rpb24oYXJyMSwgYXJyMikge1xuXHQgICAgdmFyIGFycjFMZW4sIGFycjJMZW4sIGN1cnJJdGVtLCBpLCBqLCBrLCBsZW5EaWZmLCByZWYsIHJlZjEsIHN0YXJ0STtcblx0ICAgIGFycjFMZW4gPSBhcnIxLmxlbmd0aDtcblx0ICAgIGFycjJMZW4gPSBhcnIyLmxlbmd0aDtcblx0ICAgIGlmIChhcnIxTGVuID4gYXJyMkxlbikge1xuXHQgICAgICBsZW5EaWZmID0gYXJyMUxlbiAtIGFycjJMZW47XG5cdCAgICAgIHN0YXJ0SSA9IGFycjIubGVuZ3RoO1xuXHQgICAgICBmb3IgKGkgPSBqID0gMCwgcmVmID0gbGVuRGlmZjsgMCA8PSByZWYgPyBqIDwgcmVmIDogaiA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytqIDogLS1qKSB7XG5cdCAgICAgICAgY3Vyckl0ZW0gPSBpICsgc3RhcnRJO1xuXHQgICAgICAgIGFycjIucHVzaCh0aGlzLnBhcnNlVW5pdChcIjBcIiArIGFycjFbY3Vyckl0ZW1dLnVuaXQpKTtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIGlmIChhcnIyTGVuID4gYXJyMUxlbikge1xuXHQgICAgICBsZW5EaWZmID0gYXJyMkxlbiAtIGFycjFMZW47XG5cdCAgICAgIHN0YXJ0SSA9IGFycjEubGVuZ3RoO1xuXHQgICAgICBmb3IgKGkgPSBrID0gMCwgcmVmMSA9IGxlbkRpZmY7IDAgPD0gcmVmMSA/IGsgPCByZWYxIDogayA+IHJlZjE7IGkgPSAwIDw9IHJlZjEgPyArK2sgOiAtLWspIHtcblx0ICAgICAgICBjdXJySXRlbSA9IGkgKyBzdGFydEk7XG5cdCAgICAgICAgYXJyMS5wdXNoKHRoaXMucGFyc2VVbml0KFwiMFwiICsgYXJyMltjdXJySXRlbV0udW5pdCkpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gW2FycjEsIGFycjJdO1xuXHQgIH07XG5cblx0ICBIZWxwZXJzLnByb3RvdHlwZS5tYWtlQ29sb3JPYmogPSBmdW5jdGlvbihjb2xvcikge1xuXHQgICAgdmFyIGFscGhhLCBiLCBjb2xvck9iaiwgZywgaXNSZ2IsIHIsIHJlZ2V4U3RyaW5nMSwgcmVnZXhTdHJpbmcyLCByZXN1bHQsIHJnYkNvbG9yO1xuXHQgICAgaWYgKGNvbG9yWzBdID09PSAnIycpIHtcblx0ICAgICAgcmVzdWx0ID0gL14jPyhbYS1mXFxkXXsxLDJ9KShbYS1mXFxkXXsxLDJ9KShbYS1mXFxkXXsxLDJ9KSQvaS5leGVjKGNvbG9yKTtcblx0ICAgICAgY29sb3JPYmogPSB7fTtcblx0ICAgICAgaWYgKHJlc3VsdCkge1xuXHQgICAgICAgIHIgPSByZXN1bHRbMV0ubGVuZ3RoID09PSAyID8gcmVzdWx0WzFdIDogcmVzdWx0WzFdICsgcmVzdWx0WzFdO1xuXHQgICAgICAgIGcgPSByZXN1bHRbMl0ubGVuZ3RoID09PSAyID8gcmVzdWx0WzJdIDogcmVzdWx0WzJdICsgcmVzdWx0WzJdO1xuXHQgICAgICAgIGIgPSByZXN1bHRbM10ubGVuZ3RoID09PSAyID8gcmVzdWx0WzNdIDogcmVzdWx0WzNdICsgcmVzdWx0WzNdO1xuXHQgICAgICAgIGNvbG9yT2JqID0ge1xuXHQgICAgICAgICAgcjogcGFyc2VJbnQociwgMTYpLFxuXHQgICAgICAgICAgZzogcGFyc2VJbnQoZywgMTYpLFxuXHQgICAgICAgICAgYjogcGFyc2VJbnQoYiwgMTYpLFxuXHQgICAgICAgICAgYTogMVxuXHQgICAgICAgIH07XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIGlmIChjb2xvclswXSAhPT0gJyMnKSB7XG5cdCAgICAgIGlzUmdiID0gY29sb3JbMF0gPT09ICdyJyAmJiBjb2xvclsxXSA9PT0gJ2cnICYmIGNvbG9yWzJdID09PSAnYic7XG5cdCAgICAgIGlmIChpc1JnYikge1xuXHQgICAgICAgIHJnYkNvbG9yID0gY29sb3I7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKCFpc1JnYikge1xuXHQgICAgICAgIHJnYkNvbG9yID0gIXRoaXMuc2hvcnRDb2xvcnNbY29sb3JdID8gKHRoaXMuZGl2LnN0eWxlLmNvbG9yID0gY29sb3IsIHRoaXMuY29tcHV0ZWRTdHlsZSh0aGlzLmRpdikuY29sb3IpIDogdGhpcy5zaG9ydENvbG9yc1tjb2xvcl07XG5cdCAgICAgIH1cblx0ICAgICAgcmVnZXhTdHJpbmcxID0gJ15yZ2JhP1xcXFwoKFxcXFxkezEsM30pLFxcXFxzPyhcXFxcZHsxLDN9KSwnO1xuXHQgICAgICByZWdleFN0cmluZzIgPSAnXFxcXHM/KFxcXFxkezEsM30pLD9cXFxccz8oXFxcXGR7MX18MD9cXFxcLlxcXFxkezEsfSk/XFxcXCkkJztcblx0ICAgICAgcmVzdWx0ID0gbmV3IFJlZ0V4cChyZWdleFN0cmluZzEgKyByZWdleFN0cmluZzIsICdnaScpLmV4ZWMocmdiQ29sb3IpO1xuXHQgICAgICBjb2xvck9iaiA9IHt9O1xuXHQgICAgICBhbHBoYSA9IHBhcnNlRmxvYXQocmVzdWx0WzRdIHx8IDEpO1xuXHQgICAgICBpZiAocmVzdWx0KSB7XG5cdCAgICAgICAgY29sb3JPYmogPSB7XG5cdCAgICAgICAgICByOiBwYXJzZUludChyZXN1bHRbMV0sIDEwKSxcblx0ICAgICAgICAgIGc6IHBhcnNlSW50KHJlc3VsdFsyXSwgMTApLFxuXHQgICAgICAgICAgYjogcGFyc2VJbnQocmVzdWx0WzNdLCAxMCksXG5cdCAgICAgICAgICBhOiAoYWxwaGEgIT0gbnVsbCkgJiYgIWlzTmFOKGFscGhhKSA/IGFscGhhIDogMVxuXHQgICAgICAgIH07XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiBjb2xvck9iajtcblx0ICB9O1xuXG5cdCAgSGVscGVycy5wcm90b3R5cGUuY29tcHV0ZWRTdHlsZSA9IGZ1bmN0aW9uKGVsKSB7XG5cdCAgICByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG5cdCAgfTtcblxuXHQgIEhlbHBlcnMucHJvdG90eXBlLmNhcGl0YWxpemUgPSBmdW5jdGlvbihzdHIpIHtcblx0ICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuXHQgICAgICB0aHJvdyBFcnJvcignU3RyaW5nIGV4cGVjdGVkIC0gbm90aGluZyB0byBjYXBpdGFsaXplJyk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnN1YnN0cmluZygxKTtcblx0ICB9O1xuXG5cdCAgSGVscGVycy5wcm90b3R5cGUucGFyc2VSYW5kID0gZnVuY3Rpb24oc3RyaW5nKSB7XG5cdCAgICB2YXIgcmFuZCwgcmFuZEFyciwgdW5pdHM7XG5cdCAgICByYW5kQXJyID0gc3RyaW5nLnNwbGl0KC9yYW5kXFwofFxcLHxcXCkvKTtcblx0ICAgIHVuaXRzID0gdGhpcy5wYXJzZVVuaXQocmFuZEFyclsyXSk7XG5cdCAgICByYW5kID0gdGhpcy5yYW5kKHBhcnNlRmxvYXQocmFuZEFyclsxXSksIHBhcnNlRmxvYXQocmFuZEFyclsyXSkpO1xuXHQgICAgaWYgKHVuaXRzLnVuaXQgJiYgcmFuZEFyclsyXS5tYXRjaCh1bml0cy51bml0KSkge1xuXHQgICAgICByZXR1cm4gcmFuZCArIHVuaXRzLnVuaXQ7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4gcmFuZDtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgSGVscGVycy5wcm90b3R5cGUucGFyc2VTdGFnZ2VyID0gZnVuY3Rpb24oc3RyaW5nLCBpbmRleCkge1xuXHQgICAgdmFyIGJhc2UsIG51bWJlciwgc3BsaXR0ZWRWYWx1ZSwgdW5pdCwgdW5pdFZhbHVlLCB2YWx1ZTtcblx0ICAgIHZhbHVlID0gc3RyaW5nLnNwbGl0KC9zdGFnZ2VyXFwofFxcKSQvKVsxXS50b0xvd2VyQ2FzZSgpO1xuXHQgICAgc3BsaXR0ZWRWYWx1ZSA9IHZhbHVlLnNwbGl0KC8ocmFuZFxcKC4qP1xcKXxbXlxcKCxcXHNdKykoPz1cXHMqLHxcXHMqJCkvZ2ltKTtcblx0ICAgIHZhbHVlID0gc3BsaXR0ZWRWYWx1ZS5sZW5ndGggPiAzID8gKGJhc2UgPSB0aGlzLnBhcnNlVW5pdCh0aGlzLnBhcnNlSWZSYW5kKHNwbGl0dGVkVmFsdWVbMV0pKSwgc3BsaXR0ZWRWYWx1ZVszXSkgOiAoYmFzZSA9IHRoaXMucGFyc2VVbml0KDApLCBzcGxpdHRlZFZhbHVlWzFdKTtcblx0ICAgIHZhbHVlID0gdGhpcy5wYXJzZUlmUmFuZCh2YWx1ZSk7XG5cdCAgICB1bml0VmFsdWUgPSB0aGlzLnBhcnNlVW5pdCh2YWx1ZSk7XG5cdCAgICBudW1iZXIgPSBpbmRleCAqIHVuaXRWYWx1ZS52YWx1ZSArIGJhc2UudmFsdWU7XG5cdCAgICB1bml0ID0gYmFzZS5pc1N0cmljdCA/IGJhc2UudW5pdCA6IHVuaXRWYWx1ZS5pc1N0cmljdCA/IHVuaXRWYWx1ZS51bml0IDogJyc7XG5cdCAgICBpZiAodW5pdCkge1xuXHQgICAgICByZXR1cm4gXCJcIiArIG51bWJlciArIHVuaXQ7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4gbnVtYmVyO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICBIZWxwZXJzLnByb3RvdHlwZS5wYXJzZUlmU3RhZ2dlciA9IGZ1bmN0aW9uKHZhbHVlLCBpKSB7XG5cdCAgICBpZiAoISh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLm1hdGNoKC9zdGFnZ2VyL2cpKSkge1xuXHQgICAgICByZXR1cm4gdmFsdWU7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4gdGhpcy5wYXJzZVN0YWdnZXIodmFsdWUsIGkpO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICBIZWxwZXJzLnByb3RvdHlwZS5wYXJzZUlmUmFuZCA9IGZ1bmN0aW9uKHN0cikge1xuXHQgICAgaWYgKHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnICYmIHN0ci5tYXRjaCgvcmFuZFxcKC8pKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLnBhcnNlUmFuZChzdHIpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmV0dXJuIHN0cjtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgSGVscGVycy5wcm90b3R5cGUucGFyc2VEZWx0YSA9IGZ1bmN0aW9uKGtleSwgdmFsdWUsIGluZGV4KSB7XG5cdCAgICB2YXIgY3VydmUsIGRlbHRhLCBlYXNpbmcsIGVuZCwgZW5kQXJyLCBlbmRDb2xvck9iaiwgaSwgaiwgbGVuMSwgc3RhcnQsIHN0YXJ0QXJyLCBzdGFydENvbG9yT2JqO1xuXHQgICAgdmFsdWUgPSB0aGlzLmNsb25lT2JqKHZhbHVlKTtcblx0ICAgIGVhc2luZyA9IHZhbHVlLmVhc2luZztcblx0ICAgIGlmIChlYXNpbmcgIT0gbnVsbCkge1xuXHQgICAgICBlYXNpbmcgPSBtb2pzLmVhc2luZy5wYXJzZUVhc2luZyhlYXNpbmcpO1xuXHQgICAgfVxuXHQgICAgZGVsZXRlIHZhbHVlLmVhc2luZztcblx0ICAgIGN1cnZlID0gdmFsdWUuY3VydmU7XG5cdCAgICBpZiAoY3VydmUgIT0gbnVsbCkge1xuXHQgICAgICBjdXJ2ZSA9IG1vanMuZWFzaW5nLnBhcnNlRWFzaW5nKGN1cnZlKTtcblx0ICAgIH1cblx0ICAgIGRlbGV0ZSB2YWx1ZS5jdXJ2ZTtcblx0ICAgIHN0YXJ0ID0gT2JqZWN0LmtleXModmFsdWUpWzBdO1xuXHQgICAgZW5kID0gdmFsdWVbc3RhcnRdO1xuXHQgICAgZGVsdGEgPSB7XG5cdCAgICAgIHN0YXJ0OiBzdGFydFxuXHQgICAgfTtcblx0ICAgIGlmIChpc05hTihwYXJzZUZsb2F0KHN0YXJ0KSkgJiYgIXN0YXJ0Lm1hdGNoKC9yYW5kXFwoLykgJiYgIXN0YXJ0Lm1hdGNoKC9zdGFnZ2VyXFwoLykpIHtcblx0ICAgICAgaWYgKGtleSA9PT0gJ3N0cm9rZUxpbmVjYXAnKSB7XG5cdCAgICAgICAgdGhpcy53YXJuKFwiU29ycnksIHN0cm9rZS1saW5lY2FwIHByb3BlcnR5IGlzIG5vdCBhbmltYXRhYmxlIHlldCwgdXNpbmcgdGhlIHN0YXJ0KFwiICsgc3RhcnQgKyBcIikgdmFsdWUgaW5zdGVhZFwiLCB2YWx1ZSk7XG5cdCAgICAgICAgcmV0dXJuIGRlbHRhO1xuXHQgICAgICB9XG5cdCAgICAgIHN0YXJ0Q29sb3JPYmogPSB0aGlzLm1ha2VDb2xvck9iaihzdGFydCk7XG5cdCAgICAgIGVuZENvbG9yT2JqID0gdGhpcy5tYWtlQ29sb3JPYmooZW5kKTtcblx0ICAgICAgZGVsdGEgPSB7XG5cdCAgICAgICAgdHlwZTogJ2NvbG9yJyxcblx0ICAgICAgICBuYW1lOiBrZXksXG5cdCAgICAgICAgc3RhcnQ6IHN0YXJ0Q29sb3JPYmosXG5cdCAgICAgICAgZW5kOiBlbmRDb2xvck9iaixcblx0ICAgICAgICBlYXNpbmc6IGVhc2luZyxcblx0ICAgICAgICBjdXJ2ZTogY3VydmUsXG5cdCAgICAgICAgZGVsdGE6IHtcblx0ICAgICAgICAgIHI6IGVuZENvbG9yT2JqLnIgLSBzdGFydENvbG9yT2JqLnIsXG5cdCAgICAgICAgICBnOiBlbmRDb2xvck9iai5nIC0gc3RhcnRDb2xvck9iai5nLFxuXHQgICAgICAgICAgYjogZW5kQ29sb3JPYmouYiAtIHN0YXJ0Q29sb3JPYmouYixcblx0ICAgICAgICAgIGE6IGVuZENvbG9yT2JqLmEgLSBzdGFydENvbG9yT2JqLmFcblx0ICAgICAgICB9XG5cdCAgICAgIH07XG5cdCAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ3N0cm9rZURhc2hhcnJheScgfHwga2V5ID09PSAnc3Ryb2tlRGFzaG9mZnNldCcgfHwga2V5ID09PSAnb3JpZ2luJykge1xuXHQgICAgICBzdGFydEFyciA9IHRoaXMuc3RyVG9BcnIoc3RhcnQpO1xuXHQgICAgICBlbmRBcnIgPSB0aGlzLnN0clRvQXJyKGVuZCk7XG5cdCAgICAgIHRoaXMubm9ybURhc2hBcnJheXMoc3RhcnRBcnIsIGVuZEFycik7XG5cdCAgICAgIGZvciAoaSA9IGogPSAwLCBsZW4xID0gc3RhcnRBcnIubGVuZ3RoOyBqIDwgbGVuMTsgaSA9ICsraikge1xuXHQgICAgICAgIHN0YXJ0ID0gc3RhcnRBcnJbaV07XG5cdCAgICAgICAgZW5kID0gZW5kQXJyW2ldO1xuXHQgICAgICAgIHRoaXMubWVyZ2VVbml0cyhzdGFydCwgZW5kLCBrZXkpO1xuXHQgICAgICB9XG5cdCAgICAgIGRlbHRhID0ge1xuXHQgICAgICAgIHR5cGU6ICdhcnJheScsXG5cdCAgICAgICAgbmFtZToga2V5LFxuXHQgICAgICAgIHN0YXJ0OiBzdGFydEFycixcblx0ICAgICAgICBlbmQ6IGVuZEFycixcblx0ICAgICAgICBkZWx0YTogdGhpcy5jYWxjQXJyRGVsdGEoc3RhcnRBcnIsIGVuZEFyciksXG5cdCAgICAgICAgZWFzaW5nOiBlYXNpbmcsXG5cdCAgICAgICAgY3VydmU6IGN1cnZlXG5cdCAgICAgIH07XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBpZiAoIXRoaXMuY2FsbGJhY2tzTWFwW2tleV0gJiYgIXRoaXMudHdlZW5PcHRpb25NYXBba2V5XSkge1xuXHQgICAgICAgIGlmICh0aGlzLnVuaXRPcHRpb25NYXBba2V5XSkge1xuXHQgICAgICAgICAgZW5kID0gdGhpcy5wYXJzZVVuaXQodGhpcy5wYXJzZVN0cmluZ09wdGlvbihlbmQsIGluZGV4KSk7XG5cdCAgICAgICAgICBzdGFydCA9IHRoaXMucGFyc2VVbml0KHRoaXMucGFyc2VTdHJpbmdPcHRpb24oc3RhcnQsIGluZGV4KSk7XG5cdCAgICAgICAgICB0aGlzLm1lcmdlVW5pdHMoc3RhcnQsIGVuZCwga2V5KTtcblx0ICAgICAgICAgIGRlbHRhID0ge1xuXHQgICAgICAgICAgICB0eXBlOiAndW5pdCcsXG5cdCAgICAgICAgICAgIG5hbWU6IGtleSxcblx0ICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuXHQgICAgICAgICAgICBlbmQ6IGVuZCxcblx0ICAgICAgICAgICAgZGVsdGE6IGVuZC52YWx1ZSAtIHN0YXJ0LnZhbHVlLFxuXHQgICAgICAgICAgICBlYXNpbmc6IGVhc2luZyxcblx0ICAgICAgICAgICAgY3VydmU6IGN1cnZlXG5cdCAgICAgICAgICB9O1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBlbmQgPSBwYXJzZUZsb2F0KHRoaXMucGFyc2VTdHJpbmdPcHRpb24oZW5kLCBpbmRleCkpO1xuXHQgICAgICAgICAgc3RhcnQgPSBwYXJzZUZsb2F0KHRoaXMucGFyc2VTdHJpbmdPcHRpb24oc3RhcnQsIGluZGV4KSk7XG5cdCAgICAgICAgICBkZWx0YSA9IHtcblx0ICAgICAgICAgICAgdHlwZTogJ251bWJlcicsXG5cdCAgICAgICAgICAgIG5hbWU6IGtleSxcblx0ICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuXHQgICAgICAgICAgICBlbmQ6IGVuZCxcblx0ICAgICAgICAgICAgZGVsdGE6IGVuZCAtIHN0YXJ0LFxuXHQgICAgICAgICAgICBlYXNpbmc6IGVhc2luZyxcblx0ICAgICAgICAgICAgY3VydmU6IGN1cnZlXG5cdCAgICAgICAgICB9O1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIGRlbHRhO1xuXHQgIH07XG5cblx0ICBIZWxwZXJzLnByb3RvdHlwZS5tZXJnZVVuaXRzID0gZnVuY3Rpb24oc3RhcnQsIGVuZCwga2V5KSB7XG5cdCAgICBpZiAoIWVuZC5pc1N0cmljdCAmJiBzdGFydC5pc1N0cmljdCkge1xuXHQgICAgICBlbmQudW5pdCA9IHN0YXJ0LnVuaXQ7XG5cdCAgICAgIHJldHVybiBlbmQuc3RyaW5nID0gXCJcIiArIGVuZC52YWx1ZSArIGVuZC51bml0O1xuXHQgICAgfSBlbHNlIGlmIChlbmQuaXNTdHJpY3QgJiYgIXN0YXJ0LmlzU3RyaWN0KSB7XG5cdCAgICAgIHN0YXJ0LnVuaXQgPSBlbmQudW5pdDtcblx0ICAgICAgcmV0dXJuIHN0YXJ0LnN0cmluZyA9IFwiXCIgKyBzdGFydC52YWx1ZSArIHN0YXJ0LnVuaXQ7XG5cdCAgICB9IGVsc2UgaWYgKGVuZC5pc1N0cmljdCAmJiBzdGFydC5pc1N0cmljdCkge1xuXHQgICAgICBpZiAoZW5kLnVuaXQgIT09IHN0YXJ0LnVuaXQpIHtcblx0ICAgICAgICBzdGFydC51bml0ID0gZW5kLnVuaXQ7XG5cdCAgICAgICAgc3RhcnQuc3RyaW5nID0gXCJcIiArIHN0YXJ0LnZhbHVlICsgc3RhcnQudW5pdDtcblx0ICAgICAgICByZXR1cm4gdGhpcy53YXJuKFwiVHdvIGRpZmZlcmVudCB1bml0cyB3ZXJlIHNwZWNpZmllZCBvbiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgZGVsdGEgcHJvcGVydHksIG1vIMK3IGpzIHdpbGwgZmFsbGJhY2sgdG8gZW5kIFxcXCJcIiArIGVuZC51bml0ICsgXCJcXFwiIHVuaXQgXCIpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIEhlbHBlcnMucHJvdG90eXBlLnJhbmQgPSBmdW5jdGlvbihtaW4sIG1heCkge1xuXHQgICAgcmV0dXJuIChNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbikpICsgbWluO1xuXHQgIH07XG5cblx0ICBIZWxwZXJzLnByb3RvdHlwZS5pc0RPTSA9IGZ1bmN0aW9uKG8pIHtcblx0ICAgIHZhciBpc05vZGU7XG5cdCAgICBpZiAobyA9PSBudWxsKSB7XG5cdCAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH1cblx0ICAgIGlzTm9kZSA9IHR5cGVvZiBvLm5vZGVUeXBlID09PSAnbnVtYmVyJyAmJiB0eXBlb2Ygby5ub2RlTmFtZSA9PT0gJ3N0cmluZyc7XG5cdCAgICByZXR1cm4gdHlwZW9mIG8gPT09ICdvYmplY3QnICYmIGlzTm9kZTtcblx0ICB9O1xuXG5cdCAgSGVscGVycy5wcm90b3R5cGUuZ2V0Q2hpbGRFbGVtZW50cyA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0ICAgIHZhciBjaGlsZE5vZGVzLCBjaGlsZHJlbiwgaTtcblx0ICAgIGNoaWxkTm9kZXMgPSBlbGVtZW50LmNoaWxkTm9kZXM7XG5cdCAgICBjaGlsZHJlbiA9IFtdO1xuXHQgICAgaSA9IGNoaWxkTm9kZXMubGVuZ3RoO1xuXHQgICAgd2hpbGUgKGktLSkge1xuXHQgICAgICBpZiAoY2hpbGROb2Rlc1tpXS5ub2RlVHlwZSA9PT0gMSkge1xuXHQgICAgICAgIGNoaWxkcmVuLnVuc2hpZnQoY2hpbGROb2Rlc1tpXSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiBjaGlsZHJlbjtcblx0ICB9O1xuXG5cdCAgSGVscGVycy5wcm90b3R5cGUuZGVsdGEgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG5cdCAgICB2YXIgaXNUeXBlMSwgaXNUeXBlMiwgb2JqLCB0eXBlMSwgdHlwZTI7XG5cdCAgICB0eXBlMSA9IHR5cGVvZiBzdGFydDtcblx0ICAgIHR5cGUyID0gdHlwZW9mIGVuZDtcblx0ICAgIGlzVHlwZTEgPSB0eXBlMSA9PT0gJ3N0cmluZycgfHwgdHlwZTEgPT09ICdudW1iZXInICYmICFpc05hTihzdGFydCk7XG5cdCAgICBpc1R5cGUyID0gdHlwZTIgPT09ICdzdHJpbmcnIHx8IHR5cGUyID09PSAnbnVtYmVyJyAmJiAhaXNOYU4oZW5kKTtcblx0ICAgIGlmICghaXNUeXBlMSB8fCAhaXNUeXBlMikge1xuXHQgICAgICB0aGlzLmVycm9yKFwiZGVsdGEgbWV0aG9kIGV4cGVjdHMgU3RyaW5ncyBvciBOdW1iZXJzIGF0IGlucHV0IGJ1dCBnb3QgLSBcIiArIHN0YXJ0ICsgXCIsIFwiICsgZW5kKTtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgb2JqID0ge307XG5cdCAgICBvYmpbc3RhcnRdID0gZW5kO1xuXHQgICAgcmV0dXJuIG9iajtcblx0ICB9O1xuXG5cdCAgSGVscGVycy5wcm90b3R5cGUuZ2V0VW5pcUlEID0gZnVuY3Rpb24oKSB7XG5cdCAgICByZXR1cm4gKyt0aGlzLnVuaXFJRHM7XG5cdCAgfTtcblxuXHQgIEhlbHBlcnMucHJvdG90eXBlLnBhcnNlUGF0aCA9IGZ1bmN0aW9uKHBhdGgpIHtcblx0ICAgIHZhciBkb21QYXRoO1xuXHQgICAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykge1xuXHQgICAgICBpZiAocGF0aC5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSA9PT0gJ20nKSB7XG5cdCAgICAgICAgZG9tUGF0aCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyh0aGlzLk5TLCAncGF0aCcpO1xuXHQgICAgICAgIGRvbVBhdGguc2V0QXR0cmlidXRlTlMobnVsbCwgJ2QnLCBwYXRoKTtcblx0ICAgICAgICByZXR1cm4gZG9tUGF0aDtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihwYXRoKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgaWYgKHBhdGguc3R5bGUpIHtcblx0ICAgICAgcmV0dXJuIHBhdGg7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIEhlbHBlcnMucHJvdG90eXBlLmNsb3NlRW5vdWdoID0gZnVuY3Rpb24obnVtMSwgbnVtMiwgZXBzKSB7XG5cdCAgICByZXR1cm4gTWF0aC5hYnMobnVtMSAtIG51bTIpIDwgZXBzO1xuXHQgIH07XG5cblx0ICBIZWxwZXJzLnByb3RvdHlwZS5jaGVja0lmM2QgPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciBkaXYsIHByZWZpeGVkLCBzdHlsZSwgdHI7XG5cdCAgICBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0ICAgIHRoaXMuc3R5bGUoZGl2LCAndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZVooMCknKTtcblx0ICAgIHN0eWxlID0gZGl2LnN0eWxlO1xuXHQgICAgcHJlZml4ZWQgPSB0aGlzLnByZWZpeC5jc3MgKyBcInRyYW5zZm9ybVwiO1xuXHQgICAgdHIgPSBzdHlsZVtwcmVmaXhlZF0gIT0gbnVsbCA/IHN0eWxlW3ByZWZpeGVkXSA6IHN0eWxlLnRyYW5zZm9ybTtcblx0ICAgIHJldHVybiB0ciAhPT0gJyc7XG5cdCAgfTtcblxuXG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBjaGVjayBpZiB2YXJpYWJsZSBob2xkcyBwb2ludGVyIHRvIGFuIG9iamVjdC5cblx0ICAgIEBwYXJhbSB7QW55fSBWYXJpYWJsZSB0byB0ZXN0XG5cdCAgICBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdmFyaWFibGUgaXMgb2JqZWN0LlxuXHQgICAqL1xuXG5cdCAgSGVscGVycy5wcm90b3R5cGUuaXNPYmplY3QgPSBmdW5jdGlvbih2YXJpYWJsZSkge1xuXHQgICAgcmV0dXJuIHZhcmlhYmxlICE9PSBudWxsICYmIHR5cGVvZiB2YXJpYWJsZSA9PT0gJ29iamVjdCc7XG5cdCAgfTtcblxuXG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBnZXQgZmlyc3QgdmFsdWUgb2YgdGhlIG9iamVjdC5cblx0ICAgIFVzZWQgdG8gZ2V0IGVuZCB2YWx1ZSBvbiDiiIZzLlxuXHQgICAgQHBhcmFtIHtPYmplY3R9IE9iamVjdCB0byBnZXQgdGhlIHZhbHVlIG9mLlxuXHQgICAgQHJldHVybnMge0FueX0gVGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBvYmplY3QnIHByb3BlcnR5LlxuXHQgICAqL1xuXG5cdCAgSGVscGVycy5wcm90b3R5cGUuZ2V0RGVsdGFFbmQgPSBmdW5jdGlvbihvYmopIHtcblx0ICAgIHZhciBrZXk7XG5cdCAgICBrZXkgPSBPYmplY3Qua2V5cyhvYmopWzBdO1xuXHQgICAgcmV0dXJuIG9ialtrZXldO1xuXHQgIH07XG5cblxuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gZ2V0IGZpcnN0IGtleSBvZiB0aGUgb2JqZWN0LlxuXHQgICAgVXNlZCB0byBnZXQgc3RhcnQgdmFsdWUgb24g4oiGcy5cblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBPYmplY3QgdG8gZ2V0IHRoZSB2YWx1ZSBvZi5cblx0ICAgIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBrZXkgb2YgdGhlIGZpcnN0IG9iamVjdCcgcHJvcGVydHkuXG5cdCAgICovXG5cblx0ICBIZWxwZXJzLnByb3RvdHlwZS5nZXREZWx0YVN0YXJ0ID0gZnVuY3Rpb24ob2JqKSB7XG5cdCAgICB2YXIga2V5O1xuXHQgICAga2V5ID0gT2JqZWN0LmtleXMob2JqKVswXTtcblx0ICAgIHJldHVybiBrZXk7XG5cdCAgfTtcblxuXG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBjaGVjayBpZiBwcm9wZXJ5IGV4aXN0cyBpbiBjYWxsYmFja3NNYXAgb3IgdHdlZW5PcHRpb25NYXAuXG5cdCAgICBAcGFyYW0ge1N0cmluZ30gUHJvcGVydHkgbmFtZSB0byBjaGVjayBmb3Jcblx0ICAgIEByZXR1cm5zIHtCb29sZWFufSBJZiBwcm9wZXJ0eSBpcyB0d2VlbiBwcm9wZXJ0eS5cblx0ICAgKi9cblxuXHQgIEhlbHBlcnMucHJvdG90eXBlLmlzVHdlZW5Qcm9wID0gZnVuY3Rpb24oa2V5TmFtZSkge1xuXHQgICAgcmV0dXJuIHRoaXMudHdlZW5PcHRpb25NYXBba2V5TmFtZV0gfHwgdGhpcy5jYWxsYmFja3NNYXBba2V5TmFtZV07XG5cdCAgfTtcblxuXG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBwYXJzZSBzdHJpbmcgcHJvcGVydHkgdmFsdWVcblx0ICAgIHdoaWNoIGNhbiBpbmNsdWRlIGJvdGggYHJhbmRgIGFuZCBgc3RhZ2dlciBgXG5cdCAgICB2YWx1ZSBpbiB2YXJpb3VzIHBvc2l0aW9ucy5cblx0ICAgIEBwYXJhbSB7U3RyaW5nfSBQcm9wZXJ0eSBuYW1lIHRvIGNoZWNrIGZvci5cblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBPcHRpb25hbCBpbmRleCBmb3Igc3RhZ2dlci5cblx0ICAgIEByZXR1cm5zIHtOdW1iZXJ9IFBhcnNlZCBvcHRpb24gdmFsdWUuXG5cdCAgICovXG5cblx0ICBIZWxwZXJzLnByb3RvdHlwZS5wYXJzZVN0cmluZ09wdGlvbiA9IGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xuXHQgICAgaWYgKGluZGV4ID09IG51bGwpIHtcblx0ICAgICAgaW5kZXggPSAwO1xuXHQgICAgfVxuXHQgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcblx0ICAgICAgdmFsdWUgPSB0aGlzLnBhcnNlSWZTdGFnZ2VyKHZhbHVlLCBpbmRleCk7XG5cdCAgICAgIHZhbHVlID0gdGhpcy5wYXJzZUlmUmFuZCh2YWx1ZSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdmFsdWU7XG5cdCAgfTtcblxuXG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBnZXQgdGhlIGxhc3QgaXRlbSBvZiBhcnJheS5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge0FycmF5fSBBcnJheSB0byBnZXQgdGhlIGxhc3QgaXRlbSBpbi5cblx0ICAgIEByZXR1cm5zIHtBbnl9IFRoZSBsYXN0IGl0ZW0gb2YgYXJyYXkuXG5cdCAgICovXG5cblx0ICBIZWxwZXJzLnByb3RvdHlwZS5nZXRMYXN0SXRlbSA9IGZ1bmN0aW9uKGFycikge1xuXHQgICAgcmV0dXJuIGFyclthcnIubGVuZ3RoIC0gMV07XG5cdCAgfTtcblxuXG5cdCAgLypcblx0ICAgIE1ldGhvZCBwYXJzZSBIVE1MRWxlbWVudC5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge1N0cmluZywgT2JqZWN0fSBTZWxlY3RvciBzdHJpbmcgb3IgSFRNTEVsZW1lbnQuXG5cdCAgICBAcmV0dXJucyB7T2JqZWN0fSBIVE1MRWxlbWVudC5cblx0ICAgKi9cblxuXHQgIEhlbHBlcnMucHJvdG90eXBlLnBhcnNlRWwgPSBmdW5jdGlvbihlbCkge1xuXHQgICAgaWYgKGguaXNET00oZWwpKSB7XG5cdCAgICAgIHJldHVybiBlbDtcblx0ICAgIH0gZWxzZSBpZiAodHlwZW9mIGVsID09PSAnc3RyaW5nJykge1xuXHQgICAgICBlbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWwpO1xuXHQgICAgfVxuXHQgICAgaWYgKGVsID09PSBudWxsKSB7XG5cdCAgICAgIGguZXJyb3IoXCJDYW4ndCBwYXJzZSBIVE1MIGVsZW1lbnQ6IFwiLCBlbCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gZWw7XG5cdCAgfTtcblxuXG5cdCAgLypcblx0ICAgIE1ldGhvZCBmb3JjZSBjb21wb3NpdG9yIGxheWVyIG9uIEhUTUxFbGVtZW50LlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBIVE1MRWxlbWVudC5cblx0ICAgIEByZXR1cm5zIHtPYmplY3R9IEhUTUxFbGVtZW50LlxuXHQgICAqL1xuXG5cdCAgSGVscGVycy5wcm90b3R5cGUuZm9yY2UzZCA9IGZ1bmN0aW9uKGVsKSB7XG5cdCAgICB0aGlzLnNldFByZWZpeGVkU3R5bGUoZWwsICdiYWNrZmFjZS12aXNpYmlsaXR5JywgJ2hpZGRlbicpO1xuXHQgICAgcmV0dXJuIGVsO1xuXHQgIH07XG5cblxuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gY2hlY2sgaWYgdmFsdWUgaXMgZGVsdGEuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtBbnl9IFByb3BlcnR5IHRvIGNoZWNrLlxuXHQgICAgQHJldHVybnMge0Jvb2xlYW59IElmIHZhbHVlIGlzIGRlbHRhLlxuXHQgICAqL1xuXG5cdCAgSGVscGVycy5wcm90b3R5cGUuaXNEZWx0YSA9IGZ1bmN0aW9uKG9wdGlvbnNWYWx1ZSkge1xuXHQgICAgdmFyIGlzT2JqZWN0O1xuXHQgICAgaXNPYmplY3QgPSB0aGlzLmlzT2JqZWN0KG9wdGlvbnNWYWx1ZSk7XG5cdCAgICBpc09iamVjdCA9IGlzT2JqZWN0ICYmICFvcHRpb25zVmFsdWUudW5pdDtcblx0ICAgIHJldHVybiAhKCFpc09iamVjdCB8fCB0aGlzLmlzQXJyYXkob3B0aW9uc1ZhbHVlKSB8fCB0aGlzLmlzRE9NKG9wdGlvbnNWYWx1ZSkpO1xuXHQgIH07XG5cblx0ICByZXR1cm4gSGVscGVycztcblxuXHR9KSgpO1xuXG5cdGggPSBuZXcgSGVscGVycztcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGg7XG5cblxuLyoqKi8gfSksXG4vKiA3MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBCaXQsIEJpdHNNYXAsIENpcmNsZSwgQ3Jvc3MsIEN1cnZlLCBDdXN0b20sIEVxdWFsLCBMaW5lLCBQb2x5Z29uLCBSZWN0LCBaaWd6YWcsIGg7XG5cblx0Qml0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MylbXCJkZWZhdWx0XCJdIHx8IF9fd2VicGFja19yZXF1aXJlX18oNzMpO1xuXG5cdEN1c3RvbSA9IF9fd2VicGFja19yZXF1aXJlX18oODUpW1wiZGVmYXVsdFwiXSB8fCBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1KTtcblxuXHRDaXJjbGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg2KTtcblxuXHRMaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4Nyk7XG5cblx0WmlnemFnID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4OCk7XG5cblx0UmVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oODkpO1xuXG5cdFBvbHlnb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkwKTtcblxuXHRDcm9zcyA9IF9fd2VicGFja19yZXF1aXJlX18oOTEpO1xuXG5cdEN1cnZlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MilbXCJkZWZhdWx0XCJdIHx8IF9fd2VicGFja19yZXF1aXJlX18oOTIpO1xuXG5cdEVxdWFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5Myk7XG5cblx0aCA9IF9fd2VicGFja19yZXF1aXJlX18oNzEpO1xuXG5cdEJpdHNNYXAgPSAoZnVuY3Rpb24oKSB7XG5cdCAgZnVuY3Rpb24gQml0c01hcCgpIHtcblx0ICAgIHRoaXMuYWRkU2hhcGUgPSBoLmJpbmQodGhpcy5hZGRTaGFwZSwgdGhpcyk7XG5cdCAgfVxuXG5cdCAgQml0c01hcC5wcm90b3R5cGUuYml0ID0gQml0O1xuXG5cdCAgQml0c01hcC5wcm90b3R5cGUuY3VzdG9tID0gQ3VzdG9tO1xuXG5cdCAgQml0c01hcC5wcm90b3R5cGUuY2lyY2xlID0gQ2lyY2xlO1xuXG5cdCAgQml0c01hcC5wcm90b3R5cGUubGluZSA9IExpbmU7XG5cblx0ICBCaXRzTWFwLnByb3RvdHlwZS56aWd6YWcgPSBaaWd6YWc7XG5cblx0ICBCaXRzTWFwLnByb3RvdHlwZS5yZWN0ID0gUmVjdDtcblxuXHQgIEJpdHNNYXAucHJvdG90eXBlLnBvbHlnb24gPSBQb2x5Z29uO1xuXG5cdCAgQml0c01hcC5wcm90b3R5cGUuY3Jvc3MgPSBDcm9zcztcblxuXHQgIEJpdHNNYXAucHJvdG90eXBlLmVxdWFsID0gRXF1YWw7XG5cblx0ICBCaXRzTWFwLnByb3RvdHlwZS5jdXJ2ZSA9IEN1cnZlO1xuXG5cdCAgQml0c01hcC5wcm90b3R5cGUuZ2V0U2hhcGUgPSBmdW5jdGlvbihuYW1lKSB7XG5cdCAgICByZXR1cm4gdGhpc1tuYW1lXSB8fCBoLmVycm9yKFwibm8gXFxcIlwiICsgbmFtZSArIFwiXFxcIiBzaGFwZSBhdmFpbGFibGUgeWV0LCBwbGVhc2UgY2hvb3NlIGZyb20gdGhpcyBsaXN0OlwiLCBbJ2NpcmNsZScsICdsaW5lJywgJ3ppZ3phZycsICdyZWN0JywgJ3BvbHlnb24nLCAnY3Jvc3MnLCAnZXF1YWwnLCAnY3VydmUnXSk7XG5cdCAgfTtcblxuXG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBhZGQgc2hhcGUgdG8gdGhlIG1hcC5cblx0ICAgIEBwdWJsaWNcblx0ICAgIEBwYXJhbSB7U3RyaW5nfSBOYW1lIG9mIHRoZSBzaGFwZSBtb2R1bGUuXG5cdCAgICBAcGFyYW0ge09iamVjdH0gU2hhcGUgbW9kdWxlIGNsYXNzLlxuXHQgICAqL1xuXG5cdCAgQml0c01hcC5wcm90b3R5cGUuYWRkU2hhcGUgPSBmdW5jdGlvbihuYW1lLCBNb2R1bGUpIHtcblx0ICAgIHJldHVybiB0aGlzW25hbWVdID0gTW9kdWxlO1xuXHQgIH07XG5cblx0ICByZXR1cm4gQml0c01hcDtcblxuXHR9KSgpO1xuXG5cdG1vZHVsZS5leHBvcnRzID0gbmV3IEJpdHNNYXA7XG5cblxuLyoqKi8gfSksXG4vKiA3MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5cdHZhciBfdHlwZW9mMiA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cblx0dmFyIF90eXBlb2YzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHlwZW9mMik7XG5cblx0dmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0KTtcblxuXHR2YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cblx0dmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9fd2VicGFja19yZXF1aXJlX18oNzUpO1xuXG5cdHZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMik7XG5cblx0dmFyIF9pbmhlcml0czIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc2KTtcblxuXHR2YXIgX2luaGVyaXRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luaGVyaXRzMik7XG5cblx0dmFyIF9tb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0KTtcblxuXHR2YXIgX21vZHVsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tb2R1bGUpO1xuXG5cdHZhciBfaCA9IF9fd2VicGFja19yZXF1aXJlX18oNzEpO1xuXG5cdHZhciBfaDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oKTtcblxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5cdHZhciBCaXQgPSBmdW5jdGlvbiAoX01vZHVsZSkge1xuXHQgICgwLCBfaW5oZXJpdHMzLmRlZmF1bHQpKEJpdCwgX01vZHVsZSk7XG5cblx0ICBmdW5jdGlvbiBCaXQoKSB7XG5cdCAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBCaXQpO1xuXHQgICAgcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMuZGVmYXVsdCkodGhpcywgX01vZHVsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcblx0ICB9XG5cblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGRlY2xhcmUgbW9kdWxlJ3MgZGVmYXVsdHMuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cdCAgQml0LnByb3RvdHlwZS5fZGVjbGFyZURlZmF1bHRzID0gZnVuY3Rpb24gX2RlY2xhcmVEZWZhdWx0cygpIHtcblx0ICAgIHRoaXMuX2RlZmF1bHRzID0ge1xuXHQgICAgICAnbnMnOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuXHQgICAgICAndGFnJzogJ2VsbGlwc2UnLFxuXHQgICAgICAncGFyZW50JzogZG9jdW1lbnQuYm9keSxcblx0ICAgICAgJ3JhdGlvJzogMSxcblx0ICAgICAgJ3JhZGl1cyc6IDUwLFxuXHQgICAgICAncmFkaXVzWCc6IG51bGwsXG5cdCAgICAgICdyYWRpdXNZJzogbnVsbCxcblx0ICAgICAgJ3N0cm9rZSc6ICdob3RwaW5rJyxcblx0ICAgICAgJ3N0cm9rZS1kYXNoYXJyYXknOiAnJyxcblx0ICAgICAgJ3N0cm9rZS1kYXNob2Zmc2V0JzogJycsXG5cdCAgICAgICdzdHJva2UtbGluZWNhcCc6ICcnLFxuXHQgICAgICAnc3Ryb2tlLXdpZHRoJzogMixcblx0ICAgICAgJ3N0cm9rZS1vcGFjaXR5JzogMSxcblx0ICAgICAgJ2ZpbGwnOiAndHJhbnNwYXJlbnQnLFxuXHQgICAgICAnZmlsbC1vcGFjaXR5JzogMSxcblx0ICAgICAgJ3dpZHRoJzogMCxcblx0ICAgICAgJ2hlaWdodCc6IDBcblx0ICAgIH07XG5cdCAgICB0aGlzLl9kcmF3TWFwID0gWydzdHJva2UnLCAnc3Ryb2tlLXdpZHRoJywgJ3N0cm9rZS1vcGFjaXR5JywgJ3N0cm9rZS1kYXNoYXJyYXknLCAnZmlsbCcsICdzdHJva2UtZGFzaG9mZnNldCcsICdzdHJva2UtbGluZWNhcCcsICdmaWxsLW9wYWNpdHknLCAndHJhbnNmb3JtJ107XG5cdCAgfTtcblxuXHQgIEJpdC5wcm90b3R5cGUuX3ZhcnMgPSBmdW5jdGlvbiBfdmFycygpIHtcblx0ICAgIHRoaXMuX3N0YXRlID0ge307XG5cdCAgICB0aGlzLl9kcmF3TWFwTGVuZ3RoID0gdGhpcy5fZHJhd01hcC5sZW5ndGg7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIGZvciBpbml0aWFsIHJlbmRlciBvZiB0aGUgc2hhcGUuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIEJpdC5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uIF9yZW5kZXIoKSB7XG5cdCAgICBpZiAodGhpcy5faXNSZW5kZXJlZCkge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICAvLyBzZXQgYF9pc1JlbmRlcmVkYCBoYXRjaFxuXHQgICAgdGhpcy5faXNSZW5kZXJlZCA9IHRydWU7XG5cdCAgICAvLyBjcmVhdGUgYFNWR2AgY2FudmFzIHRvIGRyYXcgaW5cblx0ICAgIHRoaXMuX2NyZWF0ZVNWR0NhbnZhcygpO1xuXHQgICAgLy8gc2V0IGNhbnZhcyBzaXplXG5cdCAgICB0aGlzLl9zZXRDYW52YXNTaXplKCk7XG5cdCAgICAvLyBkcmF3IHRoZSBpbml0aWFsIHN0YXRlXG5cdCAgICAvLyB0aGlzLl9kcmF3KCk7XG5cdCAgICAvLyBhcHBlbmQgdGhlIGNhbnZhcyB0byB0aGUgcGFyZW50IGZyb20gcHJvcHNcblx0ICAgIHRoaXMuX3Byb3BzLnBhcmVudC5hcHBlbmRDaGlsZCh0aGlzLl9jYW52YXMpO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBjcmVhdGUgYFNWR2AgY2FudmFzIHRvIGRyYXcgaW4uXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIEJpdC5wcm90b3R5cGUuX2NyZWF0ZVNWR0NhbnZhcyA9IGZ1bmN0aW9uIF9jcmVhdGVTVkdDYW52YXMoKSB7XG5cdCAgICB2YXIgcCA9IHRoaXMuX3Byb3BzO1xuXHQgICAgLy8gY3JlYXRlIGNhbnZhcyAtIGBzdmdgIGVsZW1lbnQgdG8gZHJhdyBpblxuXHQgICAgdGhpcy5fY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHAubnMsICdzdmcnKTtcblx0ICAgIC8vIGNyZWF0ZSB0aGUgZWxlbWVudCBzaGFwZSBlbGVtZW50IGFuZCBhZGQgaXQgdG8gdGhlIGNhbnZhc1xuXHQgICAgdGhpcy5lbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhwLm5zLCBwLnRhZyk7XG5cdCAgICB0aGlzLl9jYW52YXMuYXBwZW5kQ2hpbGQodGhpcy5lbCk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHNldCBzaXplIG9mIHRoZSBfY2FudmFzLlxuXHQgICAgQHByaXZhdGVcblx0ICAqL1xuXG5cblx0ICBCaXQucHJvdG90eXBlLl9zZXRDYW52YXNTaXplID0gZnVuY3Rpb24gX3NldENhbnZhc1NpemUoKSB7XG5cdCAgICB2YXIgcCA9IHRoaXMuX3Byb3BzLFxuXHQgICAgICAgIHN0eWxlID0gdGhpcy5fY2FudmFzLnN0eWxlO1xuXG5cdCAgICBzdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblx0ICAgIHN0eWxlLndpZHRoID0gJzEwMCUnO1xuXHQgICAgc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuXHQgICAgc3R5bGUubGVmdCA9ICcwcHgnO1xuXHQgICAgc3R5bGUudG9wID0gJzBweCc7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGRyYXcgdGhlIHNoYXBlLlxuXHQgICAgQ2FsbGVkIG9uIGV2ZXJ5IGZyYW1lLlxuXHQgICAgQHByaXZhdGVcblx0ICAqL1xuXG5cblx0ICBCaXQucHJvdG90eXBlLl9kcmF3ID0gZnVuY3Rpb24gX2RyYXcoKSB7XG5cdCAgICB0aGlzLl9wcm9wcy5sZW5ndGggPSB0aGlzLl9nZXRMZW5ndGgoKTtcblxuXHQgICAgdmFyIHN0YXRlID0gdGhpcy5fc3RhdGUsXG5cdCAgICAgICAgcHJvcHMgPSB0aGlzLl9wcm9wcztcblxuXHQgICAgdmFyIGxlbiA9IHRoaXMuX2RyYXdNYXBMZW5ndGg7XG5cdCAgICB3aGlsZSAobGVuLS0pIHtcblx0ICAgICAgdmFyIG5hbWUgPSB0aGlzLl9kcmF3TWFwW2xlbl07XG5cdCAgICAgIHN3aXRjaCAobmFtZSkge1xuXHQgICAgICAgIGNhc2UgJ3N0cm9rZS1kYXNoYXJyYXknOlxuXHQgICAgICAgIGNhc2UgJ3N0cm9rZS1kYXNob2Zmc2V0Jzpcblx0ICAgICAgICAgIHRoaXMuY2FzdFN0cm9rZURhc2gobmFtZSk7XG5cdCAgICAgIH1cblx0ICAgICAgdGhpcy5fc2V0QXR0cklmQ2hhbmdlZChuYW1lLCB0aGlzLl9wcm9wc1tuYW1lXSk7XG5cdCAgICB9XG5cdCAgICB0aGlzLl9zdGF0ZS5yYWRpdXMgPSB0aGlzLl9wcm9wcy5yYWRpdXM7XG5cdCAgfTtcblxuXHQgIEJpdC5wcm90b3R5cGUuY2FzdFN0cm9rZURhc2ggPSBmdW5jdGlvbiBjYXN0U3Ryb2tlRGFzaChuYW1lKSB7XG5cdCAgICAvLyAjIGlmIGFycmF5IG9mIHZhbHVlc1xuXHQgICAgdmFyIHAgPSB0aGlzLl9wcm9wcztcblx0ICAgIGlmIChfaDIuZGVmYXVsdC5pc0FycmF5KHBbbmFtZV0pKSB7XG5cdCAgICAgIHZhciBzdHJva2UgPSAnJztcblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwW25hbWVdLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgdmFyIGRhc2ggPSBwW25hbWVdW2ldLFxuXHQgICAgICAgICAgICBjYXN0ID0gZGFzaC51bml0ID09PSAnJScgPyB0aGlzLmNhc3RQZXJjZW50KGRhc2gudmFsdWUpIDogZGFzaC52YWx1ZTtcblx0ICAgICAgICBzdHJva2UgKz0gY2FzdCArICcgJztcblx0ICAgICAgfVxuXHQgICAgICBwW25hbWVdID0gc3Ryb2tlID09PSAnMCAnID8gc3Ryb2tlID0gJycgOiBzdHJva2U7XG5cdCAgICAgIHJldHVybiBwW25hbWVdID0gc3Ryb2tlO1xuXHQgICAgfVxuXHQgICAgLy8gIyBpZiBzaW5nbGUgdmFsdWVcblx0ICAgIGlmICgoMCwgX3R5cGVvZjMuZGVmYXVsdCkocFtuYW1lXSkgPT09ICdvYmplY3QnKSB7XG5cdCAgICAgIHN0cm9rZSA9IHBbbmFtZV0udW5pdCA9PT0gJyUnID8gdGhpcy5jYXN0UGVyY2VudChwW25hbWVdLnZhbHVlKSA6IHBbbmFtZV0udmFsdWU7XG5cdCAgICAgIHBbbmFtZV0gPSBzdHJva2UgPT09IDAgPyBzdHJva2UgPSAnJyA6IHN0cm9rZTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgQml0LnByb3RvdHlwZS5jYXN0UGVyY2VudCA9IGZ1bmN0aW9uIGNhc3RQZXJjZW50KHBlcmNlbnQpIHtcblx0ICAgIHJldHVybiBwZXJjZW50ICogKHRoaXMuX3Byb3BzLmxlbmd0aCAvIDEwMCk7XG5cdCAgfTtcblxuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gc2V0IHByb3BzIHRvIGF0dHJpYnV0ZXMgYW5kIGNhY2hlIHRoZSB2YWx1ZXMuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIEJpdC5wcm90b3R5cGUuX3NldEF0dHJJZkNoYW5nZWQgPSBmdW5jdGlvbiBfc2V0QXR0cklmQ2hhbmdlZChuYW1lLCB2YWx1ZSkge1xuXHQgICAgaWYgKHRoaXMuX3N0YXRlW25hbWVdICE9PSB2YWx1ZSkge1xuXHQgICAgICAvLyB0aGlzLmVsLnN0eWxlW25hbWVdID0gdmFsdWU7XG5cdCAgICAgIHRoaXMuZWwuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcblx0ICAgICAgdGhpcy5fc3RhdGVbbmFtZV0gPSB2YWx1ZTtcblx0ICAgIH1cblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gbGVuZ3RoIG9mIHRoZSBzaGFwZS5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcmV0dXJucyB7TnVtYmVyfSBMZW5ndGggb2YgdGhlIHNoYXBlLlxuXHQgICovXG5cblxuXHQgIEJpdC5wcm90b3R5cGUuX2dldExlbmd0aCA9IGZ1bmN0aW9uIF9nZXRMZW5ndGgoKSB7XG5cdCAgICB2YXIgcCA9IHRoaXMuX3Byb3BzLFxuXHQgICAgICAgIGxlbiA9IDAsXG5cdCAgICAgICAgaXNHZXRMZW5ndGggPSAhISh0aGlzLmVsICYmIHRoaXMuZWwuZ2V0VG90YWxMZW5ndGgpO1xuXG5cdCAgICBpZiAoaXNHZXRMZW5ndGggJiYgdGhpcy5lbC5nZXRBdHRyaWJ1dGUoJ2QnKSkge1xuXHQgICAgICBsZW4gPSB0aGlzLmVsLmdldFRvdGFsTGVuZ3RoKCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBsZW4gPSAyICogKHAucmFkaXVzWCAhPSBudWxsID8gcC5yYWRpdXNYIDogcC5yYWRpdXMpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGxlbjtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gY2FsY3VsYXRlIHRvdGFsIHN1bSBiZXR3ZWVuIHBvaW50cy5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge0FycmF5fSBBcnJheSBvZiBwb2ludHMuXG5cdCAgICBAcmV0dXJucyB7TnVtYmVyfSBEaXN0YW5jZSBiZXd0d2VlbiBhbGwgcG9pbnRzLlxuXHQgICovXG5cblxuXHQgIEJpdC5wcm90b3R5cGUuX2dldFBvaW50c1BlcmltaXRlciA9IGZ1bmN0aW9uIF9nZXRQb2ludHNQZXJpbWl0ZXIocG9pbnRzKSB7XG5cdCAgICB2YXIgc3VtID0gMDtcblxuXHQgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgc3VtICs9IHRoaXMuX3BvaW50c0RlbHRhKHBvaW50c1tpIC0gMV0sIHBvaW50c1tpXSk7XG5cdCAgICB9XG5cblx0ICAgIHN1bSArPSB0aGlzLl9wb2ludHNEZWx0YShwb2ludHNbMF0sIF9oMi5kZWZhdWx0LmdldExhc3RJdGVtKHBvaW50cykpO1xuXHQgICAgcmV0dXJuIHN1bTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gZ2V0IGRlbHRhIGZyb20gdHdvIHBvaW50cy5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge09iamVjdH0gUG9pbnQgMS5cblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBQb2ludCAyLlxuXHQgICAgQHJldHVybnMge051bWJlcn0gRGlzdGFuY2UgYmV0d2VlbiB0aGUgcG9vaW50cy5cblx0ICAqL1xuXG5cblx0ICBCaXQucHJvdG90eXBlLl9wb2ludHNEZWx0YSA9IGZ1bmN0aW9uIF9wb2ludHNEZWx0YShwb2ludDEsIHBvaW50Mikge1xuXHQgICAgdmFyIGR4ID0gTWF0aC5hYnMocG9pbnQxLnggLSBwb2ludDIueCksXG5cdCAgICAgICAgZHkgPSBNYXRoLmFicyhwb2ludDEueSAtIHBvaW50Mi55KTtcblx0ICAgIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBzZXQgbW9kdWxlJ3Mgc2l6ZS5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge051bWJlcn0gTW9kdWxlIHdpZHRoLlxuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IE1vZHVsZSBoZWlnaHQuXG5cdCAgKi9cblxuXG5cdCAgQml0LnByb3RvdHlwZS5fc2V0U2l6ZSA9IGZ1bmN0aW9uIF9zZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcblx0ICAgIHZhciBwID0gdGhpcy5fcHJvcHM7XG5cdCAgICBwLndpZHRoID0gd2lkdGg7XG5cdCAgICBwLmhlaWdodCA9IGhlaWdodDtcblx0ICAgIHRoaXMuX2RyYXcoKTtcblx0ICB9O1xuXG5cdCAgcmV0dXJuIEJpdDtcblx0fShfbW9kdWxlMi5kZWZhdWx0KTtcblxuXHRleHBvcnRzLmRlZmF1bHQgPSBCaXQ7XG5cbi8qKiovIH0pLFxuLyogNzQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5cdGV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcblx0ICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuXHQgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcblx0ICB9XG5cdH07XG5cbi8qKiovIH0pLFxuLyogNzUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5cdHZhciBfdHlwZW9mMiA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cblx0dmFyIF90eXBlb2YzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHlwZW9mMik7XG5cblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuXHRleHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoc2VsZiwgY2FsbCkge1xuXHQgIGlmICghc2VsZikge1xuXHQgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuXHQgIH1cblxuXHQgIHJldHVybiBjYWxsICYmICgodHlwZW9mIGNhbGwgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogKDAsIF90eXBlb2YzLmRlZmF1bHQpKGNhbGwpKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmO1xuXHR9O1xuXG4vKioqLyB9KSxcbi8qIDc2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuXHR2YXIgX3NldFByb3RvdHlwZU9mID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Nyk7XG5cblx0dmFyIF9zZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zZXRQcm90b3R5cGVPZik7XG5cblx0dmFyIF9jcmVhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgxKTtcblxuXHR2YXIgX2NyZWF0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGUpO1xuXG5cdHZhciBfdHlwZW9mMiA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cblx0dmFyIF90eXBlb2YzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHlwZW9mMik7XG5cblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuXHRleHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcblx0ICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG5cdCAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArICh0eXBlb2Ygc3VwZXJDbGFzcyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiAoMCwgX3R5cGVvZjMuZGVmYXVsdCkoc3VwZXJDbGFzcykpKTtcblx0ICB9XG5cblx0ICBzdWJDbGFzcy5wcm90b3R5cGUgPSAoMCwgX2NyZWF0ZTIuZGVmYXVsdCkoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuXHQgICAgY29uc3RydWN0b3I6IHtcblx0ICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuXHQgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcblx0ICAgICAgd3JpdGFibGU6IHRydWUsXG5cdCAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHQgICAgfVxuXHQgIH0pO1xuXHQgIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2YyLmRlZmF1bHQgPyAoMCwgX3NldFByb3RvdHlwZU9mMi5kZWZhdWx0KShzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xuXHR9O1xuXG4vKioqLyB9KSxcbi8qIDc3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDc4KSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG4vKioqLyB9KSxcbi8qIDc4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0X193ZWJwYWNrX3JlcXVpcmVfXyg3OSk7XG5cdG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCkuT2JqZWN0LnNldFByb3RvdHlwZU9mO1xuXG4vKioqLyB9KSxcbi8qIDc5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0Ly8gMTkuMS4zLjE5IE9iamVjdC5zZXRQcm90b3R5cGVPZihPLCBwcm90bylcblx0dmFyICRleHBvcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcblx0JGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7c2V0UHJvdG90eXBlT2Y6IF9fd2VicGFja19yZXF1aXJlX18oODApLnNldH0pO1xuXG4vKioqLyB9KSxcbi8qIDgwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0Ly8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXG5cdC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cdHZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMjApXG5cdCAgLCBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuXHR2YXIgY2hlY2sgPSBmdW5jdGlvbihPLCBwcm90byl7XG5cdCAgYW5PYmplY3QoTyk7XG5cdCAgaWYoIWlzT2JqZWN0KHByb3RvKSAmJiBwcm90byAhPT0gbnVsbCl0aHJvdyBUeXBlRXJyb3IocHJvdG8gKyBcIjogY2FuJ3Qgc2V0IGFzIHByb3RvdHlwZSFcIik7XG5cdH07XG5cdG1vZHVsZS5leHBvcnRzID0ge1xuXHQgIHNldDogT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8ICgnX19wcm90b19fJyBpbiB7fSA/IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblx0ICAgIGZ1bmN0aW9uKHRlc3QsIGJ1Z2d5LCBzZXQpe1xuXHQgICAgICB0cnkge1xuXHQgICAgICAgIHNldCA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpKEZ1bmN0aW9uLmNhbGwsIF9fd2VicGFja19yZXF1aXJlX18oNjcpLmYoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldCwgMik7XG5cdCAgICAgICAgc2V0KHRlc3QsIFtdKTtcblx0ICAgICAgICBidWdneSA9ICEodGVzdCBpbnN0YW5jZW9mIEFycmF5KTtcblx0ICAgICAgfSBjYXRjaChlKXsgYnVnZ3kgPSB0cnVlOyB9XG5cdCAgICAgIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90byl7XG5cdCAgICAgICAgY2hlY2soTywgcHJvdG8pO1xuXHQgICAgICAgIGlmKGJ1Z2d5KU8uX19wcm90b19fID0gcHJvdG87XG5cdCAgICAgICAgZWxzZSBzZXQoTywgcHJvdG8pO1xuXHQgICAgICAgIHJldHVybiBPO1xuXHQgICAgICB9O1xuXHQgICAgfSh7fSwgZmFsc2UpIDogdW5kZWZpbmVkKSxcblx0ICBjaGVjazogY2hlY2tcblx0fTtcblxuLyoqKi8gfSksXG4vKiA4MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdG1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogX193ZWJwYWNrX3JlcXVpcmVfXyg4MiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuLyoqKi8gfSksXG4vKiA4MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdF9fd2VicGFja19yZXF1aXJlX18oODMpO1xuXHR2YXIgJE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpLk9iamVjdDtcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGUoUCwgRCl7XG5cdCAgcmV0dXJuICRPYmplY3QuY3JlYXRlKFAsIEQpO1xuXHR9O1xuXG4vKioqLyB9KSxcbi8qIDgzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyICRleHBvcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKVxuXHQvLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcblx0JGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7Y3JlYXRlOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKX0pO1xuXG4vKioqLyB9KSxcbi8qIDg0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cblx0dmFyIF90eXBlb2YyID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxuXHR2YXIgX3R5cGVvZjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90eXBlb2YyKTtcblxuXHR2YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oNzQpO1xuXG5cdHZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxuXHR2YXIgX2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcxKTtcblxuXHR2YXIgX2gyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaCk7XG5cblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuXHQvKlxuXHQgIEJhc2UgY2xhc3MgZm9yIG1vZHVsZS4gRXh0ZW5kcyBhbmQgcGFyc2VzIGRlZmF1bHRzLlxuXHQqL1xuXHR2YXIgTW9kdWxlID0gZnVuY3Rpb24gKCkge1xuXHQgIGZ1bmN0aW9uIE1vZHVsZSgpIHtcblx0ICAgIHZhciBvID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblx0ICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIE1vZHVsZSk7XG5cblx0ICAgIC8vIHRoaXMuX2lzSXQgPSBvLmlzSXQ7XG5cdCAgICAvLyBkZWxldGUgby5pc0l0O1xuXHQgICAgdGhpcy5fbyA9IG87XG5cdCAgICB0aGlzLl9pbmRleCA9IHRoaXMuX28uaW5kZXggfHwgMDtcblx0ICAgIC8vIG1hcCBvZiBwcm9wcyB0aGF0IHNob3VsZCBiZVxuXHQgICAgLy8gcGFyc2VkIHRvIGFycmF5cyBvZiB2YWx1ZXNcblx0ICAgIHRoaXMuX2FycmF5UHJvcGVydHlNYXAgPSB7XG5cdCAgICAgIHN0cm9rZURhc2hvZmZzZXQ6IDEsXG5cdCAgICAgIHN0cm9rZURhc2hhcnJheTogMSxcblx0ICAgICAgb3JpZ2luOiAxXG5cdCAgICB9O1xuXG5cdCAgICB0aGlzLl9za2lwUHJvcHNEZWx0YSA9IHtcblx0ICAgICAgdGltZWxpbmU6IDEsXG5cdCAgICAgIHByZXZDaGFpbk1vZHVsZTogMSxcblx0ICAgICAgY2FsbGJhY2tzQ29udGV4dDogMVxuXHQgICAgfTtcblxuXHQgICAgdGhpcy5fZGVjbGFyZURlZmF1bHRzKCk7XG5cdCAgICB0aGlzLl9leHRlbmREZWZhdWx0cygpO1xuXG5cdCAgICB0aGlzLl92YXJzKCk7XG5cdCAgICB0aGlzLl9yZW5kZXIoKTtcblx0ICB9XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBkZWNsYXJlIGRlZmF1bHRzLlxuXHQgICAgQHByaXZhdGVcblx0ICAqL1xuXG5cblx0ICBNb2R1bGUucHJvdG90eXBlLl9kZWNsYXJlRGVmYXVsdHMgPSBmdW5jdGlvbiBfZGVjbGFyZURlZmF1bHRzKCkge1xuXHQgICAgdGhpcy5fZGVmYXVsdHMgPSB7fTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gZGVjbGFyZSBtb2R1bGUncyB2YXJpYWJsZXMuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIE1vZHVsZS5wcm90b3R5cGUuX3ZhcnMgPSBmdW5jdGlvbiBfdmFycygpIHtcblx0ICAgIHRoaXMuX3Byb2dyZXNzID0gMDtcblx0ICAgIHRoaXMuX3N0cm9rZURhc2hhcnJheUJ1ZmZlciA9IFtdO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byByZW5kZXIgb24gaW5pdGlhbGl6YXRpb24uXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIE1vZHVsZS5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uIF9yZW5kZXIoKSB7fTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHNldCBwcm9wZXJ0eSBvbiB0aGUgbW9kdWxlLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7U3RyaW5nLCBPYmplY3R9IE5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIHNldFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3Igb2JqZWN0IHdpdGggcHJvcGVydGllcyB0byBzZXQuXG5cdCAgICBAcGFyYW0ge0FueX0gVmFsdWUgZm9yIHRoZSBwcm9wZXJ0eSB0byBzZXQuIENvdWxkIGJlXG5cdCAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCBpZiB0aGUgZmlyc3QgcGFyYW0gaXMgb2JqZWN0LlxuXHQgICovXG5cblxuXHQgIE1vZHVsZS5wcm90b3R5cGUuX3NldFByb3AgPSBmdW5jdGlvbiBfc2V0UHJvcChhdHRyLCB2YWx1ZSkge1xuXHQgICAgaWYgKCh0eXBlb2YgYXR0ciA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6ICgwLCBfdHlwZW9mMy5kZWZhdWx0KShhdHRyKSkgPT09ICdvYmplY3QnKSB7XG5cdCAgICAgIGZvciAodmFyIGtleSBpbiBhdHRyKSB7XG5cdCAgICAgICAgdGhpcy5fYXNzaWduUHJvcChrZXksIGF0dHJba2V5XSk7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHRoaXMuX2Fzc2lnblByb3AoYXR0ciwgdmFsdWUpO1xuXHQgICAgfVxuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBhc3NpZ24gc2luZ2xlIHByb3BlcnR5J3MgdmFsdWUuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtTdHJpbmd9IFByb3BlcnR5IG5hbWUuXG5cdCAgICBAcGFyYW0ge0FueX0gICAgUHJvcGVydHkgdmFsdWUuXG5cdCAgKi9cblxuXG5cdCAgTW9kdWxlLnByb3RvdHlwZS5fYXNzaWduUHJvcCA9IGZ1bmN0aW9uIF9hc3NpZ25Qcm9wKGtleSwgdmFsdWUpIHtcblx0ICAgIHRoaXMuX3Byb3BzW2tleV0gPSB2YWx1ZTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gc2hvdyBlbGVtZW50LlxuXHQgICAgQHByaXZhdGVcblx0ICAqL1xuXG5cblx0ICBNb2R1bGUucHJvdG90eXBlLl9zaG93ID0gZnVuY3Rpb24gX3Nob3coKSB7XG5cdCAgICB2YXIgcCA9IHRoaXMuX3Byb3BzO1xuXHQgICAgaWYgKCF0aGlzLmVsKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgaWYgKHAuaXNTb2Z0SGlkZSkge1xuXHQgICAgICAvLyB0aGlzLmVsLnN0eWxlLm9wYWNpdHkgPSBwLm9wYWNpdHk7XG5cdCAgICAgIHRoaXMuX3Nob3dCeVRyYW5zZm9ybSgpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdGhpcy5lbC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblx0ICAgIH1cblxuXHQgICAgdGhpcy5faXNTaG93biA9IHRydWU7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGhpZGUgZWxlbWVudC5cblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblxuXG5cdCAgTW9kdWxlLnByb3RvdHlwZS5faGlkZSA9IGZ1bmN0aW9uIF9oaWRlKCkge1xuXHQgICAgaWYgKCF0aGlzLmVsKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgaWYgKHRoaXMuX3Byb3BzLmlzU29mdEhpZGUpIHtcblx0ICAgICAgLy8gdGhpcy5lbC5zdHlsZS5vcGFjaXR5ID0gMDtcblx0ICAgICAgX2gyLmRlZmF1bHQuc2V0UHJlZml4ZWRTdHlsZSh0aGlzLmVsLCAndHJhbnNmb3JtJywgJ3NjYWxlKDApJyk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB0aGlzLmVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuX2lzU2hvd24gPSBmYWxzZTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gc2hvdyBlbGVtZW50IGJ5IGFwcGx5aW5nIHRyYW5zZm9ybSBiYWNrIHRvIG5vcm1hbC5cblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblxuXG5cdCAgTW9kdWxlLnByb3RvdHlwZS5fc2hvd0J5VHJhbnNmb3JtID0gZnVuY3Rpb24gX3Nob3dCeVRyYW5zZm9ybSgpIHt9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gcGFyc2Ugb3B0aW9uIHN0cmluZy5cblx0ICAgIFNlYXJjaGVzIGZvciBzdGFnZ2VyIGFuZCByYW5kIHZhbHVlcyBhbmQgcGFyc2VzIHRoZW0uXG5cdCAgICBMZWF2ZXMgdGhlIHZhbHVlIHVuYXR0ZW5kZWQgb3RoZXJ3aXNlLlxuXHQgICAgQHBhcmFtIHtBbnl9IE9wdGlvbiB2YWx1ZSB0byBwYXJzZS5cblx0ICAgIEByZXR1cm5zIHtOdW1iZXJ9IFBhcnNlZCBvcHRpb25zIHZhbHVlLlxuXHQgICovXG5cblxuXHQgIE1vZHVsZS5wcm90b3R5cGUuX3BhcnNlT3B0aW9uU3RyaW5nID0gZnVuY3Rpb24gX3BhcnNlT3B0aW9uU3RyaW5nKHZhbHVlKSB7XG5cdCAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuXHQgICAgICBpZiAodmFsdWUubWF0Y2goL3N0YWdnZXIvKSkge1xuXHQgICAgICAgIHZhbHVlID0gX2gyLmRlZmF1bHQucGFyc2VTdGFnZ2VyKHZhbHVlLCB0aGlzLl9pbmRleCk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG5cdCAgICAgIGlmICh2YWx1ZS5tYXRjaCgvcmFuZC8pKSB7XG5cdCAgICAgICAgdmFsdWUgPSBfaDIuZGVmYXVsdC5wYXJzZVJhbmQodmFsdWUpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdmFsdWU7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHBhcnNlIHBvc3Rpb24gb3B0aW9uLlxuXHQgICAgQHBhcmFtIHtTdHJpbmd9IFByb3BlcnR5IG5hbWUuXG5cdCAgICBAcGFyYW0ge0FueX0gUHJvcGVydHkgVmFsdWUuXG5cdCAgICBAcmV0dXJucyB7U3RyaW5nfSBQYXJzZWQgb3B0aW9ucyB2YWx1ZS5cblx0ICAqL1xuXG5cblx0ICBNb2R1bGUucHJvdG90eXBlLl9wYXJzZVBvc2l0aW9uT3B0aW9uID0gZnVuY3Rpb24gX3BhcnNlUG9zaXRpb25PcHRpb24oa2V5LCB2YWx1ZSkge1xuXHQgICAgaWYgKF9oMi5kZWZhdWx0LnVuaXRPcHRpb25NYXBba2V5XSkge1xuXHQgICAgICB2YWx1ZSA9IF9oMi5kZWZhdWx0LnBhcnNlVW5pdCh2YWx1ZSkuc3RyaW5nO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBwYXJzZSBzdHJva2VEYXNoLi4gb3B0aW9uLlxuXHQgICAgQHBhcmFtIHtTdHJpbmd9IFByb3BlcnR5IG5hbWUuXG5cdCAgICBAcGFyYW0ge0FueX0gICAgUHJvcGVydHkgdmFsdWUuXG5cdCAgICBAcmV0dXJucyB7U3RyaW5nfSBQYXJzZWQgb3B0aW9ucyB2YWx1ZS5cblx0ICAqL1xuXG5cblx0ICBNb2R1bGUucHJvdG90eXBlLl9wYXJzZVN0cm9rZURhc2hPcHRpb24gPSBmdW5jdGlvbiBfcGFyc2VTdHJva2VEYXNoT3B0aW9uKGtleSwgdmFsdWUpIHtcblx0ICAgIHZhciByZXN1bHQgPSB2YWx1ZTtcblx0ICAgIC8vIHBhcnNlIG51bWVyaWMvcGVyY2VudCB2YWx1ZXMgZm9yIHN0cm9rZURhc2guLiBwcm9wZXJ0aWVzXG5cdCAgICBpZiAodGhpcy5fYXJyYXlQcm9wZXJ0eU1hcFtrZXldKSB7XG5cdCAgICAgIHZhciByZXN1bHQgPSBbXTtcblx0ICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiAoMCwgX3R5cGVvZjMuZGVmYXVsdCkodmFsdWUpKSB7XG5cdCAgICAgICAgY2FzZSAnbnVtYmVyJzpcblx0ICAgICAgICAgIHJlc3VsdC5wdXNoKF9oMi5kZWZhdWx0LnBhcnNlVW5pdCh2YWx1ZSkpO1xuXHQgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgY2FzZSAnc3RyaW5nJzpcblx0ICAgICAgICAgIHZhciBhcnJheSA9IHZhbHVlLnNwbGl0KCcgJyk7XG5cdCAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIHJlc3VsdC5wdXNoKF9oMi5kZWZhdWx0LnBhcnNlVW5pdChhcnJheVtpXSkpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgYnJlYWs7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGNoZWNrIGlmIHRoZSBwcm9wZXJ0eSBpcyBkZWx0YSBwcm9wZXJ0eS5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge0FueX0gUGFyYW1ldGVyIHZhbHVlIHRvIGNoZWNrLlxuXHQgICAgQHJldHVybnMge0Jvb2xlYW59XG5cdCAgKi9cblxuXG5cdCAgTW9kdWxlLnByb3RvdHlwZS5faXNEZWx0YSA9IGZ1bmN0aW9uIF9pc0RlbHRhKG9wdGlvbnNWYWx1ZSkge1xuXHQgICAgdmFyIGlzT2JqZWN0ID0gX2gyLmRlZmF1bHQuaXNPYmplY3Qob3B0aW9uc1ZhbHVlKTtcblx0ICAgIGlzT2JqZWN0ID0gaXNPYmplY3QgJiYgIW9wdGlvbnNWYWx1ZS51bml0O1xuXHQgICAgcmV0dXJuICEoIWlzT2JqZWN0IHx8IF9oMi5kZWZhdWx0LmlzQXJyYXkob3B0aW9uc1ZhbHVlKSB8fCBfaDIuZGVmYXVsdC5pc0RPTShvcHRpb25zVmFsdWUpKTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gZ2V0IGRlbHRhIGZyb20gcHJvcGVydHkgYW5kIHNldFxuXHQgICAgdGhlIHByb3BlcnR5J3Mgc3RhcnQgdmFsdWUgdG8gdGhlIHByb3BzIG9iamVjdC5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge1N0cmluZ30gS2V5IG5hbWUgdG8gZ2V0IGRlbHRhIGZvci5cblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBPcHRpb24gdmFsdWUgdG8gZ2V0IHRoZSBkZWx0YSBmb3IuXG5cdCAgKi9cblxuXG5cdCAgTW9kdWxlLnByb3RvdHlwZS5fZ2V0RGVsdGEgPSBmdW5jdGlvbiBfZ2V0RGVsdGEoa2V5LCBvcHRpb25zVmFsdWUpIHtcblx0ICAgIHZhciBkZWx0YTtcblx0ICAgIGlmICgoa2V5ID09PSAnbGVmdCcgfHwga2V5ID09PSAndG9wJykgJiYgIXRoaXMuX28uY3R4KSB7XG5cdCAgICAgIF9oMi5kZWZhdWx0Lndhcm4oJ0NvbnNpZGVyIHRvIGFuaW1hdGUgeC95IHByb3BlcnRpZXMgaW5zdGVhZCBvZiBsZWZ0L3RvcCxcXG4gICAgICAgIGFzIGl0IHdvdWxkIGJlIG11Y2ggbW9yZSBwZXJmb3JtYW50Jywgb3B0aW9uc1ZhbHVlKTtcblx0ICAgIH1cblx0ICAgIC8vIHNraXAgZGVsdGEgY2FsY3VsYXRpb24gZm9yIGEgcHJvcGVydHkgaWYgaXQgaXMgbGlzdGVkXG5cdCAgICAvLyBpbiBza2lwUHJvcHNEZWx0YSBvYmplY3Rcblx0ICAgIGlmICh0aGlzLl9za2lwUHJvcHNEZWx0YSAmJiB0aGlzLl9za2lwUHJvcHNEZWx0YVtrZXldKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIC8vIGdldCBkZWx0YVxuXHQgICAgZGVsdGEgPSBfaDIuZGVmYXVsdC5wYXJzZURlbHRhKGtleSwgb3B0aW9uc1ZhbHVlLCB0aGlzLl9pbmRleCk7XG5cdCAgICAvLyBpZiBzdWNjZXNzZnVsbHkgcGFyc2VkIC0gc2F2ZSBpdFxuXHQgICAgaWYgKGRlbHRhLnR5cGUgIT0gbnVsbCkge1xuXHQgICAgICB0aGlzLl9kZWx0YXNba2V5XSA9IGRlbHRhO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgZGVsdGFFbmQgPSAoMCwgX3R5cGVvZjMuZGVmYXVsdCkoZGVsdGEuZW5kKSA9PT0gJ29iamVjdCcgPyBkZWx0YS5lbmQudmFsdWUgPT09IDAgPyAwIDogZGVsdGEuZW5kLnN0cmluZyA6IGRlbHRhLmVuZDtcblx0ICAgIC8vIHNldCBwcm9wcyB0byBlbmQgdmFsdWUgb2YgdGhlIGRlbHRhXG5cdCAgICAvLyAwIHNob3VsZCBiZSAwIHJlZ2FyZGxlc3MgdW5pdHNcblx0ICAgIHRoaXMuX3Byb3BzW2tleV0gPSBkZWx0YUVuZDtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gY29weSBgX29gIG9wdGlvbnMgdG8gYF9wcm9wc2Agb2JqZWN0XG5cdCAgICB3aXRoIGZhbGxiYWNrIHRvIGBfZGVmYXVsdHNgLlxuXHQgICAgQHByaXZhdGVcblx0ICAqL1xuXG5cblx0ICBNb2R1bGUucHJvdG90eXBlLl9leHRlbmREZWZhdWx0cyA9IGZ1bmN0aW9uIF9leHRlbmREZWZhdWx0cygpIHtcblx0ICAgIHRoaXMuX3Byb3BzID0ge307XG5cdCAgICB0aGlzLl9kZWx0YXMgPSB7fTtcblx0ICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl9kZWZhdWx0cykge1xuXHQgICAgICAvLyBza2lwIHByb3BlcnR5IGlmIGl0IGlzIGxpc3RlZCBpbiBfc2tpcFByb3BzXG5cdCAgICAgIC8vIGlmICh0aGlzLl9za2lwUHJvcHMgJiYgdGhpcy5fc2tpcFByb3BzW2tleV0pIHsgY29udGludWU7IH1cblx0ICAgICAgLy8gY29weSB0aGUgcHJvcGVydGllcyB0byB0aGUgX28gb2JqZWN0XG5cdCAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX29ba2V5XSAhPSBudWxsID8gdGhpcy5fb1trZXldIDogdGhpcy5fZGVmYXVsdHNba2V5XTtcblx0ICAgICAgLy8gcGFyc2Ugb3B0aW9uXG5cdCAgICAgIHRoaXMuX3BhcnNlT3B0aW9uKGtleSwgdmFsdWUpO1xuXHQgICAgfVxuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byB0dW5lIG5ldyBvcHJpb25zIHRvIF9vIGFuZCBfcHJvcHMgb2JqZWN0LlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBPcHRpb25zIG9iamVjdCB0byB0dW5lIHRvLlxuXHQgICovXG5cblxuXHQgIE1vZHVsZS5wcm90b3R5cGUuX3R1bmVOZXdPcHRpb25zID0gZnVuY3Rpb24gX3R1bmVOZXdPcHRpb25zKG8pIHtcblx0ICAgIC8vIGhpZGUgdGhlIG1vZHVsZSBiZWZvcmUgdHVuaW5nIGl0J3Mgb3B0aW9uc1xuXHQgICAgLy8gY3V6IHRoZSB1c2VyIGNvdWxkIHNlZSB0aGUgY2hhbmdlXG5cdCAgICB0aGlzLl9oaWRlKCk7XG5cdCAgICBmb3IgKHZhciBrZXkgaW4gbykge1xuXHQgICAgICAvLyBza2lwIHByb3BlcnR5IGlmIGl0IGlzIGxpc3RlZCBpbiBfc2tpcFByb3BzXG5cdCAgICAgIC8vIGlmICh0aGlzLl9za2lwUHJvcHMgJiYgdGhpcy5fc2tpcFByb3BzW2tleV0pIHsgY29udGludWU7IH1cblx0ICAgICAgLy8gY29weSB0aGUgcHJvcGVydGllcyB0byB0aGUgX28gb2JqZWN0XG5cdCAgICAgIC8vIGRlbGV0ZSB0aGUga2V5IGZyb20gZGVsdGFzXG5cdCAgICAgIG8gJiYgZGVsZXRlIHRoaXMuX2RlbHRhc1trZXldO1xuXHQgICAgICAvLyByZXdyaXRlIF9vIHJlY29yZFxuXHQgICAgICB0aGlzLl9vW2tleV0gPSBvW2tleV07XG5cdCAgICAgIC8vIHNhdmUgdGhlIG9wdGlvbnMgdG8gX3Byb3BzXG5cdCAgICAgIHRoaXMuX3BhcnNlT3B0aW9uKGtleSwgb1trZXldKTtcblx0ICAgIH1cblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gcGFyc2Ugb3B0aW9uIHZhbHVlLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7U3RyaW5nfSBPcHRpb24gbmFtZS5cblx0ICAgIEBwYXJhbSB7QW55fSBPcHRpb24gdmFsdWUuXG5cdCAgKi9cblxuXG5cdCAgTW9kdWxlLnByb3RvdHlwZS5fcGFyc2VPcHRpb24gPSBmdW5jdGlvbiBfcGFyc2VPcHRpb24obmFtZSwgdmFsdWUpIHtcblx0ICAgIC8vIGlmIGRlbHRhIHByb3BlcnR5XG5cdCAgICBpZiAodGhpcy5faXNEZWx0YSh2YWx1ZSkgJiYgIXRoaXMuX3NraXBQcm9wc0RlbHRhW25hbWVdKSB7XG5cdCAgICAgIHRoaXMuX2dldERlbHRhKG5hbWUsIHZhbHVlKTtcblx0ICAgICAgdmFyIGRlbHRhRW5kID0gX2gyLmRlZmF1bHQuZ2V0RGVsdGFFbmQodmFsdWUpO1xuXHQgICAgICByZXR1cm4gdGhpcy5fYXNzaWduUHJvcChuYW1lLCB0aGlzLl9wYXJzZVByb3BlcnR5KG5hbWUsIGRlbHRhRW5kKSk7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuX2Fzc2lnblByb3AobmFtZSwgdGhpcy5fcGFyc2VQcm9wZXJ0eShuYW1lLCB2YWx1ZSkpO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBwYXJzZSBwb3N0aW9uIGFuZCBzdHJpbmcgcHJvcHMuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtTdHJpbmd9IFByb3BlcnR5IG5hbWUuXG5cdCAgICBAcGFyYW0ge0FueX0gICAgUHJvcGVydHkgdmFsdWUuXG5cdCAgICBAcmV0dXJucyB7QW55fSAgUGFyc2VkIHByb3BlcnR5IHZhbHVlLlxuXHQgICovXG5cblxuXHQgIE1vZHVsZS5wcm90b3R5cGUuX3BhcnNlUHJlQXJyYXlQcm9wZXJ0eSA9IGZ1bmN0aW9uIF9wYXJzZVByZUFycmF5UHJvcGVydHkobmFtZSwgdmFsdWUpIHtcblx0ICAgIC8vIHBhcnNlIHN0YWdnZXIgYW5kIHJhbmQgdmFsdWVzXG5cdCAgICB2YWx1ZSA9IHRoaXMuX3BhcnNlT3B0aW9uU3RyaW5nKHZhbHVlKTtcblx0ICAgIC8vIHBhcnNlIHVuaXRzIGZvciBwb3NpdGlvbiBwcm9wZXJ0aWVzXG5cdCAgICByZXR1cm4gdGhpcy5fcGFyc2VQb3NpdGlvbk9wdGlvbihuYW1lLCB2YWx1ZSk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHBhcnNlIHByb3BlcnR5IHZhbHVlLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7U3RyaW5nfSBQcm9wZXJ0eSBuYW1lLlxuXHQgICAgQHBhcmFtIHtBbnl9ICAgIFByb3BlcnR5IHZhbHVlLlxuXHQgICAgQHJldHVybnMge0FueX0gIFBhcnNlZCBwcm9wZXJ0eSB2YWx1ZS5cblx0ICAqL1xuXG5cblx0ICBNb2R1bGUucHJvdG90eXBlLl9wYXJzZVByb3BlcnR5ID0gZnVuY3Rpb24gX3BhcnNlUHJvcGVydHkobmFtZSwgdmFsdWUpIHtcblx0ICAgIC8vIHBhcnNlIGBIVE1MYCBlbGVtZW50IGluIGBwYXJlbnRgIG9wdGlvblxuXHQgICAgaWYgKG5hbWUgPT09ICdwYXJlbnQnKSB7XG5cdCAgICAgIHJldHVybiBfaDIuZGVmYXVsdC5wYXJzZUVsKHZhbHVlKTtcblx0ICAgIH1cblx0ICAgIC8vIHBhcnNlIGBzdGFnZ2VyYCwgYHJhbmRgIGFuZCBgcG9zaXRpb25gXG5cdCAgICB2YWx1ZSA9IHRoaXMuX3BhcnNlUHJlQXJyYXlQcm9wZXJ0eShuYW1lLCB2YWx1ZSk7XG5cdCAgICAvLyBwYXJzZSBudW1lcmljL3BlcmNlbnQgdmFsdWVzIGZvciBzdHJva2VEYXNoLi4gcHJvcGVydGllc1xuXHQgICAgcmV0dXJuIHRoaXMuX3BhcnNlU3Ryb2tlRGFzaE9wdGlvbihuYW1lLCB2YWx1ZSk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHBhcnNlIHZhbHVlcyBpbnNpZGUg4oiGLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7U3RyaW5nfSBLZXkgbmFtZS5cblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBEZWx0YS5cblx0ICAgIEByZXR1cm5zIHtPYmplY3R9IERlbHRhIHdpdGggcGFyc2VkIHBhcmFtZXRlcnMuXG5cdCAgKi9cblxuXG5cdCAgTW9kdWxlLnByb3RvdHlwZS5fcGFyc2VEZWx0YVZhbHVlcyA9IGZ1bmN0aW9uIF9wYXJzZURlbHRhVmFsdWVzKG5hbWUsIGRlbHRhKSB7XG5cdCAgICAvLyByZXR1cm4gaC5wYXJzZURlbHRhKCBuYW1lLCBkZWx0YSwgdGhpcy5faW5kZXggKTtcblxuXHQgICAgdmFyIGQgPSB7fTtcblx0ICAgIGZvciAodmFyIGtleSBpbiBkZWx0YSkge1xuXHQgICAgICB2YXIgdmFsdWUgPSBkZWx0YVtrZXldO1xuXG5cdCAgICAgIC8vIGRlbGV0ZSBkZWx0YVtrZXldO1xuXHQgICAgICAvLyBhZGQgcGFyc2VkIHByb3BlcnRpZXNcblx0ICAgICAgdmFyIG5ld0VuZCA9IHRoaXMuX3BhcnNlUHJlQXJyYXlQcm9wZXJ0eShuYW1lLCB2YWx1ZSk7XG5cdCAgICAgIGRbdGhpcy5fcGFyc2VQcmVBcnJheVByb3BlcnR5KG5hbWUsIGtleSldID0gbmV3RW5kO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGQ7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHBhcnNlIGRlbHRhIGFuZCBub25kZWx0YSBwcm9wZXJ0aWVzLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7U3RyaW5nfSBQcm9wZXJ0eSBuYW1lLlxuXHQgICAgQHBhcmFtIHtBbnl9ICAgIFByb3BlcnR5IHZhbHVlLlxuXHQgICAgQHJldHVybnMge0FueX0gIFBhcnNlZCBwcm9wZXJ0eSB2YWx1ZS5cblx0ICAqL1xuXG5cblx0ICBNb2R1bGUucHJvdG90eXBlLl9wcmVwYXJzZVByb3BWYWx1ZSA9IGZ1bmN0aW9uIF9wcmVwYXJzZVByb3BWYWx1ZShrZXksIHZhbHVlKSB7XG5cdCAgICByZXR1cm4gdGhpcy5faXNEZWx0YSh2YWx1ZSkgPyB0aGlzLl9wYXJzZURlbHRhVmFsdWVzKGtleSwgdmFsdWUpIDogdGhpcy5fcGFyc2VQcmVBcnJheVByb3BlcnR5KGtleSwgdmFsdWUpO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBjYWxjdWxhdGUgY3VycmVudCBwcm9ncmVzcyBvZiB0aGUgZGVsdGFzLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBFYXNlZCBwcm9ncmVzcyB0byBjYWxjdWxhdGUgLSBbMC4uMV0uXG5cdCAgICBAcGFyYW0ge051bWJlcn0gUHJvZ3Jlc3MgdG8gY2FsY3VsYXRlIC0gWzAuLjFdLlxuXHQgICovXG5cblxuXHQgIE1vZHVsZS5wcm90b3R5cGUuX2NhbGNDdXJyZW50UHJvcHMgPSBmdW5jdGlvbiBfY2FsY0N1cnJlbnRQcm9wcyhlYXNlZFByb2dyZXNzLCBwKSB7XG5cblx0ICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl9kZWx0YXMpIHtcblxuXHQgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9kZWx0YXNba2V5XTtcblxuXHQgICAgICAvLyBnZXQgZWFzZWQgcHJvZ3Jlc3MgZnJvbSBkZWx0YSBlYXNpbmcgaWYgZGVmaW5lZCBhbmQgbm90IGN1cnZlXG5cdCAgICAgIHZhciBpc0N1cnZlID0gISF2YWx1ZS5jdXJ2ZTtcblx0ICAgICAgdmFyIGVwID0gdmFsdWUuZWFzaW5nICE9IG51bGwgJiYgIWlzQ3VydmUgPyB2YWx1ZS5lYXNpbmcocCkgOiBlYXNlZFByb2dyZXNzO1xuXG5cdCAgICAgIGlmICh2YWx1ZS50eXBlID09PSAnYXJyYXknKSB7XG5cdCAgICAgICAgdmFyIGFycjtcblx0ICAgICAgICAvLyBpZiBwcm9wIHByb3BlcnR5IGlzIGFycmF5IC0gcmV1c2UgaXQgZWxzZSAtIGNyZWF0ZSBhbiBhcnJheVxuXHQgICAgICAgIGlmIChfaDIuZGVmYXVsdC5pc0FycmF5KHRoaXMuX3Byb3BzW2tleV0pKSB7XG5cdCAgICAgICAgICBhcnIgPSB0aGlzLl9wcm9wc1trZXldO1xuXHQgICAgICAgICAgYXJyLmxlbmd0aCA9IDA7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIGFyciA9IFtdO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIGp1c3Qgb3B0aW1pemF0aW9uIHRvIHByZXZlbnQgY3VydmVcblx0ICAgICAgICAvLyBjYWxjdWxhdGlvbnMgb24gZXZlcnkgYXJyYXkgaXRlbVxuXHQgICAgICAgIHZhciBwcm9jID0gaXNDdXJ2ZSA/IHZhbHVlLmN1cnZlKHApIDogbnVsbDtcblxuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUuZGVsdGEubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgIHZhciBpdGVtID0gdmFsdWUuZGVsdGFbaV0sXG5cdCAgICAgICAgICAgICAgZGFzaCA9ICFpc0N1cnZlID8gdmFsdWUuc3RhcnRbaV0udmFsdWUgKyBlcCAqIGl0ZW0udmFsdWUgOiBwcm9jICogKHZhbHVlLnN0YXJ0W2ldLnZhbHVlICsgcCAqIGl0ZW0udmFsdWUpO1xuXHQgICAgICAgICAgYXJyLnB1c2goe1xuXHQgICAgICAgICAgICBzdHJpbmc6ICcnICsgZGFzaCArIGl0ZW0udW5pdCxcblx0ICAgICAgICAgICAgdmFsdWU6IGRhc2gsXG5cdCAgICAgICAgICAgIHVuaXQ6IGl0ZW0udW5pdFxuXHQgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdGhpcy5fcHJvcHNba2V5XSA9IGFycjtcblx0ICAgICAgfSBlbHNlIGlmICh2YWx1ZS50eXBlID09PSAnbnVtYmVyJykge1xuXHQgICAgICAgIHRoaXMuX3Byb3BzW2tleV0gPSAhaXNDdXJ2ZSA/IHZhbHVlLnN0YXJ0ICsgZXAgKiB2YWx1ZS5kZWx0YSA6IHZhbHVlLmN1cnZlKHApICogKHZhbHVlLnN0YXJ0ICsgcCAqIHZhbHVlLmRlbHRhKTtcblx0ICAgICAgfSBlbHNlIGlmICh2YWx1ZS50eXBlID09PSAndW5pdCcpIHtcblx0ICAgICAgICB2YXIgY3VycmVudFZhbHVlID0gIWlzQ3VydmUgPyB2YWx1ZS5zdGFydC52YWx1ZSArIGVwICogdmFsdWUuZGVsdGEgOiB2YWx1ZS5jdXJ2ZShwKSAqICh2YWx1ZS5zdGFydC52YWx1ZSArIHAgKiB2YWx1ZS5kZWx0YSk7XG5cblx0ICAgICAgICB0aGlzLl9wcm9wc1trZXldID0gJycgKyBjdXJyZW50VmFsdWUgKyB2YWx1ZS5lbmQudW5pdDtcblx0ICAgICAgfSBlbHNlIGlmICh2YWx1ZS50eXBlID09PSAnY29sb3InKSB7XG5cdCAgICAgICAgdmFyIHIsIGcsIGIsIGE7XG5cdCAgICAgICAgaWYgKCFpc0N1cnZlKSB7XG5cdCAgICAgICAgICByID0gcGFyc2VJbnQodmFsdWUuc3RhcnQuciArIGVwICogdmFsdWUuZGVsdGEuciwgMTApO1xuXHQgICAgICAgICAgZyA9IHBhcnNlSW50KHZhbHVlLnN0YXJ0LmcgKyBlcCAqIHZhbHVlLmRlbHRhLmcsIDEwKTtcblx0ICAgICAgICAgIGIgPSBwYXJzZUludCh2YWx1ZS5zdGFydC5iICsgZXAgKiB2YWx1ZS5kZWx0YS5iLCAxMCk7XG5cdCAgICAgICAgICBhID0gcGFyc2VGbG9hdCh2YWx1ZS5zdGFydC5hICsgZXAgKiB2YWx1ZS5kZWx0YS5hKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgdmFyIGNwID0gdmFsdWUuY3VydmUocCk7XG5cdCAgICAgICAgICByID0gcGFyc2VJbnQoY3AgKiAodmFsdWUuc3RhcnQuciArIHAgKiB2YWx1ZS5kZWx0YS5yKSwgMTApO1xuXHQgICAgICAgICAgZyA9IHBhcnNlSW50KGNwICogKHZhbHVlLnN0YXJ0LmcgKyBwICogdmFsdWUuZGVsdGEuZyksIDEwKTtcblx0ICAgICAgICAgIGIgPSBwYXJzZUludChjcCAqICh2YWx1ZS5zdGFydC5iICsgcCAqIHZhbHVlLmRlbHRhLmIpLCAxMCk7XG5cdCAgICAgICAgICBhID0gcGFyc2VGbG9hdChjcCAqICh2YWx1ZS5zdGFydC5hICsgcCAqIHZhbHVlLmRlbHRhLmEpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fcHJvcHNba2V5XSA9ICdyZ2JhKCcgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnLCcgKyBhICsgJyknO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGNhbGN1bGF0ZSBjdXJyZW50IHByb2dyZXNzIGFuZCBwcm9iYWJseSBkcmF3IGl0IGluIGNoaWxkcmVuLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBFYXNlZCBwcm9ncmVzcyB0byBzZXQgLSBbMC4uMV0uXG5cdCAgICBAcGFyYW0ge051bWJlcn0gUHJvZ3Jlc3MgdG8gc2V0IC0gWzAuLjFdLlxuXHQgICovXG5cblxuXHQgIE1vZHVsZS5wcm90b3R5cGUuX3NldFByb2dyZXNzID0gZnVuY3Rpb24gX3NldFByb2dyZXNzKGVhc2VkUHJvZ3Jlc3MsIHByb2dyZXNzKSB7XG5cdCAgICB0aGlzLl9wcm9ncmVzcyA9IGVhc2VkUHJvZ3Jlc3M7XG5cdCAgICB0aGlzLl9jYWxjQ3VycmVudFByb3BzKGVhc2VkUHJvZ3Jlc3MsIHByb2dyZXNzKTtcblx0ICB9O1xuXG5cdCAgcmV0dXJuIE1vZHVsZTtcblx0fSgpO1xuXG5cdGV4cG9ydHMuZGVmYXVsdCA9IE1vZHVsZTtcblxuLyoqKi8gfSksXG4vKiA4NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5cdHZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NCk7XG5cblx0dmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG5cdHZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc1KTtcblxuXHR2YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIpO1xuXG5cdHZhciBfaW5oZXJpdHMyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Nik7XG5cblx0dmFyIF9pbmhlcml0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmhlcml0czIpO1xuXG5cdHZhciBfYml0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Myk7XG5cblx0dmFyIF9iaXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYml0KTtcblxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5cdHZhciBDdXN0b20gPSBmdW5jdGlvbiAoX0JpdCkge1xuXHQgICgwLCBfaW5oZXJpdHMzLmRlZmF1bHQpKEN1c3RvbSwgX0JpdCk7XG5cblx0ICBmdW5jdGlvbiBDdXN0b20oKSB7XG5cdCAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBDdXN0b20pO1xuXHQgICAgcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMuZGVmYXVsdCkodGhpcywgX0JpdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcblx0ICB9XG5cblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGRlY2xhcmUgbW9kdWxlJ3MgZGVmYXVsdHMuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQG92ZXJyaWRlcyBAIEJpdFxuXHQgICovXG5cdCAgQ3VzdG9tLnByb3RvdHlwZS5fZGVjbGFyZURlZmF1bHRzID0gZnVuY3Rpb24gX2RlY2xhcmVEZWZhdWx0cygpIHtcblx0ICAgIF9CaXQucHJvdG90eXBlLl9kZWNsYXJlRGVmYXVsdHMuY2FsbCh0aGlzKTtcblxuXHQgICAgdGhpcy5fZGVmYXVsdHMudGFnID0gJ3BhdGgnO1xuXHQgICAgdGhpcy5fZGVmYXVsdHMucGFyZW50ID0gbnVsbDtcblxuXHQgICAgLy8gcmVtb3ZlIGBzdHJva2Utd2lkdGhgIGZyb20gYF9kcmF3TWFwYFxuXHQgICAgLy8gYmVjYXVzZSB3ZSBuZWVkIHRvIHJlY2FsIHN0cm9rZVdpZHRoIHNpemUgcmVnYXJkaW5nIHNjYWxlXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2RyYXdNYXAubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgaWYgKHRoaXMuX2RyYXdNYXBbaV0gPT09ICdzdHJva2Utd2lkdGgnKSB7XG5cdCAgICAgICAgdGhpcy5fZHJhd01hcC5zcGxpY2UoaSwgMSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gZ2V0IHNoYXBlIHRvIHNldCBvbiBtb2R1bGUncyBwYXRoLlxuXHQgICAgQHB1YmxpY1xuXHQgICAgQHJldHVybnMge1N0cmluZ30gRW1wdHkgc3RyaW5nLlxuXHQgICovXG5cblxuXHQgIEN1c3RvbS5wcm90b3R5cGUuZ2V0U2hhcGUgPSBmdW5jdGlvbiBnZXRTaGFwZSgpIHtcblx0ICAgIHJldHVybiAnJztcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gZ2V0IHNoYXBlIHBlcmltZXRlciBsZW5ndGguXG5cdCAgICBAcHVibGljXG5cdCAgICBAcmV0dXJucyB7TnVtYmVyfSBEZWZhdWx0IGxlbmd0aCBzdHJpbmcuXG5cdCAgKi9cblxuXG5cdCAgQ3VzdG9tLnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbiBnZXRMZW5ndGgoKSB7XG5cdCAgICByZXR1cm4gMTAwO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBkcmF3IHRoZSBzaGFwZS5cblx0ICAgIENhbGxlZCBvbiBldmVyeSBmcmFtZS5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAb3ZlcnJpZGVzIEAgQml0XG5cdCAgKi9cblxuXG5cdCAgQ3VzdG9tLnByb3RvdHlwZS5fZHJhdyA9IGZ1bmN0aW9uIF9kcmF3KCkge1xuXHQgICAgdmFyIHAgPSB0aGlzLl9wcm9wcyxcblx0ICAgICAgICBzdGF0ZSA9IHRoaXMuX3N0YXRlLFxuXHQgICAgICAgIHJhZGl1c1hDaGFuZ2UgPSBzdGF0ZVsncmFkaXVzWCddICE9PSBwLnJhZGl1c1gsXG5cdCAgICAgICAgcmFkaXVzWUNoYW5nZSA9IHN0YXRlWydyYWRpdXNZJ10gIT09IHAucmFkaXVzWSxcblx0ICAgICAgICByYWRpdXNDaGFuZ2UgPSBzdGF0ZVsncmFkaXVzJ10gIT09IHAucmFkaXVzO1xuXG5cdCAgICAvLyB1cGRhdGUgdHJhbnNmb3JtIG9ubHkgaWYgb25lIG9mIHJhZGl1c2VzIGNoYW5nZWRcblx0ICAgIGlmIChyYWRpdXNYQ2hhbmdlIHx8IHJhZGl1c1lDaGFuZ2UgfHwgcmFkaXVzQ2hhbmdlKSB7XG5cdCAgICAgIHRoaXMuZWwuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCB0aGlzLl9nZXRTY2FsZSgpKTtcblx0ICAgICAgc3RhdGVbJ3JhZGl1c1gnXSA9IHAucmFkaXVzWDtcblx0ICAgICAgc3RhdGVbJ3JhZGl1c1knXSA9IHAucmFkaXVzWTtcblx0ICAgICAgc3RhdGVbJ3JhZGl1cyddID0gcC5yYWRpdXM7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuX3NldEF0dHJJZkNoYW5nZWQoJ3N0cm9rZS13aWR0aCcsIHBbJ3N0cm9rZS13aWR0aCddIC8gcC5tYXhTY2FsZSk7XG5cblx0ICAgIF9CaXQucHJvdG90eXBlLl9kcmF3LmNhbGwodGhpcyk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIGZvciBpbml0aWFsIHJlbmRlciBvZiB0aGUgc2hhcGUuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQG92ZXJyaWRlcyBAIEJpdFxuXHQgICovXG5cblxuXHQgIEN1c3RvbS5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uIF9yZW5kZXIoKSB7XG5cdCAgICBpZiAodGhpcy5faXNSZW5kZXJlZCkge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICB0aGlzLl9pc1JlbmRlcmVkID0gdHJ1ZTtcblxuXHQgICAgdGhpcy5fbGVuZ3RoID0gdGhpcy5nZXRMZW5ndGgoKTtcblxuXHQgICAgdmFyIHAgPSB0aGlzLl9wcm9wcztcblx0ICAgIHAucGFyZW50LmlubmVySFRNTCA9ICc8c3ZnIGlkPVwianMtbW9qcy1zaGFwZS1jYW52YXNcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgeGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCI+PGcgaWQ9XCJqcy1tb2pzLXNoYXBlLWVsXCI+JyArIHRoaXMuZ2V0U2hhcGUoKSArICc8L2c+PC9zdmc+JztcblxuXHQgICAgdGhpcy5fY2FudmFzID0gcC5wYXJlbnQucXVlcnlTZWxlY3RvcignI2pzLW1vanMtc2hhcGUtY2FudmFzJyk7XG5cdCAgICB0aGlzLmVsID0gcC5wYXJlbnQucXVlcnlTZWxlY3RvcignI2pzLW1vanMtc2hhcGUtZWwnKTtcblx0ICAgIHRoaXMuX3NldENhbnZhc1NpemUoKTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gZ2V0IHNjYWxlcyBmb3IgdGhlIHNoYXBlLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBtdXRhdGVzIEBwcm9wc1xuXHQgICovXG5cblxuXHQgIEN1c3RvbS5wcm90b3R5cGUuX2dldFNjYWxlID0gZnVuY3Rpb24gX2dldFNjYWxlKCkge1xuXHQgICAgdmFyIHAgPSB0aGlzLl9wcm9wcyxcblx0ICAgICAgICByYWRpdXNYID0gcC5yYWRpdXNYID8gcC5yYWRpdXNYIDogcC5yYWRpdXMsXG5cdCAgICAgICAgcmFkaXVzWSA9IHAucmFkaXVzWSA/IHAucmFkaXVzWSA6IHAucmFkaXVzO1xuXG5cdCAgICBwLnNjYWxlWCA9IDIgKiByYWRpdXNYIC8gMTAwO1xuXHQgICAgcC5zY2FsZVkgPSAyICogcmFkaXVzWSAvIDEwMDtcblx0ICAgIHAubWF4U2NhbGUgPSBNYXRoLm1heChwLnNjYWxlWCwgcC5zY2FsZVkpO1xuXG5cdCAgICBwLnNoaWZ0WCA9IHAud2lkdGggLyAyIC0gNTAgKiBwLnNjYWxlWDtcblx0ICAgIHAuc2hpZnRZID0gcC5oZWlnaHQgLyAyIC0gNTAgKiBwLnNjYWxlWTtcblxuXHQgICAgdmFyIHRyYW5zbGF0ZSA9ICd0cmFuc2xhdGUoJyArIHAuc2hpZnRYICsgJywgJyArIHAuc2hpZnRZICsgJyknO1xuXHQgICAgcmV0dXJuIHRyYW5zbGF0ZSArICcgc2NhbGUoJyArIHAuc2NhbGVYICsgJywgJyArIHAuc2NhbGVZICsgJyknO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBsZW5ndGggb2YgdGhlIHNoYXBlLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEByZXR1cm5zIHtOdW1iZXJ9IExlbmd0aCBvZiB0aGUgc2hhcGUuXG5cdCAgKi9cblxuXG5cdCAgQ3VzdG9tLnByb3RvdHlwZS5fZ2V0TGVuZ3RoID0gZnVuY3Rpb24gX2dldExlbmd0aCgpIHtcblx0ICAgIHJldHVybiB0aGlzLl9sZW5ndGg7XG5cdCAgfTtcblxuXHQgIHJldHVybiBDdXN0b207XG5cdH0oX2JpdDIuZGVmYXVsdCk7XG5cblx0ZXhwb3J0cy5kZWZhdWx0ID0gQ3VzdG9tO1xuXG4vKioqLyB9KSxcbi8qIDg2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XG5cdC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdHZhciBCaXQsIENpcmNsZSxcblx0ICBleHRlbmQgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG5cdCAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5cdEJpdCA9IF9fd2VicGFja19yZXF1aXJlX18oNzMpW1wiZGVmYXVsdFwiXSB8fCBfX3dlYnBhY2tfcmVxdWlyZV9fKDczKTtcblxuXHRDaXJjbGUgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuXHQgIGV4dGVuZChDaXJjbGUsIHN1cGVyQ2xhc3MpO1xuXG5cdCAgZnVuY3Rpb24gQ2lyY2xlKCkge1xuXHQgICAgcmV0dXJuIENpcmNsZS5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICB9XG5cblx0ICBDaXJjbGUucHJvdG90eXBlLl9kZWNsYXJlRGVmYXVsdHMgPSBmdW5jdGlvbigpIHtcblx0ICAgIENpcmNsZS5fX3N1cGVyX18uX2RlY2xhcmVEZWZhdWx0cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRzLnNoYXBlID0gJ2VsbGlwc2UnO1xuXHQgIH07XG5cblx0ICBDaXJjbGUucHJvdG90eXBlLl9kcmF3ID0gZnVuY3Rpb24oKSB7XG5cdCAgICB2YXIgcngsIHJ5O1xuXHQgICAgcnggPSB0aGlzLl9wcm9wcy5yYWRpdXNYICE9IG51bGwgPyB0aGlzLl9wcm9wcy5yYWRpdXNYIDogdGhpcy5fcHJvcHMucmFkaXVzO1xuXHQgICAgcnkgPSB0aGlzLl9wcm9wcy5yYWRpdXNZICE9IG51bGwgPyB0aGlzLl9wcm9wcy5yYWRpdXNZIDogdGhpcy5fcHJvcHMucmFkaXVzO1xuXHQgICAgdGhpcy5fc2V0QXR0cklmQ2hhbmdlZCgncngnLCByeCk7XG5cdCAgICB0aGlzLl9zZXRBdHRySWZDaGFuZ2VkKCdyeScsIHJ5KTtcblx0ICAgIHRoaXMuX3NldEF0dHJJZkNoYW5nZWQoJ2N4JywgdGhpcy5fcHJvcHMud2lkdGggLyAyKTtcblx0ICAgIHRoaXMuX3NldEF0dHJJZkNoYW5nZWQoJ2N5JywgdGhpcy5fcHJvcHMuaGVpZ2h0IC8gMik7XG5cdCAgICByZXR1cm4gQ2lyY2xlLl9fc3VwZXJfXy5fZHJhdy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgIH07XG5cblx0ICBDaXJjbGUucHJvdG90eXBlLl9nZXRMZW5ndGggPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciByYWRpdXNYLCByYWRpdXNZO1xuXHQgICAgcmFkaXVzWCA9IHRoaXMuX3Byb3BzLnJhZGl1c1ggIT0gbnVsbCA/IHRoaXMuX3Byb3BzLnJhZGl1c1ggOiB0aGlzLl9wcm9wcy5yYWRpdXM7XG5cdCAgICByYWRpdXNZID0gdGhpcy5fcHJvcHMucmFkaXVzWSAhPSBudWxsID8gdGhpcy5fcHJvcHMucmFkaXVzWSA6IHRoaXMuX3Byb3BzLnJhZGl1cztcblx0ICAgIHJldHVybiAyICogTWF0aC5QSSAqIE1hdGguc3FydCgocmFkaXVzWCAqIHJhZGl1c1ggKyByYWRpdXNZICogcmFkaXVzWSkgLyAyKTtcblx0ICB9O1xuXG5cdCAgcmV0dXJuIENpcmNsZTtcblxuXHR9KShCaXQpO1xuXG5cdG1vZHVsZS5leHBvcnRzID0gQ2lyY2xlO1xuXG5cbi8qKiovIH0pLFxuLyogODcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcblx0LyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0dmFyIEJpdCwgTGluZSxcblx0ICBleHRlbmQgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG5cdCAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5cdEJpdCA9IF9fd2VicGFja19yZXF1aXJlX18oNzMpW1wiZGVmYXVsdFwiXSB8fCBfX3dlYnBhY2tfcmVxdWlyZV9fKDczKTtcblxuXHRMaW5lID0gKGZ1bmN0aW9uKHN1cGVyQ2xhc3MpIHtcblx0ICBleHRlbmQoTGluZSwgc3VwZXJDbGFzcyk7XG5cblx0ICBmdW5jdGlvbiBMaW5lKCkge1xuXHQgICAgcmV0dXJuIExpbmUuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgfVxuXG5cdCAgTGluZS5wcm90b3R5cGUuX2RlY2xhcmVEZWZhdWx0cyA9IGZ1bmN0aW9uKCkge1xuXHQgICAgTGluZS5fX3N1cGVyX18uX2RlY2xhcmVEZWZhdWx0cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRzLnRhZyA9ICdsaW5lJztcblx0ICB9O1xuXG5cdCAgTGluZS5wcm90b3R5cGUuX2RyYXcgPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciByYWRpdXNYLCB4LCB5O1xuXHQgICAgcmFkaXVzWCA9IHRoaXMuX3Byb3BzLnJhZGl1c1ggIT0gbnVsbCA/IHRoaXMuX3Byb3BzLnJhZGl1c1ggOiB0aGlzLl9wcm9wcy5yYWRpdXM7XG5cdCAgICB4ID0gdGhpcy5fcHJvcHMud2lkdGggLyAyO1xuXHQgICAgeSA9IHRoaXMuX3Byb3BzLmhlaWdodCAvIDI7XG5cdCAgICB0aGlzLl9zZXRBdHRySWZDaGFuZ2VkKCd4MScsIHggLSByYWRpdXNYKTtcblx0ICAgIHRoaXMuX3NldEF0dHJJZkNoYW5nZWQoJ3gyJywgeCArIHJhZGl1c1gpO1xuXHQgICAgdGhpcy5fc2V0QXR0cklmQ2hhbmdlZCgneTEnLCB5KTtcblx0ICAgIHRoaXMuX3NldEF0dHJJZkNoYW5nZWQoJ3kyJywgeSk7XG5cdCAgICByZXR1cm4gTGluZS5fX3N1cGVyX18uX2RyYXcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICB9O1xuXG5cdCAgcmV0dXJuIExpbmU7XG5cblx0fSkoQml0KTtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IExpbmU7XG5cblxuLyoqKi8gfSksXG4vKiA4OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFxuXHQvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXHR2YXIgQml0LCBaaWd6YWcsXG5cdCAgZXh0ZW5kID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxuXHQgIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuXHRCaXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDczKVtcImRlZmF1bHRcIl0gfHwgX193ZWJwYWNrX3JlcXVpcmVfXyg3Myk7XG5cblx0WmlnemFnID0gKGZ1bmN0aW9uKHN1cGVyQ2xhc3MpIHtcblx0ICBleHRlbmQoWmlnemFnLCBzdXBlckNsYXNzKTtcblxuXHQgIGZ1bmN0aW9uIFppZ3phZygpIHtcblx0ICAgIHJldHVybiBaaWd6YWcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgfVxuXG5cdCAgWmlnemFnLnByb3RvdHlwZS5fZGVjbGFyZURlZmF1bHRzID0gZnVuY3Rpb24oKSB7XG5cdCAgICBaaWd6YWcuX19zdXBlcl9fLl9kZWNsYXJlRGVmYXVsdHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgIHRoaXMuX2RlZmF1bHRzLnRhZyA9ICdwYXRoJztcblx0ICAgIHJldHVybiB0aGlzLl9kZWZhdWx0cy5wb2ludHMgPSAzO1xuXHQgIH07XG5cblx0ICBaaWd6YWcucHJvdG90eXBlLl9kcmF3ID0gZnVuY3Rpb24oKSB7XG5cdCAgICB2YXIgY3VycmVudFgsIGN1cnJlbnRZLCBkZWx0YSwgaSwgaXNQb2ludHMsIGlzUmFkaXVzWCwgaXNSYWRpdXNZLCBqLCBsZW5ndGgsIHAsIHBvaW50cywgcmFkaXVzWCwgcmFkaXVzWSwgcmVmLCBzdGVwWCwgeCwgeSwgeUZsaXA7XG5cdCAgICBaaWd6YWcuX19zdXBlcl9fLl9kcmF3LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICBwID0gdGhpcy5fcHJvcHM7XG5cdCAgICBpZiAoIXRoaXMuX3Byb3BzLnBvaW50cykge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICByYWRpdXNYID0gdGhpcy5fcHJvcHMucmFkaXVzWCAhPSBudWxsID8gdGhpcy5fcHJvcHMucmFkaXVzWCA6IHRoaXMuX3Byb3BzLnJhZGl1cztcblx0ICAgIHJhZGl1c1kgPSB0aGlzLl9wcm9wcy5yYWRpdXNZICE9IG51bGwgPyB0aGlzLl9wcm9wcy5yYWRpdXNZIDogdGhpcy5fcHJvcHMucmFkaXVzO1xuXHQgICAgaXNSYWRpdXNYID0gcmFkaXVzWCA9PT0gdGhpcy5fcHJldlJhZGl1c1g7XG5cdCAgICBpc1JhZGl1c1kgPSByYWRpdXNZID09PSB0aGlzLl9wcmV2UmFkaXVzWTtcblx0ICAgIGlzUG9pbnRzID0gcC5wb2ludHMgPT09IHRoaXMuX3ByZXZQb2ludHM7XG5cdCAgICBpZiAoaXNSYWRpdXNYICYmIGlzUmFkaXVzWSAmJiBpc1BvaW50cykge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICB4ID0gcC53aWR0aCAvIDI7XG5cdCAgICB5ID0gcC5oZWlnaHQgLyAyO1xuXHQgICAgY3VycmVudFggPSB4IC0gcmFkaXVzWDtcblx0ICAgIGN1cnJlbnRZID0geTtcblx0ICAgIHN0ZXBYID0gKDIgKiByYWRpdXNYKSAvIChwLnBvaW50cyAtIDEpO1xuXHQgICAgeUZsaXAgPSAtMTtcblx0ICAgIGRlbHRhID0gTWF0aC5zcXJ0KHN0ZXBYICogc3RlcFggKyByYWRpdXNZICogcmFkaXVzWSk7XG5cdCAgICBsZW5ndGggPSAtZGVsdGE7XG5cdCAgICBwb2ludHMgPSBcIk1cIiArIGN1cnJlbnRYICsgXCIsIFwiICsgeSArIFwiIFwiO1xuXHQgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IHAucG9pbnRzOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcblx0ICAgICAgcG9pbnRzICs9IFwiTFwiICsgY3VycmVudFggKyBcIiwgXCIgKyBjdXJyZW50WSArIFwiIFwiO1xuXHQgICAgICBjdXJyZW50WCArPSBzdGVwWDtcblx0ICAgICAgbGVuZ3RoICs9IGRlbHRhO1xuXHQgICAgICBjdXJyZW50WSA9IHlGbGlwID09PSAtMSA/IHkgLSByYWRpdXNZIDogeTtcblx0ICAgICAgeUZsaXAgPSAteUZsaXA7XG5cdCAgICB9XG5cdCAgICB0aGlzLl9sZW5ndGggPSBsZW5ndGg7XG5cdCAgICB0aGlzLmVsLnNldEF0dHJpYnV0ZSgnZCcsIHBvaW50cyk7XG5cdCAgICB0aGlzLl9wcmV2UG9pbnRzID0gcC5wb2ludHM7XG5cdCAgICB0aGlzLl9wcmV2UmFkaXVzWCA9IHJhZGl1c1g7XG5cdCAgICByZXR1cm4gdGhpcy5fcHJldlJhZGl1c1kgPSByYWRpdXNZO1xuXHQgIH07XG5cblx0ICBaaWd6YWcucHJvdG90eXBlLl9nZXRMZW5ndGggPSBmdW5jdGlvbigpIHtcblx0ICAgIHJldHVybiB0aGlzLl9sZW5ndGg7XG5cdCAgfTtcblxuXHQgIHJldHVybiBaaWd6YWc7XG5cblx0fSkoQml0KTtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IFppZ3phZztcblxuXG4vKioqLyB9KSxcbi8qIDg5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XG5cdC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdHZhciBCaXQsIFJlY3QsXG5cdCAgZXh0ZW5kID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxuXHQgIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuXHRCaXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDczKVtcImRlZmF1bHRcIl0gfHwgX193ZWJwYWNrX3JlcXVpcmVfXyg3Myk7XG5cblx0UmVjdCA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG5cdCAgZXh0ZW5kKFJlY3QsIHN1cGVyQ2xhc3MpO1xuXG5cdCAgZnVuY3Rpb24gUmVjdCgpIHtcblx0ICAgIHJldHVybiBSZWN0Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgIH1cblxuXHQgIFJlY3QucHJvdG90eXBlLl9kZWNsYXJlRGVmYXVsdHMgPSBmdW5jdGlvbigpIHtcblx0ICAgIFJlY3QuX19zdXBlcl9fLl9kZWNsYXJlRGVmYXVsdHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgIHRoaXMuX2RlZmF1bHRzLnRhZyA9ICdyZWN0Jztcblx0ICAgIHRoaXMuX2RlZmF1bHRzLnJ4ID0gMDtcblx0ICAgIHJldHVybiB0aGlzLl9kZWZhdWx0cy5yeSA9IDA7XG5cdCAgfTtcblxuXHQgIFJlY3QucHJvdG90eXBlLl9kcmF3ID0gZnVuY3Rpb24oKSB7XG5cdCAgICB2YXIgcCwgcmFkaXVzWCwgcmFkaXVzWTtcblx0ICAgIFJlY3QuX19zdXBlcl9fLl9kcmF3LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICBwID0gdGhpcy5fcHJvcHM7XG5cdCAgICByYWRpdXNYID0gcC5yYWRpdXNYICE9IG51bGwgPyBwLnJhZGl1c1ggOiBwLnJhZGl1cztcblx0ICAgIHJhZGl1c1kgPSBwLnJhZGl1c1kgIT0gbnVsbCA/IHAucmFkaXVzWSA6IHAucmFkaXVzO1xuXHQgICAgdGhpcy5fc2V0QXR0cklmQ2hhbmdlZCgnd2lkdGgnLCAyICogcmFkaXVzWCk7XG5cdCAgICB0aGlzLl9zZXRBdHRySWZDaGFuZ2VkKCdoZWlnaHQnLCAyICogcmFkaXVzWSk7XG5cdCAgICB0aGlzLl9zZXRBdHRySWZDaGFuZ2VkKCd4JywgKHAud2lkdGggLyAyKSAtIHJhZGl1c1gpO1xuXHQgICAgdGhpcy5fc2V0QXR0cklmQ2hhbmdlZCgneScsIChwLmhlaWdodCAvIDIpIC0gcmFkaXVzWSk7XG5cdCAgICB0aGlzLl9zZXRBdHRySWZDaGFuZ2VkKCdyeCcsIHAucngpO1xuXHQgICAgcmV0dXJuIHRoaXMuX3NldEF0dHJJZkNoYW5nZWQoJ3J5JywgcC5yeSk7XG5cdCAgfTtcblxuXHQgIFJlY3QucHJvdG90eXBlLl9nZXRMZW5ndGggPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciByYWRpdXNYLCByYWRpdXNZO1xuXHQgICAgcmFkaXVzWCA9IHRoaXMuX3Byb3BzLnJhZGl1c1ggIT0gbnVsbCA/IHRoaXMuX3Byb3BzLnJhZGl1c1ggOiB0aGlzLl9wcm9wcy5yYWRpdXM7XG5cdCAgICByYWRpdXNZID0gdGhpcy5fcHJvcHMucmFkaXVzWSAhPSBudWxsID8gdGhpcy5fcHJvcHMucmFkaXVzWSA6IHRoaXMuX3Byb3BzLnJhZGl1cztcblx0ICAgIHJldHVybiAyICogKDIgKiByYWRpdXNYICsgMiAqIHJhZGl1c1kpO1xuXHQgIH07XG5cblx0ICByZXR1cm4gUmVjdDtcblxuXHR9KShCaXQpO1xuXG5cdG1vZHVsZS5leHBvcnRzID0gUmVjdDtcblxuXG4vKioqLyB9KSxcbi8qIDkwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XG5cdC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdHZhciBCaXQsIFBvbHlnb24sIGgsXG5cdCAgZXh0ZW5kID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxuXHQgIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuXHRCaXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDczKVtcImRlZmF1bHRcIl0gfHwgX193ZWJwYWNrX3JlcXVpcmVfXyg3Myk7XG5cblx0aCA9IF9fd2VicGFja19yZXF1aXJlX18oNzEpO1xuXG5cdFBvbHlnb24gPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuXHQgIGV4dGVuZChQb2x5Z29uLCBzdXBlckNsYXNzKTtcblxuXHQgIGZ1bmN0aW9uIFBvbHlnb24oKSB7XG5cdCAgICByZXR1cm4gUG9seWdvbi5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICB9XG5cblxuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gZGVjbGFyZSBkZWZhdWx0cy5cblx0ICAgIEBvdmVycmlkZXMgQCBCaXRcblx0ICAgKi9cblxuXHQgIFBvbHlnb24ucHJvdG90eXBlLl9kZWNsYXJlRGVmYXVsdHMgPSBmdW5jdGlvbigpIHtcblx0ICAgIFBvbHlnb24uX19zdXBlcl9fLl9kZWNsYXJlRGVmYXVsdHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgIHRoaXMuX2RlZmF1bHRzLnRhZyA9ICdwYXRoJztcblx0ICAgIHJldHVybiB0aGlzLl9kZWZhdWx0cy5wb2ludHMgPSAzO1xuXHQgIH07XG5cblxuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gZHJhdyB0aGUgc2hhcGUuXG5cdCAgICBAb3ZlcnJpZGVzIEAgQml0XG5cdCAgICovXG5cblx0ICBQb2x5Z29uLnByb3RvdHlwZS5fZHJhdyA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIGNoYXIsIGQsIGksIGlzUG9pbnRzLCBpc1JhZGl1c1gsIGlzUmFkaXVzWSwgaiwgaywgbGVuLCBwLCBwb2ludCwgcmFkaXVzWCwgcmFkaXVzWSwgcmVmLCByZWYxLCBzdGVwO1xuXHQgICAgcCA9IHRoaXMuX3Byb3BzO1xuXHQgICAgcmFkaXVzWCA9IHRoaXMuX3Byb3BzLnJhZGl1c1ggIT0gbnVsbCA/IHRoaXMuX3Byb3BzLnJhZGl1c1ggOiB0aGlzLl9wcm9wcy5yYWRpdXM7XG5cdCAgICByYWRpdXNZID0gdGhpcy5fcHJvcHMucmFkaXVzWSAhPSBudWxsID8gdGhpcy5fcHJvcHMucmFkaXVzWSA6IHRoaXMuX3Byb3BzLnJhZGl1cztcblx0ICAgIGlzUmFkaXVzWCA9IHJhZGl1c1ggPT09IHRoaXMuX3ByZXZSYWRpdXNYO1xuXHQgICAgaXNSYWRpdXNZID0gcmFkaXVzWSA9PT0gdGhpcy5fcHJldlJhZGl1c1k7XG5cdCAgICBpc1BvaW50cyA9IHAucG9pbnRzID09PSB0aGlzLl9wcmV2UG9pbnRzO1xuXHQgICAgaWYgKCEoaXNSYWRpdXNYICYmIGlzUmFkaXVzWSAmJiBpc1BvaW50cykpIHtcblx0ICAgICAgc3RlcCA9IDM2MCAvIHRoaXMuX3Byb3BzLnBvaW50cztcblx0ICAgICAgaWYgKHRoaXMuX3JhZGlhbFBvaW50cyA9PSBudWxsKSB7XG5cdCAgICAgICAgdGhpcy5fcmFkaWFsUG9pbnRzID0gW107XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdGhpcy5fcmFkaWFsUG9pbnRzLmxlbmd0aCA9IDA7XG5cdCAgICAgIH1cblx0ICAgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IHRoaXMuX3Byb3BzLnBvaW50czsgMCA8PSByZWYgPyBqIDwgcmVmIDogaiA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytqIDogLS1qKSB7XG5cdCAgICAgICAgdGhpcy5fcmFkaWFsUG9pbnRzLnB1c2goaC5nZXRSYWRpYWxQb2ludCh7XG5cdCAgICAgICAgICByYWRpdXM6IHRoaXMuX3Byb3BzLnJhZGl1cyxcblx0ICAgICAgICAgIHJhZGl1c1g6IHRoaXMuX3Byb3BzLnJhZGl1c1gsXG5cdCAgICAgICAgICByYWRpdXNZOiB0aGlzLl9wcm9wcy5yYWRpdXNZLFxuXHQgICAgICAgICAgYW5nbGU6IGkgKiBzdGVwLFxuXHQgICAgICAgICAgY2VudGVyOiB7XG5cdCAgICAgICAgICAgIHg6IHAud2lkdGggLyAyLFxuXHQgICAgICAgICAgICB5OiBwLmhlaWdodCAvIDJcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9KSk7XG5cdCAgICAgIH1cblx0ICAgICAgZCA9ICcnO1xuXHQgICAgICByZWYxID0gdGhpcy5fcmFkaWFsUG9pbnRzO1xuXHQgICAgICBmb3IgKGkgPSBrID0gMCwgbGVuID0gcmVmMS5sZW5ndGg7IGsgPCBsZW47IGkgPSArK2spIHtcblx0ICAgICAgICBwb2ludCA9IHJlZjFbaV07XG5cdCAgICAgICAgY2hhciA9IGkgPT09IDAgPyAnTScgOiAnTCc7XG5cdCAgICAgICAgZCArPSBcIlwiICsgY2hhciArIChwb2ludC54LnRvRml4ZWQoNCkpICsgXCIsXCIgKyAocG9pbnQueS50b0ZpeGVkKDQpKSArIFwiIFwiO1xuXHQgICAgICB9XG5cdCAgICAgIHRoaXMuX3ByZXZQb2ludHMgPSBwLnBvaW50cztcblx0ICAgICAgdGhpcy5fcHJldlJhZGl1c1ggPSByYWRpdXNYO1xuXHQgICAgICB0aGlzLl9wcmV2UmFkaXVzWSA9IHJhZGl1c1k7XG5cdCAgICAgIHRoaXMuZWwuc2V0QXR0cmlidXRlKCdkJywgKGQgKz0gJ3onKSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gUG9seWdvbi5fX3N1cGVyX18uX2RyYXcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICB9O1xuXG5cblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGdldCBsZW5ndGggb2YgdGhlIHNoYXBlLlxuXHQgICAgQG92ZXJyaWRlcyBAIEJpdFxuXHQgICAqL1xuXG5cdCAgUG9seWdvbi5wcm90b3R5cGUuX2dldExlbmd0aCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuX2dldFBvaW50c1BlcmltaXRlcih0aGlzLl9yYWRpYWxQb2ludHMpO1xuXHQgIH07XG5cblx0ICByZXR1cm4gUG9seWdvbjtcblxuXHR9KShCaXQpO1xuXG5cdG1vZHVsZS5leHBvcnRzID0gUG9seWdvbjtcblxuXG4vKioqLyB9KSxcbi8qIDkxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XG5cdC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdHZhciBCaXQsIENyb3NzLFxuXHQgIGV4dGVuZCA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSxcblx0ICBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5cblx0Qml0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MylbXCJkZWZhdWx0XCJdIHx8IF9fd2VicGFja19yZXF1aXJlX18oNzMpO1xuXG5cdENyb3NzID0gKGZ1bmN0aW9uKHN1cGVyQ2xhc3MpIHtcblx0ICBleHRlbmQoQ3Jvc3MsIHN1cGVyQ2xhc3MpO1xuXG5cdCAgZnVuY3Rpb24gQ3Jvc3MoKSB7XG5cdCAgICByZXR1cm4gQ3Jvc3MuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgfVxuXG5cdCAgQ3Jvc3MucHJvdG90eXBlLl9kZWNsYXJlRGVmYXVsdHMgPSBmdW5jdGlvbigpIHtcblx0ICAgIENyb3NzLl9fc3VwZXJfXy5fZGVjbGFyZURlZmF1bHRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICByZXR1cm4gdGhpcy5fZGVmYXVsdHMudGFnID0gJ3BhdGgnO1xuXHQgIH07XG5cblx0ICBDcm9zcy5wcm90b3R5cGUuX2RyYXcgPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciBkLCBpc1JhZGl1c1gsIGlzUmFkaXVzWSwgbGluZTEsIGxpbmUyLCBwLCByYWRpdXNYLCByYWRpdXNZLCB4LCB4MSwgeDIsIHksIHkxLCB5Mjtcblx0ICAgIENyb3NzLl9fc3VwZXJfXy5fZHJhdy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgcCA9IHRoaXMuX3Byb3BzO1xuXHQgICAgcmFkaXVzWCA9IHRoaXMuX3Byb3BzLnJhZGl1c1ggIT0gbnVsbCA/IHRoaXMuX3Byb3BzLnJhZGl1c1ggOiB0aGlzLl9wcm9wcy5yYWRpdXM7XG5cdCAgICByYWRpdXNZID0gdGhpcy5fcHJvcHMucmFkaXVzWSAhPSBudWxsID8gdGhpcy5fcHJvcHMucmFkaXVzWSA6IHRoaXMuX3Byb3BzLnJhZGl1cztcblx0ICAgIGlzUmFkaXVzWCA9IHJhZGl1c1ggPT09IHRoaXMuX3ByZXZSYWRpdXNYO1xuXHQgICAgaXNSYWRpdXNZID0gcmFkaXVzWSA9PT0gdGhpcy5fcHJldlJhZGl1c1k7XG5cdCAgICBpZiAoaXNSYWRpdXNYICYmIGlzUmFkaXVzWSkge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICB4ID0gdGhpcy5fcHJvcHMud2lkdGggLyAyO1xuXHQgICAgeSA9IHRoaXMuX3Byb3BzLmhlaWdodCAvIDI7XG5cdCAgICB4MSA9IHggLSByYWRpdXNYO1xuXHQgICAgeDIgPSB4ICsgcmFkaXVzWDtcblx0ICAgIGxpbmUxID0gXCJNXCIgKyB4MSArIFwiLFwiICsgeSArIFwiIExcIiArIHgyICsgXCIsXCIgKyB5O1xuXHQgICAgeTEgPSB5IC0gcmFkaXVzWTtcblx0ICAgIHkyID0geSArIHJhZGl1c1k7XG5cdCAgICBsaW5lMiA9IFwiTVwiICsgeCArIFwiLFwiICsgeTEgKyBcIiBMXCIgKyB4ICsgXCIsXCIgKyB5Mjtcblx0ICAgIGQgPSBsaW5lMSArIFwiIFwiICsgbGluZTI7XG5cdCAgICB0aGlzLmVsLnNldEF0dHJpYnV0ZSgnZCcsIGQpO1xuXHQgICAgdGhpcy5fcHJldlJhZGl1c1ggPSByYWRpdXNYO1xuXHQgICAgcmV0dXJuIHRoaXMuX3ByZXZSYWRpdXNZID0gcmFkaXVzWTtcblx0ICB9O1xuXG5cdCAgQ3Jvc3MucHJvdG90eXBlLl9nZXRMZW5ndGggPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciByYWRpdXNYLCByYWRpdXNZO1xuXHQgICAgcmFkaXVzWCA9IHRoaXMuX3Byb3BzLnJhZGl1c1ggIT0gbnVsbCA/IHRoaXMuX3Byb3BzLnJhZGl1c1ggOiB0aGlzLl9wcm9wcy5yYWRpdXM7XG5cdCAgICByYWRpdXNZID0gdGhpcy5fcHJvcHMucmFkaXVzWSAhPSBudWxsID8gdGhpcy5fcHJvcHMucmFkaXVzWSA6IHRoaXMuX3Byb3BzLnJhZGl1cztcblx0ICAgIHJldHVybiAyICogKHJhZGl1c1ggKyByYWRpdXNZKTtcblx0ICB9O1xuXG5cdCAgcmV0dXJuIENyb3NzO1xuXG5cdH0pKEJpdCk7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBDcm9zcztcblxuXG4vKioqLyB9KSxcbi8qIDkyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cblx0dmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0KTtcblxuXHR2YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cblx0dmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9fd2VicGFja19yZXF1aXJlX18oNzUpO1xuXG5cdHZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMik7XG5cblx0dmFyIF9pbmhlcml0czIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc2KTtcblxuXHR2YXIgX2luaGVyaXRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luaGVyaXRzMik7XG5cblx0dmFyIF9iaXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDczKTtcblxuXHR2YXIgX2JpdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9iaXQpO1xuXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cblx0dmFyIEN1cnZlID0gZnVuY3Rpb24gKF9CaXQpIHtcblx0ICAoMCwgX2luaGVyaXRzMy5kZWZhdWx0KShDdXJ2ZSwgX0JpdCk7XG5cblx0ICBmdW5jdGlvbiBDdXJ2ZSgpIHtcblx0ICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIEN1cnZlKTtcblx0ICAgIHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zLmRlZmF1bHQpKHRoaXMsIF9CaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG5cdCAgfVxuXG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBkZWNsYXJlIG1vZHVsZSdzIGRlZmF1bHRzLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBvdmVycmlkZXMgQCBCaXRcblx0ICAqL1xuXHQgIEN1cnZlLnByb3RvdHlwZS5fZGVjbGFyZURlZmF1bHRzID0gZnVuY3Rpb24gX2RlY2xhcmVEZWZhdWx0cygpIHtcblx0ICAgIF9CaXQucHJvdG90eXBlLl9kZWNsYXJlRGVmYXVsdHMuY2FsbCh0aGlzKTtcblx0ICAgIHRoaXMuX2RlZmF1bHRzLnRhZyA9ICdwYXRoJztcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gZHJhdyB0aGUgbW9kdWxlLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBvdmVycmlkZXMgQCBCaXRcblx0ICAqL1xuXG5cblx0ICBDdXJ2ZS5wcm90b3R5cGUuX2RyYXcgPSBmdW5jdGlvbiBfZHJhdygpIHtcblx0ICAgIF9CaXQucHJvdG90eXBlLl9kcmF3LmNhbGwodGhpcyk7XG5cdCAgICB2YXIgcCA9IHRoaXMuX3Byb3BzO1xuXG5cdCAgICB2YXIgcmFkaXVzWCA9IHAucmFkaXVzWCAhPSBudWxsID8gcC5yYWRpdXNYIDogcC5yYWRpdXM7XG5cdCAgICB2YXIgcmFkaXVzWSA9IHAucmFkaXVzWSAhPSBudWxsID8gcC5yYWRpdXNZIDogcC5yYWRpdXM7XG5cblx0ICAgIHZhciBpc1JhZGl1c1ggPSByYWRpdXNYID09PSB0aGlzLl9wcmV2UmFkaXVzWDtcblx0ICAgIHZhciBpc1JhZGl1c1kgPSByYWRpdXNZID09PSB0aGlzLl9wcmV2UmFkaXVzWTtcblx0ICAgIHZhciBpc1BvaW50cyA9IHAucG9pbnRzID09PSB0aGlzLl9wcmV2UG9pbnRzO1xuXHQgICAgLy8gc2tpcCBpZiBub3RoaW5nIGNoYW5nZWRcblx0ICAgIGlmIChpc1JhZGl1c1ggJiYgaXNSYWRpdXNZICYmIGlzUG9pbnRzKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgdmFyIHggPSBwLndpZHRoIC8gMjtcblx0ICAgIHZhciB5ID0gcC5oZWlnaHQgLyAyO1xuXHQgICAgdmFyIHgxID0geCAtIHJhZGl1c1g7XG5cdCAgICB2YXIgeDIgPSB4ICsgcmFkaXVzWDtcblxuXHQgICAgdmFyIGQgPSAnTScgKyB4MSArICcgJyArIHkgKyAnIFEgJyArIHggKyAnICcgKyAoeSAtIDIgKiByYWRpdXNZKSArICcgJyArIHgyICsgJyAnICsgeTtcblxuXHQgICAgLy8gc2V0IHRoZSBgZGAgYXR0cmlidXRlIGFuZCBzYXZlIGl0IHRvIGBfcHJldkRgXG5cdCAgICB0aGlzLmVsLnNldEF0dHJpYnV0ZSgnZCcsIGQpO1xuXHQgICAgLy8gc2F2ZSB0aGUgcHJvcGVydGllc1xuXHQgICAgdGhpcy5fcHJldlBvaW50cyA9IHAucG9pbnRzO1xuXHQgICAgdGhpcy5fcHJldlJhZGl1c1ggPSByYWRpdXNYO1xuXHQgICAgdGhpcy5fcHJldlJhZGl1c1kgPSByYWRpdXNZO1xuXHQgIH07XG5cblx0ICBDdXJ2ZS5wcm90b3R5cGUuX2dldExlbmd0aCA9IGZ1bmN0aW9uIF9nZXRMZW5ndGgoKSB7XG5cdCAgICB2YXIgcCA9IHRoaXMuX3Byb3BzO1xuXG5cdCAgICB2YXIgcmFkaXVzWCA9IHAucmFkaXVzWCAhPSBudWxsID8gcC5yYWRpdXNYIDogcC5yYWRpdXM7XG5cdCAgICB2YXIgcmFkaXVzWSA9IHAucmFkaXVzWSAhPSBudWxsID8gcC5yYWRpdXNZIDogcC5yYWRpdXM7XG5cblx0ICAgIHZhciBkUmFkaXVzID0gcmFkaXVzWCArIHJhZGl1c1k7XG5cdCAgICB2YXIgc3FydCA9IE1hdGguc3FydCgoMyAqIHJhZGl1c1ggKyByYWRpdXNZKSAqIChyYWRpdXNYICsgMyAqIHJhZGl1c1kpKTtcblxuXHQgICAgcmV0dXJuIC41ICogTWF0aC5QSSAqICgzICogZFJhZGl1cyAtIHNxcnQpO1xuXHQgIH07XG5cblx0ICByZXR1cm4gQ3VydmU7XG5cdH0oX2JpdDIuZGVmYXVsdCk7IC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG5cblxuXHRleHBvcnRzLmRlZmF1bHQgPSBDdXJ2ZTtcblxuLyoqKi8gfSksXG4vKiA5MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFxuXHQvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXHR2YXIgQml0LCBFcXVhbCxcblx0ICBleHRlbmQgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG5cdCAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5cdEJpdCA9IF9fd2VicGFja19yZXF1aXJlX18oNzMpW1wiZGVmYXVsdFwiXSB8fCBfX3dlYnBhY2tfcmVxdWlyZV9fKDczKTtcblxuXHRFcXVhbCA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG5cdCAgZXh0ZW5kKEVxdWFsLCBzdXBlckNsYXNzKTtcblxuXHQgIGZ1bmN0aW9uIEVxdWFsKCkge1xuXHQgICAgcmV0dXJuIEVxdWFsLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgIH1cblxuXHQgIEVxdWFsLnByb3RvdHlwZS5fZGVjbGFyZURlZmF1bHRzID0gZnVuY3Rpb24oKSB7XG5cdCAgICBFcXVhbC5fX3N1cGVyX18uX2RlY2xhcmVEZWZhdWx0cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgdGhpcy5fZGVmYXVsdHMudGFnID0gJ3BhdGgnO1xuXHQgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRzLnBvaW50cyA9IDI7XG5cdCAgfTtcblxuXHQgIEVxdWFsLnByb3RvdHlwZS5fZHJhdyA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIGQsIGksIGlzUG9pbnRzLCBpc1JhZGl1c1gsIGlzUmFkaXVzWSwgaiwgcCwgcmFkaXVzWCwgcmFkaXVzWSwgcmVmLCB4LCB4MSwgeDIsIHksIHlTdGFydCwgeVN0ZXA7XG5cdCAgICBFcXVhbC5fX3N1cGVyX18uX2RyYXcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgIHAgPSB0aGlzLl9wcm9wcztcblx0ICAgIGlmICghdGhpcy5fcHJvcHMucG9pbnRzKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIHJhZGl1c1ggPSB0aGlzLl9wcm9wcy5yYWRpdXNYICE9IG51bGwgPyB0aGlzLl9wcm9wcy5yYWRpdXNYIDogdGhpcy5fcHJvcHMucmFkaXVzO1xuXHQgICAgcmFkaXVzWSA9IHRoaXMuX3Byb3BzLnJhZGl1c1kgIT0gbnVsbCA/IHRoaXMuX3Byb3BzLnJhZGl1c1kgOiB0aGlzLl9wcm9wcy5yYWRpdXM7XG5cdCAgICBpc1JhZGl1c1ggPSByYWRpdXNYID09PSB0aGlzLl9wcmV2UmFkaXVzWDtcblx0ICAgIGlzUmFkaXVzWSA9IHJhZGl1c1kgPT09IHRoaXMuX3ByZXZSYWRpdXNZO1xuXHQgICAgaXNQb2ludHMgPSBwLnBvaW50cyA9PT0gdGhpcy5fcHJldlBvaW50cztcblx0ICAgIGlmIChpc1JhZGl1c1ggJiYgaXNSYWRpdXNZICYmIGlzUG9pbnRzKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIHggPSB0aGlzLl9wcm9wcy53aWR0aCAvIDI7XG5cdCAgICB5ID0gdGhpcy5fcHJvcHMuaGVpZ2h0IC8gMjtcblx0ICAgIHgxID0geCAtIHJhZGl1c1g7XG5cdCAgICB4MiA9IHggKyByYWRpdXNYO1xuXHQgICAgZCA9ICcnO1xuXHQgICAgeVN0ZXAgPSAyICogcmFkaXVzWSAvICh0aGlzLl9wcm9wcy5wb2ludHMgLSAxKTtcblx0ICAgIHlTdGFydCA9IHkgLSByYWRpdXNZO1xuXHQgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IHRoaXMuX3Byb3BzLnBvaW50czsgMCA8PSByZWYgPyBqIDwgcmVmIDogaiA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytqIDogLS1qKSB7XG5cdCAgICAgIHkgPSBcIlwiICsgKGkgKiB5U3RlcCArIHlTdGFydCk7XG5cdCAgICAgIGQgKz0gXCJNXCIgKyB4MSArIFwiLCBcIiArIHkgKyBcIiBMXCIgKyB4MiArIFwiLCBcIiArIHkgKyBcIiBcIjtcblx0ICAgIH1cblx0ICAgIHRoaXMuZWwuc2V0QXR0cmlidXRlKCdkJywgZCk7XG5cdCAgICB0aGlzLl9wcmV2UG9pbnRzID0gcC5wb2ludHM7XG5cdCAgICB0aGlzLl9wcmV2UmFkaXVzWCA9IHJhZGl1c1g7XG5cdCAgICByZXR1cm4gdGhpcy5fcHJldlJhZGl1c1kgPSByYWRpdXNZO1xuXHQgIH07XG5cblx0ICBFcXVhbC5wcm90b3R5cGUuX2dldExlbmd0aCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgcmV0dXJuIDIgKiAodGhpcy5fcHJvcHMucmFkaXVzWCAhPSBudWxsID8gdGhpcy5fcHJvcHMucmFkaXVzWCA6IHRoaXMuX3Byb3BzLnJhZGl1cyk7XG5cdCAgfTtcblxuXHQgIHJldHVybiBFcXVhbDtcblxuXHR9KShCaXQpO1xuXG5cdG1vZHVsZS5leHBvcnRzID0gRXF1YWw7XG5cblxuLyoqKi8gfSksXG4vKiA5NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5cdHZhciBfa2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oOTUpO1xuXG5cdHZhciBfa2V5czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9rZXlzKTtcblxuXHR2YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oNzQpO1xuXG5cdHZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxuXHR2YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NSk7XG5cblx0dmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yKTtcblxuXHR2YXIgX2luaGVyaXRzMiA9IF9fd2VicGFja19yZXF1aXJlX18oNzYpO1xuXG5cdHZhciBfaW5oZXJpdHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5oZXJpdHMyKTtcblxuXHR2YXIgX21vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oODQpO1xuXG5cdHZhciBfbW9kdWxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21vZHVsZSk7XG5cblx0dmFyIF90aGVuYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oOTkpO1xuXG5cdHZhciBfdGhlbmFibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGhlbmFibGUpO1xuXG5cdHZhciBfdHVuYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTE2KTtcblxuXHR2YXIgX3R1bmFibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHVuYWJsZSk7XG5cblx0dmFyIF90d2VlbmFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwMCk7XG5cblx0dmFyIF90d2VlbmFibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHdlZW5hYmxlKTtcblxuXHR2YXIgX3R3ZWVuID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDEpO1xuXG5cdHZhciBfdHdlZW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHdlZW4pO1xuXG5cdHZhciBfdGltZWxpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExMCk7XG5cblx0dmFyIF90aW1lbGluZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90aW1lbGluZSk7XG5cblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuXHR2YXIgaCA9IF9fd2VicGFja19yZXF1aXJlX18oNzEpO1xuXHR2YXIgQml0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Myk7XG5cdHZhciBzaGFwZXNNYXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcyKTtcblxuXHQvLyBUT0RPXG5cdC8vICAtIHJlZmFjdG9yXG5cdC8vICAgIC0gYWRkIHNldElmQ2hhbmdlZCB0byBNb2R1bGVcblx0Ly8gIC0tXG5cdC8vICAtIHR3ZWVuIGZvciBldmVyeSBwcm9wXG5cblx0dmFyIFNoYXBlID0gZnVuY3Rpb24gKF9UdW5hYmxlKSB7XG5cdCAgKDAsIF9pbmhlcml0czMuZGVmYXVsdCkoU2hhcGUsIF9UdW5hYmxlKTtcblxuXHQgIGZ1bmN0aW9uIFNoYXBlKCkge1xuXHQgICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgU2hhcGUpO1xuXHQgICAgcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMuZGVmYXVsdCkodGhpcywgX1R1bmFibGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG5cdCAgfVxuXG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBkZWNsYXJlIG1vZHVsZSdzIGRlZmF1bHRzLlxuXHQgICAgQHByaXZhdGVcblx0ICAqL1xuXHQgIFNoYXBlLnByb3RvdHlwZS5fZGVjbGFyZURlZmF1bHRzID0gZnVuY3Rpb24gX2RlY2xhcmVEZWZhdWx0cygpIHtcblx0ICAgIC8vIERFRkFVTFRTIC8gQVBJc1xuXHQgICAgdGhpcy5fZGVmYXVsdHMgPSB7XG5cdCAgICAgIC8vIHdoZXJlIHRvIGFwcGVuZCB0aGUgbW9kdWxlIHRvIFtzZWxlY3RvciwgSFRNTEVsZW1lbnRdXG5cdCAgICAgIHBhcmVudDogZG9jdW1lbnQuYm9keSxcblx0ICAgICAgLy8gY2xhc3MgbmFtZSBmb3IgdGhlIGBlbGBcblx0ICAgICAgY2xhc3NOYW1lOiAnJyxcblx0ICAgICAgLy8gUG9zc2libGUgdmFsdWVzOiBbY2lyY2xlLCBsaW5lLCB6aWd6YWcsIHJlY3QsIHBvbHlnb24sIGNyb3NzLCBlcXVhbCBdXG5cdCAgICAgIHNoYXBlOiAnY2lyY2xlJyxcblx0ICAgICAgLy8g4oiGIDo6IFBvc3NpYmxlIHZhbHVlczogW2NvbG9yIG5hbWUsIHJnYiwgcmdiYSwgaGV4XVxuXHQgICAgICBzdHJva2U6ICd0cmFuc3BhcmVudCcsXG5cdCAgICAgIC8vIOKIhiA6OiBQb3NzaWJsZSB2YWx1ZXM6IFsgMC4uMSBdXG5cdCAgICAgIHN0cm9rZU9wYWNpdHk6IDEsXG5cdCAgICAgIC8vIFBvc3NpYmxlIHZhbHVlczogWydidXR0JyB8ICdyb3VuZCcgfCAnc3F1YXJlJ11cblx0ICAgICAgc3Ryb2tlTGluZWNhcDogJycsXG5cdCAgICAgIC8vIOKIhiA6OiBQb3NzaWJsZSB2YWx1ZXM6IFsgbnVtYmVyIF1cblx0ICAgICAgc3Ryb2tlV2lkdGg6IDIsXG5cdCAgICAgIC8vIOKIhiA6OiBVbml0cyA6OiBQb3NzaWJsZSB2YWx1ZXM6IFsgbnVtYmVyLCBzdHJpbmcgXVxuXHQgICAgICBzdHJva2VEYXNoYXJyYXk6IDAsXG5cdCAgICAgIC8vIOKIhiA6OiBVbml0cyA6OiBQb3NzaWJsZSB2YWx1ZXM6IFsgbnVtYmVyLCBzdHJpbmcgXVxuXHQgICAgICBzdHJva2VEYXNob2Zmc2V0OiAwLFxuXHQgICAgICAvLyDiiIYgOjogUG9zc2libGUgdmFsdWVzOiBbY29sb3IgbmFtZSwgcmdiLCByZ2JhLCBoZXhdXG5cdCAgICAgIGZpbGw6ICdkZWVwcGluaycsXG5cdCAgICAgIC8vIOKIhiA6OiBQb3NzaWJsZSB2YWx1ZXM6IFsgMC4uMSBdXG5cdCAgICAgIGZpbGxPcGFjaXR5OiAxLFxuXHQgICAgICAvLyB7Qm9vbGVhbn0gLSBpZiBzaG91bGQgaGlkZSBtb2R1bGUgd2l0aCBgb3BhY2l0eWAgaW5zdGVhZCBvZiBgZGlzcGxheWBcblx0ICAgICAgaXNTb2Z0SGlkZTogdHJ1ZSxcblx0ICAgICAgLy8ge0Jvb2xlYW59IC0gaWYgc2hvdWxkIHRyaWdnZXIgY29tcG9zaXRlIGxheWVyIGZvciB0aGUgYGVsYFxuXHQgICAgICBpc0ZvcmNlM2Q6IGZhbHNlLFxuXHQgICAgICAvLyDiiIYgOjogVW5pdHMgOjogUG9zc2libGUgdmFsdWVzOiBbIG51bWJlciwgc3RyaW5nIF1cblx0ICAgICAgbGVmdDogJzUwJScsXG5cdCAgICAgIC8vIOKIhiA6OiBVbml0cyA6OiBQb3NzaWJsZSB2YWx1ZXM6IFsgbnVtYmVyLCBzdHJpbmcgXVxuXHQgICAgICB0b3A6ICc1MCUnLFxuXHQgICAgICAvLyDiiIYgOjogVW5pdHMgOjogUG9zc2libGUgdmFsdWVzOiBbIG51bWJlciwgc3RyaW5nIF1cblx0ICAgICAgeDogMCxcblx0ICAgICAgLy8g4oiGIDo6IFVuaXRzIDo6IFBvc3NpYmxlIHZhbHVlczogWyBudW1iZXIsIHN0cmluZyBdXG5cdCAgICAgIHk6IDAsXG5cdCAgICAgIC8vIOKIhiA6OiBQb3NzaWJsZSB2YWx1ZXM6IFsgbnVtYmVyIF1cblx0ICAgICAgYW5nbGU6IDAsXG5cdCAgICAgIC8vIOKIhiA6OiBQb3NzaWJsZSB2YWx1ZXM6IFsgbnVtYmVyIF1cblx0ICAgICAgc2NhbGU6IDEsXG5cdCAgICAgIC8vIOKIhiA6OiBQb3NzaWJsZSB2YWx1ZXM6IFsgbnVtYmVyIF0gRmFsbGJhY2tzIHRvIGBzY2FsZWAuXG5cdCAgICAgIHNjYWxlWDogbnVsbCxcblx0ICAgICAgLy8g4oiGIDo6IFBvc3NpYmxlIHZhbHVlczogWyBudW1iZXIgXSBGYWxsYmFja3MgdG8gYHNjYWxlYC5cblx0ICAgICAgc2NhbGVZOiBudWxsLFxuXHQgICAgICAvLyDiiIYgOjogUG9zc2libGUgdmFsdWVzOiBbIG51bWJlciwgc3RyaW5nIF1cblx0ICAgICAgb3JpZ2luOiAnNTAlIDUwJScsXG5cdCAgICAgIC8vIOKIhiA6OiBQb3NzaWJsZSB2YWx1ZXM6IFsgMC4uMSBdXG5cdCAgICAgIG9wYWNpdHk6IDEsXG5cdCAgICAgIC8vIOKIhiA6OiBVbml0cyA6OiBQb3NzaWJsZSB2YWx1ZXM6IFsgbnVtYmVyLCBzdHJpbmcgXVxuXHQgICAgICByeDogMCxcblx0ICAgICAgLy8g4oiGIDo6IFVuaXRzIDo6IFBvc3NpYmxlIHZhbHVlczogWyBudW1iZXIsIHN0cmluZyBdXG5cdCAgICAgIHJ5OiAwLFxuXHQgICAgICAvLyDiiIYgOjogUG9zc2libGUgdmFsdWVzOiBbIG51bWJlciBdXG5cdCAgICAgIHBvaW50czogMyxcblx0ICAgICAgLy8g4oiGIDo6IFBvc3NpYmxlIHZhbHVlczogWyBudW1iZXIgXVxuXHQgICAgICByYWRpdXM6IDUwLFxuXHQgICAgICAvLyDiiIYgOjogUG9zc2libGUgdmFsdWVzOiBbIG51bWJlciBdXG5cdCAgICAgIHJhZGl1c1g6IG51bGwsXG5cdCAgICAgIC8vIOKIhiA6OiBQb3NzaWJsZSB2YWx1ZXM6IFsgbnVtYmVyIF1cblx0ICAgICAgcmFkaXVzWTogbnVsbCxcblx0ICAgICAgLy8gUG9zc2libGUgdmFsdWVzOiBbIGJvb2xlYW4gXVxuXHQgICAgICBpc1Nob3dTdGFydDogZmFsc2UsXG5cdCAgICAgIC8vIFBvc3NpYmxlIHZhbHVlczogWyBib29sZWFuIF1cblx0ICAgICAgaXNTaG93RW5kOiB0cnVlLFxuXHQgICAgICAvLyBQb3NzaWJsZSB2YWx1ZXM6IFsgYm9vbGVhbiBdXG5cdCAgICAgIGlzUmVmcmVzaFN0YXRlOiB0cnVlLFxuXHQgICAgICAvLyBQb3NzaWJsZSB2YWx1ZXM6IFsgbnVtYmVyID4gMCBdXG5cdCAgICAgIGR1cmF0aW9uOiA0MDAsXG5cdCAgICAgIC8vIFBvc3NpYmxlIHZhbHVlczogWyBudW1iZXIgXVxuXG5cdCAgICAgIC8qIHRlY2huaWNhbCBvbmVzOiAqL1xuXHQgICAgICAvLyBleHBsaWNpdCB3aWR0aCBvZiB0aGUgbW9kdWxlIGNhbnZhc1xuXHQgICAgICB3aWR0aDogbnVsbCxcblx0ICAgICAgLy8gZXhwbGljaXQgaGVpZ2h0IG9mIHRoZSBtb2R1bGUgY2FudmFzXG5cdCAgICAgIGhlaWdodDogbnVsbCxcblx0ICAgICAgLy8gUG9zc2libGUgdmFsdWVzOiBbIG51bWJlciBdXG5cdCAgICAgIC8vIHNpemVHYXA6ICAgICAgICAgIDAsXG5cdCAgICAgIC8qIFtib29sZWFuXSA6OiBJZiBzaG91bGQgaGF2ZSBjaGlsZCBzaGFwZS4gKi9cblx0ICAgICAgaXNXaXRoU2hhcGU6IHRydWUsXG5cdCAgICAgIC8vIGNvbnRleHQgZm9yIGFsbCB0aGUgY2FsbGJhY2tzXG5cdCAgICAgIGNhbGxiYWNrc0NvbnRleHQ6IHRoaXNcblx0ICAgIH07XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHN0YXJ0IHRoZSBhbmltYXRpb24gd2l0aCBvcHRpb25hbCBuZXcgb3B0aW9ucy5cblx0ICAgIEBwdWJsaWNcblx0ICAgIEBvdmVycmlkZXMgQCBUdW5hYmxlXG5cdCAgICBAcGFyYW0ge09iamVjdH0gTmV3IG9wdGlvbnMgdG8gc2V0IG9uIHRoZSBydW4uXG5cdCAgICBAcmV0dXJucyB7T2JqZWN0fSB0aGlzLlxuXHQgICovXG5cblxuXHQgIFNoYXBlLnByb3RvdHlwZS50dW5lID0gZnVuY3Rpb24gdHVuZShvKSB7XG5cdCAgICBfVHVuYWJsZS5wcm90b3R5cGUudHVuZS5jYWxsKHRoaXMsIG8pO1xuXHQgICAgLy8gdXBkYXRlIHNoYXBlTW9kdWxlJ3Mgc2l6ZSB0byB0aGUgbWF4IGluIGB0aGVuYCBjaGFpblxuXHQgICAgdGhpcy5fZ2V0TWF4U2l6ZUluQ2hhaW4oKTtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBjcmVhdGUgYSB0aGVuIHJlY29yZCBmb3IgdGhlIG1vZHVsZS5cblx0ICAgIEBwdWJsaWNcblx0ICAgIEBvdmVycmlkZXMgQCBUaGVuYWJsZVxuXHQgICAgQHBhcmFtICAgIHtPYmplY3R9IE9wdGlvbnMgZm9yIHRoZSBuZXh0IGFuaW1hdGlvbi5cblx0ICAgIEByZXR1cm5zICB7T2JqZWN0fSB0aGlzLlxuXHQgICovXG5cblxuXHQgIFNoYXBlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gdGhlbihvKSB7XG5cdCAgICAvLyB0aGlzLl9tYWtlVGltZWxpbmUoKVxuXHQgICAgX1R1bmFibGUucHJvdG90eXBlLnRoZW4uY2FsbCh0aGlzLCBvKTtcblx0ICAgIC8vIHVwZGF0ZSBzaGFwZU1vZHVsZSdzIHNpemUgdG8gdGhlIG1heCBpbiBgdGhlbmAgY2hhaW5cblx0ICAgIHRoaXMuX2dldE1heFNpemVJbkNoYWluKCk7XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXG5cdCAgLy8gXiBQVUJMSUMgIE1FVEhPRChTKSBeXG5cdCAgLy8gdiBQUklWQVRFIE1FVEhPRChTKSB2XG5cblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGRlY2xhcmUgdmFyaWFibGVzLlxuXHQgICAgQG92ZXJyaWRlcyBUaGVuYWJsZVxuXHQgICovXG5cblxuXHQgIFNoYXBlLnByb3RvdHlwZS5fdmFycyA9IGZ1bmN0aW9uIF92YXJzKCkge1xuXHQgICAgLy8gY2FsbCBfdmFycyBtZXRob2Qgb24gVGhlbmFibGVcblx0ICAgIF9UdW5hYmxlLnByb3RvdHlwZS5fdmFycy5jYWxsKHRoaXMpO1xuXHQgICAgdGhpcy5fbGFzdFNldCA9IHt9O1xuXHQgICAgLy8gc2F2ZSBwcmV2aW91cyBtb2R1bGUgaW4gdGhlIGNoYWluXG5cdCAgICB0aGlzLl9wcmV2Q2hhaW5Nb2R1bGUgPSB0aGlzLl9vLnByZXZDaGFpbk1vZHVsZTtcblx0ICAgIC8vIHNob3VsZCBkcmF3IG9uIGZvcmVpZ24gc3ZnIGNhbnZhc1xuXHQgICAgdGhpcy5pc0ZvcmVpZ24gPSAhIXRoaXMuX28uY3R4O1xuXHQgICAgLy8gdGhpcy5fby5pc1RpbWVsaW5lTGVzcyA9IHRydWU7XG5cdCAgICAvLyBzaG91bGQgdGFrZSBhbiBzdmcgZWxlbWVudCBhcyBzZWxmIGJpdFxuXHQgICAgcmV0dXJuIHRoaXMuaXNGb3JlaWduQml0ID0gISF0aGlzLl9vLnNoYXBlO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBpbml0aWFsaXplIG1vZHVsZXMgcHJlc2VudGF0aW9uLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBvdmVycmlkZXMgTW9kdWxlXG5cdCAgKi9cblxuXG5cdCAgU2hhcGUucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiBfcmVuZGVyKCkge1xuXHQgICAgaWYgKCF0aGlzLl9pc1JlbmRlcmVkICYmICF0aGlzLl9pc0NoYWluZWQpIHtcblx0ICAgICAgLy8gY3JlYXRlIGBtb2pzYCBzaGFwZSBlbGVtZW50XG5cdCAgICAgIHRoaXMuZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0ICAgICAgLy8gc2V0IG5hbWUgb24gdGhlIGBlbGBcblx0ICAgICAgdGhpcy5lbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtbmFtZScsICdtb2pzLXNoYXBlJyk7XG5cdCAgICAgIC8vIHNldCBjbGFzcyBvbiB0aGUgYGVsYFxuXHQgICAgICB0aGlzLmVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCB0aGlzLl9wcm9wcy5jbGFzc05hbWUpO1xuXHQgICAgICAvLyBjcmVhdGUgc2hhcGUgbW9kdWxlXG5cdCAgICAgIHRoaXMuX2NyZWF0ZVNoYXBlKCk7XG5cdCAgICAgIC8vIGFwcGVuZCBgZWxgIHRvIHBhcmVudFxuXHQgICAgICB0aGlzLl9wcm9wcy5wYXJlbnQuYXBwZW5kQ2hpbGQodGhpcy5lbCk7XG5cdCAgICAgIC8vIHNldCBwb3NpdGlvbiBzdHlsZXMgb24gdGhlIGVsXG5cdCAgICAgIHRoaXMuX3NldEVsU3R5bGVzKCk7XG5cdCAgICAgIC8vIHNldCBpbml0aWFsIHBvc2l0aW9uIGZvciB0aGUgZmlyc3QgbW9kdWxlIGluIHRoZSBjaGFpblxuXHQgICAgICB0aGlzLl9zZXRQcm9ncmVzcygwLCAwKTtcblx0ICAgICAgLy8gc2hvdyBhdCBzdGFydCBpZiBgaXNTaG93U3RhcnRgXG5cdCAgICAgIGlmICh0aGlzLl9wcm9wcy5pc1Nob3dTdGFydCkge1xuXHQgICAgICAgIHRoaXMuX3Nob3coKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB0aGlzLl9oaWRlKCk7XG5cdCAgICAgIH1cblx0ICAgICAgLy8gc2V0IGBfaXNSZW5kZXJlZGAgaGF0Y2hcblx0ICAgICAgdGhpcy5faXNSZW5kZXJlZCA9IHRydWU7XG5cdCAgICB9IGVsc2UgaWYgKHRoaXMuX2lzQ2hhaW5lZCkge1xuXHQgICAgICAvLyBzYXZlIGVsZW1lbnRzIGZyb20gbWFzdGVyIG1vZHVsZVxuXHQgICAgICB0aGlzLmVsID0gdGhpcy5fbWFzdGVyTW9kdWxlLmVsO1xuXHQgICAgICB0aGlzLnNoYXBlTW9kdWxlID0gdGhpcy5fbWFzdGVyTW9kdWxlLnNoYXBlTW9kdWxlO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gc2V0IGVsIHN0eWxlcyBvbiBpbml0aWFsaXphdGlvbi5cblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblxuXG5cdCAgU2hhcGUucHJvdG90eXBlLl9zZXRFbFN0eWxlcyA9IGZ1bmN0aW9uIF9zZXRFbFN0eWxlcygpIHtcblx0ICAgIGlmICghdGhpcy5lbCkge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICAvLyBpZiAoIXRoaXMuaXNGb3JlaWduKSB7XG5cdCAgICB2YXIgcCA9IHRoaXMuX3Byb3BzLFxuXHQgICAgICAgIHN0eWxlID0gdGhpcy5lbC5zdHlsZSxcblx0ICAgICAgICB3aWR0aCA9IHAuc2hhcGVXaWR0aCxcblx0ICAgICAgICBoZWlnaHQgPSBwLnNoYXBlSGVpZ2h0O1xuXG5cdCAgICBzdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG5cdCAgICB0aGlzLl9zZXRFbFNpemVTdHlsZXMod2lkdGgsIGhlaWdodCk7XG5cblx0ICAgIGlmIChwLmlzRm9yY2UzZCkge1xuXHQgICAgICB2YXIgbmFtZSA9ICdiYWNrZmFjZS12aXNpYmlsaXR5Jztcblx0ICAgICAgc3R5bGVbJycgKyBuYW1lXSA9ICdoaWRkZW4nO1xuXHQgICAgICBzdHlsZVsnJyArIGgucHJlZml4LmNzcyArIG5hbWVdID0gJ2hpZGRlbic7XG5cdCAgICB9XG5cdCAgICAvLyB9XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHNldCBgd2lkdGhgL2BoZWlnaHRgL2BtYXJnaW5zYCB0byB0aGUgYGVsYCBzdHlsZXMuXG5cdCAgICBAcGFyYW0ge051bWJlcn0gV2lkdGguXG5cdCAgICBAcGFyYW0ge2hlaWdodH0gSGVpZ2h0LlxuXHQgICovXG5cblxuXHQgIFNoYXBlLnByb3RvdHlwZS5fc2V0RWxTaXplU3R5bGVzID0gZnVuY3Rpb24gX3NldEVsU2l6ZVN0eWxlcyh3aWR0aCwgaGVpZ2h0KSB7XG5cdCAgICB2YXIgc3R5bGUgPSB0aGlzLmVsLnN0eWxlO1xuXHQgICAgc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG5cdCAgICBzdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuXHQgICAgc3R5bGVbJ21hcmdpbi1sZWZ0J10gPSAtd2lkdGggLyAyICsgJ3B4Jztcblx0ICAgIHN0eWxlWydtYXJnaW4tdG9wJ10gPSAtaGVpZ2h0IC8gMiArICdweCc7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGRyYXcgc2hhcGUuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIFNoYXBlLnByb3RvdHlwZS5fZHJhdyA9IGZ1bmN0aW9uIF9kcmF3KCkge1xuXHQgICAgaWYgKCF0aGlzLnNoYXBlTW9kdWxlKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgdmFyIHAgPSB0aGlzLl9wcm9wcyxcblx0ICAgICAgICBiUCA9IHRoaXMuc2hhcGVNb2R1bGUuX3Byb3BzO1xuXHQgICAgLy8gc2V0IHByb3BzIG9uIGJpdFxuXHQgICAgLy8gYlAueCAgICAgICAgICAgICAgICAgICAgPSB0aGlzLl9vcmlnaW4ueDtcblx0ICAgIC8vIGJQLnkgICAgICAgICAgICAgICAgICAgID0gdGhpcy5fb3JpZ2luLnk7XG5cdCAgICBiUC5yeCA9IHAucng7XG5cdCAgICBiUC5yeSA9IHAucnk7XG5cdCAgICBiUC5zdHJva2UgPSBwLnN0cm9rZTtcblx0ICAgIGJQWydzdHJva2Utd2lkdGgnXSA9IHAuc3Ryb2tlV2lkdGg7XG5cdCAgICBiUFsnc3Ryb2tlLW9wYWNpdHknXSA9IHAuc3Ryb2tlT3BhY2l0eTtcblx0ICAgIGJQWydzdHJva2UtZGFzaGFycmF5J10gPSBwLnN0cm9rZURhc2hhcnJheTtcblx0ICAgIGJQWydzdHJva2UtZGFzaG9mZnNldCddID0gcC5zdHJva2VEYXNob2Zmc2V0O1xuXHQgICAgYlBbJ3N0cm9rZS1saW5lY2FwJ10gPSBwLnN0cm9rZUxpbmVjYXA7XG5cdCAgICBiUFsnZmlsbCddID0gcC5maWxsO1xuXHQgICAgYlBbJ2ZpbGwtb3BhY2l0eSddID0gcC5maWxsT3BhY2l0eTtcblx0ICAgIGJQLnJhZGl1cyA9IHAucmFkaXVzO1xuXHQgICAgYlAucmFkaXVzWCA9IHAucmFkaXVzWDtcblx0ICAgIGJQLnJhZGl1c1kgPSBwLnJhZGl1c1k7XG5cdCAgICBiUC5wb2ludHMgPSBwLnBvaW50cztcblxuXHQgICAgdGhpcy5zaGFwZU1vZHVsZS5fZHJhdygpO1xuXHQgICAgdGhpcy5fZHJhd0VsKCk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHNldCBjdXJyZW50IG1vZHVsZXMgcHJvcHMgdG8gbWFpbiBkaXYgZWwuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIFNoYXBlLnByb3RvdHlwZS5fZHJhd0VsID0gZnVuY3Rpb24gX2RyYXdFbCgpIHtcblx0ICAgIC8vIHJldHVybjtcblx0ICAgIGlmICh0aGlzLmVsID09IG51bGwpIHtcblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cdCAgICB2YXIgcCA9IHRoaXMuX3Byb3BzO1xuXHQgICAgdmFyIHN0eWxlID0gdGhpcy5lbC5zdHlsZTtcblxuXHQgICAgLy8gc3R5bGUub3BhY2l0eSA9IHAub3BhY2l0eTtcblx0ICAgIHRoaXMuX2lzUHJvcENoYW5nZWQoJ29wYWNpdHknKSAmJiAoc3R5bGUub3BhY2l0eSA9IHAub3BhY2l0eSk7XG5cdCAgICBpZiAoIXRoaXMuaXNGb3JlaWduKSB7XG5cdCAgICAgIHRoaXMuX2lzUHJvcENoYW5nZWQoJ2xlZnQnKSAmJiAoc3R5bGUubGVmdCA9IHAubGVmdCk7XG5cdCAgICAgIHRoaXMuX2lzUHJvcENoYW5nZWQoJ3RvcCcpICYmIChzdHlsZS50b3AgPSBwLnRvcCk7XG5cblx0ICAgICAgdmFyIGlzWCA9IHRoaXMuX2lzUHJvcENoYW5nZWQoJ3gnKSxcblx0ICAgICAgICAgIGlzWSA9IHRoaXMuX2lzUHJvcENoYW5nZWQoJ3knKSxcblx0ICAgICAgICAgIGlzVHJhbnNsYXRlID0gaXNYIHx8IGlzWSxcblx0ICAgICAgICAgIGlzU2NhbGVYID0gdGhpcy5faXNQcm9wQ2hhbmdlZCgnc2NhbGVYJyksXG5cdCAgICAgICAgICBpc1NjYWxlWSA9IHRoaXMuX2lzUHJvcENoYW5nZWQoJ3NjYWxlWScpLFxuXHQgICAgICAgICAgaXNTY2FsZSA9IHRoaXMuX2lzUHJvcENoYW5nZWQoJ3NjYWxlJyksXG5cdCAgICAgICAgICBpc1NjYWxlID0gaXNTY2FsZSB8fCBpc1NjYWxlWCB8fCBpc1NjYWxlWSxcblx0ICAgICAgICAgIGlzUm90YXRlID0gdGhpcy5faXNQcm9wQ2hhbmdlZCgnYW5nbGUnKTtcblxuXHQgICAgICBpZiAoaXNUcmFuc2xhdGUgfHwgaXNTY2FsZSB8fCBpc1JvdGF0ZSkge1xuXHQgICAgICAgIHZhciB0cmFuc2Zvcm0gPSB0aGlzLl9maWxsVHJhbnNmb3JtKCk7XG5cdCAgICAgICAgc3R5bGVbaC5wcmVmaXguY3NzICsgJ3RyYW5zZm9ybSddID0gdHJhbnNmb3JtO1xuXHQgICAgICAgIHN0eWxlWyd0cmFuc2Zvcm0nXSA9IHRyYW5zZm9ybTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmICh0aGlzLl9pc1Byb3BDaGFuZ2VkKCdvcmlnaW4nKSB8fCB0aGlzLl9kZWx0YXNbJ29yaWdpbiddKSB7XG5cdCAgICAgICAgdmFyIG9yaWdpbiA9IHRoaXMuX2ZpbGxPcmlnaW4oKTtcblx0ICAgICAgICBzdHlsZVtoLnByZWZpeC5jc3MgKyAndHJhbnNmb3JtLW9yaWdpbiddID0gb3JpZ2luO1xuXHQgICAgICAgIHN0eWxlWyd0cmFuc2Zvcm0tb3JpZ2luJ10gPSBvcmlnaW47XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gY2hlY2sgaWYgcHJvcGVydHkgY2hhbmdlZCBhZnRlciB0aGUgbGF0ZXN0IGNoZWNrLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7U3RyaW5nfSBOYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBjaGVjay5cblx0ICAgIEByZXR1cm5zIHtCb29sZWFufVxuXHQgICovXG5cblxuXHQgIFNoYXBlLnByb3RvdHlwZS5faXNQcm9wQ2hhbmdlZCA9IGZ1bmN0aW9uIF9pc1Byb3BDaGFuZ2VkKG5hbWUpIHtcblx0ICAgIC8vIGlmIHRoZXJlIGlzIG5vIHJlY29kIGZvciB0aGUgcHJvcGVydHkgLSBjcmVhdGUgaXRcblx0ICAgIGlmICh0aGlzLl9sYXN0U2V0W25hbWVdID09IG51bGwpIHtcblx0ICAgICAgdGhpcy5fbGFzdFNldFtuYW1lXSA9IHt9O1xuXHQgICAgfVxuXHQgICAgaWYgKHRoaXMuX2xhc3RTZXRbbmFtZV0udmFsdWUgIT09IHRoaXMuX3Byb3BzW25hbWVdKSB7XG5cdCAgICAgIHRoaXMuX2xhc3RTZXRbbmFtZV0udmFsdWUgPSB0aGlzLl9wcm9wc1tuYW1lXTtcblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHR1bmUgbmV3IG9wdGlvbiBvbiBydW4uXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQG92ZXJyaWRlIEAgTW9kdWxlXG5cdCAgICBAcGFyYW0ge09iamVjdH0gIE9wdGlvbiB0byB0dW5lIG9uIHJ1bi5cblx0ICAqL1xuXG5cblx0ICBTaGFwZS5wcm90b3R5cGUuX3R1bmVOZXdPcHRpb25zID0gZnVuY3Rpb24gX3R1bmVOZXdPcHRpb25zKG8pIHtcblx0ICAgIC8vIGNhbGwgc3VwZXIgb24gTW9kdWxlXG5cdCAgICBfVHVuYWJsZS5wcm90b3R5cGUuX3R1bmVOZXdPcHRpb25zLmNhbGwodGhpcywgbyk7XG5cdCAgICAvLyByZXR1cm4gaWYgZW1wdHkgb2JqZWN0XG5cdCAgICBpZiAoIShvICE9IG51bGwgJiYgKDAsIF9rZXlzMi5kZWZhdWx0KShvKS5sZW5ndGgpKSB7XG5cdCAgICAgIHJldHVybiAxO1xuXHQgICAgfVxuXG5cdCAgICAvLyB0aGlzLl9jYWxjU2l6ZSgpO1xuXHQgICAgdGhpcy5fc2V0RWxTdHlsZXMoKTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gZ2V0IG1heCByYWRpdXNYIHZhbHVlLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7U3RyaW5nfSBSYWRpdXMgbmFtZS5cblx0ICAqL1xuXG5cblx0ICBTaGFwZS5wcm90b3R5cGUuX2dldE1heFJhZGl1cyA9IGZ1bmN0aW9uIF9nZXRNYXhSYWRpdXMobmFtZSkge1xuXHQgICAgdmFyIHNlbGZTaXplLCBzZWxmU2l6ZVg7XG5cdCAgICBzZWxmU2l6ZSA9IHRoaXMuX2dldFJhZGl1c1NpemUoJ3JhZGl1cycpO1xuXHQgICAgcmV0dXJuIHRoaXMuX2dldFJhZGl1c1NpemUobmFtZSwgc2VsZlNpemUpO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBpbmNyZWFzZSBjYWxjdWxhdGVkIHNpemUgYmFzZWQgb24gZWFzaW5nLlxuXHQgICAgQHByaXZhdGVcblx0ICAqL1xuXG5cblx0ICBTaGFwZS5wcm90b3R5cGUuX2luY3JlYXNlU2l6ZVdpdGhFYXNpbmcgPSBmdW5jdGlvbiBfaW5jcmVhc2VTaXplV2l0aEVhc2luZygpIHtcblx0ICAgIHZhciBwID0gdGhpcy5fcHJvcHMsXG5cdCAgICAgICAgZWFzaW5nID0gdGhpcy5fby5lYXNpbmcsXG5cdCAgICAgICAgaXNTdHJpbmdFYXNpbmcgPSBlYXNpbmcgJiYgdHlwZW9mIGVhc2luZyA9PT0gJ3N0cmluZyc7XG5cblx0ICAgIHN3aXRjaCAoaXNTdHJpbmdFYXNpbmcgJiYgZWFzaW5nLnRvTG93ZXJDYXNlKCkpIHtcblx0ICAgICAgY2FzZSAnZWxhc3RpYy5vdXQnOlxuXHQgICAgICBjYXNlICdlbGFzdGljLmlub3V0Jzpcblx0ICAgICAgICBwLnNpemUgKj0gMS4yNTtcblx0ICAgICAgICBicmVhaztcblx0ICAgICAgY2FzZSAnYmFjay5vdXQnOlxuXHQgICAgICBjYXNlICdiYWNrLmlub3V0Jzpcblx0ICAgICAgICBwLnNpemUgKj0gMS4xO1xuXHQgICAgfVxuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBpbmNyZWFzZSBjYWxjdWxhdGVkIHNpemUgYmFzZWQgb24gYml0IHJhdGlvLlxuXHQgICAgQHByaXZhdGVcblx0ICAqL1xuXHQgIC8vIF9pbmNyZWFzZVNpemVXaXRoQml0UmF0aW8gKCkge1xuXHQgIC8vICAgdmFyIHAgICA9IHRoaXMuX3Byb3BzO1xuXHQgIC8vICAgLy8gcC5zaXplICo9IHRoaXMuc2hhcGUuX3Byb3BzLnJhdGlvO1xuXHQgIC8vICAgcC5zaXplICs9IDIgKiBwLnNpemVHYXA7XG5cdCAgLy8gfVxuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gZ2V0IG1heGltdW0gcmFkaXVzIHNpemUgd2l0aCBvcHRpb25hbCBmYWxsYmFjay5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge09iamVjdH1cblx0ICAgICAgQHBhcmFtIGtleSB7U3RyaW5nfSBOYW1lIG9mIHRoZSByYWRpdXMgLSBbcmFkaXVzfHJhZGl1c1h8cmFkaXVzWV0uXG5cdCAgICAgIEBwYXJhbSBAb3B0aW9uYWwgZmFsbGJhY2sge051bWJlcn0gIE9wdGlvbmFsIG51bWJlciB0byBzZXQgaWYgdGhlcmVcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgbm8gdmFsdWUgZm9yIHRoZSBrZXkuXG5cdCAgKi9cblxuXG5cdCAgU2hhcGUucHJvdG90eXBlLl9nZXRSYWRpdXNTaXplID0gZnVuY3Rpb24gX2dldFJhZGl1c1NpemUobmFtZSkge1xuXHQgICAgdmFyIGZhbGxiYWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuXG5cdCAgICB2YXIgZGVsdGEgPSB0aGlzLl9kZWx0YXNbbmFtZV07XG5cdCAgICAvLyBpZiB2YWx1ZSBpcyBkZWx0YSB2YWx1ZVxuXHQgICAgaWYgKGRlbHRhICE9IG51bGwpIHtcblx0ICAgICAgLy8gZ2V0IG1heGltdW0gbnVtYmVyIGJldHdlZW4gc3RhcnQgYW5kIGVuZCB2YWx1ZXMgb2YgdGhlIGRlbHRhXG5cdCAgICAgIHJldHVybiBNYXRoLm1heChNYXRoLmFicyhkZWx0YS5lbmQpLCBNYXRoLmFicyhkZWx0YS5zdGFydCkpO1xuXHQgICAgfSBlbHNlIGlmICh0aGlzLl9wcm9wc1tuYW1lXSAhPSBudWxsKSB7XG5cdCAgICAgIC8vIGVsc2UgZ2V0IHRoZSB2YWx1ZSBmcm9tIHByb3BzIG9iamVjdFxuXHQgICAgICByZXR1cm4gcGFyc2VGbG9hdCh0aGlzLl9wcm9wc1tuYW1lXSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4gZmFsbGJhY2s7XG5cdCAgICB9XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGdldCBtYXggc2hhcGUgY2FudmFzIHNpemUgYW5kIHNhdmUgaXQgdG8gX3Byb3BzLlxuXHQgICAgQHByaXZhdGVcblx0ICAqL1xuXG5cblx0ICBTaGFwZS5wcm90b3R5cGUuX2dldFNoYXBlU2l6ZSA9IGZ1bmN0aW9uIF9nZXRTaGFwZVNpemUoKSB7XG5cdCAgICB2YXIgcCA9IHRoaXMuX3Byb3BzLFxuXG5cdCAgICAvLyBnZXQgbWF4aW11bSBzdHJva2UgdmFsdWVcblx0ICAgIHN0cm9rZSA9IHRoaXMuX2dldE1heFN0cm9rZSgpO1xuXHQgICAgLy8gc2F2ZSBzaGFwZSBgd2lkdGhgIGFuZCBgaGVpZ2h0YCB0byBgX3Byb3BzYFxuXHQgICAgcC5zaGFwZVdpZHRoID0gcC53aWR0aCAhPSBudWxsID8gcC53aWR0aCA6IDIgKiB0aGlzLl9nZXRNYXhSYWRpdXMoJ3JhZGl1c1gnKSArIHN0cm9rZTtcblxuXHQgICAgcC5zaGFwZUhlaWdodCA9IHAuaGVpZ2h0ICE9IG51bGwgPyBwLmhlaWdodCA6IDIgKiB0aGlzLl9nZXRNYXhSYWRpdXMoJ3JhZGl1c1knKSArIHN0cm9rZTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gY3JlYXRlIHNoYXBlLlxuXHQgICAgQHByaXZhdGVcblx0ICAqL1xuXG5cblx0ICBTaGFwZS5wcm90b3R5cGUuX2NyZWF0ZVNoYXBlID0gZnVuY3Rpb24gX2NyZWF0ZVNoYXBlKCkge1xuXHQgICAgLy8gY2FsY3VsYXRlIG1heCBzaGFwZSBjYW52YXMgc2l6ZSBhbmQgc2V0IHRvIF9wcm9wc1xuXHQgICAgdGhpcy5fZ2V0U2hhcGVTaXplKCk7XG5cdCAgICAvLyBkb24ndCBjcmVhdGUgYWN0dWFsIHNoYXBlIGlmICFgaXNXaXRoU2hhcGVgXG5cdCAgICBpZiAoIXRoaXMuX3Byb3BzLmlzV2l0aFNoYXBlKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgdmFyIHAgPSB0aGlzLl9wcm9wcztcblx0ICAgIC8vIGdldCBzaGFwZSdzIGNsYXNzXG5cdCAgICB2YXIgU2hhcGUgPSBzaGFwZXNNYXAuZ2V0U2hhcGUodGhpcy5fcHJvcHMuc2hhcGUpO1xuXHQgICAgLy8gY3JlYXRlIGBfc2hhcGVgIG1vZHVsZVxuXHQgICAgdGhpcy5zaGFwZU1vZHVsZSA9IG5ldyBTaGFwZSh7XG5cdCAgICAgIHdpZHRoOiBwLnNoYXBlV2lkdGgsXG5cdCAgICAgIGhlaWdodDogcC5zaGFwZUhlaWdodCxcblx0ICAgICAgcGFyZW50OiB0aGlzLmVsXG5cdCAgICB9KTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gZ2V0IG1heCBzaXplIGluIGB0aGVuYCBjaGFpblxuXHQgICAgQHByaXZhdGVcblx0ICAqL1xuXG5cblx0ICBTaGFwZS5wcm90b3R5cGUuX2dldE1heFNpemVJbkNoYWluID0gZnVuY3Rpb24gX2dldE1heFNpemVJbkNoYWluKCkge1xuXHQgICAgdmFyIHAgPSB0aGlzLl9wcm9wcyxcblx0ICAgICAgICBtYXhXID0gMCxcblx0ICAgICAgICBtYXhIID0gMDtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9tb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHRoaXMuX21vZHVsZXNbaV0uX2dldFNoYXBlU2l6ZSgpO1xuXHQgICAgICBtYXhXID0gTWF0aC5tYXgobWF4VywgdGhpcy5fbW9kdWxlc1tpXS5fcHJvcHMuc2hhcGVXaWR0aCk7XG5cdCAgICAgIG1heEggPSBNYXRoLm1heChtYXhILCB0aGlzLl9tb2R1bGVzW2ldLl9wcm9wcy5zaGFwZUhlaWdodCk7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuc2hhcGVNb2R1bGUgJiYgdGhpcy5zaGFwZU1vZHVsZS5fc2V0U2l6ZShtYXhXLCBtYXhIKTtcblx0ICAgIHRoaXMuX3NldEVsU2l6ZVN0eWxlcyhtYXhXLCBtYXhIKTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gZ2V0IG1heCB2YWx1ZSBvZiB0aGUgc3Ryb2tlV2lkdGguXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIFNoYXBlLnByb3RvdHlwZS5fZ2V0TWF4U3Ryb2tlID0gZnVuY3Rpb24gX2dldE1heFN0cm9rZSgpIHtcblx0ICAgIHZhciBwID0gdGhpcy5fcHJvcHM7XG5cdCAgICB2YXIgZFN0cm9rZSA9IHRoaXMuX2RlbHRhc1snc3Ryb2tlV2lkdGgnXTtcblx0ICAgIHJldHVybiBkU3Ryb2tlICE9IG51bGwgPyBNYXRoLm1heChkU3Ryb2tlLnN0YXJ0LCBkU3Ryb2tlLmVuZCkgOiBwLnN0cm9rZVdpZHRoO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBkcmF3IGN1cnJlbnQgcHJvZ3Jlc3Mgb2YgdGhlIGRlbHRhcy5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAb3ZlcnJpZGUgQCBNb2R1bGVcblx0ICAgIEBwYXJhbSAgIHtOdW1iZXJ9ICBFYXNlZFByb2dyZXNzIHRvIHNldCAtIFswLi4xXS5cblx0ICAgIEBwYXJhbSAgIHtOdW1iZXJ9ICBQcm9ncmVzcyB0byBzZXQgLSBbMC4uMV0uXG5cdCAgKi9cblxuXG5cdCAgU2hhcGUucHJvdG90eXBlLl9zZXRQcm9ncmVzcyA9IGZ1bmN0aW9uIF9zZXRQcm9ncmVzcyhlYXNlZFByb2dyZXNzLCBwcm9ncmVzcykge1xuXHQgICAgLy8gY2FsbCB0aGUgc3VwZXIgb24gTW9kdWxlXG5cdCAgICBfbW9kdWxlMi5kZWZhdWx0LnByb3RvdHlwZS5fc2V0UHJvZ3Jlc3MuY2FsbCh0aGlzLCBlYXNlZFByb2dyZXNzLCBwcm9ncmVzcyk7XG5cdCAgICAvLyBkcmF3IGN1cnJlbnQgcHJvZ3Jlc3Ncblx0ICAgIHRoaXMuX2RyYXcoZWFzZWRQcm9ncmVzcyk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGFkZCBjYWxsYmFjayBvdmVycmlkZXMgdG8gcGFzc2VkIG9iamVjdC5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge09iamVjdH0gT2JqZWN0IHRvIGFkZCB0aGUgb3ZlcnJpZGVzIHRvLlxuXHQgICovXG5cblxuXHQgIFNoYXBlLnByb3RvdHlwZS5fYXBwbHlDYWxsYmFja092ZXJyaWRlcyA9IGZ1bmN0aW9uIF9hcHBseUNhbGxiYWNrT3ZlcnJpZGVzKG9iaikge1xuXHQgICAgdmFyIGl0ID0gdGhpcyxcblx0ICAgICAgICBwID0gdGhpcy5fcHJvcHM7XG5cdCAgICAvLyBzcGVjaWZ5IGNvbnRyb2wgZnVuY3Rpb25zIGZvciB0aGUgbW9kdWxlXG5cdCAgICBvYmouY2FsbGJhY2tPdmVycmlkZXMgPSB7XG5cdCAgICAgIG9uVXBkYXRlOiBmdW5jdGlvbiBvblVwZGF0ZShlcCwgcCkge1xuXHQgICAgICAgIHJldHVybiBpdC5fc2V0UHJvZ3Jlc3MoZXAsIHApO1xuXHQgICAgICB9LFxuXHQgICAgICBvblN0YXJ0OiBmdW5jdGlvbiBvblN0YXJ0KGlzRndkKSB7XG5cdCAgICAgICAgLy8gZG9uJ3QgdG91Y2ggbWFpbiBgZWxgIG9uU3RhcnQgaW4gY2hhaW5lZCBlbGVtZW50c1xuXHQgICAgICAgIGlmIChpdC5faXNDaGFpbmVkKSB7XG5cdCAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBpZiAoaXNGd2QpIHtcblx0ICAgICAgICAgIGl0Ll9zaG93KCk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIGlmICghcC5pc1Nob3dTdGFydCkge1xuXHQgICAgICAgICAgICBpdC5faGlkZSgpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfSxcblx0ICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24gb25Db21wbGV0ZShpc0Z3ZCkge1xuXHQgICAgICAgIC8vIGRvbid0IHRvdWNoIG1haW4gYGVsYCBpZiBub3QgdGhlIGxhc3QgaW4gYHRoZW5gIGNoYWluXG5cdCAgICAgICAgaWYgKCFpdC5faXNMYXN0SW5DaGFpbigpKSB7XG5cdCAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChpc0Z3ZCkge1xuXHQgICAgICAgICAgaWYgKCFwLmlzU2hvd0VuZCkge1xuXHQgICAgICAgICAgICBpdC5faGlkZSgpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBpdC5fc2hvdygpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSxcblx0ICAgICAgb25SZWZyZXNoOiBmdW5jdGlvbiBvblJlZnJlc2goaXNCZWZvcmUpIHtcblx0ICAgICAgICBwLmlzUmVmcmVzaFN0YXRlICYmIGlzQmVmb3JlICYmIGl0Ll9yZWZyZXNoQmVmb3JlKCk7XG5cdCAgICAgIH1cblx0ICAgIH07XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHNldHVwIHR3ZWVuIGFuZCB0aW1lbGluZSBvcHRpb25zIGJlZm9yZSBjcmVhdGluZyB0aGVtLlxuXHQgICAgQG92ZXJyaWRlIEAgVHdlZW5hYmxlXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIFNoYXBlLnByb3RvdHlwZS5fdHJhbnNmb3JtVHdlZW5PcHRpb25zID0gZnVuY3Rpb24gX3RyYW5zZm9ybVR3ZWVuT3B0aW9ucygpIHtcblx0ICAgIHRoaXMuX2FwcGx5Q2FsbGJhY2tPdmVycmlkZXModGhpcy5fbyk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGNyZWF0ZSB0cmFuc2Zvcm0gc3RyaW5nLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEByZXR1cm5zIHtTdHJpbmd9IFRyYW5zZm9ybSBzdHJpbmcuXG5cdCAgKi9cblxuXG5cdCAgU2hhcGUucHJvdG90eXBlLl9maWxsVHJhbnNmb3JtID0gZnVuY3Rpb24gX2ZpbGxUcmFuc2Zvcm0oKSB7XG5cdCAgICB2YXIgcCA9IHRoaXMuX3Byb3BzLFxuXHQgICAgICAgIHNjYWxlWCA9IHAuc2NhbGVYICE9IG51bGwgPyBwLnNjYWxlWCA6IHAuc2NhbGUsXG5cdCAgICAgICAgc2NhbGVZID0gcC5zY2FsZVkgIT0gbnVsbCA/IHAuc2NhbGVZIDogcC5zY2FsZSxcblx0ICAgICAgICBzY2FsZSA9IHNjYWxlWCArICcsICcgKyBzY2FsZVk7XG5cdCAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgcC54ICsgJywgJyArIHAueSArICcpIHJvdGF0ZSgnICsgcC5hbmdsZSArICdkZWcpIHNjYWxlKCcgKyBzY2FsZSArICcpJztcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gY3JlYXRlIHRyYW5zZm9ybS1vcmlnaW4gc3RyaW5nLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEByZXR1cm5zIHtTdHJpbmd9IFRyYW5zZm9ybSBzdHJpbmcuXG5cdCAgKi9cblxuXG5cdCAgU2hhcGUucHJvdG90eXBlLl9maWxsT3JpZ2luID0gZnVuY3Rpb24gX2ZpbGxPcmlnaW4oKSB7XG5cdCAgICB2YXIgcCA9IHRoaXMuX3Byb3BzLFxuXHQgICAgICAgIHN0ciA9ICcnO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwLm9yaWdpbi5sZW5ndGg7IGkrKykge1xuXHQgICAgICBzdHIgKz0gcC5vcmlnaW5baV0uc3RyaW5nICsgJyAnO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHN0cjtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gcmVmcmVzaCBzdGF0ZSBiZWZvciBzdGFydFRpbWUuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIFNoYXBlLnByb3RvdHlwZS5fcmVmcmVzaEJlZm9yZSA9IGZ1bmN0aW9uIF9yZWZyZXNoQmVmb3JlKCkge1xuXHQgICAgLy8gY2FsbCBzZXRQcm9ncmVzcyB3aXRoIGVhc2VkIGFuZCBub3JtYWwgcHJvZ3Jlc3Ncblx0ICAgIHRoaXMuX3NldFByb2dyZXNzKHRoaXMudHdlZW4uX3Byb3BzLmVhc2luZygwKSwgMCk7XG5cblx0ICAgIGlmICh0aGlzLl9wcm9wcy5pc1Nob3dTdGFydCkge1xuXHQgICAgICB0aGlzLl9zaG93KCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB0aGlzLl9oaWRlKCk7XG5cdCAgICB9XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRoYXQgZ2V0cyBjYWxsZWQgb24gYHNvZnRgIHNob3cgb2YgdGhlIG1vZHVsZSxcblx0ICAgIGl0IHNob3VsZCByZXN0b3JlIHRyYW5zZm9ybSBzdHlsZXMgb2YgdGhlIG1vZHVsZS5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAb3ZlcnJpZGVzIEAgTW9kdWxlXG5cdCAgKi9cblxuXG5cdCAgU2hhcGUucHJvdG90eXBlLl9zaG93QnlUcmFuc2Zvcm0gPSBmdW5jdGlvbiBfc2hvd0J5VHJhbnNmb3JtKCkge1xuXHQgICAgLy8gcmVzZXQgdGhlIGNhY2hlIG9mIHRoZSBzY2FsZSBwcm9wXG5cdCAgICB0aGlzLl9sYXN0U2V0LnNjYWxlID0gbnVsbDtcblx0ICAgIC8vIGRyYXcgZWwgYWNjcm9kaW5nIHRvIGl0J3MgcHJvcHNcblx0ICAgIHRoaXMuX2RyYXdFbCgpO1xuXHQgIH07XG5cblx0ICByZXR1cm4gU2hhcGU7XG5cdH0oX3R1bmFibGUyLmRlZmF1bHQpO1xuXG5cdGV4cG9ydHMuZGVmYXVsdCA9IFNoYXBlO1xuXG4vKioqLyB9KSxcbi8qIDk1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDk2KSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG4vKioqLyB9KSxcbi8qIDk2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0X193ZWJwYWNrX3JlcXVpcmVfXyg5Nyk7XG5cdG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCkuT2JqZWN0LmtleXM7XG5cbi8qKiovIH0pLFxuLyogOTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvLyAxOS4xLjIuMTQgT2JqZWN0LmtleXMoTylcblx0dmFyIHRvT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OSlcblx0ICAsICRrZXlzICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG5cblx0X193ZWJwYWNrX3JlcXVpcmVfXyg5OCkoJ2tleXMnLCBmdW5jdGlvbigpe1xuXHQgIHJldHVybiBmdW5jdGlvbiBrZXlzKGl0KXtcblx0ICAgIHJldHVybiAka2V5cyh0b09iamVjdChpdCkpO1xuXHQgIH07XG5cdH0pO1xuXG4vKioqLyB9KSxcbi8qIDk4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0Ly8gbW9zdCBPYmplY3QgbWV0aG9kcyBieSBFUzYgc2hvdWxkIGFjY2VwdCBwcmltaXRpdmVzXG5cdHZhciAkZXhwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMilcblx0ICAsIGNvcmUgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KVxuXHQgICwgZmFpbHMgICA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEtFWSwgZXhlYyl7XG5cdCAgdmFyIGZuICA9IChjb3JlLk9iamVjdCB8fCB7fSlbS0VZXSB8fCBPYmplY3RbS0VZXVxuXHQgICAgLCBleHAgPSB7fTtcblx0ICBleHBbS0VZXSA9IGV4ZWMoZm4pO1xuXHQgICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24oKXsgZm4oMSk7IH0pLCAnT2JqZWN0JywgZXhwKTtcblx0fTtcblxuLyoqKi8gfSksXG4vKiA5OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5cdHZhciBfa2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oOTUpO1xuXG5cdHZhciBfa2V5czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9rZXlzKTtcblxuXHR2YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oNzQpO1xuXG5cdHZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxuXHR2YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NSk7XG5cblx0dmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yKTtcblxuXHR2YXIgX2luaGVyaXRzMiA9IF9fd2VicGFja19yZXF1aXJlX18oNzYpO1xuXG5cdHZhciBfaW5oZXJpdHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5oZXJpdHMyKTtcblxuXHR2YXIgX3R3ZWVuYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTAwKTtcblxuXHR2YXIgX3R3ZWVuYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90d2VlbmFibGUpO1xuXG5cdHZhciBfaCA9IF9fd2VicGFja19yZXF1aXJlX18oNzEpO1xuXG5cdHZhciBfaDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oKTtcblxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5cdC8qXG5cdCAgVGhlIFRoZW5hYmxlIGNsYXNzIGFkZHMgLnRoZW4gcHVibGljIG1ldGhvZCBhbmRcblx0ICB0aGUgYWJpbGl0eSB0byBjaGFpbiBBUEkgY2FsbHMuXG5cdCovXG5cdHZhciBUaGVuYWJsZSA9IGZ1bmN0aW9uIChfVHdlZW5hYmxlKSB7XG5cdCAgKDAsIF9pbmhlcml0czMuZGVmYXVsdCkoVGhlbmFibGUsIF9Ud2VlbmFibGUpO1xuXG5cdCAgZnVuY3Rpb24gVGhlbmFibGUoKSB7XG5cdCAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBUaGVuYWJsZSk7XG5cdCAgICByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMy5kZWZhdWx0KSh0aGlzLCBfVHdlZW5hYmxlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuXHQgIH1cblxuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gY3JlYXRlIGEgdGhlbiByZWNvcmQgZm9yIHRoZSBtb2R1bGUuXG5cdCAgICBAcHVibGljXG5cdCAgICBAcGFyYW0gICAge09iamVjdH0gT3B0aW9ucyBmb3IgdGhlIG5leHQgYW5pbWF0aW9uLlxuXHQgICAgQHJldHVybnMgIHtPYmplY3R9IHRoaXMuXG5cdCAgKi9cblx0ICBUaGVuYWJsZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uIHRoZW4obykge1xuXHQgICAgLy8gcmV0dXJuIGlmIG5vdGhpbmcgd2FzIHBhc3NlZFxuXHQgICAgaWYgKG8gPT0gbnVsbCB8fCAhKDAsIF9rZXlzMi5kZWZhdWx0KShvKS5sZW5ndGgpIHtcblx0ICAgICAgcmV0dXJuIDE7XG5cdCAgICB9XG5cdCAgICAvLyBtZXJnZSB0aGVuIG9wdGlvbnMgd2l0aCB0aGUgY3VycmVudCBvbmVzXG5cdCAgICB2YXIgcHJldlJlY29yZCA9IHRoaXMuX2hpc3RvcnlbdGhpcy5faGlzdG9yeS5sZW5ndGggLSAxXSxcblx0ICAgICAgICBwcmV2TW9kdWxlID0gdGhpcy5fbW9kdWxlc1t0aGlzLl9tb2R1bGVzLmxlbmd0aCAtIDFdLFxuXHQgICAgICAgIG1lcmdlZCA9IHRoaXMuX21lcmdlVGhlbk9wdGlvbnMocHJldlJlY29yZCwgbyk7XG5cblx0ICAgIHRoaXMuX3Jlc2V0TWVyZ2VkRmxhZ3MobWVyZ2VkKTtcblx0ICAgIC8vIGNyZWF0ZSBhIHN1Ym1vZHVsZSBvZiB0aGUgc2FtZSB0eXBlIGFzIHRoZSBtYXN0ZXIgbW9kdWxlXG5cdCAgICB2YXIgbW9kdWxlID0gbmV3IHRoaXMuY29uc3RydWN0b3IobWVyZ2VkKTtcblx0ICAgIC8vIHNldCBgdGhpc2AgYXMgYW1zdGVyIG1vZHVsZSBvZiBjaGlsZCBtb2R1bGVcblx0ICAgIG1vZHVsZS5fbWFzdGVyTW9kdWxlID0gdGhpcztcblx0ICAgIC8vIHNhdmUgdGhlIG1vZHVsZXMgdG8gdGhlIF9tb2R1bGVzIGFycmF5XG5cdCAgICB0aGlzLl9tb2R1bGVzLnB1c2gobW9kdWxlKTtcblx0ICAgIC8vIGFkZCBtb2R1bGUncyB0d2VlbiBpbnRvIG1hc3RlciB0aW1lbGluZVxuXHQgICAgdGhpcy50aW1lbGluZS5hcHBlbmQobW9kdWxlKTtcblxuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblxuXHQgIC8vIF4gUFVCTElDICBNRVRIT0QoUykgXlxuXHQgIC8vIHYgUFJJVkFURSBNRVRIT0QoUykgdlxuXG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byByZXNldCBzb21lIGZsYWdzIG9uIG1lcmdlZCBvcHRpb25zIG9iamVjdC5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0gICB7T2JqZWN0fSBPcHRpb25zIG9iamVjdC5cblx0ICAgIEByZXR1cm5zIHtPYmplY3R9IE9wdGlvbnMgb2JqZWN0LlxuXHQgICovXG5cblxuXHQgIFRoZW5hYmxlLnByb3RvdHlwZS5fcmVzZXRNZXJnZWRGbGFncyA9IGZ1bmN0aW9uIF9yZXNldE1lcmdlZEZsYWdzKG9iaikge1xuXHQgICAgLy8gc2V0IHRoZSBzdWJtb2R1bGUgdG8gYmUgd2l0aG91dCB0aW1lbGluZSBmb3IgcGVyZiByZWFzb25zXG5cdCAgICBvYmouaXNUaW1lbGluZUxlc3MgPSB0cnVlO1xuXHQgICAgLy8gcmVzZXQgaXNTaG93U3RhcnQgZmxhZyBmb3IgdGhlIHN1Ym1vZHVsZXNcblx0ICAgIG9iai5pc1Nob3dTdGFydCA9IGZhbHNlO1xuXHQgICAgLy8gcmVzZXQgaXNSZWZyZXNoU3RhdGUgZmxhZyBmb3IgdGhlIHN1Ym1vZHVsZXNcblx0ICAgIG9iai5pc1JlZnJlc2hTdGF0ZSA9IGZhbHNlO1xuXHQgICAgLy8gc2V0IHRoZSBzdWJtb2R1bGUgY2FsbGJhY2tzIGNvbnRleHRcblx0ICAgIG9iai5jYWxsYmFja3NDb250ZXh0ID0gdGhpcy5fcHJvcHMuY2FsbGJhY2tzQ29udGV4dCB8fCB0aGlzO1xuXHQgICAgLy8gc2V0IHByZXZpb3VzIG1vZHVsZVxuXHQgICAgb2JqLnByZXZDaGFpbk1vZHVsZSA9IF9oMi5kZWZhdWx0LmdldExhc3RJdGVtKHRoaXMuX21vZHVsZXMpO1xuXHQgICAgLy8gcGFzcyB0aGUgYHRoaXNgIGFzIG1hc3RlciBtb2R1bGVcblx0ICAgIG9iai5tYXN0ZXJNb2R1bGUgPSB0aGlzO1xuXHQgICAgcmV0dXJuIG9iajtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gaW5pdGlhbGl6ZSBwcm9wZXJ0aWVzLlxuXHQgICAgQHByaXZhdGVcblx0ICAqL1xuXG5cblx0ICBUaGVuYWJsZS5wcm90b3R5cGUuX3ZhcnMgPSBmdW5jdGlvbiBfdmFycygpIHtcblx0ICAgIF9Ud2VlbmFibGUucHJvdG90eXBlLl92YXJzLmNhbGwodGhpcyk7XG5cdCAgICAvLyBzYXZlIF9tYXN0ZXIgbW9kdWxlXG5cdCAgICB0aGlzLl9tYXN0ZXJNb2R1bGUgPSB0aGlzLl9vLm1hc3Rlck1vZHVsZTtcblx0ICAgIC8vIHNldCBpc0NoYWluZWQgZmxhZyBiYXNlZCBvbiBwcmV2Q2hhaW5Nb2R1bGUgb3B0aW9uXG5cdCAgICB0aGlzLl9pc0NoYWluZWQgPSAhIXRoaXMuX21hc3Rlck1vZHVsZTtcblx0ICAgIC8vIHdlIGFyZSBleHBlY3QgdGhhdCB0aGUgX28gb2JqZWN0XG5cdCAgICAvLyBoYXZlIGJlZW4gYWxyZWFkeSBleHRlbmRlZCBieSBkZWZhdWx0c1xuXHQgICAgdmFyIGluaXRpYWxSZWNvcmQgPSBfaDIuZGVmYXVsdC5jbG9uZU9iaih0aGlzLl9wcm9wcyk7XG5cdCAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fYXJyYXlQcm9wZXJ0eU1hcCkge1xuXHQgICAgICBpZiAodGhpcy5fb1trZXldKSB7XG5cdCAgICAgICAgdmFyIHByZVBhcnNlZCA9IHRoaXMuX3BhcnNlUHJlQXJyYXlQcm9wZXJ0eShrZXksIHRoaXMuX29ba2V5XSk7XG5cdCAgICAgICAgaW5pdGlhbFJlY29yZFtrZXldID0gcHJlUGFyc2VkO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuX2hpc3RvcnkgPSBbaW5pdGlhbFJlY29yZF07XG5cdCAgICAvLyB0aGUgYXJyYXkgaG9sZHMgYWxsIG1vZHVsZXMgaW4gdGhlIHRoZW4gY2hhaW5cblx0ICAgIHRoaXMuX21vZHVsZXMgPSBbdGhpc107XG5cdCAgICAvLyB0aGUgcHJvcHMgdGhhdCB0byBleGNsdWRlIGZyb20gdGhlbiBtZXJnZVxuXHQgICAgdGhpcy5fbm9uTWVyZ2VQcm9wcyA9IHsgc2hhcGU6IDEgfTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gbWVyZ2UgdHdvIG9wdGlvbnMgaW50byBvbmUuIFVzZWQgaW4gLnRoZW4gY2hhaW5zLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBTdGFydCBvcHRpb25zIGZvciB0aGUgbWVyZ2UuXG5cdCAgICBAcGFyYW0ge09iamVjdH0gRW5kIG9wdGlvbnMgZm9yIHRoZSBtZXJnZS5cblx0ICAgIEByZXR1cm5zIHtPYmplY3R9IE1lcmdlZCBvcHRpb25zLlxuXHQgICovXG5cblxuXHQgIFRoZW5hYmxlLnByb3RvdHlwZS5fbWVyZ2VUaGVuT3B0aW9ucyA9IGZ1bmN0aW9uIF9tZXJnZVRoZW5PcHRpb25zKHN0YXJ0LCBlbmQpIHtcblx0ICAgIHZhciBvID0ge307XG5cdCAgICB0aGlzLl9tZXJnZVN0YXJ0TG9vcChvLCBzdGFydCk7XG5cdCAgICB0aGlzLl9tZXJnZUVuZExvb3Aobywgc3RhcnQsIGVuZCk7XG5cdCAgICB0aGlzLl9oaXN0b3J5LnB1c2gobyk7XG5cdCAgICByZXR1cm4gbztcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gcGlwZSBzdGFydFZhbHVlIG9mIHRoZSBkZWx0YS5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge1N0cmluZ30gU3RhcnQgcHJvcGVydHkgbmFtZS5cblx0ICAgIEBwYXJhbSB7QW55fSBTdGFydCBwcm9wZXJ0eSB2YWx1ZS5cblx0ICAgIEByZXR1cm5zIHtBbnl9IFN0YXJ0IHByb3BlcnR5IHZhbHVlLlxuXHQgICovXG5cblxuXHQgIFRoZW5hYmxlLnByb3RvdHlwZS5fY2hlY2tTdGFydFZhbHVlID0gZnVuY3Rpb24gX2NoZWNrU3RhcnRWYWx1ZShuYW1lLCB2YWx1ZSkge1xuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE9yaWdpbmFsbHkgcGFydCBvZiB0aGUgX21lcmdlVGhlbk9wdGlvbnMuXG5cdCAgICBMb29wcyB0aHJ1IHN0YXJ0IG9iamVjdCBhbmQgY29waWVzIGFsbCB0aGUgcHJvcHMgZnJvbSBpdC5cblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBBbiBvYmplY3QgdG8gY29weSBpbi5cblx0ICAgIEBwYXJtYSB7T2JqZWN0fSBTdGFydCBvcHRpb25zIG9iamVjdC5cblx0ICAqL1xuXG5cblx0ICBUaGVuYWJsZS5wcm90b3R5cGUuX21lcmdlU3RhcnRMb29wID0gZnVuY3Rpb24gX21lcmdlU3RhcnRMb29wKG8sIHN0YXJ0KSB7XG5cdCAgICAvLyBsb29wIHRocnUgc3RhcnQgb3B0aW9ucyBvYmplY3Rcblx0ICAgIGZvciAodmFyIGtleSBpbiBzdGFydCkge1xuXHQgICAgICB2YXIgdmFsdWUgPSBzdGFydFtrZXldO1xuXHQgICAgICBpZiAoc3RhcnRba2V5XSA9PSBudWxsKSB7XG5cdCAgICAgICAgY29udGludWU7XG5cdCAgICAgIH07XG5cdCAgICAgIC8vIGNvcHkgYWxsIHZhbHVlcyBmcm9tIHN0YXJ0IGlmIG5vdCB0d2VlbiBwcm9wIG9yIGR1cmF0aW9uXG5cdCAgICAgIGlmICghX2gyLmRlZmF1bHQuaXNUd2VlblByb3Aoa2V5KSB8fCBrZXkgPT09ICdkdXJhdGlvbicpIHtcblx0ICAgICAgICAvLyBpZiBkZWx0YSAtIGNvcHkgb25seSB0aGUgZW5kIHZhbHVlXG5cdCAgICAgICAgaWYgKHRoaXMuX2lzRGVsdGEodmFsdWUpKSB7XG5cdCAgICAgICAgICBvW2tleV0gPSBfaDIuZGVmYXVsdC5nZXREZWx0YUVuZCh2YWx1ZSk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIG9ba2V5XSA9IHZhbHVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH07XG5cdCAgLypcblx0ICAgIE9yaWdpbmFsbHkgcGFydCBvZiB0aGUgX21lcmdlVGhlbk9wdGlvbnMuXG5cdCAgICBMb29wcyB0aHJ1IHN0YXJ0IG9iamVjdCBhbmQgbWVyZ2VzIGFsbCB0aGUgcHJvcHMgZnJvbSBpdC5cblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBBbiBvYmplY3QgdG8gY29weSBpbi5cblx0ICAgIEBwYXJtYSB7T2JqZWN0fSBTdGFydCBvcHRpb25zIG9iamVjdC5cblx0ICAgIEBwYXJtYSB7T2JqZWN0fSBFbmQgb3B0aW9ucyBvYmplY3QuXG5cdCAgKi9cblxuXG5cdCAgVGhlbmFibGUucHJvdG90eXBlLl9tZXJnZUVuZExvb3AgPSBmdW5jdGlvbiBfbWVyZ2VFbmRMb29wKG8sIHN0YXJ0LCBlbmQpIHtcblx0ICAgIHZhciBlbmRLZXlzID0gKDAsIF9rZXlzMi5kZWZhdWx0KShlbmQpO1xuXG5cdCAgICBmb3IgKHZhciBrZXkgaW4gZW5kKSB7XG5cdCAgICAgIC8vIGp1c3QgY29weSBwYXJlbnQgb3B0aW9uXG5cdCAgICAgIGlmIChrZXkgPT0gJ3BhcmVudCcpIHtcblx0ICAgICAgICBvW2tleV0gPSBlbmRba2V5XTtjb250aW51ZTtcblx0ICAgICAgfTtcblxuXHQgICAgICAvLyBnZXQga2V5L3ZhbHVlIG9mIHRoZSBlbmQgb2JqZWN0XG5cdCAgICAgIC8vIGVuZEtleSAtIG5hbWUgb2YgdGhlIHByb3BlcnR5LCBlbmRWYWx1ZSAtIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eVxuXHQgICAgICB2YXIgZW5kVmFsdWUgPSBlbmRba2V5XSxcblx0ICAgICAgICAgIHN0YXJ0VmFsdWUgPSBzdGFydFtrZXldICE9IG51bGwgPyBzdGFydFtrZXldIDogdGhpcy5fZGVmYXVsdHNba2V5XTtcblxuXHQgICAgICBzdGFydFZhbHVlID0gdGhpcy5fY2hlY2tTdGFydFZhbHVlKGtleSwgc3RhcnRWYWx1ZSk7XG5cdCAgICAgIGlmIChlbmRWYWx1ZSA9PSBudWxsKSB7XG5cdCAgICAgICAgY29udGludWU7XG5cdCAgICAgIH07XG5cdCAgICAgIC8vIG1ha2Ug4oiGIG9mIHN0YXJ0IC0+IGVuZFxuXHQgICAgICAvLyBpZiBrZXkgbmFtZSBpcyByYWRpdXNYL3JhZGl1c1kgYW5kXG5cdCAgICAgIC8vIHRoZSBzdGFydFZhbHVlIGlzIG5vdCBzZXQgZmFsbGJhY2sgdG8gcmFkaXVzIHZhbHVlXG5cdCAgICAgIHZhciBpc1N1YlJhZGl1cyA9IGtleSA9PT0gJ3JhZGl1c1gnIHx8IGtleSA9PT0gJ3JhZGl1c1knO1xuXHQgICAgICBpZiAoaXNTdWJSYWRpdXMgJiYgc3RhcnRWYWx1ZSA9PSBudWxsKSB7XG5cdCAgICAgICAgc3RhcnRWYWx1ZSA9IHN0YXJ0LnJhZGl1cztcblx0ICAgICAgfVxuXG5cdCAgICAgIHZhciBpc1N1YlJhZGl1cyA9IGtleSA9PT0gJ3NjYWxlWCcgfHwga2V5ID09PSAnc2NhbGVZJztcblx0ICAgICAgaWYgKGlzU3ViUmFkaXVzICYmIHN0YXJ0VmFsdWUgPT0gbnVsbCkge1xuXHQgICAgICAgIHN0YXJ0VmFsdWUgPSBzdGFydC5zY2FsZTtcblx0ICAgICAgfVxuXG5cdCAgICAgIG9ba2V5XSA9IHRoaXMuX21lcmdlVGhlblByb3BlcnR5KGtleSwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUpO1xuXHQgICAgfVxuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBtZXJnZSBgc3RhcnRgIGFuZCBgZW5kYCBmb3IgYSBwcm9wZXJ0eSBpbiB0aGVuIHJlY29yZC5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge1N0cmluZ30gUHJvcGVydHkgbmFtZS5cblx0ICAgIEBwYXJhbSB7QW55fSAgICBTdGFydCB2YWx1ZSBvZiB0aGUgcHJvcGVydHkuXG5cdCAgICBAcGFyYW0ge0FueX0gICAgRW5kIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eS5cblx0ICAqL1xuXG5cblx0ICBUaGVuYWJsZS5wcm90b3R5cGUuX21lcmdlVGhlblByb3BlcnR5ID0gZnVuY3Rpb24gX21lcmdlVGhlblByb3BlcnR5KGtleSwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUpIHtcblx0ICAgIC8vIGlmIGlzbnQgdHdlZW4gcHJvcGVydHlcblx0ICAgIHZhciBpc0Jvb2xlYW4gPSB0eXBlb2YgZW5kVmFsdWUgPT09ICdib29sZWFuJyxcblx0ICAgICAgICBjdXJ2ZSxcblx0ICAgICAgICBlYXNpbmc7XG5cblx0ICAgIGlmICghX2gyLmRlZmF1bHQuaXNUd2VlblByb3Aoa2V5KSAmJiAhdGhpcy5fbm9uTWVyZ2VQcm9wc1trZXldICYmICFpc0Jvb2xlYW4pIHtcblxuXHQgICAgICBpZiAoX2gyLmRlZmF1bHQuaXNPYmplY3QoZW5kVmFsdWUpICYmIGVuZFZhbHVlLnRvICE9IG51bGwpIHtcblx0ICAgICAgICBjdXJ2ZSA9IGVuZFZhbHVlLmN1cnZlO1xuXHQgICAgICAgIGVhc2luZyA9IGVuZFZhbHVlLmVhc2luZztcblx0ICAgICAgICBlbmRWYWx1ZSA9IGVuZFZhbHVlLnRvO1xuXHQgICAgICB9XG5cblx0ICAgICAgLy8gaWYgZW5kIHZhbHVlIGlzIGRlbHRhIC0ganVzdCBzYXZlIGl0XG5cdCAgICAgIGlmICh0aGlzLl9pc0RlbHRhKGVuZFZhbHVlKSkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9wYXJzZURlbHRhVmFsdWVzKGtleSwgZW5kVmFsdWUpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHZhciBwYXJzZWRFbmRWYWx1ZSA9IHRoaXMuX3BhcnNlUHJlQXJyYXlQcm9wZXJ0eShrZXksIGVuZFZhbHVlKTtcblx0ICAgICAgICAvLyBpZiBlbmQgdmFsdWUgaXMgbm90IGRlbHRhIC0gbWVyZ2Ugd2l0aCBzdGFydCB2YWx1ZVxuXHQgICAgICAgIGlmICh0aGlzLl9pc0RlbHRhKHN0YXJ0VmFsdWUpKSB7XG5cdCAgICAgICAgICB2YXIgX3JlZjtcblxuXHQgICAgICAgICAgLy8gaWYgc3RhcnQgdmFsdWUgaXMgZGVsdGEgLSB0YWtlIHRoZSBlbmQgdmFsdWVcblx0ICAgICAgICAgIC8vIGFzIHN0YXJ0IHZhbHVlIG9mIHRoZSBuZXcgZGVsdGFcblx0ICAgICAgICAgIHJldHVybiBfcmVmID0ge30sIF9yZWZbX2gyLmRlZmF1bHQuZ2V0RGVsdGFFbmQoc3RhcnRWYWx1ZSldID0gcGFyc2VkRW5kVmFsdWUsIF9yZWYuZWFzaW5nID0gZWFzaW5nLCBfcmVmLmN1cnZlID0gY3VydmUsIF9yZWY7XG5cdCAgICAgICAgICAvLyBpZiBib3RoIHN0YXJ0IGFuZCBlbmQgdmFsdWUgYXJlIG5vdCDiiIYgLSBtYWtlIOKIhlxuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICB2YXIgX3JlZjI7XG5cblx0ICAgICAgICAgIHJldHVybiBfcmVmMiA9IHt9LCBfcmVmMltzdGFydFZhbHVlXSA9IHBhcnNlZEVuZFZhbHVlLCBfcmVmMi5lYXNpbmcgPSBlYXNpbmcsIF9yZWYyLmN1cnZlID0gY3VydmUsIF9yZWYyO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICAvLyBjb3B5IHRoZSB0d2VlbiB2YWx1ZXMgdW5hdHRlbmRlZFxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmV0dXJuIGVuZFZhbHVlO1xuXHQgICAgfVxuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byByZXRyZWl2ZSBhcnJheSdzIGxlbmd0aCBhbmQgcmV0dXJuIC0xIGZvclxuXHQgICAgYWxsIG90aGVyIHR5cGVzLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7QXJyYXksIEFueX0gQXJyYXkgdG8gZ2V0IHRoZSB3aWR0aCBmb3IuXG5cdCAgICBAcmV0dXJucyB7TnVtYmVyfSBBcnJheSBsZW5ndGggb3IgLTEgaWYgbm90IGFycmF5LlxuXHQgICovXG5cblxuXHQgIFRoZW5hYmxlLnByb3RvdHlwZS5fZ2V0QXJyYXlMZW5ndGggPSBmdW5jdGlvbiBfZ2V0QXJyYXlMZW5ndGgoYXJyKSB7XG5cdCAgICByZXR1cm4gX2gyLmRlZmF1bHQuaXNBcnJheShhcnIpID8gYXJyLmxlbmd0aCA6IC0xO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBjaGVjayBpZiB0aGUgcHJvcGVydHkgaXMgZGVsdGEgcHJvcGVydHkuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtBbnl9IFBhcmFtZXRlciB2YWx1ZSB0byBjaGVjay5cblx0ICAgIEByZXR1cm5zIHtCb29sZWFufVxuXHQgICovXG5cblxuXHQgIFRoZW5hYmxlLnByb3RvdHlwZS5faXNEZWx0YSA9IGZ1bmN0aW9uIF9pc0RlbHRhKG9wdGlvbnNWYWx1ZSkge1xuXHQgICAgdmFyIGlzT2JqZWN0ID0gX2gyLmRlZmF1bHQuaXNPYmplY3Qob3B0aW9uc1ZhbHVlKTtcblx0ICAgIGlzT2JqZWN0ID0gaXNPYmplY3QgJiYgIW9wdGlvbnNWYWx1ZS51bml0O1xuXHQgICAgcmV0dXJuICEoIWlzT2JqZWN0IHx8IF9oMi5kZWZhdWx0LmlzQXJyYXkob3B0aW9uc1ZhbHVlKSB8fCBfaDIuZGVmYXVsdC5pc0RPTShvcHRpb25zVmFsdWUpKTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gY2hlY2sgaWYgdGhlIG1vZHVsZSBpcyBmaXJzdCBpbiBgdGhlbmAgY2hhaW4uXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSBtb2R1bGUgaXMgdGhlIGZpcnN0IGluIG1vZHVsZSBjaGFpbi5cblx0ICAqL1xuXG5cblx0ICBUaGVuYWJsZS5wcm90b3R5cGUuX2lzRmlyc3RJbkNoYWluID0gZnVuY3Rpb24gX2lzRmlyc3RJbkNoYWluKCkge1xuXHQgICAgcmV0dXJuICF0aGlzLl9tYXN0ZXJNb2R1bGU7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGNoZWNrIGlmIHRoZSBtb2R1bGUgaXMgbGFzdCBpbiBgdGhlbmAgY2hhaW4uXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSBtb2R1bGUgaXMgdGhlIGxhc3QgaW4gbW9kdWxlIGNoYWluLlxuXHQgICovXG5cblxuXHQgIFRoZW5hYmxlLnByb3RvdHlwZS5faXNMYXN0SW5DaGFpbiA9IGZ1bmN0aW9uIF9pc0xhc3RJbkNoYWluKCkge1xuXHQgICAgdmFyIG1hc3RlciA9IHRoaXMuX21hc3Rlck1vZHVsZTtcblx0ICAgIC8vIGlmIHRoZXJlIGlzIG5vIG1hc3RlciBmaWVsZCAtIGNoZWNrIHRoZSBtb2R1bGVzIGxlbmd0aFxuXHQgICAgLy8gaWYgbW9kdWxlIGxlbmd0aCBpcyAxIHRodXMgdGhlcmUgaXMgbm8gbW9kdWxlcyBjaGFpbiBcblx0ICAgIC8vIGl0IGlzIHRoZSBsYXN0IG9uZSwgb3RoZXJ3aXNlIGl0IGlzbnRcblx0ICAgIGlmICghbWFzdGVyKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9tb2R1bGVzLmxlbmd0aCA9PT0gMTtcblx0ICAgIH1cblx0ICAgIC8vIGlmIHRoZXJlIGlzIG1hc3RlciAtIGNoZWNrIGlmIGl0IGlzIHRoZSBsYXN0IGl0ZW0gaW4gX21vZHVsZXMgY2hhaW5cblx0ICAgIHJldHVybiB0aGlzID09PSBfaDIuZGVmYXVsdC5nZXRMYXN0SXRlbShtYXN0ZXIuX21vZHVsZXMpO1xuXHQgIH07XG5cblx0ICByZXR1cm4gVGhlbmFibGU7XG5cdH0oX3R3ZWVuYWJsZTIuZGVmYXVsdCk7XG5cblx0ZXhwb3J0cy5kZWZhdWx0ID0gVGhlbmFibGU7XG5cbi8qKiovIH0pLFxuLyogMTAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cblx0dmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0KTtcblxuXHR2YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cblx0dmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9fd2VicGFja19yZXF1aXJlX18oNzUpO1xuXG5cdHZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMik7XG5cblx0dmFyIF9pbmhlcml0czIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc2KTtcblxuXHR2YXIgX2luaGVyaXRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luaGVyaXRzMik7XG5cblx0dmFyIF90d2VlbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTAxKTtcblxuXHR2YXIgX3R3ZWVuMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R3ZWVuKTtcblxuXHR2YXIgX3RpbWVsaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTApO1xuXG5cdHZhciBfdGltZWxpbmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGltZWxpbmUpO1xuXG5cdHZhciBfbW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NCk7XG5cblx0dmFyIF9tb2R1bGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbW9kdWxlKTtcblxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5cdC8qXG5cdCAgQ2xhc3MgdG8gZGVmaW5lIGEgbW9kdWxlIGFuY2VzdG9yXG5cdCAgd2l0aCB0aW1lbGluZSBhbmQgdHdlZW4gb3B0aW9ucyBhbmQgZnVuY3Rpb25hbGl0eS5cblx0ICBBbGwgcnVuYWJsZSBtb2R1bGVzIHNob3VsZCBpbmhlcml0IGZyb20gdGhpcyBjbGFzcy5cblxuXHQgIEBjbGFzcyBUd2VlbmFibGVcblx0Ki9cblx0dmFyIFR3ZWVuYWJsZSA9IGZ1bmN0aW9uIChfTW9kdWxlKSB7XG5cdCAgKDAsIF9pbmhlcml0czMuZGVmYXVsdCkoVHdlZW5hYmxlLCBfTW9kdWxlKTtcblxuXHQgIC8qXG5cdCAgICBgcGxheWAgbWV0aG9kIGZvciB0aGUgdGltZWxpbmUuXG5cdCAgICBAcHVibGljXG5cdCAgICBAcGFyYW0ge051bWJlcn0gVGltZSBzaGlmdC5cblx0ICAgIEByZXR1cm5zIHRoaXMuXG5cdCAgKi9cblx0ICBUd2VlbmFibGUucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiBwbGF5KCkge1xuXHQgICAgdGhpcy50aW1lbGluZS5wbGF5LmFwcGx5KHRoaXMudGltZWxpbmUsIGFyZ3VtZW50cyk7XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBgcGxheUJhY2t3YXJkYCBtZXRob2QgZm9yIHRoZSB0aW1lbGluZS5cblx0ICAgIEBwdWJsaWNcblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBUaW1lIHNoaWZ0LlxuXHQgICAgQHJldHVybnMgdGhpcy5cblx0ICAqL1xuXG5cblx0ICBUd2VlbmFibGUucHJvdG90eXBlLnBsYXlCYWNrd2FyZCA9IGZ1bmN0aW9uIHBsYXlCYWNrd2FyZCgpIHtcblx0ICAgIHRoaXMudGltZWxpbmUucGxheUJhY2t3YXJkLmFwcGx5KHRoaXMudGltZWxpbmUsIGFyZ3VtZW50cyk7XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBgcGF1c2VgIG1ldGhvZCBmb3IgdGhlIHRpbWVsaW5lLlxuXHQgICAgQHB1YmxpY1xuXHQgICAgQHJldHVybnMgdGhpcy5cblx0ICAqL1xuXG5cblx0ICBUd2VlbmFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gcGF1c2UoKSB7XG5cdCAgICB0aGlzLnRpbWVsaW5lLnBhdXNlLmFwcGx5KHRoaXMudGltZWxpbmUsIGFyZ3VtZW50cyk7XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBgc3RvcGAgbWV0aG9kIGZvciB0aGUgdGltZWxpbmUuXG5cdCAgICBAcHVibGljXG5cdCAgICBAcGFyYW0ge051bWJlcn0gWzAuLi4xXSBQcm9ncmVzcyB0byBzZXQgb24gc3RvcC5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICpEZWZhdWx0KiBpcyBgMGAgaWYgYHBsYXlgXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgYDFgIGlmIGBwbGF5QkFja3dhcmRgLlxuXHQgICAgQHJldHVybnMgdGhpcy5cblx0ICAqL1xuXG5cblx0ICBUd2VlbmFibGUucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiBzdG9wKCkge1xuXHQgICAgdGhpcy50aW1lbGluZS5zdG9wLmFwcGx5KHRoaXMudGltZWxpbmUsIGFyZ3VtZW50cyk7XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBgcmVzZXRgIG1ldGhvZCBmb3IgdGhlIHRpbWVsaW5lLlxuXHQgICAgQHB1YmxpY1xuXHQgICAgQHJldHVybnMgdGhpcy5cblx0ICAqL1xuXG5cblx0ICBUd2VlbmFibGUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG5cdCAgICB0aGlzLnRpbWVsaW5lLnJlc2V0LmFwcGx5KHRoaXMudGltZWxpbmUsIGFyZ3VtZW50cyk7XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBgcmVwbGF5YCBtZXRob2QgZm9yIHRoZSB0aW1lbGluZS5cblx0ICAgIEBwdWJsaWNcblx0ICAgIEByZXR1cm5zIHRoaXMuXG5cdCAgKi9cblxuXG5cdCAgVHdlZW5hYmxlLnByb3RvdHlwZS5yZXBsYXkgPSBmdW5jdGlvbiByZXBsYXkoKSB7XG5cdCAgICB0aGlzLnRpbWVsaW5lLnJlcGxheS5hcHBseSh0aGlzLnRpbWVsaW5lLCBhcmd1bWVudHMpO1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgYHJlcGxheWAgbWV0aG9kIGZvciB0aGUgdGltZWxpbmUuXG5cdCAgICBAcHVibGljXG5cdCAgICBAcmV0dXJucyB0aGlzLlxuXHQgICovXG5cblxuXHQgIFR3ZWVuYWJsZS5wcm90b3R5cGUucmVwbGF5QmFja3dhcmQgPSBmdW5jdGlvbiByZXBsYXlCYWNrd2FyZCgpIHtcblx0ICAgIHRoaXMudGltZWxpbmUucmVwbGF5QmFja3dhcmQuYXBwbHkodGhpcy50aW1lbGluZSwgYXJndW1lbnRzKTtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIGByZXN1bWVgIG1ldGhvZCBmb3IgdGhlIHRpbWVsaW5lLlxuXHQgICAgQHB1YmxpY1xuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IFRpbWUgc2hpZnQuXG5cdCAgICBAcmV0dXJucyB0aGlzLlxuXHQgICovXG5cblxuXHQgIFR3ZWVuYWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gcmVzdW1lKCkge1xuXHQgICAgdmFyIHNoaWZ0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuXG5cdCAgICB0aGlzLnRpbWVsaW5lLnJlc3VtZS5hcHBseSh0aGlzLnRpbWVsaW5lLCBhcmd1bWVudHMpO1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgYHNldFByb2dyZXNzYCBtZXRob2QgZm9yIHRoZSB0aW1lbGluZS5cblx0ICAgIEBwdWJsaWNcblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBbMC4uLjFdIFByb2dyZXNzIHZhbHVlLlxuXHQgICAgQHJldHVybnMgdGhpcy5cblx0ICAqL1xuXG5cblx0ICBUd2VlbmFibGUucHJvdG90eXBlLnNldFByb2dyZXNzID0gZnVuY3Rpb24gc2V0UHJvZ3Jlc3MoKSB7XG5cdCAgICB0aGlzLnRpbWVsaW5lLnNldFByb2dyZXNzLmFwcGx5KHRoaXMudGltZWxpbmUsIGFyZ3VtZW50cyk7XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBzZXRTcGVlZCBtZXRob2QgZm9yIHRoZSB0aW1lbGluZS5cblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBTcGVlZCB2YWx1ZS5cblx0ICAgIEByZXR1cm5zIHRoaXMuXG5cdCAgKi9cblxuXG5cdCAgVHdlZW5hYmxlLnByb3RvdHlwZS5zZXRTcGVlZCA9IGZ1bmN0aW9uIHNldFNwZWVkKHNwZWVkKSB7XG5cdCAgICB0aGlzLnRpbWVsaW5lLnNldFNwZWVkLmFwcGx5KHRoaXMudGltZWxpbmUsIGFyZ3VtZW50cyk7XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXG5cdCAgLy8gXiBQVUJMSUMgIE1FVEhPRChTKSBeXG5cdCAgLy8gdiBQUklWQVRFIE1FVEhPRChTKSB2XG5cblx0ICBmdW5jdGlvbiBUd2VlbmFibGUoKSB7XG5cdCAgICB2YXIgbyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cdCAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBUd2VlbmFibGUpO1xuXG5cdCAgICAvLyBwaXBlIGZ1bmN0aW9uIGZvciBfbyBvYmplY3Rcblx0ICAgIC8vIGJlZm9yZSBjcmVhdGluZyB0d2Vlbi90aW1lbGluZVxuXHQgICAgdmFyIF90aGlzID0gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMy5kZWZhdWx0KSh0aGlzLCBfTW9kdWxlLmNhbGwodGhpcywgbykpO1xuXHQgICAgLy8gc3VwZXIgb2YgTW9kdWxlXG5cblxuXHQgICAgX3RoaXMuX3RyYW5zZm9ybVR3ZWVuT3B0aW9ucygpO1xuXHQgICAgLy8gbWFrZSB0d2VlbiBvbmx5IGlmIGlzVHdlZW5MZXNzIG9wdGlvbiBpcyBub3Qgc2V0XG5cdCAgICAhX3RoaXMuX28uaXNUd2Vlbkxlc3MgJiYgX3RoaXMuX21ha2VUd2VlbigpO1xuXHQgICAgLy8gbWFrZSB0aW1lbGluZSBvbmx5IGlmIGlzVGltZWxpbmVMZXNzIG9wdGlvbiBpcyBub3Qgc2V0XG5cdCAgICAhX3RoaXMuX28uaXNUaW1lbGluZUxlc3MgJiYgX3RoaXMuX21ha2VUaW1lbGluZSgpO1xuXHQgICAgcmV0dXJuIF90aGlzO1xuXHQgIH1cblx0ICAvKlxuXHQgICAgUGxhY2Vob2xkZXIgbWV0aG9kIHRoYXQgc2hvdWxkIGJlIG92ZXJyaWRlZFxuXHQgICAgYW5kIHdpbGwgYmUgY2FsbGVkIGJlZm9yZSB0d2Vlbi90aW1lbGluZSBjcmVhdGlvbi5cblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblxuXG5cdCAgVHdlZW5hYmxlLnByb3RvdHlwZS5fdHJhbnNmb3JtVHdlZW5PcHRpb25zID0gZnVuY3Rpb24gX3RyYW5zZm9ybVR3ZWVuT3B0aW9ucygpIHt9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gY3JlYXRlIHR3ZWVuLlxuXHQgICAgQHByaXZhdGVcblx0ICAqL1xuXG5cblx0ICBUd2VlbmFibGUucHJvdG90eXBlLl9tYWtlVHdlZW4gPSBmdW5jdGlvbiBfbWFrZVR3ZWVuKCkge1xuXHQgICAgLy8gcGFzcyBjYWxsYmFja3MgY29udGV4dFxuXHQgICAgdGhpcy5fby5jYWxsYmFja3NDb250ZXh0ID0gdGhpcy5fby5jYWxsYmFja3NDb250ZXh0IHx8IHRoaXM7XG5cdCAgICB0aGlzLnR3ZWVuID0gbmV3IF90d2VlbjIuZGVmYXVsdCh0aGlzLl9vKTtcblx0ICAgIC8vIG1ha2UgdGltZWxpbmUgcHJvcGVydHkgcG9pbnQgdG8gdHdlZW4gb25lIGlzIFwibm8gdGltZWxpbmVcIiBtb2RlXG5cdCAgICB0aGlzLl9vLmlzVGltZWxpbmVMZXNzICYmICh0aGlzLnRpbWVsaW5lID0gdGhpcy50d2Vlbik7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGNyZWF0ZSB0aW1lbGluZS5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge09iamVjdH0gVGltZWxpbmUncyBvcHRpb25zLlxuXHQgICAgICAgICAgICAgICAgICAgIEFuIG9iamVjdCB3aGljaCBjb250YWlucyBcInRpbWVsaW5lXCIgcHJvcGVydHkgd2l0aFxuXHQgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lIG9wdGlvbnMuXG5cdCAgKi9cblxuXG5cdCAgVHdlZW5hYmxlLnByb3RvdHlwZS5fbWFrZVRpbWVsaW5lID0gZnVuY3Rpb24gX21ha2VUaW1lbGluZSgpIHtcblx0ICAgIC8vIHBhc3MgY2FsbGJhY2tzIGNvbnRleHRcblx0ICAgIHRoaXMuX28udGltZWxpbmUgPSB0aGlzLl9vLnRpbWVsaW5lIHx8IHt9O1xuXHQgICAgdGhpcy5fby50aW1lbGluZS5jYWxsYmFja3NDb250ZXh0ID0gdGhpcy5fby5jYWxsYmFja3NDb250ZXh0IHx8IHRoaXM7XG5cdCAgICB0aGlzLnRpbWVsaW5lID0gbmV3IF90aW1lbGluZTIuZGVmYXVsdCh0aGlzLl9vLnRpbWVsaW5lKTtcblx0ICAgIC8vIHNldCB0aGUgZmxhZyB0byBpbmRpY2F0ZSB0aGF0IHJlYWwgdGltZWxpbmUgaXMgcHJlc2VudFxuXHQgICAgdGhpcy5faXNUaW1lbGluZSA9IHRydWU7XG5cdCAgICAvLyBpZiB0d2VlbiBleGlzdCAtIGFkZCBpdCB0byB0aGUgdGltZWxpbmUgdGhlcmUgaXMgc29tZVxuXHQgICAgLy8gbW9kdWxlcyBsaWtlIGJ1cnN0IGFuZCBzdGFnZ2VyIHRoYXQgaGF2ZSBubyB0d2VlblxuXHQgICAgdGhpcy50d2VlbiAmJiB0aGlzLnRpbWVsaW5lLmFkZCh0aGlzLnR3ZWVuKTtcblx0ICB9O1xuXG5cdCAgcmV0dXJuIFR3ZWVuYWJsZTtcblx0fShfbW9kdWxlMi5kZWZhdWx0KTtcblxuXHRleHBvcnRzLmRlZmF1bHQgPSBUd2VlbmFibGU7XG5cbi8qKiovIH0pLFxuLyogMTAxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cblx0dmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0KTtcblxuXHR2YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cblx0dmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9fd2VicGFja19yZXF1aXJlX18oNzUpO1xuXG5cdHZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMik7XG5cblx0dmFyIF9pbmhlcml0czIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc2KTtcblxuXHR2YXIgX2luaGVyaXRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luaGVyaXRzMik7XG5cblx0dmFyIF9oID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MSk7XG5cblx0dmFyIF9oMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2gpO1xuXG5cdHZhciBfdHdlZW5lciA9IF9fd2VicGFja19yZXF1aXJlX18oMTAyKTtcblxuXHR2YXIgX3R3ZWVuZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHdlZW5lcik7XG5cblx0dmFyIF9lYXNpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwNSk7XG5cblx0dmFyIF9lYXNpbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZWFzaW5nKTtcblxuXHR2YXIgX21vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oODQpO1xuXG5cdHZhciBfbW9kdWxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21vZHVsZSk7XG5cblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuXHQvLyBpbXBvcnQgaCBmcm9tICcuLi9oJztcblx0dmFyIFR3ZWVuID0gZnVuY3Rpb24gKF9Nb2R1bGUpIHtcblx0ICAoMCwgX2luaGVyaXRzMy5kZWZhdWx0KShUd2VlbiwgX01vZHVsZSk7XG5cblx0ICAvKlxuXHQgICAgTWV0aG9kIGRvIGRlY2xhcmUgZGVmYXVsdHMgd2l0aCB0aGlzLl9kZWZhdWx0cyBvYmplY3QuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cdCAgVHdlZW4ucHJvdG90eXBlLl9kZWNsYXJlRGVmYXVsdHMgPSBmdW5jdGlvbiBfZGVjbGFyZURlZmF1bHRzKCkge1xuXHQgICAgLy8gREVGQVVMVFNcblx0ICAgIHRoaXMuX2RlZmF1bHRzID0ge1xuXHQgICAgICAvKiBkdXJhdGlvbiBvZiB0aGUgdHdlZW4gWzAuLuKInl0gKi9cblx0ICAgICAgZHVyYXRpb246IDM1MCxcblx0ICAgICAgLyogZGVsYXkgb2YgdGhlIHR3ZWVuIFst4oieLi7iiJ5dICovXG5cdCAgICAgIGRlbGF5OiAwLFxuXHQgICAgICAvKiByZXBlYXQgb2YgdGhlIHR3ZWVuIFswLi7iiJ5dLCBtZWFucyBob3cgbXVjaCB0b1xuXHQgICAgICAgICByZXBlYXQgdGhlIHR3ZWVuIHJlZ2FyZGxlc3MgZmlyc3QgcnVuLFxuXHQgICAgICAgICBmb3IgaW5zdGFuY2UgcmVwZWF0OiAyIHdpbGwgbWFrZSB0aGUgdHdlZW4gcnVuIDMgdGltZXMgKi9cblx0ICAgICAgcmVwZWF0OiAwLFxuXHQgICAgICAvKiBzcGVlZCBvZiBwbGF5YmFjayBbMC4u4oieXSwgc3BlZWQgdGhhdCBpcyBsZXNzIHRoZW4gMVxuXHQgICAgICAgICB3aWxsIHNsb3dkb3duIHBsYXliYWNrLCBmb3IgaW5zdGFuY2UgLjUgd2lsbCBtYWtlIHR3ZWVuXG5cdCAgICAgICAgIHJ1biAyeCBzbG93ZXIuIFNwZWVkIG9mIDIgd2lsbCBzcGVlZHVwIHRoZSB0d2VlbiB0byAyeC4gKi9cblx0ICAgICAgc3BlZWQ6IDEsXG5cdCAgICAgIC8qICBmbGlwIG9uVXBkYXRlJ3MgcHJvZ3Jlc3Mgb24gZWFjaCBldmVuIHBlcmlvZC5cblx0ICAgICAgICAgIG5vdGUgdGhhdCBjYWxsYmFja3Mgb3JkZXIgd29uJ3QgZmxpcCBhdCBsZWFzdFxuXHQgICAgICAgICAgZm9yIG5vdyAodW5kZXIgY29uc2lkZXJhdGlvbikuICovXG5cdCAgICAgIGlzWW95bzogZmFsc2UsXG5cdCAgICAgIC8qIGVhc2luZyBmb3IgdGhlIHR3ZWVuLCBjb3VsZCBiZSBhbnkgZWFzaW5nIHR5cGUgW2xpbmsgdG8gZWFzaW5nLXR5cGVzLm1kXSAqL1xuXHQgICAgICBlYXNpbmc6ICdTaW4uT3V0Jyxcblx0ICAgICAgLypcblx0ICAgICAgICBFYXNpbmcgZm9yIGJhY2t3YXJkIGRpcmVjdGlvbiBvZiB0aGUgdHdlZW50aGUgdHdlZW4sXG5cdCAgICAgICAgaWYgYG51bGxgIC0gZmFsbGJhY2tzIHRvIGBlYXNpbmdgIHByb3BlcnR5LlxuXHQgICAgICAgIGZvcndhcmQgZGlyZWN0aW9uIGluIGB5b3lvYCBwZXJpb2QgaXMgdHJlYXRlZCBhcyBiYWNrd2FyZCBmb3IgdGhlIGVhc2luZy5cblx0ICAgICAgKi9cblx0ICAgICAgYmFja3dhcmRFYXNpbmc6IG51bGwsXG5cdCAgICAgIC8qIGN1c3RvbSB0d2VlbidzIG5hbWUgKi9cblx0ICAgICAgbmFtZTogbnVsbCxcblx0ICAgICAgLyogY3VzdG9tIHR3ZWVuJ3MgYmFzZSBuYW1lICovXG5cdCAgICAgIG5hbWVCYXNlOiAnVHdlZW4nLFxuXHQgICAgICAvKlxuXHQgICAgICAgIG9uUHJvZ3Jlc3MgY2FsbGJhY2sgcnVucyBiZWZvcmUgYW55IG90aGVyIGNhbGxiYWNrLlxuXHQgICAgICAgIEBwYXJhbSB7TnVtYmVyfSAgIFRoZSBlbnRpcmUsIG5vdCBlYXNlZCwgcHJvZ3Jlc3Ncblx0ICAgICAgICAgICAgICAgICAgICAgICAgICBvZiB0aGUgdHdlZW4gcmVnYXJkaW5nIHJlcGVhdCBvcHRpb24uXG5cdCAgICAgICAgQHBhcmFtIHtCb29sZWFufSAgVGhlIGRpcmVjdGlvbiBvZiB0aGUgdHdlZW4uXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgYHRydWVgIGZvciBmb3J3YXJkIGRpcmVjdGlvbi5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICBgZmFsc2VgIGZvciBiYWNrd2FyZCBkaXJlY3Rpb24odHdlZW4gcnVucyBpbiByZXZlcnNlKS5cblx0ICAgICAgKi9cblx0ICAgICAgb25Qcm9ncmVzczogbnVsbCxcblx0ICAgICAgLypcblx0ICAgICAgICBvblN0YXJ0IGNhbGxiYWNrIHJ1bnMgb24gdmVyeSBzdGFydCBvZiB0aGUgdHdlZW4ganVzdCBhZnRlciBvblByb2dyZXNzXG5cdCAgICAgICAgb25lLiBSdW5zIG9uIHZlcnkgZW5kIG9mIHRoZSB0d2VlbiBpZiB0d2VlbiBpcyByZXZlcnNlZC5cblx0ICAgICAgICBAcGFyYW0ge0Jvb2xlYW59ICBEaXJlY3Rpb24gb2YgdGhlIHR3ZWVuLlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgIGB0cnVlYCBmb3IgZm9yd2FyZCBkaXJlY3Rpb24uXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgYGZhbHNlYCBmb3IgYmFja3dhcmQgZGlyZWN0aW9uKHR3ZWVuIHJ1bnMgaW4gcmV2ZXJzZSkuXG5cdCAgICAgICovXG5cdCAgICAgIG9uU3RhcnQ6IG51bGwsXG5cdCAgICAgIG9uUmVmcmVzaDogbnVsbCxcblx0ICAgICAgb25Db21wbGV0ZTogbnVsbCxcblx0ICAgICAgb25SZXBlYXRTdGFydDogbnVsbCxcblx0ICAgICAgb25SZXBlYXRDb21wbGV0ZTogbnVsbCxcblx0ICAgICAgb25GaXJzdFVwZGF0ZTogbnVsbCxcblx0ICAgICAgb25VcGRhdGU6IG51bGwsXG5cdCAgICAgIGlzQ2hhaW5lZDogZmFsc2UsXG5cdCAgICAgIC8vIHBsYXliYWNrIGNhbGxiYWNrc1xuXHQgICAgICBvblBsYXliYWNrU3RhcnQ6IG51bGwsXG5cdCAgICAgIG9uUGxheWJhY2tQYXVzZTogbnVsbCxcblx0ICAgICAgb25QbGF5YmFja1N0b3A6IG51bGwsXG5cdCAgICAgIG9uUGxheWJhY2tDb21wbGV0ZTogbnVsbCxcblx0ICAgICAgLy8gY29udGV4dCB3aGljaCBhbGwgY2FsbGJhY2tzIHdpbGwgYmUgY2FsbGVkIHdpdGhcblx0ICAgICAgY2FsbGJhY2tzQ29udGV4dDogbnVsbFxuXHQgICAgfTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBBUEkgbWV0aG9kIHRvIHBsYXkgdGhlIFR3ZWVuLlxuXHQgICAgQHB1YmxpY1xuXHQgICAgQHBhcmFtICB7TnVtYmVyfSBTaGlmdCB0aW1lIGluIG1pbGxpc2Vjb25kcy5cblx0ICAgIEByZXR1cm4ge09iamVjdH0gU2VsZi5cblx0ICAqL1xuXG5cblx0ICBUd2Vlbi5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uIHBsYXkoKSB7XG5cdCAgICB2YXIgc2hpZnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG5cblx0ICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gJ3BsYXknICYmIHRoaXMuX2lzUnVubmluZykge1xuXHQgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH1cblx0ICAgIHRoaXMuX3Byb3BzLmlzUmV2ZXJzZWQgPSBmYWxzZTtcblx0ICAgIHRoaXMuX3N1YlBsYXkoc2hpZnQsICdwbGF5Jyk7XG5cdCAgICB0aGlzLl9zZXRQbGF5YmFja1N0YXRlKCdwbGF5Jyk7XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBBUEkgbWV0aG9kIHRvIHBsYXkgdGhlIFR3ZWVuIGluIHJldmVyc2UuXG5cdCAgICBAcHVibGljXG5cdCAgICBAcGFyYW0gIHtOdW1iZXJ9IFNoaWZ0IHRpbWUgaW4gbWlsbGlzZWNvbmRzLlxuXHQgICAgQHJldHVybiB7T2JqZWN0fSBTZWxmLlxuXHQgICovXG5cblxuXHQgIFR3ZWVuLnByb3RvdHlwZS5wbGF5QmFja3dhcmQgPSBmdW5jdGlvbiBwbGF5QmFja3dhcmQoKSB7XG5cdCAgICB2YXIgc2hpZnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG5cblx0ICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gJ3JldmVyc2UnICYmIHRoaXMuX2lzUnVubmluZykge1xuXHQgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH1cblx0ICAgIHRoaXMuX3Byb3BzLmlzUmV2ZXJzZWQgPSB0cnVlO1xuXHQgICAgdGhpcy5fc3ViUGxheShzaGlmdCwgJ3JldmVyc2UnKTtcblx0ICAgIHRoaXMuX3NldFBsYXliYWNrU3RhdGUoJ3JldmVyc2UnKTtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIEFQSSBtZXRob2QgdG8gcGF1c2UgVHdlZW4uXG5cdCAgICBAcHVibGljXG5cdCAgICBAcmV0dXJucyB7T2JqZWN0fSBTZWxmLlxuXHQgICovXG5cblxuXHQgIFR3ZWVuLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uIHBhdXNlKCkge1xuXHQgICAgaWYgKHRoaXMuX3N0YXRlID09PSAncGF1c2UnIHx8IHRoaXMuX3N0YXRlID09PSAnc3RvcCcpIHtcblx0ICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9XG5cdCAgICB0aGlzLl9yZW1vdmVGcm9tVHdlZW5lcigpO1xuXHQgICAgdGhpcy5fc2V0UGxheWJhY2tTdGF0ZSgncGF1c2UnKTtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIEFQSSBtZXRob2QgdG8gc3RvcCB0aGUgVHdlZW4uXG5cdCAgICBAcHVibGljXG5cdCAgICBAcGFyYW0gICB7TnVtYmVyfSBQcm9ncmVzcyBbMC4uMV0gdG8gc2V0IHdoZW4gc3RvcHBlZC5cblx0ICAgIEByZXR1cm5zIHtPYmplY3R9IFNlbGYuXG5cdCAgKi9cblxuXG5cdCAgVHdlZW4ucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiBzdG9wKHByb2dyZXNzKSB7XG5cdCAgICBpZiAodGhpcy5fc3RhdGUgPT09ICdzdG9wJykge1xuXHQgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH1cblxuXHQgICAgdGhpcy5fd2FzVWtub3duVXBkYXRlID0gdW5kZWZpbmVkO1xuXG5cdCAgICB2YXIgc3RvcFByb2MgPSBwcm9ncmVzcyAhPSBudWxsID8gcHJvZ3Jlc3Ncblx0ICAgIC8qIGlmIG5vIHByb2dyZXNzIHBhc3NzZWQgLSBzZXQgMSBpZiB0d2VlblxuXHQgICAgICAgaXMgcGxheWluZ0JhY2t3YXJkLCBvdGhlcndpc2Ugc2V0IHRvIDAgKi9cblx0ICAgIDogdGhpcy5fc3RhdGUgPT09ICdyZXZlcnNlJyA/IDEgOiAwO1xuXG5cdCAgICB0aGlzLnNldFByb2dyZXNzKHN0b3BQcm9jKTtcblxuXHQgICAgdGhpcy5yZXNldCgpO1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgQVBJIG1ldGhvZCB0byByZXBsYXkocmVzdGFydCkgdGhlIFR3ZWVuLlxuXHQgICAgQHB1YmxpY1xuXHQgICAgQHBhcmFtICAge051bWJlcn0gU2hpZnQgdGltZSBpbiBtaWxsaXNlY29uZHMuXG5cdCAgICBAcmV0dXJucyB7T2JqZWN0fSBTZWxmLlxuXHQgICovXG5cblxuXHQgIFR3ZWVuLnByb3RvdHlwZS5yZXBsYXkgPSBmdW5jdGlvbiByZXBsYXkoKSB7XG5cdCAgICB2YXIgc2hpZnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG5cblx0ICAgIHRoaXMucmVzZXQoKTtcblx0ICAgIHRoaXMucGxheShzaGlmdCk7XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBBUEkgbWV0aG9kIHRvIHJlcGxheShyZXN0YXJ0KSBiYWNrd2FyZCB0aGUgVHdlZW4uXG5cdCAgICBAcHVibGljXG5cdCAgICBAcGFyYW0gICB7TnVtYmVyfSBTaGlmdCB0aW1lIGluIG1pbGxpc2Vjb25kcy5cblx0ICAgIEByZXR1cm5zIHtPYmplY3R9IFNlbGYuXG5cdCAgKi9cblxuXG5cdCAgVHdlZW4ucHJvdG90eXBlLnJlcGxheUJhY2t3YXJkID0gZnVuY3Rpb24gcmVwbGF5QmFja3dhcmQoKSB7XG5cdCAgICB2YXIgc2hpZnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG5cblx0ICAgIHRoaXMucmVzZXQoKTtcblx0ICAgIHRoaXMucGxheUJhY2t3YXJkKHNoaWZ0KTtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIEFQSSBtZXRob2QgdG8gcmVzdW1lIHRoZSBUd2Vlbi5cblx0ICAgIEBwdWJsaWNcblx0ICAgIEBwYXJhbSAge051bWJlcn0gU2hpZnQgdGltZSBpbiBtaWxsaXNlY29uZHMuXG5cdCAgICBAcmV0dXJuIHtPYmplY3R9IFNlbGYuXG5cdCAgKi9cblxuXG5cdCAgVHdlZW4ucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uIHJlc3VtZSgpIHtcblx0ICAgIHZhciBzaGlmdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcblxuXHQgICAgaWYgKHRoaXMuX3N0YXRlICE9PSAncGF1c2UnKSB7XG5cdCAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfVxuXG5cdCAgICBzd2l0Y2ggKHRoaXMuX3ByZXZTdGF0ZSkge1xuXHQgICAgICBjYXNlICdwbGF5Jzpcblx0ICAgICAgICB0aGlzLnBsYXkoc2hpZnQpO1xuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgICBjYXNlICdyZXZlcnNlJzpcblx0ICAgICAgICB0aGlzLnBsYXlCYWNrd2FyZChzaGlmdCk7XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIEFQSSBtZXRob2QgdG8gc2V0IHByb2dyZXNzIG9uIHR3ZWVuLlxuXHQgICAgQHB1YmxpY1xuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IFByb2dyZXNzIHRvIHNldC5cblx0ICAgIEByZXR1cm5zIHtPYmplY3R9IFNlbGYuXG5cdCAgKi9cblxuXG5cdCAgVHdlZW4ucHJvdG90eXBlLnNldFByb2dyZXNzID0gZnVuY3Rpb24gc2V0UHJvZ3Jlc3MocHJvZ3Jlc3MpIHtcblx0ICAgIHZhciBwID0gdGhpcy5fcHJvcHM7XG5cdCAgICAvLyBzZXQgc3RhcnQgdGltZSBpZiB0aGVyZSBpcyBubyBvbmUgeWV0LlxuXHQgICAgIXAuc3RhcnRUaW1lICYmIHRoaXMuX3NldFN0YXJ0VGltZSgpO1xuXHQgICAgLy8gcmVzZXQgcGxheSB0aW1lXG5cdCAgICB0aGlzLl9wbGF5VGltZSA9IG51bGw7XG5cdCAgICAvLyBwcm9ncmVzcyBzaG91bGQgYmUgaW4gcmFuZ2Ugb2YgWzAuLjFdXG5cdCAgICBwcm9ncmVzcyA8IDAgJiYgKHByb2dyZXNzID0gMCk7XG5cdCAgICBwcm9ncmVzcyA+IDEgJiYgKHByb2dyZXNzID0gMSk7XG5cdCAgICAvLyB1cGRhdGUgc2VsZiB3aXRoIGNhbGN1bGF0ZWQgdGltZVxuXHQgICAgdGhpcy5fdXBkYXRlKHAuc3RhcnRUaW1lIC0gcC5kZWxheSArIHByb2dyZXNzICogcC5yZXBlYXRUaW1lKTtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBzZXQgdHdlZW4ncyBzcGVlZC5cblx0ICAgIEBwdWJsaWNcblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBTcGVlZCB2YWx1ZS5cblx0ICAgIEByZXR1cm5zIHRoaXMuXG5cdCAgKi9cblxuXG5cdCAgVHdlZW4ucHJvdG90eXBlLnNldFNwZWVkID0gZnVuY3Rpb24gc2V0U3BlZWQoc3BlZWQpIHtcblx0ICAgIHRoaXMuX3Byb3BzLnNwZWVkID0gc3BlZWQ7XG5cdCAgICAvLyBpZiBwbGF5aW5nIC0gbm9ybWFsaXplIF9zdGFydFRpbWUgYW5kIF9wcmV2VGltZSB0byB0aGUgY3VycmVudCBwb2ludC5cblx0ICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gJ3BsYXknIHx8IHRoaXMuX3N0YXRlID09PSAncmV2ZXJzZScpIHtcblx0ICAgICAgdGhpcy5fc2V0UmVzdW1lVGltZSh0aGlzLl9zdGF0ZSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gcmVzZXQgdHdlZW4ncyBzdGF0ZSBhbmQgcHJvcGVydGllcy5cblx0ICAgIEBwdWJsaWNcblx0ICAgIEByZXR1cm5zIHRoaXMuXG5cdCAgKi9cblxuXG5cdCAgVHdlZW4ucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG5cdCAgICB0aGlzLl9yZW1vdmVGcm9tVHdlZW5lcigpO1xuXHQgICAgdGhpcy5fc2V0UGxheWJhY2tTdGF0ZSgnc3RvcCcpO1xuXHQgICAgdGhpcy5fcHJvZ3Jlc3NUaW1lID0gMDtcblx0ICAgIHRoaXMuX2lzQ29tcGxldGVkID0gZmFsc2U7XG5cdCAgICB0aGlzLl9pc1N0YXJ0ZWQgPSBmYWxzZTtcblx0ICAgIHRoaXMuX2lzRmlyc3RVcGRhdGUgPSBmYWxzZTtcblx0ICAgIHRoaXMuX3dhc1Vrbm93blVwZGF0ZSA9IHVuZGVmaW5lZDtcblx0ICAgIHRoaXMuX3ByZXZUaW1lID0gdW5kZWZpbmVkO1xuXHQgICAgdGhpcy5fcHJldllveW8gPSB1bmRlZmluZWQ7XG5cdCAgICAvLyB0aGlzLl9wcm9wcy5zdGFydFRpbWUgID0gdW5kZWZpbmVkO1xuXHQgICAgdGhpcy5fcHJvcHMuaXNSZXZlcnNlZCA9IGZhbHNlO1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblxuXHQgIC8vIF4gUFVCTElDICBNRVRIT0QoUykgXlxuXHQgIC8vIHYgUFJJVkFURSBNRVRIT0QoUykgdlxuXG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBsYXVuY2ggcGxheS4gVXNlZCBhcyBsYXVuY2hcblx0ICAgIG1ldGhvZCBmb3IgYm90aHBsYXkgYW5kIHJldmVyc2UgbWV0aG9kcy5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0gIHtOdW1iZXJ9IFNoaWZ0IHRpbWUgaW4gbWlsbGlzZWNvbmRzLlxuXHQgICAgQHBhcmFtICB7U3RyaW5nfSBQbGF5IG9yIHJldmVyc2Ugc3RhdGUuXG5cdCAgICBAcmV0dXJuIHtPYmplY3R9IFNlbGYuXG5cdCAgKi9cblxuXG5cdCAgVHdlZW4ucHJvdG90eXBlLl9zdWJQbGF5ID0gZnVuY3Rpb24gX3N1YlBsYXkoKSB7XG5cdCAgICB2YXIgc2hpZnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG5cdCAgICB2YXIgc3RhdGUgPSBhcmd1bWVudHNbMV07XG5cblx0ICAgIHZhciByZXN1bWVUaW1lLFxuXHQgICAgICAgIHN0YXJ0VGltZSxcblx0ICAgICAgICBwID0gdGhpcy5fcHJvcHMsXG5cblx0ICAgIC8vIGNoZWNrIGlmIGRpcmVjdGlvbiBvZiBwbGF5YmFjayBjaGFuZ2VzLFxuXHQgICAgLy8gaWYgc28sIHRoZSBfcHJvZ3Jlc3NUaW1lIG5lZWRzIHRvIGJlIGZsaXBwZWRcblx0ICAgIF9zdGF0ZSA9IHRoaXMuX3N0YXRlLFxuXHQgICAgICAgIF9wcmV2U3RhdGUgPSB0aGlzLl9wcmV2U3RhdGUsXG5cdCAgICAgICAgaXNQYXVzZSA9IF9zdGF0ZSA9PT0gJ3BhdXNlJyxcblx0ICAgICAgICB3YXNQbGF5ID0gX3N0YXRlID09PSAncGxheScgfHwgaXNQYXVzZSAmJiBfcHJldlN0YXRlID09PSAncGxheScsXG5cdCAgICAgICAgd2FzUmV2ZXJzZSA9IF9zdGF0ZSA9PT0gJ3JldmVyc2UnIHx8IGlzUGF1c2UgJiYgX3ByZXZTdGF0ZSA9PT0gJ3JldmVyc2UnLFxuXHQgICAgICAgIGlzRmxpcCA9IHdhc1BsYXkgJiYgc3RhdGUgPT09ICdyZXZlcnNlJyB8fCB3YXNSZXZlcnNlICYmIHN0YXRlID09PSAncGxheSc7XG5cblx0ICAgIC8vIGlmIHR3ZWVuIHdhcyBlbmRlZCwgc2V0IHByb2dyZXNzIHRvIDAgaWYgbm90LCBzZXQgdG8gZWxhcHNlZCBwcm9ncmVzc1xuXHQgICAgdGhpcy5fcHJvZ3Jlc3NUaW1lID0gdGhpcy5fcHJvZ3Jlc3NUaW1lID49IHAucmVwZWF0VGltZSA/IDAgOiB0aGlzLl9wcm9ncmVzc1RpbWU7XG5cdCAgICAvLyBmbGlwIHRoZSBfcHJvZ3Jlc3NUaW1lIGlmIHBsYXliYWNrIGRpcmVjdGlvbiBjaGFuZ2VkXG5cdCAgICBpZiAoaXNGbGlwKSB7XG5cdCAgICAgIHRoaXMuX3Byb2dyZXNzVGltZSA9IHAucmVwZWF0VGltZSAtIHRoaXMuX3Byb2dyZXNzVGltZTtcblx0ICAgIH1cblx0ICAgIC8vIHNldCByZXN1bWUgdGltZSBhbmQgbm9ybWFsaXplIHByZXYvc3RhcnQgdGltZXNcblx0ICAgIHRoaXMuX3NldFJlc3VtZVRpbWUoc3RhdGUsIHNoaWZ0KTtcblx0ICAgIC8vIGFkZCBzZWxmIHRvIHR3ZWVuZXIgPSBwbGF5XG5cdCAgICBfdHdlZW5lcjIuZGVmYXVsdC5hZGQodGhpcyk7XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gc2V0IF9yZXN1bWVUaW1lLCBfc3RhcnRUaW1lIGFuZCBfcHJldlRpbWUuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtTdHJpbmd9IEN1cnJlbnQgc3RhdGUuIFtwbGF5LCByZXZlcnNlXVxuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IFRpbWUgc2hpZnQuICpEZWZhdWx0KiBpcyAwLlxuXHQgICovXG5cblxuXHQgIFR3ZWVuLnByb3RvdHlwZS5fc2V0UmVzdW1lVGltZSA9IGZ1bmN0aW9uIF9zZXRSZXN1bWVUaW1lKHN0YXRlKSB7XG5cdCAgICB2YXIgc2hpZnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG5cblx0ICAgIC8vIGdldCBjdXJyZW50IG1vbWVudCBhcyByZXN1bWUgdGltZVxuXHQgICAgdGhpcy5fcmVzdW1lVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXHQgICAgLy8gc2V0IHN0YXJ0IHRpbWUgcmVnYXJkaW5nIHBhc3NlZCBgc2hpZnRgIGFuZCBgcHJvY1RpbWVgXG5cdCAgICB2YXIgc3RhcnRUaW1lID0gdGhpcy5fcmVzdW1lVGltZSAtIE1hdGguYWJzKHNoaWZ0KSAtIHRoaXMuX3Byb2dyZXNzVGltZTtcblx0ICAgIHRoaXMuX3NldFN0YXJ0VGltZShzdGFydFRpbWUsIGZhbHNlKTtcblx0ICAgIC8vIGlmIHdlIGhhdmUgcHJldlRpbWUgLSB3ZSBuZWVkIHRvIG5vcm1hbGl6ZVxuXHQgICAgLy8gaXQgZm9yIHRoZSBjdXJyZW50IHJlc3VtZSB0aW1lXG5cdCAgICBpZiAodGhpcy5fcHJldlRpbWUgIT0gbnVsbCkge1xuXHQgICAgICB0aGlzLl9wcmV2VGltZSA9IHN0YXRlID09PSAncGxheScgPyB0aGlzLl9ub3JtUHJldlRpbWVGb3J3YXJkKCkgOiB0aGlzLl9wcm9wcy5lbmRUaW1lIC0gdGhpcy5fcHJvZ3Jlc3NUaW1lO1xuXHQgICAgfVxuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCByZWNhbGN1bGF0ZSBfcHJldlRpbWUgZm9yIGZvcndhcmQgZGlyZWN0aW9uLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEByZXR1cm4ge051bWJlcn0gTm9ybWFsaXplZCBwcmV2IHRpbWUuXG5cdCAgKi9cblxuXG5cdCAgVHdlZW4ucHJvdG90eXBlLl9ub3JtUHJldlRpbWVGb3J3YXJkID0gZnVuY3Rpb24gX25vcm1QcmV2VGltZUZvcndhcmQoKSB7XG5cdCAgICB2YXIgcCA9IHRoaXMuX3Byb3BzO1xuXHQgICAgcmV0dXJuIHAuc3RhcnRUaW1lICsgdGhpcy5fcHJvZ3Jlc3NUaW1lIC0gcC5kZWxheTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBDb25zdHJ1Y3RvciBvZiB0aGUgY2xhc3MuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIGZ1bmN0aW9uIFR3ZWVuKCkge1xuXHQgICAgdmFyIF9yZXQ7XG5cblx0ICAgIHZhciBvID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblx0ICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIFR3ZWVuKTtcblxuXHQgICAgdmFyIF90aGlzID0gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMy5kZWZhdWx0KSh0aGlzLCBfTW9kdWxlLmNhbGwodGhpcywgbykpO1xuXG5cdCAgICBfdGhpcy5fcHJvcHMubmFtZSA9PSBudWxsICYmIF90aGlzLl9zZXRTZWxmTmFtZSgpO1xuXHQgICAgcmV0dXJuIF9yZXQgPSBfdGhpcywgKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMy5kZWZhdWx0KShfdGhpcywgX3JldCk7XG5cdCAgfVxuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gc2V0IHNlbGYgbmFtZSB0byBnZW5lcmljIG9uZS5cblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblxuXG5cdCAgVHdlZW4ucHJvdG90eXBlLl9zZXRTZWxmTmFtZSA9IGZ1bmN0aW9uIF9zZXRTZWxmTmFtZSgpIHtcblx0ICAgIHZhciBnbG9iYWxOYW1lID0gJ18nICsgdGhpcy5fcHJvcHMubmFtZUJhc2UgKyAncyc7XG5cdCAgICAvLyB0cmFjayBhbW91bnQgb2YgdHdlZW5zIGdsb2JhbGx5XG5cdCAgICBfdHdlZW5lcjIuZGVmYXVsdFtnbG9iYWxOYW1lXSA9IF90d2VlbmVyMi5kZWZhdWx0W2dsb2JhbE5hbWVdID09IG51bGwgPyAxIDogKytfdHdlZW5lcjIuZGVmYXVsdFtnbG9iYWxOYW1lXTtcblx0ICAgIC8vIGFuZCBzZXQgZ2VuZXJpYyB0d2VlbidzIG5hbWUgIHx8IFR3ZWVuICMgfHxcblx0ICAgIHRoaXMuX3Byb3BzLm5hbWUgPSB0aGlzLl9wcm9wcy5uYW1lQmFzZSArICcgJyArIF90d2VlbmVyMi5kZWZhdWx0W2dsb2JhbE5hbWVdO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCBzZXQgcGxheWJhY2sgc3RhdGUgc3RyaW5nLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7U3RyaW5nfSBTdGF0ZSBuYW1lXG5cdCAgKi9cblxuXG5cdCAgVHdlZW4ucHJvdG90eXBlLl9zZXRQbGF5YmFja1N0YXRlID0gZnVuY3Rpb24gX3NldFBsYXliYWNrU3RhdGUoc3RhdGUpIHtcblx0ICAgIC8vIHNhdmUgcHJldmlvdXMgc3RhdGVcblx0ICAgIHRoaXMuX3ByZXZTdGF0ZSA9IHRoaXMuX3N0YXRlO1xuXHQgICAgdGhpcy5fc3RhdGUgPSBzdGF0ZTtcblxuXHQgICAgLy8gY2FsbGJhY2tzXG5cdCAgICB2YXIgd2FzUGF1c2UgPSB0aGlzLl9wcmV2U3RhdGUgPT09ICdwYXVzZScsXG5cdCAgICAgICAgd2FzU3RvcCA9IHRoaXMuX3ByZXZTdGF0ZSA9PT0gJ3N0b3AnLFxuXHQgICAgICAgIHdhc1BsYXkgPSB0aGlzLl9wcmV2U3RhdGUgPT09ICdwbGF5Jyxcblx0ICAgICAgICB3YXNSZXZlcnNlID0gdGhpcy5fcHJldlN0YXRlID09PSAncmV2ZXJzZScsXG5cdCAgICAgICAgd2FzUGxheWluZyA9IHdhc1BsYXkgfHwgd2FzUmV2ZXJzZSxcblx0ICAgICAgICB3YXNTdGlsbCA9IHdhc1N0b3AgfHwgd2FzUGF1c2U7XG5cblx0ICAgIGlmICgoc3RhdGUgPT09ICdwbGF5JyB8fCBzdGF0ZSA9PT0gJ3JldmVyc2UnKSAmJiB3YXNTdGlsbCkge1xuXHQgICAgICB0aGlzLl9wbGF5YmFja1N0YXJ0KCk7XG5cdCAgICB9XG5cdCAgICBpZiAoc3RhdGUgPT09ICdwYXVzZScgJiYgd2FzUGxheWluZykge1xuXHQgICAgICB0aGlzLl9wbGF5YmFja1BhdXNlKCk7XG5cdCAgICB9XG5cdCAgICBpZiAoc3RhdGUgPT09ICdzdG9wJyAmJiAod2FzUGxheWluZyB8fCB3YXNQYXVzZSkpIHtcblx0ICAgICAgdGhpcy5fcGxheWJhY2tTdG9wKCk7XG5cdCAgICB9XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGRlY2xhcmUgc29tZSB2YXJzLlxuXHQgICAgQHByaXZhdGVcblx0ICAqL1xuXG5cblx0ICBUd2Vlbi5wcm90b3R5cGUuX3ZhcnMgPSBmdW5jdGlvbiBfdmFycygpIHtcblx0ICAgIHRoaXMucHJvZ3Jlc3MgPSAwO1xuXHQgICAgdGhpcy5fcHJldlRpbWUgPSB1bmRlZmluZWQ7XG5cdCAgICB0aGlzLl9wcm9ncmVzc1RpbWUgPSAwO1xuXHQgICAgdGhpcy5fbmVnYXRpdmVTaGlmdCA9IDA7XG5cdCAgICB0aGlzLl9zdGF0ZSA9ICdzdG9wJztcblx0ICAgIC8vIGlmIG5lZ2F0aXZlIGRlbGF5IHdhcyBzcGVjaWZpZWQsXG5cdCAgICAvLyBzYXZlIGl0IHRvIF9uZWdhdGl2ZVNoaWZ0IHByb3BlcnR5IGFuZFxuXHQgICAgLy8gcmVzZXQgaXQgYmFjayB0byAwXG5cdCAgICBpZiAodGhpcy5fcHJvcHMuZGVsYXkgPCAwKSB7XG5cdCAgICAgIHRoaXMuX25lZ2F0aXZlU2hpZnQgPSB0aGlzLl9wcm9wcy5kZWxheTtcblx0ICAgICAgdGhpcy5fcHJvcHMuZGVsYXkgPSAwO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdGhpcy5fY2FsY0RpbWVudGlvbnMoKTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gY2FsY3VsYXRlIHR3ZWVuJ3MgZGltZW50aW9ucy5cblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblxuXG5cdCAgVHdlZW4ucHJvdG90eXBlLl9jYWxjRGltZW50aW9ucyA9IGZ1bmN0aW9uIF9jYWxjRGltZW50aW9ucygpIHtcblx0ICAgIHRoaXMuX3Byb3BzLnRpbWUgPSB0aGlzLl9wcm9wcy5kdXJhdGlvbiArIHRoaXMuX3Byb3BzLmRlbGF5O1xuXHQgICAgdGhpcy5fcHJvcHMucmVwZWF0VGltZSA9IHRoaXMuX3Byb3BzLnRpbWUgKiAodGhpcy5fcHJvcHMucmVwZWF0ICsgMSk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGV4dGVuZCBkZWZhdWx0cyBieSBvcHRpb25zIGFuZCBwdXQgdGhlbSBpbiBfcHJvcHMuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIFR3ZWVuLnByb3RvdHlwZS5fZXh0ZW5kRGVmYXVsdHMgPSBmdW5jdGlvbiBfZXh0ZW5kRGVmYXVsdHMoKSB7XG5cdCAgICAvLyBzYXZlIGNhbGxiYWNrIG92ZXJyaWRlcyBvYmplY3Qgd2l0aCBmYWxsYmFjayB0byBlbXB0eSBvbmVcblx0ICAgIHRoaXMuX2NhbGxiYWNrT3ZlcnJpZGVzID0gdGhpcy5fby5jYWxsYmFja092ZXJyaWRlcyB8fCB7fTtcblx0ICAgIGRlbGV0ZSB0aGlzLl9vLmNhbGxiYWNrT3ZlcnJpZGVzO1xuXHQgICAgLy8gY2FsbCB0aGUgX2V4dGVuZERlZmF1bHRzIEAgTW9kdWxlXG5cdCAgICBfTW9kdWxlLnByb3RvdHlwZS5fZXh0ZW5kRGVmYXVsdHMuY2FsbCh0aGlzKTtcblxuXHQgICAgdmFyIHAgPSB0aGlzLl9wcm9wcztcblx0ICAgIHAuZWFzaW5nID0gX2Vhc2luZzIuZGVmYXVsdC5wYXJzZUVhc2luZyhwLmVhc2luZyk7XG5cdCAgICBwLmVhc2luZy5fcGFyZW50ID0gdGhpcztcblxuXHQgICAgLy8gcGFyc2Ugb25seSBwcmVzZW50IGJhY2t3YXJkIGVhc2luZyB0byBwcmV2ZW50IHBhcnNpbmcgYXMgYGxpbmVhci5ub25lYFxuXHQgICAgLy8gYmVjYXVzZSB3ZSBuZWVkIHRvIGZhbGxiYWNrIHRvIGBlYXNpbmdgIGluIGBfc2V0UHJvZ3Jlc3NgIG1ldGhvZFxuXHQgICAgaWYgKHAuYmFja3dhcmRFYXNpbmcgIT0gbnVsbCkge1xuXHQgICAgICBwLmJhY2t3YXJkRWFzaW5nID0gX2Vhc2luZzIuZGVmYXVsdC5wYXJzZUVhc2luZyhwLmJhY2t3YXJkRWFzaW5nKTtcblx0ICAgICAgcC5iYWNrd2FyZEVhc2luZy5fcGFyZW50ID0gdGhpcztcblx0ICAgIH1cblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgZm9yIHNldHRpbmcgc3RhcnQgYW5kIGVuZCB0aW1lIHRvIHByb3BzLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7TnVtYmVyKFRpbWVzdGFtcCl9LCB7TnVsbH0gU3RhcnQgdGltZS5cblx0ICAgIEBwYXJhbSB7Qm9vbGVhbn0gU2hvdWxkIHJlc2V0IGZsYWdzLlxuXHQgICAgQHJldHVybnMgdGhpc1xuXHQgICovXG5cblxuXHQgIFR3ZWVuLnByb3RvdHlwZS5fc2V0U3RhcnRUaW1lID0gZnVuY3Rpb24gX3NldFN0YXJ0VGltZSh0aW1lKSB7XG5cdCAgICB2YXIgaXNSZXNldEZsYWdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuXG5cdCAgICB2YXIgcCA9IHRoaXMuX3Byb3BzLFxuXHQgICAgICAgIHNoaWZ0VGltZSA9IHAuc2hpZnRUaW1lIHx8IDA7XG5cdCAgICAvLyByZXNldCBmbGFnc1xuXHQgICAgaWYgKGlzUmVzZXRGbGFncykge1xuXHQgICAgICB0aGlzLl9pc0NvbXBsZXRlZCA9IGZhbHNlO3RoaXMuX2lzUmVwZWF0Q29tcGxldGVkID0gZmFsc2U7XG5cdCAgICAgIHRoaXMuX2lzU3RhcnRlZCA9IGZhbHNlO1xuXHQgICAgfVxuXHQgICAgLy8gc2V0IHN0YXJ0IHRpbWUgdG8gcGFzc2VkIHRpbWUgb3IgdG8gdGhlIGN1cnJlbnQgbW9tZW50XG5cdCAgICB2YXIgc3RhcnRUaW1lID0gdGltZSA9PSBudWxsID8gcGVyZm9ybWFuY2Uubm93KCkgOiB0aW1lO1xuXHQgICAgLy8gY2FsY3VsYXRlIGJvdW5kc1xuXHQgICAgLy8gLSBuZWdhdGl2ZVNoaWZ0IGlzIG5lZ2F0aXZlIGRlbGF5IGluIG9wdGlvbnMgaGFzaFxuXHQgICAgLy8gLSBzaGlmdCB0aW1lIGlzIHNoaWZ0IG9mIHRoZSBwYXJlbnRcblx0ICAgIHAuc3RhcnRUaW1lID0gc3RhcnRUaW1lICsgcC5kZWxheSArIHRoaXMuX25lZ2F0aXZlU2hpZnQgKyBzaGlmdFRpbWU7XG5cdCAgICBwLmVuZFRpbWUgPSBwLnN0YXJ0VGltZSArIHAucmVwZWF0VGltZSAtIHAuZGVsYXk7XG5cdCAgICAvLyBzZXQgcGxheSB0aW1lIHRvIHRoZSBzdGFydFRpbWVzXG5cdCAgICAvLyBpZiBwbGF5YmFjayBjb250cm9scyBhcmUgdXNlZCAtIHVzZSBfcmVzdW1lVGltZSBhcyBwbGF5IHRpbWUsXG5cdCAgICAvLyBlbHNlIHVzZSBzaGlmdGVkIHN0YXJ0VGltZSAtLSBzaGlmdCBpcyBuZWVkZWQgZm9yIHRpbWVsaW5lcyBhcHBlbmQgY2hhaW5zXG5cdCAgICB0aGlzLl9wbGF5VGltZSA9IHRoaXMuX3Jlc3VtZVRpbWUgIT0gbnVsbCA/IHRoaXMuX3Jlc3VtZVRpbWUgOiBzdGFydFRpbWUgKyBzaGlmdFRpbWU7XG5cdCAgICB0aGlzLl9yZXN1bWVUaW1lID0gbnVsbDtcblxuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHVwZGF0ZSB0d2VlbidzIHByb2dyZXNzLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBDdXJyZW50IHVwZGF0ZSB0aW1lLlxuXHQgICAgLS0gbmV4dCBwYXJhbXMgb25seSBwcmVzZW50IHdoZW4gcGFyZW50IFRpbWVsaW5lIGNhbGxzIHRoZSBtZXRob2QuXG5cdCAgICBAcGFyYW0ge051bWJlcn0gUHJldmlvdXMgVGltZWxpbmUncyB1cGRhdGUgdGltZS5cblx0ICAgIEBwYXJhbSB7Qm9vbGVhbn0gV2FzIHBhcmVudCBpbiB5b3lvIHBlcmlvZC5cblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBbLTEsIDAsIDFdIElmIHVwZGF0ZSBpcyBvbiBlZGdlLlxuXHQgICAgICAgICAgICAgICAgICAgLTEgPSBlZGdlIGp1bXAgaW4gbmVnYXRpdmUgZGlyZWN0aW9uLlxuXHQgICAgICAgICAgICAgICAgICAgIDAgPSBubyBlZGdlIGp1bXAuXG5cdCAgICAgICAgICAgICAgICAgICAgMSA9IGVkZ2UganVtcCBpbiBwb3NpdGl2ZSBkaXJlY3Rpb24uXG5cdCAgKi9cblxuXG5cdCAgVHdlZW4ucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiBfdXBkYXRlKHRpbWUsIHRpbWVsaW5lUHJldlRpbWUsIHdhc1lveW8sIG9uRWRnZSkge1xuXHQgICAgdmFyIHAgPSB0aGlzLl9wcm9wcztcblx0ICAgIC8vIGlmIHdlIGRvbid0IHRoZSBfcHJldlRpbWUgdGh1cyB0aGUgZGlyZWN0aW9uIHdlIGFyZSBoZWFkaW5nIHRvLFxuXHQgICAgLy8gYnV0IHByZXZUaW1lIHdhcyBwYXNzZWQgdGh1cyB3ZSBhcmUgY2hpbGQgb2YgYSBUaW1lbGluZVxuXHQgICAgLy8gc2V0IF9wcmV2VGltZSB0byBwYXNzZWQgb25lIGFuZCBwcmV0ZW50IHRoYXQgdGhlcmUgd2FzIHVua25vd25cblx0ICAgIC8vIHVwZGF0ZSB0byBub3QgdG8gYmxvY2sgc3RhcnQvY29tcGxldGUgY2FsbGJhY2tzXG5cdCAgICBpZiAodGhpcy5fcHJldlRpbWUgPT0gbnVsbCAmJiB0aW1lbGluZVByZXZUaW1lICE9IG51bGwpIHtcblxuXHQgICAgICBpZiAodGhpcy5fcHJvcHMuc3BlZWQgJiYgdGhpcy5fcGxheVRpbWUpIHtcblx0ICAgICAgICAvLyBwbGF5IHBvaW50ICsgKCBzcGVlZCAqIGRlbHRhIClcblx0ICAgICAgICB0aGlzLl9wcmV2VGltZSA9IHRoaXMuX3BsYXlUaW1lICsgdGhpcy5fcHJvcHMuc3BlZWQgKiAodGltZWxpbmVQcmV2VGltZSAtIHRoaXMuX3BsYXlUaW1lKTtcblx0ICAgICAgfVxuXHQgICAgICAvLyB0aGlzLl9wcmV2VGltZSA9IHRpbWVsaW5lUHJldlRpbWU7XG5cdCAgICAgIHRoaXMuX3dhc1Vrbm93blVwZGF0ZSA9IHRydWU7XG5cdCAgICB9XG5cblx0ICAgIC8vIHZhciBiZWZvcmUgPSB0aW1lO1xuXHQgICAgLy8gY2FjaGUgdmFyc1xuXHQgICAgdmFyIHN0YXJ0UG9pbnQgPSBwLnN0YXJ0VGltZSAtIHAuZGVsYXk7XG5cdCAgICAvLyBpZiBzcGVlZCBwYXJhbSB3YXMgZGVmaW5lZCAtIGNhbGN1bGF0ZVxuXHQgICAgLy8gbmV3IHRpbWUgcmVnYXJkaW5nIHNwZWVkXG5cdCAgICBpZiAocC5zcGVlZCAmJiB0aGlzLl9wbGF5VGltZSkge1xuXHQgICAgICAvLyBwbGF5IHBvaW50ICsgKCBzcGVlZCAqIGRlbHRhIClcblx0ICAgICAgdGltZSA9IHRoaXMuX3BsYXlUaW1lICsgcC5zcGVlZCAqICh0aW1lIC0gdGhpcy5fcGxheVRpbWUpO1xuXHQgICAgfVxuXG5cdCAgICAvLyBkdWUgdG8gamF2YXNjcmlwdCBwcmVjaXNpb24gaXNzdWVzLCBhZnRlciBzcGVlZCBtYXBwaW5nXG5cdCAgICAvLyB3ZSBjYW4gZ2V0IHZlcnkgY2xvc2UgbnVtYmVyIHRoYXQgd2FzIG1hZGUgZnJvbSBwcm9ncmVzcyBvZiAxXG5cdCAgICAvLyBhbmQgaW4gZmFjdCByZXByZXNlbnRzIGBlbmRUaW1lYCBpZiBzbywgc2V0IHRoZSB0aW1lIHRvIGBlbmRUaW1lYFxuXHQgICAgaWYgKE1hdGguYWJzKHAuZW5kVGltZSAtIHRpbWUpIDwgMC4wMDAwMDAwMSkge1xuXHQgICAgICB0aW1lID0gcC5lbmRUaW1lO1xuXHQgICAgfVxuXG5cdCAgICAvLyBpZiBwYXJlbnQgaXMgb25FZGdlIGJ1dCBub3QgdmVyeSBzdGFydCBub3IgdmVyeSBlbmRcblx0ICAgIGlmIChvbkVkZ2UgJiYgd2FzWW95byAhPSBudWxsKSB7XG5cdCAgICAgIHZhciBUID0gdGhpcy5fZ2V0UGVyaW9kKHRpbWUpLFxuXHQgICAgICAgICAgaXNZb3lvID0gISEocC5pc1lveW8gJiYgdGhpcy5fcHJvcHMucmVwZWF0ICYmIFQgJSAyID09PSAxKTtcblxuXHQgICAgICAvLyBmb3IgdGltZWxpbmVcblx0ICAgICAgLy8gbm90aWZ5IGNoaWxkcmVuIGFib3V0IGVkZ2UganVtcFxuXHQgICAgICBpZiAodGhpcy5fdGltZWxpbmVzKSB7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl90aW1lbGluZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgIHRoaXMuX3RpbWVsaW5lc1tpXS5fdXBkYXRlKHRpbWUsIHRpbWVsaW5lUHJldlRpbWUsIHdhc1lveW8sIG9uRWRnZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIC8vIGZvcndhcmQgZWRnZSBkaXJlY3Rpb25cblx0ICAgICAgaWYgKG9uRWRnZSA9PT0gMSkge1xuXHQgICAgICAgIC8vIGp1bXBlZCBmcm9tIHlveW8gcGVyaW9kP1xuXHQgICAgICAgIGlmICh3YXNZb3lvKSB7XG5cdCAgICAgICAgICB0aGlzLl9wcmV2VGltZSA9IHRpbWUgKyAxO1xuXHQgICAgICAgICAgdGhpcy5fcmVwZWF0U3RhcnQodGltZSwgaXNZb3lvKTtcblx0ICAgICAgICAgIHRoaXMuX3N0YXJ0KHRpbWUsIGlzWW95byk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIHRoaXMuX3ByZXZUaW1lID0gdGltZSAtIDE7XG5cdCAgICAgICAgICB0aGlzLl9yZXBlYXRDb21wbGV0ZSh0aW1lLCBpc1lveW8pO1xuXHQgICAgICAgICAgdGhpcy5fY29tcGxldGUodGltZSwgaXNZb3lvKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gYmFja3dhcmQgZWRnZSBkaXJlY3Rpb25cblx0ICAgICAgfSBlbHNlIGlmIChvbkVkZ2UgPT09IC0xKSB7XG5cdCAgICAgICAgLy8ganVtcGVkIGZyb20geW95byBwZXJpb2Q/XG5cdCAgICAgICAgaWYgKHdhc1lveW8pIHtcblx0ICAgICAgICAgIHRoaXMuX3ByZXZUaW1lID0gdGltZSAtIDE7XG5cdCAgICAgICAgICB0aGlzLl9yZXBlYXRDb21wbGV0ZSh0aW1lLCBpc1lveW8pO1xuXHQgICAgICAgICAgdGhpcy5fY29tcGxldGUodGltZSwgaXNZb3lvKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgLy8gY2FsbCBfc3RhcnQgY2FsbGJhY2tzIG9ubHkgaWYgcHJldiB0aW1lIHdhcyBpbiBhY3RpdmUgYXJlYVxuXHQgICAgICAgICAgLy8gbm90IGFsd2F5cyB0cnVlIGZvciBhcHBlbmQgY2hhaW5zXG5cdCAgICAgICAgICBpZiAodGhpcy5fcHJldlRpbWUgPj0gcC5zdGFydFRpbWUgJiYgdGhpcy5fcHJldlRpbWUgPD0gcC5lbmRUaW1lKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3ByZXZUaW1lID0gdGltZSArIDE7XG5cdCAgICAgICAgICAgIHRoaXMuX3JlcGVhdFN0YXJ0KHRpbWUsIGlzWW95byk7XG5cdCAgICAgICAgICAgIHRoaXMuX3N0YXJ0KHRpbWUsIGlzWW95byk7XG5cdCAgICAgICAgICAgIC8vIHJlc2V0IGlzQ09tcGxldGVkIGltbWVkaWF0ZWx5IHRvIHByZXZlbnQgb25Db21wbGV0ZSBjYlxuXHQgICAgICAgICAgICB0aGlzLl9pc0NvbXBsZXRlZCA9IHRydWU7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIC8vIHJlc2V0IHRoZSBfcHJldlRpbWUgLSBkcm9wIG9uZSBmcmFtZSB0byB1bmRlc3RhbmRcblx0ICAgICAgLy8gd2hlcmUgd2UgYXJlIGhlYWRpbmdcblx0ICAgICAgdGhpcy5fcHJldlRpbWUgPSB1bmRlZmluZWQ7XG5cdCAgICB9XG5cdCAgICAvLyBpZiBpbiBhY3RpdmUgYXJlYSBhbmQgbm90IGVuZGVkIC0gc2F2ZSBwcm9ncmVzcyB0aW1lXG5cdCAgICAvLyBmb3IgcGF1c2UvcGxheSBwdXJwb3Nlcy5cblx0ICAgIGlmICh0aW1lID4gc3RhcnRQb2ludCAmJiB0aW1lIDwgcC5lbmRUaW1lKSB7XG5cdCAgICAgIHRoaXMuX3Byb2dyZXNzVGltZSA9IHRpbWUgLSBzdGFydFBvaW50O1xuXHQgICAgfVxuXHQgICAgLy8gZWxzZSBpZiBub3Qgc3RhcnRlZCBvciBlbmRlZCBzZXQgcHJvZ3Jlc3MgdGltZSB0byAwXG5cdCAgICBlbHNlIGlmICh0aW1lIDw9IHN0YXJ0UG9pbnQpIHtcblx0ICAgICAgICB0aGlzLl9wcm9ncmVzc1RpbWUgPSAwO1xuXHQgICAgICB9IGVsc2UgaWYgKHRpbWUgPj0gcC5lbmRUaW1lKSB7XG5cdCAgICAgICAgLy8gc2V0IHByb2dyZXNzIHRpbWUgdG8gcmVwZWF0IHRpbWUgKyB0aW55IGNvZmZpY2llbnRcblx0ICAgICAgICAvLyB0byBtYWtlIGl0IGV4dGVuZCBmdXJ0aGVyIHRoYW4gdGhlIGVuZCB0aW1lXG5cdCAgICAgICAgdGhpcy5fcHJvZ3Jlc3NUaW1lID0gcC5yZXBlYXRUaW1lICsgLjAwMDAwMDAwMDAxO1xuXHQgICAgICB9XG5cdCAgICAvLyByZXZlcnNlIHRpbWUgaWYgX3Byb3BzLmlzUmV2ZXJzZWQgaXMgc2V0XG5cdCAgICBpZiAocC5pc1JldmVyc2VkKSB7XG5cdCAgICAgIHRpbWUgPSBwLmVuZFRpbWUgLSB0aGlzLl9wcm9ncmVzc1RpbWU7XG5cdCAgICB9XG5cdCAgICAvLyBXZSBuZWVkIHRvIGtub3cgd2hhdCBkaXJlY3Rpb24gd2UgYXJlIGhlYWRpbmcgdG8sXG5cdCAgICAvLyBzbyBpZiB3ZSBkb24ndCBoYXZlIHRoZSBwcmV2aW91cyB1cGRhdGUgdmFsdWUgLSB0aGlzIGlzIHZlcnkgZmlyc3Rcblx0ICAgIC8vIHVwZGF0ZSwgLSBza2lwIGl0IGVudGlyZWx5IGFuZCB3YWl0IGZvciB0aGUgbmV4dCB2YWx1ZVxuXHQgICAgaWYgKHRoaXMuX3ByZXZUaW1lID09IG51bGwpIHtcblx0ICAgICAgdGhpcy5fcHJldlRpbWUgPSB0aW1lO1xuXHQgICAgICB0aGlzLl93YXNVa25vd25VcGRhdGUgPSB0cnVlO1xuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cblx0ICAgIC8vID09PT09PSBBRlRFUiBTS0lQUEVEIEZSQU1FID09PT09PVxuXG5cdCAgICAvLyBoYW5kbGUgb25Qcm9ncmVzcyBjYWxsYmFja1xuXHQgICAgaWYgKHRpbWUgPj0gc3RhcnRQb2ludCAmJiB0aW1lIDw9IHAuZW5kVGltZSkge1xuXHQgICAgICB0aGlzLl9wcm9ncmVzcygodGltZSAtIHN0YXJ0UG9pbnQpIC8gcC5yZXBlYXRUaW1lLCB0aW1lKTtcblx0ICAgIH1cblx0ICAgIC8qXG5cdCAgICAgIGlmIHRpbWUgaXMgaW5zaWRlIHRoZSBhY3RpdmUgYXJlYSBvZiB0aGUgdHdlZW4uXG5cdCAgICAgIGFjdGl2ZSBhcmVhIGlzIHRoZSBhcmVhIGZyb20gc3RhcnQgdGltZSB0byBlbmQgdGltZSxcblx0ICAgICAgd2l0aCBhbGwgdGhlIHJlcGVhdCBhbmQgZGVsYXlzIGluIGl0XG5cdCAgICAqL1xuXHQgICAgaWYgKHRpbWUgPj0gcC5zdGFydFRpbWUgJiYgdGltZSA8PSBwLmVuZFRpbWUpIHtcblx0ICAgICAgdGhpcy5fdXBkYXRlSW5BY3RpdmVBcmVhKHRpbWUpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgLy8gaWYgd2FzIGluIGFjdGl2ZSBhcmVhIC0gdXBkYXRlIGluIGluYWN0aXZlIGFyZWEgYnV0IGp1c3Qgb25jZSAtXG5cdCAgICAgIC8vIHJpZ2h0IGFmdGVyIHRoZSBhY3RpdmUgYXJlYVxuXHQgICAgICBpZiAodGhpcy5faXNJbkFjdGl2ZUFyZWEpIHtcblx0ICAgICAgICB0aGlzLl91cGRhdGVJbkluYWN0aXZlQXJlYSh0aW1lKTtcblx0ICAgICAgfSBlbHNlIGlmICghdGhpcy5faXNSZWZyZXNoZWQpIHtcblx0ICAgICAgICAvLyBvblJlZnJlc2ggY2FsbGJhY2tcblx0ICAgICAgICAvLyBiZWZvcmUgc3RhcnRUaW1lXG5cdCAgICAgICAgaWYgKHRpbWUgPCBwLnN0YXJ0VGltZSAmJiB0aGlzLnByb2dyZXNzICE9PSAwKSB7XG5cdCAgICAgICAgICB0aGlzLl9yZWZyZXNoKHRydWUpO1xuXHQgICAgICAgICAgdGhpcy5faXNSZWZyZXNoZWQgPSB0cnVlO1xuXHQgICAgICAgICAgLy8gYWZ0ZXIgZW5kVGltZVxuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBlbHNlIGlmICggdGltZSA+IHAuZW5kVGltZSApIHsgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuX3ByZXZUaW1lID0gdGltZTtcblx0ICAgIHJldHVybiB0aW1lID49IHAuZW5kVGltZSB8fCB0aW1lIDw9IHN0YXJ0UG9pbnQ7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGhhbmRsZSB0d2VlbidzIHByb2dyZXNzIGluIGluYWN0aXZlIGFyZWEuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IEN1cnJlbnQgdXBkYXRlIHRpbWUuXG5cdCAgKi9cblxuXG5cdCAgVHdlZW4ucHJvdG90eXBlLl91cGRhdGVJbkluYWN0aXZlQXJlYSA9IGZ1bmN0aW9uIF91cGRhdGVJbkluYWN0aXZlQXJlYSh0aW1lKSB7XG5cdCAgICBpZiAoIXRoaXMuX2lzSW5BY3RpdmVBcmVhKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIHZhciBwID0gdGhpcy5fcHJvcHM7XG5cdCAgICAvLyBjb21wbGV0ZSBpZiB0aW1lIGlzIGxhcmdlciB0aGVuIGVuZCB0aW1lXG5cdCAgICBpZiAodGltZSA+IHAuZW5kVGltZSAmJiAhdGhpcy5faXNDb21wbGV0ZWQpIHtcblx0ICAgICAgdGhpcy5fcHJvZ3Jlc3MoMSwgdGltZSk7XG5cdCAgICAgIC8vIGdldCBwZXJpb2QgbnVtYmVyXG5cdCAgICAgIHZhciBUID0gdGhpcy5fZ2V0UGVyaW9kKHAuZW5kVGltZSksXG5cdCAgICAgICAgICBpc1lveW8gPSBwLmlzWW95byAmJiBUICUgMiA9PT0gMDtcblxuXHQgICAgICB0aGlzLl9zZXRQcm9ncmVzcyhpc1lveW8gPyAwIDogMSwgdGltZSwgaXNZb3lvKTtcblx0ICAgICAgdGhpcy5fcmVwZWF0Q29tcGxldGUodGltZSwgaXNZb3lvKTtcblx0ICAgICAgdGhpcy5fY29tcGxldGUodGltZSwgaXNZb3lvKTtcblx0ICAgIH1cblx0ICAgIC8vIGlmIHdhcyBhY3RpdmUgYW5kIHdlbnQgdG8gLSBpbmFjdGl2ZSBhcmVhIFwiLVwiXG5cdCAgICBpZiAodGltZSA8IHRoaXMuX3ByZXZUaW1lICYmIHRpbWUgPCBwLnN0YXJ0VGltZSAmJiAhdGhpcy5faXNTdGFydGVkICYmICF0aGlzLl9pc0NvbXBsZXRlZCkge1xuXHQgICAgICAvLyBpZiB3YXMgaW4gYWN0aXZlIGFyZWEgYW5kIGRpZG4ndCBmaXJlIG9uU3RhcnQgY2FsbGJhY2tcblx0ICAgICAgdGhpcy5fcHJvZ3Jlc3MoMCwgdGltZSwgZmFsc2UpO1xuXHQgICAgICB0aGlzLl9zZXRQcm9ncmVzcygwLCB0aW1lLCBmYWxzZSk7XG5cdCAgICAgIHRoaXMuX2lzUmVwZWF0U3RhcnQgPSBmYWxzZTtcblx0ICAgICAgdGhpcy5fcmVwZWF0U3RhcnQodGltZSwgZmFsc2UpO1xuXHQgICAgICB0aGlzLl9zdGFydCh0aW1lLCBmYWxzZSk7XG5cdCAgICB9XG5cdCAgICB0aGlzLl9pc0luQWN0aXZlQXJlYSA9IGZhbHNlO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBoYW5kbGUgdHdlZW4ncyBwcm9ncmVzcyBpbiBhY3RpdmUgYXJlYS5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge051bWJlcn0gQ3VycmVudCB1cGRhdGUgdGltZS5cblx0ICAqL1xuXG5cblx0ICBUd2Vlbi5wcm90b3R5cGUuX3VwZGF0ZUluQWN0aXZlQXJlYSA9IGZ1bmN0aW9uIF91cGRhdGVJbkFjdGl2ZUFyZWEodGltZSkge1xuXG5cdCAgICB2YXIgcHJvcHMgPSB0aGlzLl9wcm9wcyxcblx0ICAgICAgICBkZWxheUR1cmF0aW9uID0gcHJvcHMuZGVsYXkgKyBwcm9wcy5kdXJhdGlvbixcblx0ICAgICAgICBzdGFydFBvaW50ID0gcHJvcHMuc3RhcnRUaW1lIC0gcHJvcHMuZGVsYXksXG5cdCAgICAgICAgZWxhcHNlZCA9ICh0aW1lIC0gcHJvcHMuc3RhcnRUaW1lICsgcHJvcHMuZGVsYXkpICUgZGVsYXlEdXJhdGlvbixcblx0ICAgICAgICBUQ291bnQgPSBNYXRoLnJvdW5kKChwcm9wcy5lbmRUaW1lIC0gcHJvcHMuc3RhcnRUaW1lICsgcHJvcHMuZGVsYXkpIC8gZGVsYXlEdXJhdGlvbiksXG5cdCAgICAgICAgVCA9IHRoaXMuX2dldFBlcmlvZCh0aW1lKSxcblx0ICAgICAgICBUVmFsdWUgPSB0aGlzLl9kZWxheVQsXG5cdCAgICAgICAgcHJldlQgPSB0aGlzLl9nZXRQZXJpb2QodGhpcy5fcHJldlRpbWUpLFxuXHQgICAgICAgIFRQcmV2VmFsdWUgPSB0aGlzLl9kZWxheVQ7XG5cblx0ICAgIC8vIFwiemVyb1wiIGFuZCBcIm9uZVwiIHZhbHVlIHJlZ2FyZGluZyB5b3lvIGFuZCBpdCdzIHBlcmlvZFxuXHQgICAgdmFyIGlzWW95byA9IHByb3BzLmlzWW95byAmJiBUICUgMiA9PT0gMSxcblx0ICAgICAgICBpc1lveW9QcmV2ID0gcHJvcHMuaXNZb3lvICYmIHByZXZUICUgMiA9PT0gMSxcblx0ICAgICAgICB5b3lvWmVybyA9IGlzWW95byA/IDEgOiAwLFxuXHQgICAgICAgIHlveW9PbmUgPSAxIC0geW95b1plcm87XG5cblx0ICAgIGlmICh0aW1lID09PSBwcm9wcy5lbmRUaW1lKSB7XG5cdCAgICAgIHRoaXMuX3dhc1Vrbm93blVwZGF0ZSA9IGZhbHNlO1xuXHQgICAgICAvLyBpZiBgdGltZWAgaXMgZXF1YWwgdG8gYGVuZFRpbWVgLCBUIHJlcHJlc2VudHMgdGhlIG5leHQgcGVyaW9kLFxuXHQgICAgICAvLyBzbyB3ZSBuZWVkIHRvIGRlY3JlbWVudCBUIGFuZCBjYWxjdWxhdGUgXCJvbmVcIiB2YWx1ZSByZWdhcmRpbmcgeW95b1xuXHQgICAgICB2YXIgaXNZb3lvID0gcHJvcHMuaXNZb3lvICYmIChUIC0gMSkgJSAyID09PSAxO1xuXHQgICAgICB0aGlzLl9zZXRQcm9ncmVzcyhpc1lveW8gPyAwIDogMSwgdGltZSwgaXNZb3lvKTtcblx0ICAgICAgaWYgKHRpbWUgPiB0aGlzLl9wcmV2VGltZSkge1xuXHQgICAgICAgIHRoaXMuX2lzUmVwZWF0Q29tcGxldGVkID0gZmFsc2U7XG5cdCAgICAgIH1cblx0ICAgICAgdGhpcy5fcmVwZWF0Q29tcGxldGUodGltZSwgaXNZb3lvKTtcblx0ICAgICAgcmV0dXJuIHRoaXMuX2NvbXBsZXRlKHRpbWUsIGlzWW95byk7XG5cdCAgICB9XG5cblx0ICAgIC8vIHJlc2V0IGNhbGxiYWNrIGZsYWdzXG5cdCAgICB0aGlzLl9pc0NvbXBsZXRlZCA9IGZhbHNlO1xuXHQgICAgdGhpcy5faXNSZWZyZXNoZWQgPSBmYWxzZTtcblx0ICAgIC8vIGlmIHRpbWUgaXMgaW5zaWRlIHRoZSBkdXJhdGlvbiBhcmVhIG9mIHRoZSB0d2VlblxuXHQgICAgaWYgKHN0YXJ0UG9pbnQgKyBlbGFwc2VkID49IHByb3BzLnN0YXJ0VGltZSkge1xuXHQgICAgICB0aGlzLl9pc0luQWN0aXZlQXJlYSA9IHRydWU7dGhpcy5faXNSZXBlYXRDb21wbGV0ZWQgPSBmYWxzZTtcblx0ICAgICAgdGhpcy5faXNSZXBlYXRTdGFydCA9IGZhbHNlO3RoaXMuX2lzU3RhcnRlZCA9IGZhbHNlO1xuXHQgICAgICAvLyBhY3RpdmUgem9uZSBvciBsYXJnZXIgdGhlbiBlbmRcblx0ICAgICAgdmFyIGVsYXBzZWQyID0gKHRpbWUgLSBwcm9wcy5zdGFydFRpbWUpICUgZGVsYXlEdXJhdGlvbixcblx0ICAgICAgICAgIHByb2MgPSBlbGFwc2VkMiAvIHByb3BzLmR1cmF0aW9uO1xuXHQgICAgICAvLyB8PT09PT18PT09PT18PT09PT18ID4+PlxuXHQgICAgICAvLyAgICAgIF4xXjJcblx0ICAgICAgdmFyIGlzT25FZGdlID0gVCA+IDAgJiYgcHJldlQgPCBUO1xuXHQgICAgICAvLyB8PT09PT18PT09PT18PT09PT18IDw8PFxuXHQgICAgICAvLyAgICAgIF4yXjFcblx0ICAgICAgdmFyIGlzT25SZXZlcnNlRWRnZSA9IHByZXZUID4gVDtcblxuXHQgICAgICAvLyBmb3IgdXNlIGluIHRpbWVsaW5lXG5cdCAgICAgIHRoaXMuX29uRWRnZSA9IDA7XG5cdCAgICAgIGlzT25FZGdlICYmICh0aGlzLl9vbkVkZ2UgPSAxKTtcblx0ICAgICAgaXNPblJldmVyc2VFZGdlICYmICh0aGlzLl9vbkVkZ2UgPSAtMSk7XG5cblx0ICAgICAgaWYgKHRoaXMuX3dhc1Vrbm93blVwZGF0ZSkge1xuXHQgICAgICAgIGlmICh0aW1lID4gdGhpcy5fcHJldlRpbWUpIHtcblx0ICAgICAgICAgIHRoaXMuX3N0YXJ0KHRpbWUsIGlzWW95byk7XG5cdCAgICAgICAgICB0aGlzLl9yZXBlYXRTdGFydCh0aW1lLCBpc1lveW8pO1xuXHQgICAgICAgICAgdGhpcy5fZmlyc3RVcGRhdGUodGltZSwgaXNZb3lvKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gaWYgYmFja3dhcmQgZGlyZWN0aW9uIGFuZCBcblx0ICAgICAgICAvLyBpZiAoIHRpbWUgPCB0aGlzLl9wcmV2VGltZSAmJiB0aW1lICE9PSB0aGlzLl9wcm9wcy5zdGFydFRpbWUgKSB7XG5cdCAgICAgICAgaWYgKHRpbWUgPCB0aGlzLl9wcmV2VGltZSkge1xuXHQgICAgICAgICAgdGhpcy5fY29tcGxldGUodGltZSwgaXNZb3lvKTtcblx0ICAgICAgICAgIHRoaXMuX3JlcGVhdENvbXBsZXRlKHRpbWUsIGlzWW95byk7XG5cdCAgICAgICAgICB0aGlzLl9maXJzdFVwZGF0ZSh0aW1lLCBpc1lveW8pO1xuXHQgICAgICAgICAgLy8gcmVzZXQgaXNDb21wbGV0ZWQgaW1tZWRpYXRlbHlcblx0ICAgICAgICAgIHRoaXMuX2lzQ29tcGxldGVkID0gZmFsc2U7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKGlzT25FZGdlKSB7XG5cdCAgICAgICAgLy8gaWYgbm90IGp1c3QgYWZ0ZXIgZGVsYXlcblx0ICAgICAgICAvLyB8LS0tPT09PT18LS0tPT09PT18LS0tPT09PT18ID4+PlxuXHQgICAgICAgIC8vICAgICAgICAgICAgXjEgXjJcblx0ICAgICAgICAvLyBiZWNhdXNlIHdlIGhhdmUgYWxyZWFkeSBoYW5kbGVkXG5cdCAgICAgICAgLy8gMSBhbmQgb25SZXBlYXRDb21wbGV0ZSBpbiBkZWxheSBnYXBcblx0ICAgICAgICBpZiAodGhpcy5wcm9ncmVzcyAhPT0gMSkge1xuXHQgICAgICAgICAgLy8gcHJldlRcblx0ICAgICAgICAgIHZhciBpc1RoaXNZb3lvID0gcHJvcHMuaXNZb3lvICYmIChUIC0gMSkgJSAyID09PSAxO1xuXHQgICAgICAgICAgdGhpcy5fcmVwZWF0Q29tcGxldGUodGltZSwgaXNUaGlzWW95byk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIGlmIG9uIGVkZ2UgYnV0IG5vdCBhdCB2ZXJ5IHN0YXJ0XG5cdCAgICAgICAgLy8gfD09PT09fD09PT09fD09PT09fCA+Pj5cblx0ICAgICAgICAvLyBeISAgICBeaGVyZSBeaGVyZSBcblx0ICAgICAgICBpZiAocHJldlQgPj0gMCkge1xuXHQgICAgICAgICAgdGhpcy5fcmVwZWF0U3RhcnQodGltZSwgaXNZb3lvKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAodGltZSA+IHRoaXMuX3ByZXZUaW1lKSB7XG5cdCAgICAgICAgLy8gIHw9PT09PXw9PT09PXw9PT09PXwgPj4+XG5cdCAgICAgICAgLy8gXjEgIF4yXG5cdCAgICAgICAgaWYgKCF0aGlzLl9pc1N0YXJ0ZWQgJiYgdGhpcy5fcHJldlRpbWUgPD0gcHJvcHMuc3RhcnRUaW1lKSB7XG5cdCAgICAgICAgICB0aGlzLl9zdGFydCh0aW1lLCBpc1lveW8pO1xuXHQgICAgICAgICAgdGhpcy5fcmVwZWF0U3RhcnQodGltZSwgaXNZb3lvKTtcblx0ICAgICAgICAgIC8vIGl0IHdhcyB6ZXJvIGFueXdheXNcblxuXHQgICAgICAgICAgLy8gcmVzdGFydCBmbGFncyBpbW1lZGlhdGVseSBpbiBjYXNlIGlmIHdlIHdpbGxcblx0ICAgICAgICAgIC8vIHJldHVybiB0byAnLScgaW5hY3RpdmUgYXJlYSBvbiB0aGUgbmV4dCBzdGVwXG5cdCAgICAgICAgICB0aGlzLl9pc1N0YXJ0ZWQgPSBmYWxzZTtcblx0ICAgICAgICAgIHRoaXMuX2lzUmVwZWF0U3RhcnQgPSBmYWxzZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fZmlyc3RVcGRhdGUodGltZSwgaXNZb3lvKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChpc09uUmV2ZXJzZUVkZ2UpIHtcblx0ICAgICAgICAvLyBpZiBvbiBlZGdlIGJ1dCBub3QgYXQgdmVyeSBlbmRcblx0ICAgICAgICAvLyB8PT09PT18PT09PT18PT09PT18IDw8PFxuXHQgICAgICAgIC8vICAgICAgIF5oZXJlIF5oZXJlIF5ub3QgaGVyZVxuXHQgICAgICAgIGlmICh0aGlzLnByb2dyZXNzICE9PSAwICYmIHRoaXMucHJvZ3Jlc3MgIT09IDEgJiYgcHJldlQgIT0gVENvdW50KSB7XG5cdCAgICAgICAgICB0aGlzLl9yZXBlYXRTdGFydCh0aW1lLCBpc1lveW9QcmV2KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gaWYgb24gdmVyeSBlbmQgZWRnZVxuXHQgICAgICAgIC8vIHw9PT09PXw9PT09PXw9PT09PXwgPDw8XG5cdCAgICAgICAgLy8gICAgICAgXiEgICAgXiEgXjIgXjFcblx0ICAgICAgICAvLyB3ZSBoYXZlIGhhbmRsZWQgdGhlIGNhc2UgaW4gdGhpcy5fd2FzVWtub3duVXBkYXRlXG5cdCAgICAgICAgLy8gYmxvY2sgc28gZmlsdGVyIHRoYXRcblx0ICAgICAgICBpZiAocHJldlQgPT09IFRDb3VudCAmJiAhdGhpcy5fd2FzVWtub3duVXBkYXRlKSB7XG5cdCAgICAgICAgICB0aGlzLl9jb21wbGV0ZSh0aW1lLCBpc1lveW8pO1xuXHQgICAgICAgICAgdGhpcy5fcmVwZWF0Q29tcGxldGUodGltZSwgaXNZb3lvKTtcblx0ICAgICAgICAgIHRoaXMuX2ZpcnN0VXBkYXRlKHRpbWUsIGlzWW95byk7XG5cdCAgICAgICAgICAvLyByZXNldCBpc0NvbXBsZXRlIGZsYWcgY2FsbFxuXHQgICAgICAgICAgLy8gY3V6IHdlIHJldHVybmVkIHRvIGFjdGl2ZSBhcmVhXG5cdCAgICAgICAgICAvLyB0aGlzLl9pc1JlcGVhdENvbXBsZXRlZCA9IGZhbHNlO1xuXHQgICAgICAgICAgdGhpcy5faXNDb21wbGV0ZWQgPSBmYWxzZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fcmVwZWF0Q29tcGxldGUodGltZSwgaXNZb3lvKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChwcmV2VCA9PT0gJ2RlbGF5Jykge1xuXHQgICAgICAgIC8vIGlmIGp1c3QgYmVmb3JlIGRlbGF5IGdhcFxuXHQgICAgICAgIC8vIHwtLS09PT09PXwtLS09PT09PXwtLS09PT09PXwgPDw8XG5cdCAgICAgICAgLy8gICAgICAgICAgICAgICBeMiAgICBeMVxuXHQgICAgICAgIGlmIChUIDwgVFByZXZWYWx1ZSkge1xuXHQgICAgICAgICAgdGhpcy5fcmVwZWF0Q29tcGxldGUodGltZSwgaXNZb3lvKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gaWYganVzdCBhZnRlciBkZWxheSBnYXBcblx0ICAgICAgICAvLyB8LS0tPT09PT18LS0tPT09PT18LS0tPT09PT18ID4+PlxuXHQgICAgICAgIC8vICAgICAgICAgICAgXjEgIF4yXG5cdCAgICAgICAgaWYgKFQgPT09IFRQcmV2VmFsdWUgJiYgVCA+IDApIHtcblx0ICAgICAgICAgIHRoaXMuX3JlcGVhdFN0YXJ0KHRpbWUsIGlzWW95byk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgLy8gc3dhcCBwcm9ncmVzcyBhbmQgcmVwZWF0U3RhcnQgYmFzZWQgb24gZGlyZWN0aW9uXG5cdCAgICAgIGlmICh0aW1lID4gdGhpcy5fcHJldlRpbWUpIHtcblx0ICAgICAgICAvLyBpZiBwcm9ncmVzcyBpcyBlcXVhbCAwIGFuZCBwcm9ncmVzcyBncm93c1xuXHQgICAgICAgIGlmIChwcm9jID09PSAwKSB7XG5cdCAgICAgICAgICB0aGlzLl9yZXBlYXRTdGFydCh0aW1lLCBpc1lveW8pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodGltZSAhPT0gcHJvcHMuZW5kVGltZSkge1xuXHQgICAgICAgICAgdGhpcy5fc2V0UHJvZ3Jlc3MoaXNZb3lvID8gMSAtIHByb2MgOiBwcm9jLCB0aW1lLCBpc1lveW8pO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBpZiAodGltZSAhPT0gcHJvcHMuZW5kVGltZSkge1xuXHQgICAgICAgICAgdGhpcy5fc2V0UHJvZ3Jlc3MoaXNZb3lvID8gMSAtIHByb2MgOiBwcm9jLCB0aW1lLCBpc1lveW8pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBpZiBwcm9ncmVzcyBpcyBlcXVhbCAwIGFuZCBwcm9ncmVzcyBncm93c1xuXHQgICAgICAgIGlmIChwcm9jID09PSAwKSB7XG5cdCAgICAgICAgICB0aGlzLl9yZXBlYXRTdGFydCh0aW1lLCBpc1lveW8pO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIGlmICh0aW1lID09PSBwcm9wcy5zdGFydFRpbWUpIHtcblx0ICAgICAgICB0aGlzLl9zdGFydCh0aW1lLCBpc1lveW8pO1xuXHQgICAgICB9XG5cdCAgICAgIC8vIGRlbGF5IGdhcCAtIHJlYWN0IG9ubHkgb25jZVxuXHQgICAgfSBlbHNlIGlmICh0aGlzLl9pc0luQWN0aXZlQXJlYSkge1xuXHQgICAgICAvLyBiZWNhdXNlIFQgd2lsbCBiZSBzdHJpbmcgb2YgXCJkZWxheVwiIGhlcmUsXG5cdCAgICAgIC8vIGxldCdzIG5vcm1hbGl6ZSBpdCBiZSBzZXR0aW5nIHRvIFRWYWx1ZVxuXHQgICAgICB2YXIgdCA9IFQgPT09ICdkZWxheScgPyBUVmFsdWUgOiBULFxuXHQgICAgICAgICAgaXNHcm93cyA9IHRpbWUgPiB0aGlzLl9wcmV2VGltZTtcblx0ICAgICAgLy8gZGVjcmVtZW50IHBlcmlvZCBpZiBmb3J3YXJkIGRpcmVjdGlvbiBvZiB1cGRhdGVcblx0ICAgICAgaXNHcm93cyAmJiB0LS07XG5cdCAgICAgIC8vIGNhbGN1bGF0ZSBub3JtYWxpemVkIHlveW9aZXJvIHZhbHVlXG5cdCAgICAgIHlveW9aZXJvID0gcHJvcHMuaXNZb3lvICYmIHQgJSAyID09PSAxID8gMSA6IDA7XG5cdCAgICAgIC8vIGlmIHdhcyBpbiBhY3RpdmUgYXJlYSBhbmQgcHJldmlvdXMgdGltZSB3YXMgbGFyZ2VyXG5cdCAgICAgIC8vIHwtLS09PT09PXwtLS09PT09PXwtLS09PT09PXwgPDw8XG5cdCAgICAgIC8vICAgXjIgXjEgICAgXjIgXjEgICAgXjIgXjFcblx0ICAgICAgaWYgKHRpbWUgPCB0aGlzLl9wcmV2VGltZSkge1xuXHQgICAgICAgIHRoaXMuX3NldFByb2dyZXNzKHlveW9aZXJvLCB0aW1lLCB5b3lvWmVybyA9PT0gMSk7XG5cdCAgICAgICAgdGhpcy5fcmVwZWF0U3RhcnQodGltZSwgeW95b1plcm8gPT09IDEpO1xuXHQgICAgICB9XG5cdCAgICAgIC8vIHNldCAxIG9yIDAgcmVnYXJkaW5nIGRpcmVjdGlvbiBhbmQgeW95b1xuXHQgICAgICB0aGlzLl9zZXRQcm9ncmVzcyhpc0dyb3dzID8gMSAtIHlveW9aZXJvIDogeW95b1plcm8sIHRpbWUsIHlveW9aZXJvID09PSAxKTtcblx0ICAgICAgLy8gaWYgdGltZSBncm93c1xuXHQgICAgICBpZiAodGltZSA+IHRoaXMuX3ByZXZUaW1lKSB7XG5cdCAgICAgICAgLy8gaWYgcmV2ZXJzZSBkaXJlY3Rpb24gYW5kIGluIGRlbGF5IGdhcCwgdGhlbiBwcm9ncmVzcyB3aWxsIGJlIDBcblx0ICAgICAgICAvLyBpZiBzbyB3ZSBkb24ndCBuZWVkIHRvIGNhbGwgdGhlIG9uUmVwZWF0Q29tcGxldGUgY2FsbGJhY2tcblx0ICAgICAgICAvLyB8LS0tPT09PT18LS0tPT09PT18LS0tPT09PT18IDw8PFxuXHQgICAgICAgIC8vICAgXjAgICAgICAgXjAgICAgICAgXjAgICBcblx0ICAgICAgICAvLyBPUiB3ZSBoYXZlIGZsaXBwZWQgMCB0byAxIHJlZ2FyZGluZyB5b3lvIG9wdGlvblxuXHQgICAgICAgIGlmICh0aGlzLnByb2dyZXNzICE9PSAwIHx8IHlveW9aZXJvID09PSAxKSB7XG5cdCAgICAgICAgICAvLyBzaW5jZSB3ZSByZXBlYXRDb21wbGV0ZSBmb3IgcHJldmlvdXMgcGVyaW9kXG5cdCAgICAgICAgICAvLyBpbnZlcnQgaXNZb3lvIG9wdGlvblxuXHQgICAgICAgICAgLy8gaXMgZWxhcHNlZCBpcyAwIC0gY291bnQgYXMgcHJldmlvdXMgcGVyaW9kXG5cdCAgICAgICAgICB0aGlzLl9yZXBlYXRDb21wbGV0ZSh0aW1lLCB5b3lvWmVybyA9PT0gMSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIC8vIHNldCBmbGFnIHRvIGluZGljYXRlIGluYWN0aXZlIGFyZWFcblx0ICAgICAgdGhpcy5faXNJbkFjdGl2ZUFyZWEgPSBmYWxzZTtcblx0ICAgIH1cblx0ICAgIC8vIHdlJ3ZlIGdvdCB0aGUgZmlyc3QgdXBkYXRlIG5vd1xuXHQgICAgdGhpcy5fd2FzVWtub3duVXBkYXRlID0gZmFsc2U7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHJlbW92ZSB0aGUgVHdlZW4gZnJvbSB0aGUgdHdlZW5lci5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcmV0dXJucyB7T2JqZWN0fSBTZWxmLlxuXHQgICovXG5cblxuXHQgIFR3ZWVuLnByb3RvdHlwZS5fcmVtb3ZlRnJvbVR3ZWVuZXIgPSBmdW5jdGlvbiBfcmVtb3ZlRnJvbVR3ZWVuZXIoKSB7XG5cdCAgICBfdHdlZW5lcjIuZGVmYXVsdC5yZW1vdmUodGhpcyk7cmV0dXJuIHRoaXM7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGdldCBjdXJyZW50IHBlcmlvZCBudW1iZXIuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IFRpbWUgdG8gZ2V0IHRoZSBwZXJpb2QgZm9yLlxuXHQgICAgQHJldHVybnMge051bWJlcn0gQ3VycmVudCBwZXJpb2QgbnVtYmVyLlxuXHQgICovXG5cblxuXHQgIFR3ZWVuLnByb3RvdHlwZS5fZ2V0UGVyaW9kID0gZnVuY3Rpb24gX2dldFBlcmlvZCh0aW1lKSB7XG5cdCAgICB2YXIgcCA9IHRoaXMuX3Byb3BzLFxuXHQgICAgICAgIFRUaW1lID0gcC5kZWxheSArIHAuZHVyYXRpb24sXG5cdCAgICAgICAgZFRpbWUgPSBwLmRlbGF5ICsgdGltZSAtIHAuc3RhcnRUaW1lLFxuXHQgICAgICAgIFQgPSBkVGltZSAvIFRUaW1lLFxuXG5cdCAgICAvLyBpZiB0aW1lIGlmIGVxdWFsIHRvIGVuZFRpbWUgd2UgbmVlZCB0byBzZXQgdGhlIGVsYXBzZWRcblx0ICAgIC8vIHRpbWUgdG8gMCB0byBmaXggdGhlIG9jY2FzaW9uYWwgcHJlY2lzaW9uIGpzIGJ1Zywgd2hpY2hcblx0ICAgIC8vIGNhdXNlcyAwIHRvIGJlIHNvbWV0aGluZyBsaWtlIDFlLTEyXG5cdCAgICBlbGFwc2VkID0gdGltZSA8IHAuZW5kVGltZSA/IGRUaW1lICUgVFRpbWUgOiAwO1xuXHQgICAgLy8gSWYgdGhlIGxhdGVzdCBwZXJpb2QsIHJvdW5kIHRoZSByZXN1bHQsIG90aGVyd2lzZSBmbG9vciBpdC5cblx0ICAgIC8vIEJhc2ljYWxseSB3ZSBhbHdheXMgY2FuIGZsb29yIHRoZSByZXN1bHQsIGJ1dCBiZWNhdXNlIG9mIGpzXG5cdCAgICAvLyBwcmVjaXNpb24gaXNzdWVzLCBzb21ldGltZXMgdGhlIHJlc3VsdCBpcyAyLjk5OTk5OTk4IHdoaWNoXG5cdCAgICAvLyB3aWxsIHJlc3VsdCBpbiAyIGluc3RlYWQgb2YgMyBhZnRlciB0aGUgZmxvb3Igb3BlcmF0aW9uLlxuXHQgICAgVCA9IHRpbWUgPj0gcC5lbmRUaW1lID8gTWF0aC5yb3VuZChUKSA6IE1hdGguZmxvb3IoVCk7XG5cdCAgICAvLyBpZiB0aW1lIGlzIGxhcmdlciB0aGVuIHRoZSBlbmQgdGltZVxuXHQgICAgaWYgKHRpbWUgPiBwLmVuZFRpbWUpIHtcblx0ICAgICAgLy8gc2V0IGVxdWFsIHRvIHRoZSBwZXJpb2RzIGNvdW50XG5cdCAgICAgIFQgPSBNYXRoLnJvdW5kKChwLmVuZFRpbWUgLSBwLnN0YXJ0VGltZSArIHAuZGVsYXkpIC8gVFRpbWUpO1xuXHQgICAgICAvLyBpZiBpbiBkZWxheSBnYXAsIHNldCBfZGVsYXlUIHRvIGN1cnJlbnRcblx0ICAgICAgLy8gcGVyaW9kIG51bWJlciBhbmQgcmV0dXJuIFwiZGVsYXlcIlxuXHQgICAgfSBlbHNlIGlmIChlbGFwc2VkID4gMCAmJiBlbGFwc2VkIDwgcC5kZWxheSkge1xuXHQgICAgICB0aGlzLl9kZWxheVQgPSBUO1QgPSAnZGVsYXknO1xuXHQgICAgfVxuXHQgICAgLy8gaWYgdGhlIGVuZCBvZiBwZXJpb2QgYW5kIHRoZXJlIGlzIGEgZGVsYXlcblx0ICAgIHJldHVybiBUO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBzZXQgVHdlZW4ncyBwcm9ncmVzcyBhbmQgY2FsbCBvblVwZGF0ZSBjYWxsYmFjay5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAb3ZlcnJpZGUgQCBNb2R1bGVcblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBQcm9ncmVzcyB0byBzZXQuXG5cdCAgICBAcGFyYW0ge051bWJlcn0gQ3VycmVudCB1cGRhdGUgdGltZS5cblx0ICAgIEBwYXJhbSB7Qm9vbGVhbn0gSXMgeW95byBwZXJpZG8uIFVzZWQgaW4gVGltZWxpbmUgdG8gcGFzcyB0byBUd2Vlbi5cblx0ICAgIEByZXR1cm5zIHtPYmplY3R9IFNlbGYuXG5cdCAgKi9cblxuXG5cdCAgVHdlZW4ucHJvdG90eXBlLl9zZXRQcm9ncmVzcyA9IGZ1bmN0aW9uIF9zZXRQcm9ncmVzcyhwcm9jLCB0aW1lLCBpc1lveW8pIHtcblx0ICAgIHZhciBwID0gdGhpcy5fcHJvcHMsXG5cdCAgICAgICAgaXNZb3lvQ2hhbmdlZCA9IHAud2FzWW95byAhPT0gaXNZb3lvLFxuXHQgICAgICAgIGlzRm9yd2FyZCA9IHRpbWUgPiB0aGlzLl9wcmV2VGltZTtcblxuXHQgICAgdGhpcy5wcm9ncmVzcyA9IHByb2M7XG5cdCAgICAvLyBnZXQgdGhlIGN1cnJlbnQgZWFzaW5nIGZvciBgZm9yd2FyZGAgZGlyZWN0aW9uIHJlZ2FyZGluZyBgeW95b2Bcblx0ICAgIGlmIChpc0ZvcndhcmQgJiYgIWlzWW95byB8fCAhaXNGb3J3YXJkICYmIGlzWW95bykge1xuXHQgICAgICB0aGlzLmVhc2VkUHJvZ3Jlc3MgPSBwLmVhc2luZyhwcm9jKTtcblx0ICAgICAgLy8gZ2V0IHRoZSBjdXJyZW50IGVhc2luZyBmb3IgYGJhY2t3YXJkYCBkaXJlY3Rpb24gcmVnYXJkaW5nIGB5b3lvYFxuXHQgICAgfSBlbHNlIGlmICghaXNGb3J3YXJkICYmICFpc1lveW8gfHwgaXNGb3J3YXJkICYmIGlzWW95bykge1xuXHQgICAgICB2YXIgZWFzaW5nID0gcC5iYWNrd2FyZEVhc2luZyAhPSBudWxsID8gcC5iYWNrd2FyZEVhc2luZyA6IHAuZWFzaW5nO1xuXG5cdCAgICAgIHRoaXMuZWFzZWRQcm9ncmVzcyA9IGVhc2luZyhwcm9jKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKHAucHJldkVhc2VkUHJvZ3Jlc3MgIT09IHRoaXMuZWFzZWRQcm9ncmVzcyB8fCBpc1lveW9DaGFuZ2VkKSB7XG5cdCAgICAgIGlmIChwLm9uVXBkYXRlICE9IG51bGwgJiYgdHlwZW9mIHAub25VcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICBwLm9uVXBkYXRlLmNhbGwocC5jYWxsYmFja3NDb250ZXh0IHx8IHRoaXMsIHRoaXMuZWFzZWRQcm9ncmVzcywgdGhpcy5wcm9ncmVzcywgaXNGb3J3YXJkLCBpc1lveW8pO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICBwLnByZXZFYXNlZFByb2dyZXNzID0gdGhpcy5lYXNlZFByb2dyZXNzO1xuXHQgICAgcC53YXNZb3lvID0gaXNZb3lvO1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHNldCB0d2VlbidzIHN0YXRlIHRvIHN0YXJ0IGFuZCBjYWxsIG9uU3RhcnQgY2FsbGJhY2suXG5cdCAgICBAbWV0aG9kIF9zdGFydFxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBQcm9ncmVzcyB0byBzZXQuXG5cdCAgICBAcGFyYW0ge0Jvb2xlYW59IElzIHlveW8gcGVyaW9kLlxuXHQgICovXG5cblxuXHQgIFR3ZWVuLnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbiBfc3RhcnQodGltZSwgaXNZb3lvKSB7XG5cdCAgICBpZiAodGhpcy5faXNTdGFydGVkKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIHZhciBwID0gdGhpcy5fcHJvcHM7XG5cdCAgICBpZiAocC5vblN0YXJ0ICE9IG51bGwgJiYgdHlwZW9mIHAub25TdGFydCA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICBwLm9uU3RhcnQuY2FsbChwLmNhbGxiYWNrc0NvbnRleHQgfHwgdGhpcywgdGltZSA+IHRoaXMuX3ByZXZUaW1lLCBpc1lveW8pO1xuXHQgICAgfVxuXHQgICAgdGhpcy5faXNDb21wbGV0ZWQgPSBmYWxzZTt0aGlzLl9pc1N0YXJ0ZWQgPSB0cnVlO1xuXHQgICAgdGhpcy5faXNGaXJzdFVwZGF0ZSA9IGZhbHNlO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBjYWxsIG9uUGxheWJhY2tTdGFydCBjYWxsYmFja1xuXHQgICAgQHByaXZhdGVcblx0ICAqL1xuXG5cblx0ICBUd2Vlbi5wcm90b3R5cGUuX3BsYXliYWNrU3RhcnQgPSBmdW5jdGlvbiBfcGxheWJhY2tTdGFydCgpIHtcblx0ICAgIHZhciBwID0gdGhpcy5fcHJvcHM7XG5cdCAgICBpZiAocC5vblBsYXliYWNrU3RhcnQgIT0gbnVsbCAmJiB0eXBlb2YgcC5vblBsYXliYWNrU3RhcnQgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgcC5vblBsYXliYWNrU3RhcnQuY2FsbChwLmNhbGxiYWNrc0NvbnRleHQgfHwgdGhpcyk7XG5cdCAgICB9XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGNhbGwgb25QbGF5YmFja1BhdXNlIGNhbGxiYWNrXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIFR3ZWVuLnByb3RvdHlwZS5fcGxheWJhY2tQYXVzZSA9IGZ1bmN0aW9uIF9wbGF5YmFja1BhdXNlKCkge1xuXHQgICAgdmFyIHAgPSB0aGlzLl9wcm9wcztcblx0ICAgIGlmIChwLm9uUGxheWJhY2tQYXVzZSAhPSBudWxsICYmIHR5cGVvZiBwLm9uUGxheWJhY2tQYXVzZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICBwLm9uUGxheWJhY2tQYXVzZS5jYWxsKHAuY2FsbGJhY2tzQ29udGV4dCB8fCB0aGlzKTtcblx0ICAgIH1cblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gY2FsbCBvblBsYXliYWNrU3RvcCBjYWxsYmFja1xuXHQgICAgQHByaXZhdGVcblx0ICAqL1xuXG5cblx0ICBUd2Vlbi5wcm90b3R5cGUuX3BsYXliYWNrU3RvcCA9IGZ1bmN0aW9uIF9wbGF5YmFja1N0b3AoKSB7XG5cdCAgICB2YXIgcCA9IHRoaXMuX3Byb3BzO1xuXHQgICAgaWYgKHAub25QbGF5YmFja1N0b3AgIT0gbnVsbCAmJiB0eXBlb2YgcC5vblBsYXliYWNrU3RvcCA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICBwLm9uUGxheWJhY2tTdG9wLmNhbGwocC5jYWxsYmFja3NDb250ZXh0IHx8IHRoaXMpO1xuXHQgICAgfVxuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBjYWxsIG9uUGxheWJhY2tDb21wbGV0ZSBjYWxsYmFja1xuXHQgICAgQHByaXZhdGVcblx0ICAqL1xuXG5cblx0ICBUd2Vlbi5wcm90b3R5cGUuX3BsYXliYWNrQ29tcGxldGUgPSBmdW5jdGlvbiBfcGxheWJhY2tDb21wbGV0ZSgpIHtcblx0ICAgIHZhciBwID0gdGhpcy5fcHJvcHM7XG5cdCAgICBpZiAocC5vblBsYXliYWNrQ29tcGxldGUgIT0gbnVsbCAmJiB0eXBlb2YgcC5vblBsYXliYWNrQ29tcGxldGUgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgcC5vblBsYXliYWNrQ29tcGxldGUuY2FsbChwLmNhbGxiYWNrc0NvbnRleHQgfHwgdGhpcyk7XG5cdCAgICB9XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHNldCB0d2VlbidzIHN0YXRlIHRvIGNvbXBsZXRlLlxuXHQgICAgQG1ldGhvZCBfY29tcGxldGVcblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge051bWJlcn0gQ3VycmVudCB0aW1lLlxuXHQgICAgQHBhcmFtIHtCb29sZWFufSBJcyB5b3lvIHBlcmlvZC5cblx0ICAqL1xuXG5cblx0ICBUd2Vlbi5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gX2NvbXBsZXRlKHRpbWUsIGlzWW95bykge1xuXHQgICAgaWYgKHRoaXMuX2lzQ29tcGxldGVkKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIHZhciBwID0gdGhpcy5fcHJvcHM7XG5cdCAgICBpZiAocC5vbkNvbXBsZXRlICE9IG51bGwgJiYgdHlwZW9mIHAub25Db21wbGV0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICBwLm9uQ29tcGxldGUuY2FsbChwLmNhbGxiYWNrc0NvbnRleHQgfHwgdGhpcywgdGltZSA+IHRoaXMuX3ByZXZUaW1lLCBpc1lveW8pO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLl9pc0NvbXBsZXRlZCA9IHRydWU7dGhpcy5faXNTdGFydGVkID0gZmFsc2U7XG5cdCAgICB0aGlzLl9pc0ZpcnN0VXBkYXRlID0gZmFsc2U7XG5cdCAgICAvLyByZXNldCBfcHJldllveW8gZm9yIHRpbWVsaW5lIHVzYWdlXG5cdCAgICB0aGlzLl9wcmV2WW95byA9IHVuZGVmaW5lZDtcblx0ICB9O1xuXG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBydW4gb25GaXJzdFVwZGF0ZSBjYWxsYmFjay5cblx0ICAgIEBtZXRob2QgX2ZpcnN0VXBkYXRlXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IEN1cnJlbnQgdXBkYXRlIHRpbWUuXG5cdCAgICBAcGFyYW0ge0Jvb2xlYW59IElzIHlveW8gcGVyaW9kLlxuXHQgICovXG5cblxuXHQgIFR3ZWVuLnByb3RvdHlwZS5fZmlyc3RVcGRhdGUgPSBmdW5jdGlvbiBfZmlyc3RVcGRhdGUodGltZSwgaXNZb3lvKSB7XG5cdCAgICBpZiAodGhpcy5faXNGaXJzdFVwZGF0ZSkge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICB2YXIgcCA9IHRoaXMuX3Byb3BzO1xuXHQgICAgaWYgKHAub25GaXJzdFVwZGF0ZSAhPSBudWxsICYmIHR5cGVvZiBwLm9uRmlyc3RVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgLy8gb25GaXJzdFVwZGF0ZSBzaG91bGQgaGF2ZSB0d2VlbiBwb2ludGVyXG5cdCAgICAgIHAub25GaXJzdFVwZGF0ZS50d2VlbiA9IHRoaXM7XG5cdCAgICAgIHAub25GaXJzdFVwZGF0ZS5jYWxsKHAuY2FsbGJhY2tzQ29udGV4dCB8fCB0aGlzLCB0aW1lID4gdGhpcy5fcHJldlRpbWUsIGlzWW95byk7XG5cdCAgICB9XG5cdCAgICB0aGlzLl9pc0ZpcnN0VXBkYXRlID0gdHJ1ZTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgY2FsbCBvblJlcGVhdENvbXBsZXRlIGNhbGJhY2sgYW5kIHNldCBmbGFncy5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge051bWJlcn0gQ3VycmVudCB1cGRhdGUgdGltZS5cblx0ICAgIEBwYXJhbSB7Qm9vbGVhbn0gSXMgcmVwZWF0IHBlcmlvZC5cblx0ICAqL1xuXG5cblx0ICBUd2Vlbi5wcm90b3R5cGUuX3JlcGVhdENvbXBsZXRlID0gZnVuY3Rpb24gX3JlcGVhdENvbXBsZXRlKHRpbWUsIGlzWW95bykge1xuXHQgICAgaWYgKHRoaXMuX2lzUmVwZWF0Q29tcGxldGVkKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIHZhciBwID0gdGhpcy5fcHJvcHM7XG5cdCAgICBpZiAocC5vblJlcGVhdENvbXBsZXRlICE9IG51bGwgJiYgdHlwZW9mIHAub25SZXBlYXRDb21wbGV0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICBwLm9uUmVwZWF0Q29tcGxldGUuY2FsbChwLmNhbGxiYWNrc0NvbnRleHQgfHwgdGhpcywgdGltZSA+IHRoaXMuX3ByZXZUaW1lLCBpc1lveW8pO1xuXHQgICAgfVxuXHQgICAgdGhpcy5faXNSZXBlYXRDb21wbGV0ZWQgPSB0cnVlO1xuXHQgICAgLy8gdGhpcy5fcHJldllveW8gPSBudWxsO1xuXHQgIH07XG5cblx0ICAvKlxuXHQgICAgTWV0aG9kIGNhbGwgb25SZXBlYXRTdGFydCBjYWxiYWNrIGFuZCBzZXQgZmxhZ3MuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IEN1cnJlbnQgdXBkYXRlIHRpbWUuXG5cdCAgICBAcGFyYW0ge0Jvb2xlYW59IElzIHlveW8gcGVyaW9kLlxuXHQgICovXG5cblxuXHQgIFR3ZWVuLnByb3RvdHlwZS5fcmVwZWF0U3RhcnQgPSBmdW5jdGlvbiBfcmVwZWF0U3RhcnQodGltZSwgaXNZb3lvKSB7XG5cdCAgICBpZiAodGhpcy5faXNSZXBlYXRTdGFydCkge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICB2YXIgcCA9IHRoaXMuX3Byb3BzO1xuXHQgICAgaWYgKHAub25SZXBlYXRTdGFydCAhPSBudWxsICYmIHR5cGVvZiBwLm9uUmVwZWF0U3RhcnQgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgcC5vblJlcGVhdFN0YXJ0LmNhbGwocC5jYWxsYmFja3NDb250ZXh0IHx8IHRoaXMsIHRpbWUgPiB0aGlzLl9wcmV2VGltZSwgaXNZb3lvKTtcblx0ICAgIH1cblx0ICAgIHRoaXMuX2lzUmVwZWF0U3RhcnQgPSB0cnVlO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBsYXVuY2ggb25Qcm9ncmVzcyBjYWxsYmFjay5cblx0ICAgIEBtZXRob2QgX3Byb2dyZXNzXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IFByb2dyZXNzIHRvIHNldC5cblx0ICAqL1xuXG5cblx0ICBUd2Vlbi5wcm90b3R5cGUuX3Byb2dyZXNzID0gZnVuY3Rpb24gX3Byb2dyZXNzKHByb2dyZXNzLCB0aW1lKSB7XG5cdCAgICB2YXIgcCA9IHRoaXMuX3Byb3BzO1xuXHQgICAgaWYgKHAub25Qcm9ncmVzcyAhPSBudWxsICYmIHR5cGVvZiBwLm9uUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgcC5vblByb2dyZXNzLmNhbGwocC5jYWxsYmFja3NDb250ZXh0IHx8IHRoaXMsIHByb2dyZXNzLCB0aW1lID4gdGhpcy5fcHJldlRpbWUpO1xuXHQgICAgfVxuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBsYXVuY2ggb25SZWZyZXNoIGNhbGxiYWNrLlxuXHQgICAgQG1ldGhvZCBfcmVmcmVzaFxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7Qm9vbGVhbn0gSWYgcmVmcmVzaCBldmVuIGJlZm9yZSBzdGFydCB0aW1lLlxuXHQgICovXG5cblxuXHQgIFR3ZWVuLnByb3RvdHlwZS5fcmVmcmVzaCA9IGZ1bmN0aW9uIF9yZWZyZXNoKGlzQmVmb3JlKSB7XG5cdCAgICB2YXIgcCA9IHRoaXMuX3Byb3BzO1xuXHQgICAgaWYgKHAub25SZWZyZXNoICE9IG51bGwpIHtcblx0ICAgICAgdmFyIGNvbnRleHQgPSBwLmNhbGxiYWNrc0NvbnRleHQgfHwgdGhpcyxcblx0ICAgICAgICAgIHByb2dyZXNzID0gaXNCZWZvcmUgPyAwIDogMTtcblxuXHQgICAgICBwLm9uUmVmcmVzaC5jYWxsKGNvbnRleHQsIGlzQmVmb3JlLCBwLmVhc2luZyhwcm9ncmVzcyksIHByb2dyZXNzKTtcblx0ICAgIH1cblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2Qgd2hpY2ggaXMgY2FsbGVkIHdoZW4gdGhlIHR3ZWVuIGlzIHJlbW92ZWQgZnJvbSB0d2VlbmVyLlxuXHQgICAgQHByaXZhdGVcblx0ICAqL1xuXG5cblx0ICBUd2Vlbi5wcm90b3R5cGUuX29uVHdlZW5lclJlbW92ZSA9IGZ1bmN0aW9uIF9vblR3ZWVuZXJSZW1vdmUoKSB7fTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHdoaWNoIGlzIGNhbGxlZCB3aGVuIHRoZSB0d2VlbiBpcyByZW1vdmVkXG5cdCAgICBmcm9tIHR3ZWVuZXIgd2hlbiBmaW5pc2hlZC5cblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblxuXG5cdCAgVHdlZW4ucHJvdG90eXBlLl9vblR3ZWVuZXJGaW5pc2ggPSBmdW5jdGlvbiBfb25Ud2VlbmVyRmluaXNoKCkge1xuXHQgICAgdGhpcy5fc2V0UGxheWJhY2tTdGF0ZSgnc3RvcCcpO1xuXHQgICAgdGhpcy5fcGxheWJhY2tDb21wbGV0ZSgpO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBzZXQgcHJvcGVydHlbc10gb24gVHdlZW4uXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQG92ZXJyaWRlIEAgTW9kdWxlXG5cdCAgICBAcGFyYW0ge09iamVjdCwgU3RyaW5nfSBIYXNoIG9iamVjdCBvZiBrZXkvdmFsdWUgcGFpcnMsIG9yIHByb3BlcnR5IG5hbWUuXG5cdCAgICBAcGFyYW0ge199IFByb3BlcnR5J3MgdmFsdWUgdG8gc2V0LlxuXHQgICovXG5cblxuXHQgIFR3ZWVuLnByb3RvdHlwZS5fc2V0UHJvcCA9IGZ1bmN0aW9uIF9zZXRQcm9wKG9iaiwgdmFsdWUpIHtcblx0ICAgIF9Nb2R1bGUucHJvdG90eXBlLl9zZXRQcm9wLmNhbGwodGhpcywgb2JqLCB2YWx1ZSk7XG5cdCAgICB0aGlzLl9jYWxjRGltZW50aW9ucygpO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBzZXQgc2luZ2xlIHByb3BlcnR5LlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBvdmVycmlkZSBAIE1vZHVsZVxuXHQgICAgQHBhcmFtIHtTdHJpbmd9IE5hbWUgb2YgdGhlIHByb3BlcnR5LlxuXHQgICAgQHBhcmFtIHtBbnl9IFZhbHVlIGZvciB0aGUgcHJvcGVydHkuXG5cdCAgKi9cblxuXG5cdCAgVHdlZW4ucHJvdG90eXBlLl9hc3NpZ25Qcm9wID0gZnVuY3Rpb24gX2Fzc2lnblByb3Aoa2V5LCB2YWx1ZSkge1xuXHQgICAgLy8gZmFsbGJhY2sgdG8gZGVmYXVsdHNcblx0ICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG5cdCAgICAgIHZhbHVlID0gdGhpcy5fZGVmYXVsdHNba2V5XTtcblx0ICAgIH1cblx0ICAgIC8vIHBhcnNlIGVhc2luZ1xuXHQgICAgaWYgKGtleSA9PT0gJ2Vhc2luZycpIHtcblx0ICAgICAgdmFsdWUgPSBfZWFzaW5nMi5kZWZhdWx0LnBhcnNlRWFzaW5nKHZhbHVlKTtcblx0ICAgICAgdmFsdWUuX3BhcmVudCA9IHRoaXM7XG5cdCAgICB9XG5cdCAgICAvLyBoYW5kbGUgY29udHJvbCBjYWxsYmFja3Mgb3ZlcnJpZGVzXG5cdCAgICB2YXIgY29udHJvbCA9IHRoaXMuX2NhbGxiYWNrT3ZlcnJpZGVzW2tleV0sXG5cdCAgICAgICAgaXNudE92ZXJyaWRlbiA9ICF2YWx1ZSB8fCAhdmFsdWUuaXNNb2pzQ2FsbGJhY2tPdmVycmlkZTtcblx0ICAgIGlmIChjb250cm9sICYmIGlzbnRPdmVycmlkZW4pIHtcblx0ICAgICAgdmFsdWUgPSB0aGlzLl9vdmVycmlkZUNhbGxiYWNrKHZhbHVlLCBjb250cm9sKTtcblx0ICAgIH1cblx0ICAgIC8vIGNhbGwgc3VwZXIgb24gTW9kdWxlXG5cdCAgICBfTW9kdWxlLnByb3RvdHlwZS5fYXNzaWduUHJvcC5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBvdmVycmlkZSBjYWxsYmFjayBmb3IgY29udHJvbGwgcHVwcm9wZXMuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtTdHJpbmd9ICAgIENhbGxiYWNrIG5hbWUuXG5cdCAgICBAcGFybWEge0Z1bmN0aW9ufSAgTWV0aG9kIHRvIGNhbGwgIFxuXHQgICovXG5cblxuXHQgIFR3ZWVuLnByb3RvdHlwZS5fb3ZlcnJpZGVDYWxsYmFjayA9IGZ1bmN0aW9uIF9vdmVycmlkZUNhbGxiYWNrKGNhbGxiYWNrLCBmdW4pIHtcblx0ICAgIHZhciBpc0NhbGxiYWNrID0gY2FsbGJhY2sgJiYgdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nLFxuXHQgICAgICAgIG92ZXJyaWRlID0gZnVuY3Rpb24gY2FsbGJhY2tPdmVycmlkZSgpIHtcblx0ICAgICAgLy8gY2FsbCBvdmVycmlkZW4gY2FsbGJhY2sgaWYgaXQgZXhpc3RzXG5cdCAgICAgIGlzQ2FsbGJhY2sgJiYgY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgLy8gY2FsbCB0aGUgcGFzc2VkIGNsZWFudXAgZnVuY3Rpb25cblx0ICAgICAgZnVuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICB9O1xuXHQgICAgLy8gYWRkIG92ZXJyaWRkZW4gZmxhZ1xuXHQgICAgb3ZlcnJpZGUuaXNNb2pzQ2FsbGJhY2tPdmVycmlkZSA9IHRydWU7XG5cdCAgICByZXR1cm4gb3ZlcnJpZGU7XG5cdCAgfTtcblxuXHQgIC8vIF92aXN1YWxpemVQcm9ncmVzcyh0aW1lKSB7XG5cdCAgLy8gICB2YXIgc3RyID0gJ3wnLFxuXHQgIC8vICAgICAgIHByb2NTdHIgPSAnICcsXG5cdCAgLy8gICAgICAgcCA9IHRoaXMuX3Byb3BzLFxuXHQgIC8vICAgICAgIHByb2MgPSBwLnN0YXJ0VGltZSAtIHAuZGVsYXk7XG5cblx0ICAvLyAgIHdoaWxlICggcHJvYyA8IHAuZW5kVGltZSApIHtcblx0ICAvLyAgICAgaWYgKHAuZGVsYXkgPiAwICkge1xuXHQgIC8vICAgICAgIHZhciBuZXdQcm9jID0gcHJvYyArIHAuZGVsYXk7XG5cdCAgLy8gICAgICAgaWYgKCB0aW1lID4gcHJvYyAmJiB0aW1lIDwgbmV3UHJvYyApIHtcblx0ICAvLyAgICAgICAgIHByb2NTdHIgKz0gJyBeICc7XG5cdCAgLy8gICAgICAgfSBlbHNlIHtcblx0ICAvLyAgICAgICAgIHByb2NTdHIgKz0gJyAgICc7XG5cdCAgLy8gICAgICAgfVxuXHQgIC8vICAgICAgIHByb2MgPSBuZXdQcm9jO1xuXHQgIC8vICAgICAgIHN0ciAgKz0gJy0tLSc7XG5cdCAgLy8gICAgIH1cblx0ICAvLyAgICAgdmFyIG5ld1Byb2MgPSBwcm9jICsgcC5kdXJhdGlvbjtcblx0ICAvLyAgICAgaWYgKCB0aW1lID4gcHJvYyAmJiB0aW1lIDwgbmV3UHJvYyApIHtcblx0ICAvLyAgICAgICBwcm9jU3RyICs9ICcgIF4gICAnO1xuXHQgIC8vICAgICB9IGVsc2UgaWYgKHRpbWUgPT09IHByb2MpIHtcblx0ICAvLyAgICAgICBwcm9jU3RyICs9ICdeICAgICAnO1xuXHQgIC8vICAgICB9IGVsc2UgaWYgKHRpbWUgPT09IG5ld1Byb2MpIHtcblx0ICAvLyAgICAgICBwcm9jU3RyICs9ICcgICAgXiAnO1xuXHQgIC8vICAgICB9IGVsc2Uge1xuXHQgIC8vICAgICAgIHByb2NTdHIgKz0gJyAgICAgICc7XG5cdCAgLy8gICAgIH1cblx0ICAvLyAgICAgcHJvYyA9IG5ld1Byb2M7XG5cdCAgLy8gICAgIHN0ciArPSAnPT09PT18Jztcblx0ICAvLyAgIH1cblxuXHQgIC8vICAgY29uc29sZS5sb2coc3RyKTtcblx0ICAvLyAgIGNvbnNvbGUubG9nKHByb2NTdHIpO1xuXHQgIC8vIH1cblxuXG5cdCAgcmV0dXJuIFR3ZWVuO1xuXHR9KF9tb2R1bGUyLmRlZmF1bHQpO1xuXG5cdGV4cG9ydHMuZGVmYXVsdCA9IFR3ZWVuO1xuXG4vKioqLyB9KSxcbi8qIDEwMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5cdHZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NCk7XG5cblx0dmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG5cdF9fd2VicGFja19yZXF1aXJlX18oMTAzKTtcblxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDEwNCk7XG5cblx0dmFyIF9oID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MSk7XG5cblx0dmFyIF9oMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2gpO1xuXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cblx0dmFyIFR3ZWVuZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgZnVuY3Rpb24gVHdlZW5lcigpIHtcblx0ICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIFR3ZWVuZXIpO1xuXG5cdCAgICB0aGlzLl92YXJzKCk7XG5cdCAgICB0aGlzLl9saXN0ZW5WaXNpYmlsaXR5Q2hhbmdlKCk7XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9XG5cblx0ICBUd2VlbmVyLnByb3RvdHlwZS5fdmFycyA9IGZ1bmN0aW9uIF92YXJzKCkge1xuXHQgICAgdGhpcy50d2VlbnMgPSBbXTtcblx0ICAgIHRoaXMuX3NhdmVkVHdlZW5zID0gW107XG5cdCAgICB0aGlzLl9sb29wID0gdGhpcy5fbG9vcC5iaW5kKHRoaXMpO1xuXHQgICAgdGhpcy5fb25WaXNpYmlsaXR5Q2hhbmdlID0gdGhpcy5fb25WaXNpYmlsaXR5Q2hhbmdlLmJpbmQodGhpcyk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWFpbiBhbmltYXRpb24gbG9vcC4gU2hvdWxkIGhhdmUgb25seSBvbmUgY29uY3VycmVudCBsb29wLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEByZXR1cm5zIHRoaXNcblx0ICAqL1xuXG5cblx0ICBUd2VlbmVyLnByb3RvdHlwZS5fbG9vcCA9IGZ1bmN0aW9uIF9sb29wKCkge1xuXHQgICAgaWYgKCF0aGlzLl9pc1J1bm5pbmcpIHtcblx0ICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXHQgICAgdGhpcy5fdXBkYXRlKHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKSk7XG5cdCAgICBpZiAoIXRoaXMudHdlZW5zLmxlbmd0aCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5faXNSdW5uaW5nID0gZmFsc2U7XG5cdCAgICB9XG5cdCAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5fbG9vcCk7XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gc3RhcnQgYW5pbWF0aW9uIGxvb3AuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIFR3ZWVuZXIucHJvdG90eXBlLl9zdGFydExvb3AgPSBmdW5jdGlvbiBfc3RhcnRMb29wKCkge1xuXHQgICAgaWYgKHRoaXMuX2lzUnVubmluZykge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9O3RoaXMuX2lzUnVubmluZyA9IHRydWU7XG5cdCAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5fbG9vcCk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHN0b3AgYW5pbWF0aW9uIGxvb3AuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIFR3ZWVuZXIucHJvdG90eXBlLl9zdG9wTG9vcCA9IGZ1bmN0aW9uIF9zdG9wTG9vcCgpIHtcblx0ICAgIHRoaXMuX2lzUnVubmluZyA9IGZhbHNlO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byB1cGRhdGUgZXZlcnkgdHdlZW4vdGltZWxpbmUgb24gYW5pbWF0aW9uIGZyYW1lLlxuXHQgICAgQHByaXZhdGVcblx0ICAqL1xuXG5cblx0ICBUd2VlbmVyLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gX3VwZGF0ZSh0aW1lKSB7XG5cdCAgICB2YXIgaSA9IHRoaXMudHdlZW5zLmxlbmd0aDtcblx0ICAgIHdoaWxlIChpLS0pIHtcblx0ICAgICAgLy8gY2FjaGUgdGhlIGN1cnJlbnQgdHdlZW5cblx0ICAgICAgdmFyIHR3ZWVuID0gdGhpcy50d2VlbnNbaV07XG5cdCAgICAgIGlmICh0d2VlbiAmJiB0d2Vlbi5fdXBkYXRlKHRpbWUpID09PSB0cnVlKSB7XG5cdCAgICAgICAgdGhpcy5yZW1vdmUodHdlZW4pO1xuXHQgICAgICAgIHR3ZWVuLl9vblR3ZWVuZXJGaW5pc2goKTtcblx0ICAgICAgICB0d2Vlbi5fcHJldlRpbWUgPSB1bmRlZmluZWQ7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gYWRkIGEgVHdlZW4vVGltZWxpbmUgdG8gbG9vcCBwb29sLlxuXHQgICAgQHBhcmFtIHtPYmplY3R9IFR3ZWVuL1RpbWVsaW5lIHRvIGFkZC5cblx0ICAqL1xuXG5cblx0ICBUd2VlbmVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQodHdlZW4pIHtcblx0ICAgIC8vIHJldHVybiBpZiB0d2VlbiBpcyBhbHJlYWR5IHJ1bm5pbmdcblx0ICAgIGlmICh0d2Vlbi5faXNSdW5uaW5nKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIHR3ZWVuLl9pc1J1bm5pbmcgPSB0cnVlO1xuXHQgICAgdGhpcy50d2VlbnMucHVzaCh0d2Vlbik7XG5cdCAgICB0aGlzLl9zdGFydExvb3AoKTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2Qgc3RvcCB1cGRhdGluZyBhbGwgdGhlIGNoaWxkIHR3ZWVucy90aW1lbGluZXMuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIFR3ZWVuZXIucHJvdG90eXBlLnJlbW92ZUFsbCA9IGZ1bmN0aW9uIHJlbW92ZUFsbCgpIHtcblx0ICAgIHRoaXMudHdlZW5zLmxlbmd0aCA9IDA7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHJlbW92ZSBzcGVjaWZpYyB0d2Vlbi90aW1lbGluZSBmb3JtIHVwZGF0aW5nLlxuXHQgICAgQHByaXZhdGVcblx0ICAqL1xuXG5cblx0ICBUd2VlbmVyLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUodHdlZW4pIHtcblx0ICAgIHZhciBpbmRleCA9IHR5cGVvZiB0d2VlbiA9PT0gJ251bWJlcicgPyB0d2VlbiA6IHRoaXMudHdlZW5zLmluZGV4T2YodHdlZW4pO1xuXG5cdCAgICBpZiAoaW5kZXggIT09IC0xKSB7XG5cdCAgICAgIHR3ZWVuID0gdGhpcy50d2VlbnNbaW5kZXhdO1xuXHQgICAgICBpZiAodHdlZW4pIHtcblx0ICAgICAgICB0d2Vlbi5faXNSdW5uaW5nID0gZmFsc2U7XG5cdCAgICAgICAgdGhpcy50d2VlbnMuc3BsaWNlKGluZGV4LCAxKTtcblx0ICAgICAgICB0d2Vlbi5fb25Ud2VlbmVyUmVtb3ZlKCk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBpbml0aWFsaXplIGV2ZW50IGxpc3RlbmVycyB0byB2aXNpYmlsaXR5IGNoYW5nZSBldmVudHMuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIFR3ZWVuZXIucHJvdG90eXBlLl9saXN0ZW5WaXNpYmlsaXR5Q2hhbmdlID0gZnVuY3Rpb24gX2xpc3RlblZpc2liaWxpdHlDaGFuZ2UoKSB7XG5cdCAgICBpZiAodHlwZW9mIGRvY3VtZW50LmhpZGRlbiAhPT0gXCJ1bmRlZmluZWRcIikge1xuXHQgICAgICB0aGlzLl92aXNpYmlsaXR5SGlkZGVuID0gXCJoaWRkZW5cIjtcblx0ICAgICAgdGhpcy5fdmlzaWJpbGl0eUNoYW5nZSA9IFwidmlzaWJpbGl0eWNoYW5nZVwiO1xuXHQgICAgfSBlbHNlIGlmICh0eXBlb2YgZG9jdW1lbnQubW96SGlkZGVuICE9PSBcInVuZGVmaW5lZFwiKSB7XG5cdCAgICAgIHRoaXMuX3Zpc2liaWxpdHlIaWRkZW4gPSBcIm1vekhpZGRlblwiO1xuXHQgICAgICB0aGlzLl92aXNpYmlsaXR5Q2hhbmdlID0gXCJtb3p2aXNpYmlsaXR5Y2hhbmdlXCI7XG5cdCAgICB9IGVsc2UgaWYgKHR5cGVvZiBkb2N1bWVudC5tc0hpZGRlbiAhPT0gXCJ1bmRlZmluZWRcIikge1xuXHQgICAgICB0aGlzLl92aXNpYmlsaXR5SGlkZGVuID0gXCJtc0hpZGRlblwiO1xuXHQgICAgICB0aGlzLl92aXNpYmlsaXR5Q2hhbmdlID0gXCJtc3Zpc2liaWxpdHljaGFuZ2VcIjtcblx0ICAgIH0gZWxzZSBpZiAodHlwZW9mIGRvY3VtZW50LndlYmtpdEhpZGRlbiAhPT0gXCJ1bmRlZmluZWRcIikge1xuXHQgICAgICB0aGlzLl92aXNpYmlsaXR5SGlkZGVuID0gXCJ3ZWJraXRIaWRkZW5cIjtcblx0ICAgICAgdGhpcy5fdmlzaWJpbGl0eUNoYW5nZSA9IFwid2Via2l0dmlzaWJpbGl0eWNoYW5nZVwiO1xuXHQgICAgfVxuXG5cdCAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKHRoaXMuX3Zpc2liaWxpdHlDaGFuZ2UsIHRoaXMuX29uVmlzaWJpbGl0eUNoYW5nZSwgZmFsc2UpO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0aGF0IHdpbGwgZmlyZSBvbiB2aXNpYmlsaXR5IGNoYW5nZS5cblx0ICAqL1xuXG5cblx0ICBUd2VlbmVyLnByb3RvdHlwZS5fb25WaXNpYmlsaXR5Q2hhbmdlID0gZnVuY3Rpb24gX29uVmlzaWJpbGl0eUNoYW5nZSgpIHtcblx0ICAgIGlmIChkb2N1bWVudFt0aGlzLl92aXNpYmlsaXR5SGlkZGVuXSkge1xuXHQgICAgICB0aGlzLl9zYXZlUGxheWluZ1R3ZWVucygpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdGhpcy5fcmVzdG9yZVBsYXlpbmdUd2VlbnMoKTtcblx0ICAgIH1cblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gc2F2ZSBhbGwgcGxheWluZyB0d2VlbnMuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIFR3ZWVuZXIucHJvdG90eXBlLl9zYXZlUGxheWluZ1R3ZWVucyA9IGZ1bmN0aW9uIF9zYXZlUGxheWluZ1R3ZWVucygpIHtcblx0ICAgIHRoaXMuX3NhdmVkVHdlZW5zID0gdGhpcy50d2VlbnMuc2xpY2UoMCk7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NhdmVkVHdlZW5zLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHRoaXMuX3NhdmVkVHdlZW5zW2ldLnBhdXNlKCk7XG5cdCAgICB9XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHJlc3RvcmUgYWxsIHBsYXlpbmcgdHdlZW5zLlxuXHQgICAgQHByaXZhdGVcblx0ICAqL1xuXG5cblx0ICBUd2VlbmVyLnByb3RvdHlwZS5fcmVzdG9yZVBsYXlpbmdUd2VlbnMgPSBmdW5jdGlvbiBfcmVzdG9yZVBsYXlpbmdUd2VlbnMoKSB7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NhdmVkVHdlZW5zLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHRoaXMuX3NhdmVkVHdlZW5zW2ldLnJlc3VtZSgpO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICByZXR1cm4gVHdlZW5lcjtcblx0fSgpO1xuXG5cdHZhciB0ID0gbmV3IFR3ZWVuZXIoKTtcblx0ZXhwb3J0cy5kZWZhdWx0ID0gdDtcblxuLyoqKi8gfSksXG4vKiAxMDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRcblx0LyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0KGZ1bmN0aW9uKCkge1xuXHQgICd1c2Ugc3RyaWN0Jztcblx0ICB2YXIgY2FuY2VsLCBpLCBpc09sZEJyb3dzZXIsIGxhc3RUaW1lLCB2ZW5kb3JzLCB2cCwgdztcblx0ICB2ZW5kb3JzID0gWyd3ZWJraXQnLCAnbW96J107XG5cdCAgaSA9IDA7XG5cdCAgdyA9IHdpbmRvdztcblx0ICB3aGlsZSAoaSA8IHZlbmRvcnMubGVuZ3RoICYmICF3LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuXHQgICAgdnAgPSB2ZW5kb3JzW2ldO1xuXHQgICAgdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB3W3ZwICsgJ1JlcXVlc3RBbmltYXRpb25GcmFtZSddO1xuXHQgICAgY2FuY2VsID0gd1t2cCArICdDYW5jZWxBbmltYXRpb25GcmFtZSddO1xuXHQgICAgdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGNhbmNlbCB8fCB3W3ZwICsgJ0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSddO1xuXHQgICAgKytpO1xuXHQgIH1cblx0ICBpc09sZEJyb3dzZXIgPSAhdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgIXcuY2FuY2VsQW5pbWF0aW9uRnJhbWU7XG5cdCAgaWYgKC9pUChhZHxob25lfG9kKS4qT1MgNi8udGVzdCh3Lm5hdmlnYXRvci51c2VyQWdlbnQpIHx8IGlzT2xkQnJvd3Nlcikge1xuXHQgICAgbGFzdFRpbWUgPSAwO1xuXHQgICAgdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuXHQgICAgICB2YXIgbmV4dFRpbWUsIG5vdztcblx0ICAgICAgbm93ID0gRGF0ZS5ub3coKTtcblx0ICAgICAgbmV4dFRpbWUgPSBNYXRoLm1heChsYXN0VGltZSArIDE2LCBub3cpO1xuXHQgICAgICByZXR1cm4gc2V0VGltZW91dCgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgY2FsbGJhY2sobGFzdFRpbWUgPSBuZXh0VGltZSk7XG5cdCAgICAgIH0pLCBuZXh0VGltZSAtIG5vdyk7XG5cdCAgICB9O1xuXHQgICAgdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGNsZWFyVGltZW91dDtcblx0ICB9XG5cdH0pKCk7XG5cblxuLyoqKi8gfSksXG4vKiAxMDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRcblx0LyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0KGZ1bmN0aW9uKHJvb3QpIHtcblx0ICB2YXIgb2Zmc2V0LCByZWYsIHJlZjE7XG5cdCAgaWYgKHJvb3QucGVyZm9ybWFuY2UgPT0gbnVsbCkge1xuXHQgICAgcm9vdC5wZXJmb3JtYW5jZSA9IHt9O1xuXHQgIH1cblx0ICBEYXRlLm5vdyA9IERhdGUubm93IHx8IGZ1bmN0aW9uKCkge1xuXHQgICAgcmV0dXJuIChuZXcgRGF0ZSkuZ2V0VGltZSgpO1xuXHQgIH07XG5cdCAgaWYgKHJvb3QucGVyZm9ybWFuY2Uubm93ID09IG51bGwpIHtcblx0ICAgIG9mZnNldCA9ICgocmVmID0gcm9vdC5wZXJmb3JtYW5jZSkgIT0gbnVsbCA/IChyZWYxID0gcmVmLnRpbWluZykgIT0gbnVsbCA/IHJlZjEubmF2aWdhdGlvblN0YXJ0IDogdm9pZCAwIDogdm9pZCAwKSA/IHBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnQgOiBEYXRlLm5vdygpO1xuXHQgICAgcmV0dXJuIHJvb3QucGVyZm9ybWFuY2Uubm93ID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gb2Zmc2V0O1xuXHQgICAgfTtcblx0ICB9XG5cdH0pKHdpbmRvdyk7XG5cblxuLyoqKi8gfSksXG4vKiAxMDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgRWFzaW5nLCBQSSwgUGF0aEVhc2luZywgYXBwcm94aW1hdGUsIGJlemllciwgZWFzaW5nLCBoLCBtaXgsIHNpbjtcblxuXHRiZXppZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwNik7XG5cblx0UGF0aEVhc2luZyA9IF9fd2VicGFja19yZXF1aXJlX18oMTA3KTtcblxuXHRtaXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwOCk7XG5cblx0aCA9IF9fd2VicGFja19yZXF1aXJlX18oNzEpO1xuXG5cdGFwcHJveGltYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDkpW1wiZGVmYXVsdFwiXSB8fCBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwOSk7XG5cblx0c2luID0gTWF0aC5zaW47XG5cblx0UEkgPSBNYXRoLlBJO1xuXG5cdEVhc2luZyA9IChmdW5jdGlvbigpIHtcblx0ICBmdW5jdGlvbiBFYXNpbmcoKSB7fVxuXG5cdCAgRWFzaW5nLnByb3RvdHlwZS5iZXppZXIgPSBiZXppZXI7XG5cblx0ICBFYXNpbmcucHJvdG90eXBlLlBhdGhFYXNpbmcgPSBQYXRoRWFzaW5nO1xuXG5cdCAgRWFzaW5nLnByb3RvdHlwZS5wYXRoID0gKG5ldyBQYXRoRWFzaW5nKCdjcmVhdG9yJykpLmNyZWF0ZTtcblxuXHQgIEVhc2luZy5wcm90b3R5cGUuYXBwcm94aW1hdGUgPSBhcHByb3hpbWF0ZTtcblxuXHQgIEVhc2luZy5wcm90b3R5cGUuaW52ZXJzZSA9IGZ1bmN0aW9uKHApIHtcblx0ICAgIHJldHVybiAxIC0gcDtcblx0ICB9O1xuXG5cdCAgRWFzaW5nLnByb3RvdHlwZS5saW5lYXIgPSB7XG5cdCAgICBub25lOiBmdW5jdGlvbihrKSB7XG5cdCAgICAgIHJldHVybiBrO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICBFYXNpbmcucHJvdG90eXBlLmVhc2UgPSB7XG5cdCAgICBcImluXCI6IGJlemllci5hcHBseShFYXNpbmcsIFswLjQyLCAwLCAxLCAxXSksXG5cdCAgICBvdXQ6IGJlemllci5hcHBseShFYXNpbmcsIFswLCAwLCAwLjU4LCAxXSksXG5cdCAgICBpbm91dDogYmV6aWVyLmFwcGx5KEVhc2luZywgWzAuNDIsIDAsIDAuNTgsIDFdKVxuXHQgIH07XG5cblx0ICBFYXNpbmcucHJvdG90eXBlLnNpbiA9IHtcblx0ICAgIFwiaW5cIjogZnVuY3Rpb24oaykge1xuXHQgICAgICByZXR1cm4gMSAtIE1hdGguY29zKGsgKiBQSSAvIDIpO1xuXHQgICAgfSxcblx0ICAgIG91dDogZnVuY3Rpb24oaykge1xuXHQgICAgICByZXR1cm4gc2luKGsgKiBQSSAvIDIpO1xuXHQgICAgfSxcblx0ICAgIGlub3V0OiBmdW5jdGlvbihrKSB7XG5cdCAgICAgIHJldHVybiAwLjUgKiAoMSAtIE1hdGguY29zKFBJICogaykpO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICBFYXNpbmcucHJvdG90eXBlLnF1YWQgPSB7XG5cdCAgICBcImluXCI6IGZ1bmN0aW9uKGspIHtcblx0ICAgICAgcmV0dXJuIGsgKiBrO1xuXHQgICAgfSxcblx0ICAgIG91dDogZnVuY3Rpb24oaykge1xuXHQgICAgICByZXR1cm4gayAqICgyIC0gayk7XG5cdCAgICB9LFxuXHQgICAgaW5vdXQ6IGZ1bmN0aW9uKGspIHtcblx0ICAgICAgaWYgKChrICo9IDIpIDwgMSkge1xuXHQgICAgICAgIHJldHVybiAwLjUgKiBrICogaztcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gLTAuNSAqICgtLWsgKiAoayAtIDIpIC0gMSk7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIEVhc2luZy5wcm90b3R5cGUuY3ViaWMgPSB7XG5cdCAgICBcImluXCI6IGZ1bmN0aW9uKGspIHtcblx0ICAgICAgcmV0dXJuIGsgKiBrICogaztcblx0ICAgIH0sXG5cdCAgICBvdXQ6IGZ1bmN0aW9uKGspIHtcblx0ICAgICAgcmV0dXJuIC0tayAqIGsgKiBrICsgMTtcblx0ICAgIH0sXG5cdCAgICBpbm91dDogZnVuY3Rpb24oaykge1xuXHQgICAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG5cdCAgICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrICogaztcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gMC41ICogKChrIC09IDIpICogayAqIGsgKyAyKTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgRWFzaW5nLnByb3RvdHlwZS5xdWFydCA9IHtcblx0ICAgIFwiaW5cIjogZnVuY3Rpb24oaykge1xuXHQgICAgICByZXR1cm4gayAqIGsgKiBrICogaztcblx0ICAgIH0sXG5cdCAgICBvdXQ6IGZ1bmN0aW9uKGspIHtcblx0ICAgICAgcmV0dXJuIDEgLSAoLS1rICogayAqIGsgKiBrKTtcblx0ICAgIH0sXG5cdCAgICBpbm91dDogZnVuY3Rpb24oaykge1xuXHQgICAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG5cdCAgICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrICogayAqIGs7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIC0wLjUgKiAoKGsgLT0gMikgKiBrICogayAqIGsgLSAyKTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgRWFzaW5nLnByb3RvdHlwZS5xdWludCA9IHtcblx0ICAgIFwiaW5cIjogZnVuY3Rpb24oaykge1xuXHQgICAgICByZXR1cm4gayAqIGsgKiBrICogayAqIGs7XG5cdCAgICB9LFxuXHQgICAgb3V0OiBmdW5jdGlvbihrKSB7XG5cdCAgICAgIHJldHVybiAtLWsgKiBrICogayAqIGsgKiBrICsgMTtcblx0ICAgIH0sXG5cdCAgICBpbm91dDogZnVuY3Rpb24oaykge1xuXHQgICAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG5cdCAgICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrICogayAqIGsgKiBrO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiAwLjUgKiAoKGsgLT0gMikgKiBrICogayAqIGsgKiBrICsgMik7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIEVhc2luZy5wcm90b3R5cGUuZXhwbyA9IHtcblx0ICAgIFwiaW5cIjogZnVuY3Rpb24oaykge1xuXHQgICAgICBpZiAoayA9PT0gMCkge1xuXHQgICAgICAgIHJldHVybiAwO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHJldHVybiBNYXRoLnBvdygxMDI0LCBrIC0gMSk7XG5cdCAgICAgIH1cblx0ICAgIH0sXG5cdCAgICBvdXQ6IGZ1bmN0aW9uKGspIHtcblx0ICAgICAgaWYgKGsgPT09IDEpIHtcblx0ICAgICAgICByZXR1cm4gMTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICByZXR1cm4gMSAtIE1hdGgucG93KDIsIC0xMCAqIGspO1xuXHQgICAgICB9XG5cdCAgICB9LFxuXHQgICAgaW5vdXQ6IGZ1bmN0aW9uKGspIHtcblx0ICAgICAgaWYgKGsgPT09IDApIHtcblx0ICAgICAgICByZXR1cm4gMDtcblx0ICAgICAgfVxuXHQgICAgICBpZiAoayA9PT0gMSkge1xuXHQgICAgICAgIHJldHVybiAxO1xuXHQgICAgICB9XG5cdCAgICAgIGlmICgoayAqPSAyKSA8IDEpIHtcblx0ICAgICAgICByZXR1cm4gMC41ICogTWF0aC5wb3coMTAyNCwgayAtIDEpO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiAwLjUgKiAoLU1hdGgucG93KDIsIC0xMCAqIChrIC0gMSkpICsgMik7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIEVhc2luZy5wcm90b3R5cGUuY2lyYyA9IHtcblx0ICAgIFwiaW5cIjogZnVuY3Rpb24oaykge1xuXHQgICAgICByZXR1cm4gMSAtIE1hdGguc3FydCgxIC0gayAqIGspO1xuXHQgICAgfSxcblx0ICAgIG91dDogZnVuY3Rpb24oaykge1xuXHQgICAgICByZXR1cm4gTWF0aC5zcXJ0KDEgLSAoLS1rICogaykpO1xuXHQgICAgfSxcblx0ICAgIGlub3V0OiBmdW5jdGlvbihrKSB7XG5cdCAgICAgIGlmICgoayAqPSAyKSA8IDEpIHtcblx0ICAgICAgICByZXR1cm4gLTAuNSAqIChNYXRoLnNxcnQoMSAtIGsgKiBrKSAtIDEpO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiAwLjUgKiAoTWF0aC5zcXJ0KDEgLSAoayAtPSAyKSAqIGspICsgMSk7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIEVhc2luZy5wcm90b3R5cGUuYmFjayA9IHtcblx0ICAgIFwiaW5cIjogZnVuY3Rpb24oaykge1xuXHQgICAgICB2YXIgcztcblx0ICAgICAgcyA9IDEuNzAxNTg7XG5cdCAgICAgIHJldHVybiBrICogayAqICgocyArIDEpICogayAtIHMpO1xuXHQgICAgfSxcblx0ICAgIG91dDogZnVuY3Rpb24oaykge1xuXHQgICAgICB2YXIgcztcblx0ICAgICAgcyA9IDEuNzAxNTg7XG5cdCAgICAgIHJldHVybiAtLWsgKiBrICogKChzICsgMSkgKiBrICsgcykgKyAxO1xuXHQgICAgfSxcblx0ICAgIGlub3V0OiBmdW5jdGlvbihrKSB7XG5cdCAgICAgIHZhciBzO1xuXHQgICAgICBzID0gMS43MDE1OCAqIDEuNTI1O1xuXHQgICAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG5cdCAgICAgICAgcmV0dXJuIDAuNSAqIChrICogayAqICgocyArIDEpICogayAtIHMpKTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gMC41ICogKChrIC09IDIpICogayAqICgocyArIDEpICogayArIHMpICsgMik7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIEVhc2luZy5wcm90b3R5cGUuZWxhc3RpYyA9IHtcblx0ICAgIFwiaW5cIjogZnVuY3Rpb24oaykge1xuXHQgICAgICB2YXIgYSwgcCwgcztcblx0ICAgICAgcyA9IHZvaWQgMDtcblx0ICAgICAgcCA9IDAuNDtcblx0ICAgICAgaWYgKGsgPT09IDApIHtcblx0ICAgICAgICByZXR1cm4gMDtcblx0ICAgICAgfVxuXHQgICAgICBpZiAoayA9PT0gMSkge1xuXHQgICAgICAgIHJldHVybiAxO1xuXHQgICAgICB9XG5cdCAgICAgIGEgPSAxO1xuXHQgICAgICBzID0gcCAvIDQ7XG5cdCAgICAgIHJldHVybiAtKGEgKiBNYXRoLnBvdygyLCAxMCAqIChrIC09IDEpKSAqIE1hdGguc2luKChrIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkpO1xuXHQgICAgfSxcblx0ICAgIG91dDogZnVuY3Rpb24oaykge1xuXHQgICAgICB2YXIgYSwgcCwgcztcblx0ICAgICAgcyA9IHZvaWQgMDtcblx0ICAgICAgcCA9IDAuNDtcblx0ICAgICAgaWYgKGsgPT09IDApIHtcblx0ICAgICAgICByZXR1cm4gMDtcblx0ICAgICAgfVxuXHQgICAgICBpZiAoayA9PT0gMSkge1xuXHQgICAgICAgIHJldHVybiAxO1xuXHQgICAgICB9XG5cdCAgICAgIGEgPSAxO1xuXHQgICAgICBzID0gcCAvIDQ7XG5cdCAgICAgIHJldHVybiBhICogTWF0aC5wb3coMiwgLTEwICogaykgKiBNYXRoLnNpbigoayAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApICsgMTtcblx0ICAgIH0sXG5cdCAgICBpbm91dDogZnVuY3Rpb24oaykge1xuXHQgICAgICB2YXIgYSwgcCwgcztcblx0ICAgICAgcyA9IHZvaWQgMDtcblx0ICAgICAgcCA9IDAuNDtcblx0ICAgICAgaWYgKGsgPT09IDApIHtcblx0ICAgICAgICByZXR1cm4gMDtcblx0ICAgICAgfVxuXHQgICAgICBpZiAoayA9PT0gMSkge1xuXHQgICAgICAgIHJldHVybiAxO1xuXHQgICAgICB9XG5cdCAgICAgIGEgPSAxO1xuXHQgICAgICBzID0gcCAvIDQ7XG5cdCAgICAgIGlmICgoayAqPSAyKSA8IDEpIHtcblx0ICAgICAgICByZXR1cm4gLTAuNSAqIChhICogTWF0aC5wb3coMiwgMTAgKiAoayAtPSAxKSkgKiBNYXRoLnNpbigoayAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApKTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gYSAqIE1hdGgucG93KDIsIC0xMCAqIChrIC09IDEpKSAqIE1hdGguc2luKChrIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkgKiAwLjUgKyAxO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICBFYXNpbmcucHJvdG90eXBlLmJvdW5jZSA9IHtcblx0ICAgIFwiaW5cIjogZnVuY3Rpb24oaykge1xuXHQgICAgICByZXR1cm4gMSAtIGVhc2luZy5ib3VuY2Uub3V0KDEgLSBrKTtcblx0ICAgIH0sXG5cdCAgICBvdXQ6IGZ1bmN0aW9uKGspIHtcblx0ICAgICAgaWYgKGsgPCAoMSAvIDIuNzUpKSB7XG5cdCAgICAgICAgcmV0dXJuIDcuNTYyNSAqIGsgKiBrO1xuXHQgICAgICB9IGVsc2UgaWYgKGsgPCAoMiAvIDIuNzUpKSB7XG5cdCAgICAgICAgcmV0dXJuIDcuNTYyNSAqIChrIC09IDEuNSAvIDIuNzUpICogayArIDAuNzU7XG5cdCAgICAgIH0gZWxzZSBpZiAoayA8ICgyLjUgLyAyLjc1KSkge1xuXHQgICAgICAgIHJldHVybiA3LjU2MjUgKiAoayAtPSAyLjI1IC8gMi43NSkgKiBrICsgMC45Mzc1O1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHJldHVybiA3LjU2MjUgKiAoayAtPSAyLjYyNSAvIDIuNzUpICogayArIDAuOTg0Mzc1O1xuXHQgICAgICB9XG5cdCAgICB9LFxuXHQgICAgaW5vdXQ6IGZ1bmN0aW9uKGspIHtcblx0ICAgICAgaWYgKGsgPCAwLjUpIHtcblx0ICAgICAgICByZXR1cm4gZWFzaW5nLmJvdW5jZVtcImluXCJdKGsgKiAyKSAqIDAuNTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gZWFzaW5nLmJvdW5jZS5vdXQoayAqIDIgLSAxKSAqIDAuNSArIDAuNTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgRWFzaW5nLnByb3RvdHlwZS5wYXJzZUVhc2luZyA9IGZ1bmN0aW9uKGVhc2luZykge1xuXHQgICAgdmFyIGVhc2luZ1BhcmVudCwgdHlwZTtcblx0ICAgIGlmIChlYXNpbmcgPT0gbnVsbCkge1xuXHQgICAgICBlYXNpbmcgPSAnbGluZWFyLm5vbmUnO1xuXHQgICAgfVxuXHQgICAgdHlwZSA9IHR5cGVvZiBlYXNpbmc7XG5cdCAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcblx0ICAgICAgaWYgKGVhc2luZy5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSA9PT0gJ20nKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMucGF0aChlYXNpbmcpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGVhc2luZyA9IHRoaXMuX3NwbGl0RWFzaW5nKGVhc2luZyk7XG5cdCAgICAgICAgZWFzaW5nUGFyZW50ID0gdGhpc1tlYXNpbmdbMF1dO1xuXHQgICAgICAgIGlmICghZWFzaW5nUGFyZW50KSB7XG5cdCAgICAgICAgICBoLmVycm9yKFwiRWFzaW5nIHdpdGggbmFtZSBcXFwiXCIgKyBlYXNpbmdbMF0gKyBcIlxcXCIgd2FzIG5vdCBmb3VuZCwgZmFsbGJhY2sgdG8gXFxcImxpbmVhci5ub25lXFxcIiBpbnN0ZWFkXCIpO1xuXHQgICAgICAgICAgcmV0dXJuIHRoaXNbJ2xpbmVhciddWydub25lJ107XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBlYXNpbmdQYXJlbnRbZWFzaW5nWzFdXTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgaWYgKGguaXNBcnJheShlYXNpbmcpKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLmJlemllci5hcHBseSh0aGlzLCBlYXNpbmcpO1xuXHQgICAgfVxuXHQgICAgaWYgKCdmdW5jdGlvbicpIHtcblx0ICAgICAgcmV0dXJuIGVhc2luZztcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgRWFzaW5nLnByb3RvdHlwZS5fc3BsaXRFYXNpbmcgPSBmdW5jdGlvbihzdHJpbmcpIHtcblx0ICAgIHZhciBmaXJzdFBhcnQsIHNlY29uZFBhcnQsIHNwbGl0O1xuXHQgICAgaWYgKHR5cGVvZiBzdHJpbmcgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgcmV0dXJuIHN0cmluZztcblx0ICAgIH1cblx0ICAgIGlmICh0eXBlb2Ygc3RyaW5nID09PSAnc3RyaW5nJyAmJiBzdHJpbmcubGVuZ3RoKSB7XG5cdCAgICAgIHNwbGl0ID0gc3RyaW5nLnNwbGl0KCcuJyk7XG5cdCAgICAgIGZpcnN0UGFydCA9IHNwbGl0WzBdLnRvTG93ZXJDYXNlKCkgfHwgJ2xpbmVhcic7XG5cdCAgICAgIHNlY29uZFBhcnQgPSBzcGxpdFsxXS50b0xvd2VyQ2FzZSgpIHx8ICdub25lJztcblx0ICAgICAgcmV0dXJuIFtmaXJzdFBhcnQsIHNlY29uZFBhcnRdO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmV0dXJuIFsnbGluZWFyJywgJ25vbmUnXTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgcmV0dXJuIEVhc2luZztcblxuXHR9KSgpO1xuXG5cdGVhc2luZyA9IG5ldyBFYXNpbmc7XG5cblx0ZWFzaW5nLm1peCA9IG1peChlYXNpbmcpO1xuXG5cdG1vZHVsZS5leHBvcnRzID0gZWFzaW5nO1xuXG5cbi8qKiovIH0pLFxuLyogMTA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkge3ZhciBCZXppZXJFYXNpbmcsIGJlemllckVhc2luZywgaCxcblx0ICBpbmRleE9mID0gW10uaW5kZXhPZiB8fCBmdW5jdGlvbihpdGVtKSB7IGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHsgaWYgKGkgaW4gdGhpcyAmJiB0aGlzW2ldID09PSBpdGVtKSByZXR1cm4gaTsgfSByZXR1cm4gLTE7IH07XG5cblx0aCA9IF9fd2VicGFja19yZXF1aXJlX18oNzEpO1xuXG5cblx0LyoqXG5cdCAqIENvcHlyaWdodCAoYykgMjAxNCBHYcOrdGFuIFJlbmF1ZGVhdSBodHRwOi8vZ29vLmdsL0VsM2s3dVxuXHQgKiBBZG9wdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2dyZS9iZXppZXItZWFzaW5nXG5cdCAqL1xuXG5cdEJlemllckVhc2luZyA9IChmdW5jdGlvbigpIHtcblx0ICBmdW5jdGlvbiBCZXppZXJFYXNpbmcobykge1xuXHQgICAgdGhpcy52YXJzKCk7XG5cdCAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZTtcblx0ICB9XG5cblx0ICBCZXppZXJFYXNpbmcucHJvdG90eXBlLnZhcnMgPSBmdW5jdGlvbigpIHtcblx0ICAgIHJldHVybiB0aGlzLmdlbmVyYXRlID0gaC5iaW5kKHRoaXMuZ2VuZXJhdGUsIHRoaXMpO1xuXHQgIH07XG5cblx0ICBCZXppZXJFYXNpbmcucHJvdG90eXBlLmdlbmVyYXRlID0gZnVuY3Rpb24obVgxLCBtWTEsIG1YMiwgbVkyKSB7XG5cdCAgICB2YXIgQSwgQiwgQywgTkVXVE9OX0lURVJBVElPTlMsIE5FV1RPTl9NSU5fU0xPUEUsIFNVQkRJVklTSU9OX01BWF9JVEVSQVRJT05TLCBTVUJESVZJU0lPTl9QUkVDSVNJT04sIF9wcmVjb21wdXRlZCwgYXJnLCBiaW5hcnlTdWJkaXZpZGUsIGNhbGNCZXppZXIsIGNhbGNTYW1wbGVWYWx1ZXMsIGYsIGZsb2F0MzJBcnJheVN1cHBvcnRlZCwgZ2V0U2xvcGUsIGdldFRGb3JYLCBpLCBqLCBrU2FtcGxlU3RlcFNpemUsIGtTcGxpbmVUYWJsZVNpemUsIG1TYW1wbGVWYWx1ZXMsIG5ld3RvblJhcGhzb25JdGVyYXRlLCBwcmVjb21wdXRlLCBzdHI7XG5cdCAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDQpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoJ0JlemllciBmdW5jdGlvbiBleHBlY3RzIDQgYXJndW1lbnRzJyk7XG5cdCAgICB9XG5cdCAgICBmb3IgKGkgPSBqID0gMDsgaiA8IDQ7IGkgPSArK2opIHtcblx0ICAgICAgYXJnID0gYXJndW1lbnRzW2ldO1xuXHQgICAgICBpZiAodHlwZW9mIGFyZyAhPT0gXCJudW1iZXJcIiB8fCBpc05hTihhcmcpIHx8ICFpc0Zpbml0ZShhcmcpKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoJ0JlemllciBmdW5jdGlvbiBleHBlY3RzIDQgYXJndW1lbnRzJyk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIGlmIChtWDEgPCAwIHx8IG1YMSA+IDEgfHwgbVgyIDwgMCB8fCBtWDIgPiAxKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLmVycm9yKCdCZXppZXIgeCB2YWx1ZXMgc2hvdWxkIGJlID4gMCBhbmQgPCAxJyk7XG5cdCAgICB9XG5cdCAgICBORVdUT05fSVRFUkFUSU9OUyA9IDQ7XG5cdCAgICBORVdUT05fTUlOX1NMT1BFID0gMC4wMDE7XG5cdCAgICBTVUJESVZJU0lPTl9QUkVDSVNJT04gPSAwLjAwMDAwMDE7XG5cdCAgICBTVUJESVZJU0lPTl9NQVhfSVRFUkFUSU9OUyA9IDEwO1xuXHQgICAga1NwbGluZVRhYmxlU2l6ZSA9IDExO1xuXHQgICAga1NhbXBsZVN0ZXBTaXplID0gMS4wIC8gKGtTcGxpbmVUYWJsZVNpemUgLSAxLjApO1xuXHQgICAgZmxvYXQzMkFycmF5U3VwcG9ydGVkID0gaW5kZXhPZi5jYWxsKGdsb2JhbCwgJ0Zsb2F0MzJBcnJheScpID49IDA7XG5cdCAgICBBID0gZnVuY3Rpb24oYUExLCBhQTIpIHtcblx0ICAgICAgcmV0dXJuIDEuMCAtIDMuMCAqIGFBMiArIDMuMCAqIGFBMTtcblx0ICAgIH07XG5cdCAgICBCID0gZnVuY3Rpb24oYUExLCBhQTIpIHtcblx0ICAgICAgcmV0dXJuIDMuMCAqIGFBMiAtIDYuMCAqIGFBMTtcblx0ICAgIH07XG5cdCAgICBDID0gZnVuY3Rpb24oYUExKSB7XG5cdCAgICAgIHJldHVybiAzLjAgKiBhQTE7XG5cdCAgICB9O1xuXHQgICAgY2FsY0JlemllciA9IGZ1bmN0aW9uKGFULCBhQTEsIGFBMikge1xuXHQgICAgICByZXR1cm4gKChBKGFBMSwgYUEyKSAqIGFUICsgQihhQTEsIGFBMikpICogYVQgKyBDKGFBMSkpICogYVQ7XG5cdCAgICB9O1xuXHQgICAgZ2V0U2xvcGUgPSBmdW5jdGlvbihhVCwgYUExLCBhQTIpIHtcblx0ICAgICAgcmV0dXJuIDMuMCAqIEEoYUExLCBhQTIpICogYVQgKiBhVCArIDIuMCAqIEIoYUExLCBhQTIpICogYVQgKyBDKGFBMSk7XG5cdCAgICB9O1xuXHQgICAgbmV3dG9uUmFwaHNvbkl0ZXJhdGUgPSBmdW5jdGlvbihhWCwgYUd1ZXNzVCkge1xuXHQgICAgICB2YXIgY3VycmVudFNsb3BlLCBjdXJyZW50WDtcblx0ICAgICAgaSA9IDA7XG5cdCAgICAgIHdoaWxlIChpIDwgTkVXVE9OX0lURVJBVElPTlMpIHtcblx0ICAgICAgICBjdXJyZW50U2xvcGUgPSBnZXRTbG9wZShhR3Vlc3NULCBtWDEsIG1YMik7XG5cblx0ICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0ICAgICAgICBpZiAoY3VycmVudFNsb3BlID09PSAwLjApIHtcblx0ICAgICAgICAgIHJldHVybiBhR3Vlc3NUO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBjdXJyZW50WCA9IGNhbGNCZXppZXIoYUd1ZXNzVCwgbVgxLCBtWDIpIC0gYVg7XG5cdCAgICAgICAgYUd1ZXNzVCAtPSBjdXJyZW50WCAvIGN1cnJlbnRTbG9wZTtcblx0ICAgICAgICArK2k7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIGFHdWVzc1Q7XG5cdCAgICB9O1xuXHQgICAgY2FsY1NhbXBsZVZhbHVlcyA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICBpID0gMDtcblx0ICAgICAgd2hpbGUgKGkgPCBrU3BsaW5lVGFibGVTaXplKSB7XG5cdCAgICAgICAgbVNhbXBsZVZhbHVlc1tpXSA9IGNhbGNCZXppZXIoaSAqIGtTYW1wbGVTdGVwU2l6ZSwgbVgxLCBtWDIpO1xuXHQgICAgICAgICsraTtcblx0ICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0ICAgIGJpbmFyeVN1YmRpdmlkZSA9IGZ1bmN0aW9uKGFYLCBhQSwgYUIpIHtcblx0ICAgICAgdmFyIGN1cnJlbnRULCBjdXJyZW50WCwgaXNCaWc7XG5cdCAgICAgIGN1cnJlbnRYID0gdm9pZCAwO1xuXHQgICAgICBjdXJyZW50VCA9IHZvaWQgMDtcblx0ICAgICAgaSA9IDA7XG5cdCAgICAgIHdoaWxlICh0cnVlKSB7XG5cdCAgICAgICAgY3VycmVudFQgPSBhQSArIChhQiAtIGFBKSAvIDIuMDtcblx0ICAgICAgICBjdXJyZW50WCA9IGNhbGNCZXppZXIoY3VycmVudFQsIG1YMSwgbVgyKSAtIGFYO1xuXHQgICAgICAgIGlmIChjdXJyZW50WCA+IDAuMCkge1xuXHQgICAgICAgICAgYUIgPSBjdXJyZW50VDtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgYUEgPSBjdXJyZW50VDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaXNCaWcgPSBNYXRoLmFicyhjdXJyZW50WCkgPiBTVUJESVZJU0lPTl9QUkVDSVNJT047XG5cdCAgICAgICAgaWYgKCEoaXNCaWcgJiYgKytpIDwgU1VCRElWSVNJT05fTUFYX0lURVJBVElPTlMpKSB7XG5cdCAgICAgICAgICBicmVhaztcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIGN1cnJlbnRUO1xuXHQgICAgfTtcblx0ICAgIGdldFRGb3JYID0gZnVuY3Rpb24oYVgpIHtcblx0ICAgICAgdmFyIGN1cnJlbnRTYW1wbGUsIGRlbHRhLCBkaXN0LCBndWVzc0ZvclQsIGluaXRpYWxTbG9wZSwgaW50ZXJ2YWxTdGFydCwgbGFzdFNhbXBsZTtcblx0ICAgICAgaW50ZXJ2YWxTdGFydCA9IDAuMDtcblx0ICAgICAgY3VycmVudFNhbXBsZSA9IDE7XG5cdCAgICAgIGxhc3RTYW1wbGUgPSBrU3BsaW5lVGFibGVTaXplIC0gMTtcblx0ICAgICAgd2hpbGUgKGN1cnJlbnRTYW1wbGUgIT09IGxhc3RTYW1wbGUgJiYgbVNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSA8PSBhWCkge1xuXHQgICAgICAgIGludGVydmFsU3RhcnQgKz0ga1NhbXBsZVN0ZXBTaXplO1xuXHQgICAgICAgICsrY3VycmVudFNhbXBsZTtcblx0ICAgICAgfVxuXHQgICAgICAtLWN1cnJlbnRTYW1wbGU7XG5cdCAgICAgIGRlbHRhID0gbVNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlICsgMV0gLSBtU2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdO1xuXHQgICAgICBkaXN0ID0gKGFYIC0gbVNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSkgLyBkZWx0YTtcblx0ICAgICAgZ3Vlc3NGb3JUID0gaW50ZXJ2YWxTdGFydCArIGRpc3QgKiBrU2FtcGxlU3RlcFNpemU7XG5cdCAgICAgIGluaXRpYWxTbG9wZSA9IGdldFNsb3BlKGd1ZXNzRm9yVCwgbVgxLCBtWDIpO1xuXHQgICAgICBpZiAoaW5pdGlhbFNsb3BlID49IE5FV1RPTl9NSU5fU0xPUEUpIHtcblx0ICAgICAgICByZXR1cm4gbmV3dG9uUmFwaHNvbkl0ZXJhdGUoYVgsIGd1ZXNzRm9yVCk7XG5cdCAgICAgIH0gZWxzZSB7XG5cblx0ICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXHQgICAgICAgIGlmIChpbml0aWFsU2xvcGUgPT09IDAuMCkge1xuXHQgICAgICAgICAgcmV0dXJuIGd1ZXNzRm9yVDtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgcmV0dXJuIGJpbmFyeVN1YmRpdmlkZShhWCwgaW50ZXJ2YWxTdGFydCwgaW50ZXJ2YWxTdGFydCArIGtTYW1wbGVTdGVwU2l6ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9O1xuXHQgICAgcHJlY29tcHV0ZSA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICB2YXIgX3ByZWNvbXB1dGVkO1xuXHQgICAgICBfcHJlY29tcHV0ZWQgPSB0cnVlO1xuXHQgICAgICBpZiAobVgxICE9PSBtWTEgfHwgbVgyICE9PSBtWTIpIHtcblx0ICAgICAgICByZXR1cm4gY2FsY1NhbXBsZVZhbHVlcygpO1xuXHQgICAgICB9XG5cdCAgICB9O1xuXHQgICAgbVNhbXBsZVZhbHVlcyA9ICFmbG9hdDMyQXJyYXlTdXBwb3J0ZWQgPyBuZXcgQXJyYXkoa1NwbGluZVRhYmxlU2l6ZSkgOiBuZXcgRmxvYXQzMkFycmF5KGtTcGxpbmVUYWJsZVNpemUpO1xuXHQgICAgX3ByZWNvbXB1dGVkID0gZmFsc2U7XG5cdCAgICBmID0gZnVuY3Rpb24oYVgpIHtcblx0ICAgICAgaWYgKCFfcHJlY29tcHV0ZWQpIHtcblx0ICAgICAgICBwcmVjb21wdXRlKCk7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKG1YMSA9PT0gbVkxICYmIG1YMiA9PT0gbVkyKSB7XG5cdCAgICAgICAgcmV0dXJuIGFYO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChhWCA9PT0gMCkge1xuXHQgICAgICAgIHJldHVybiAwO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChhWCA9PT0gMSkge1xuXHQgICAgICAgIHJldHVybiAxO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBjYWxjQmV6aWVyKGdldFRGb3JYKGFYKSwgbVkxLCBtWTIpO1xuXHQgICAgfTtcblx0ICAgIHN0ciA9IFwiYmV6aWVyKFwiICsgW21YMSwgbVkxLCBtWDIsIG1ZMl0gKyBcIilcIjtcblx0ICAgIGYudG9TdHIgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgcmV0dXJuIHN0cjtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gZjtcblx0ICB9O1xuXG5cdCAgQmV6aWVyRWFzaW5nLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uKG1zZykge1xuXHQgICAgcmV0dXJuIGguZXJyb3IobXNnKTtcblx0ICB9O1xuXG5cdCAgcmV0dXJuIEJlemllckVhc2luZztcblxuXHR9KSgpO1xuXG5cdGJlemllckVhc2luZyA9IG5ldyBCZXppZXJFYXNpbmc7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBiZXppZXJFYXNpbmc7XG5cblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0oKSkpKVxuXG4vKioqLyB9KSxcbi8qIDEwNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBQYXRoRWFzaW5nLCBoO1xuXG5cdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcxKTtcblxuXHRQYXRoRWFzaW5nID0gKGZ1bmN0aW9uKCkge1xuXHQgIFBhdGhFYXNpbmcucHJvdG90eXBlLl92YXJzID0gZnVuY3Rpb24oKSB7XG5cdCAgICB0aGlzLl9wcmVjb21wdXRlID0gaC5jbGFtcCh0aGlzLm8ucHJlY29tcHV0ZSB8fCAxNDUwLCAxMDAsIDEwMDAwKTtcblx0ICAgIHRoaXMuX3N0ZXAgPSAxIC8gdGhpcy5fcHJlY29tcHV0ZTtcblx0ICAgIHRoaXMuX3JlY3QgPSB0aGlzLm8ucmVjdCB8fCAxMDA7XG5cdCAgICB0aGlzLl9hcHByb3hpbWF0ZU1heCA9IHRoaXMuby5hcHByb3hpbWF0ZU1heCB8fCA1O1xuXHQgICAgdGhpcy5fZXBzID0gdGhpcy5vLmVwcyB8fCAwLjAwMTtcblx0ICAgIHJldHVybiB0aGlzLl9ib3VuZHNQcmV2UHJvZ3Jlc3MgPSAtMTtcblx0ICB9O1xuXG5cdCAgZnVuY3Rpb24gUGF0aEVhc2luZyhwYXRoLCBvMSkge1xuXHQgICAgdGhpcy5vID0gbzEgIT0gbnVsbCA/IG8xIDoge307XG5cdCAgICBpZiAocGF0aCA9PT0gJ2NyZWF0b3InKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIHRoaXMucGF0aCA9IGgucGFyc2VQYXRoKHBhdGgpO1xuXHQgICAgaWYgKHRoaXMucGF0aCA9PSBudWxsKSB7XG5cdCAgICAgIHJldHVybiBoLmVycm9yKCdFcnJvciB3aGlsZSBwYXJzaW5nIHRoZSBwYXRoJyk7XG5cdCAgICB9XG5cdCAgICB0aGlzLl92YXJzKCk7XG5cdCAgICB0aGlzLnBhdGguc2V0QXR0cmlidXRlKCdkJywgdGhpcy5fbm9ybWFsaXplUGF0aCh0aGlzLnBhdGguZ2V0QXR0cmlidXRlKCdkJykpKTtcblx0ICAgIHRoaXMucGF0aExlbmd0aCA9IHRoaXMucGF0aC5nZXRUb3RhbExlbmd0aCgpO1xuXHQgICAgdGhpcy5zYW1wbGUgPSBoLmJpbmQodGhpcy5zYW1wbGUsIHRoaXMpO1xuXHQgICAgdGhpcy5faGFyZFNhbXBsZSA9IGguYmluZCh0aGlzLl9oYXJkU2FtcGxlLCB0aGlzKTtcblx0ICAgIHRoaXMuX3ByZVNhbXBsZSgpO1xuXHQgICAgdGhpcztcblx0ICB9XG5cblx0ICBQYXRoRWFzaW5nLnByb3RvdHlwZS5fcHJlU2FtcGxlID0gZnVuY3Rpb24oKSB7XG5cdCAgICB2YXIgaSwgaiwgbGVuZ3RoLCBwb2ludCwgcHJvZ3Jlc3MsIHJlZiwgcmVzdWx0cztcblx0ICAgIHRoaXMuX3NhbXBsZXMgPSBbXTtcblx0ICAgIHJlc3VsdHMgPSBbXTtcblx0ICAgIGZvciAoaSA9IGogPSAwLCByZWYgPSB0aGlzLl9wcmVjb21wdXRlOyAwIDw9IHJlZiA/IGogPD0gcmVmIDogaiA+PSByZWY7IGkgPSAwIDw9IHJlZiA/ICsraiA6IC0taikge1xuXHQgICAgICBwcm9ncmVzcyA9IGkgKiB0aGlzLl9zdGVwO1xuXHQgICAgICBsZW5ndGggPSB0aGlzLnBhdGhMZW5ndGggKiBwcm9ncmVzcztcblx0ICAgICAgcG9pbnQgPSB0aGlzLnBhdGguZ2V0UG9pbnRBdExlbmd0aChsZW5ndGgpO1xuXHQgICAgICByZXN1bHRzLnB1c2godGhpcy5fc2FtcGxlc1tpXSA9IHtcblx0ICAgICAgICBwb2ludDogcG9pbnQsXG5cdCAgICAgICAgbGVuZ3RoOiBsZW5ndGgsXG5cdCAgICAgICAgcHJvZ3Jlc3M6IHByb2dyZXNzXG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdHM7XG5cdCAgfTtcblxuXHQgIFBhdGhFYXNpbmcucHJvdG90eXBlLl9maW5kQm91bmRzID0gZnVuY3Rpb24oYXJyYXksIHApIHtcblx0ICAgIHZhciBidWZmZXIsIGRpcmVjdGlvbiwgZW5kLCBpLCBqLCBsZW4sIGxvb3BFbmQsIHBvaW50UCwgcG9pbnRYLCByZWYsIHJlZjEsIHN0YXJ0LCB2YWx1ZTtcblx0ICAgIGlmIChwID09PSB0aGlzLl9ib3VuZHNQcmV2UHJvZ3Jlc3MpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuX3ByZXZCb3VuZHM7XG5cdCAgICB9XG5cdCAgICBpZiAodGhpcy5fYm91bmRzU3RhcnRJbmRleCA9PSBudWxsKSB7XG5cdCAgICAgIHRoaXMuX2JvdW5kc1N0YXJ0SW5kZXggPSAwO1xuXHQgICAgfVxuXHQgICAgbGVuID0gYXJyYXkubGVuZ3RoO1xuXHQgICAgaWYgKHRoaXMuX2JvdW5kc1ByZXZQcm9ncmVzcyA+IHApIHtcblx0ICAgICAgbG9vcEVuZCA9IDA7XG5cdCAgICAgIGRpcmVjdGlvbiA9ICdyZXZlcnNlJztcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGxvb3BFbmQgPSBsZW47XG5cdCAgICAgIGRpcmVjdGlvbiA9ICdmb3J3YXJkJztcblx0ICAgIH1cblx0ICAgIGlmIChkaXJlY3Rpb24gPT09ICdmb3J3YXJkJykge1xuXHQgICAgICBzdGFydCA9IGFycmF5WzBdO1xuXHQgICAgICBlbmQgPSBhcnJheVthcnJheS5sZW5ndGggLSAxXTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHN0YXJ0ID0gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV07XG5cdCAgICAgIGVuZCA9IGFycmF5WzBdO1xuXHQgICAgfVxuXHQgICAgZm9yIChpID0gaiA9IHJlZiA9IHRoaXMuX2JvdW5kc1N0YXJ0SW5kZXgsIHJlZjEgPSBsb29wRW5kOyByZWYgPD0gcmVmMSA/IGogPCByZWYxIDogaiA+IHJlZjE7IGkgPSByZWYgPD0gcmVmMSA/ICsraiA6IC0taikge1xuXHQgICAgICB2YWx1ZSA9IGFycmF5W2ldO1xuXHQgICAgICBwb2ludFggPSB2YWx1ZS5wb2ludC54IC8gdGhpcy5fcmVjdDtcblx0ICAgICAgcG9pbnRQID0gcDtcblx0ICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ3JldmVyc2UnKSB7XG5cdCAgICAgICAgYnVmZmVyID0gcG9pbnRYO1xuXHQgICAgICAgIHBvaW50WCA9IHBvaW50UDtcblx0ICAgICAgICBwb2ludFAgPSBidWZmZXI7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHBvaW50WCA8IHBvaW50UCkge1xuXHQgICAgICAgIHN0YXJ0ID0gdmFsdWU7XG5cdCAgICAgICAgdGhpcy5fYm91bmRzU3RhcnRJbmRleCA9IGk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgZW5kID0gdmFsdWU7XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHRoaXMuX2JvdW5kc1ByZXZQcm9ncmVzcyA9IHA7XG5cdCAgICByZXR1cm4gdGhpcy5fcHJldkJvdW5kcyA9IHtcblx0ICAgICAgc3RhcnQ6IHN0YXJ0LFxuXHQgICAgICBlbmQ6IGVuZFxuXHQgICAgfTtcblx0ICB9O1xuXG5cdCAgUGF0aEVhc2luZy5wcm90b3R5cGUuc2FtcGxlID0gZnVuY3Rpb24ocCkge1xuXHQgICAgdmFyIGJvdW5kcywgcmVzO1xuXHQgICAgcCA9IGguY2xhbXAocCwgMCwgMSk7XG5cdCAgICBib3VuZHMgPSB0aGlzLl9maW5kQm91bmRzKHRoaXMuX3NhbXBsZXMsIHApO1xuXHQgICAgcmVzID0gdGhpcy5fY2hlY2tJZkJvdW5kc0Nsb3NlRW5vdWdoKHAsIGJvdW5kcyk7XG5cdCAgICBpZiAocmVzICE9IG51bGwpIHtcblx0ICAgICAgcmV0dXJuIHJlcztcblx0ICAgIH1cblx0ICAgIHJldHVybiB0aGlzLl9maW5kQXBwcm94aW1hdGUocCwgYm91bmRzLnN0YXJ0LCBib3VuZHMuZW5kKTtcblx0ICB9O1xuXG5cdCAgUGF0aEVhc2luZy5wcm90b3R5cGUuX2NoZWNrSWZCb3VuZHNDbG9zZUVub3VnaCA9IGZ1bmN0aW9uKHAsIGJvdW5kcykge1xuXHQgICAgdmFyIHBvaW50LCB5O1xuXHQgICAgcG9pbnQgPSB2b2lkIDA7XG5cdCAgICB5ID0gdGhpcy5fY2hlY2tJZlBvaW50Q2xvc2VFbm91Z2gocCwgYm91bmRzLnN0YXJ0LnBvaW50KTtcblx0ICAgIGlmICh5ICE9IG51bGwpIHtcblx0ICAgICAgcmV0dXJuIHk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcy5fY2hlY2tJZlBvaW50Q2xvc2VFbm91Z2gocCwgYm91bmRzLmVuZC5wb2ludCk7XG5cdCAgfTtcblxuXHQgIFBhdGhFYXNpbmcucHJvdG90eXBlLl9jaGVja0lmUG9pbnRDbG9zZUVub3VnaCA9IGZ1bmN0aW9uKHAsIHBvaW50KSB7XG5cdCAgICBpZiAoaC5jbG9zZUVub3VnaChwLCBwb2ludC54IC8gdGhpcy5fcmVjdCwgdGhpcy5fZXBzKSkge1xuXHQgICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZVkocG9pbnQpO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICBQYXRoRWFzaW5nLnByb3RvdHlwZS5fYXBwcm94aW1hdGUgPSBmdW5jdGlvbihzdGFydCwgZW5kLCBwKSB7XG5cdCAgICB2YXIgZGVsdGFQLCBwZXJjZW50UDtcblx0ICAgIGRlbHRhUCA9IGVuZC5wb2ludC54IC0gc3RhcnQucG9pbnQueDtcblx0ICAgIHBlcmNlbnRQID0gKHAgLSAoc3RhcnQucG9pbnQueCAvIHRoaXMuX3JlY3QpKSAvIChkZWx0YVAgLyB0aGlzLl9yZWN0KTtcblx0ICAgIHJldHVybiBzdGFydC5sZW5ndGggKyBwZXJjZW50UCAqIChlbmQubGVuZ3RoIC0gc3RhcnQubGVuZ3RoKTtcblx0ICB9O1xuXG5cdCAgUGF0aEVhc2luZy5wcm90b3R5cGUuX2ZpbmRBcHByb3hpbWF0ZSA9IGZ1bmN0aW9uKHAsIHN0YXJ0LCBlbmQsIGFwcHJveGltYXRlTWF4KSB7XG5cdCAgICB2YXIgYXBwcm94aW1hdGlvbiwgYXJncywgbmV3UG9pbnQsIHBvaW50LCB4O1xuXHQgICAgaWYgKGFwcHJveGltYXRlTWF4ID09IG51bGwpIHtcblx0ICAgICAgYXBwcm94aW1hdGVNYXggPSB0aGlzLl9hcHByb3hpbWF0ZU1heDtcblx0ICAgIH1cblx0ICAgIGFwcHJveGltYXRpb24gPSB0aGlzLl9hcHByb3hpbWF0ZShzdGFydCwgZW5kLCBwKTtcblx0ICAgIHBvaW50ID0gdGhpcy5wYXRoLmdldFBvaW50QXRMZW5ndGgoYXBwcm94aW1hdGlvbik7XG5cdCAgICB4ID0gcG9pbnQueCAvIHRoaXMuX3JlY3Q7XG5cdCAgICBpZiAoaC5jbG9zZUVub3VnaChwLCB4LCB0aGlzLl9lcHMpKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlWShwb2ludCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBpZiAoLS1hcHByb3hpbWF0ZU1heCA8IDEpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZVkocG9pbnQpO1xuXHQgICAgICB9XG5cdCAgICAgIG5ld1BvaW50ID0ge1xuXHQgICAgICAgIHBvaW50OiBwb2ludCxcblx0ICAgICAgICBsZW5ndGg6IGFwcHJveGltYXRpb25cblx0ICAgICAgfTtcblx0ICAgICAgYXJncyA9IHAgPCB4ID8gW3AsIHN0YXJ0LCBuZXdQb2ludCwgYXBwcm94aW1hdGVNYXhdIDogW3AsIG5ld1BvaW50LCBlbmQsIGFwcHJveGltYXRlTWF4XTtcblx0ICAgICAgcmV0dXJuIHRoaXMuX2ZpbmRBcHByb3hpbWF0ZS5hcHBseSh0aGlzLCBhcmdzKTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgUGF0aEVhc2luZy5wcm90b3R5cGUuX3Jlc29sdmVZID0gZnVuY3Rpb24ocG9pbnQpIHtcblx0ICAgIHJldHVybiAxIC0gKHBvaW50LnkgLyB0aGlzLl9yZWN0KTtcblx0ICB9O1xuXG5cdCAgUGF0aEVhc2luZy5wcm90b3R5cGUuX25vcm1hbGl6ZVBhdGggPSBmdW5jdGlvbihwYXRoKSB7XG5cdCAgICB2YXIgY29tbWFuZHMsIGVuZEluZGV4LCBub3JtYWxpemVkUGF0aCwgcG9pbnRzLCBzdGFydEluZGV4LCBzdmdDb21tYW5kc1JlZ2V4cDtcblx0ICAgIHN2Z0NvbW1hbmRzUmVnZXhwID0gL1tNfEx8SHxWfEN8U3xRfFR8QV0vZ2ltO1xuXHQgICAgcG9pbnRzID0gcGF0aC5zcGxpdChzdmdDb21tYW5kc1JlZ2V4cCk7XG5cdCAgICBwb2ludHMuc2hpZnQoKTtcblx0ICAgIGNvbW1hbmRzID0gcGF0aC5tYXRjaChzdmdDb21tYW5kc1JlZ2V4cCk7XG5cdCAgICBzdGFydEluZGV4ID0gMDtcblx0ICAgIHBvaW50c1tzdGFydEluZGV4XSA9IHRoaXMuX25vcm1hbGl6ZVNlZ21lbnQocG9pbnRzW3N0YXJ0SW5kZXhdKTtcblx0ICAgIGVuZEluZGV4ID0gcG9pbnRzLmxlbmd0aCAtIDE7XG5cdCAgICBwb2ludHNbZW5kSW5kZXhdID0gdGhpcy5fbm9ybWFsaXplU2VnbWVudChwb2ludHNbZW5kSW5kZXhdLCB0aGlzLl9yZWN0IHx8IDEwMCk7XG5cdCAgICByZXR1cm4gbm9ybWFsaXplZFBhdGggPSB0aGlzLl9qb2luTm9ybWFsaXplZFBhdGgoY29tbWFuZHMsIHBvaW50cyk7XG5cdCAgfTtcblxuXHQgIFBhdGhFYXNpbmcucHJvdG90eXBlLl9qb2luTm9ybWFsaXplZFBhdGggPSBmdW5jdGlvbihjb21tYW5kcywgcG9pbnRzKSB7XG5cdCAgICB2YXIgY29tbWFuZCwgaSwgaiwgbGVuMSwgbm9ybWFsaXplZFBhdGgsIHNwYWNlO1xuXHQgICAgbm9ybWFsaXplZFBhdGggPSAnJztcblx0ICAgIGZvciAoaSA9IGogPSAwLCBsZW4xID0gY29tbWFuZHMubGVuZ3RoOyBqIDwgbGVuMTsgaSA9ICsraikge1xuXHQgICAgICBjb21tYW5kID0gY29tbWFuZHNbaV07XG5cdCAgICAgIHNwYWNlID0gaSA9PT0gMCA/ICcnIDogJyAnO1xuXHQgICAgICBub3JtYWxpemVkUGF0aCArPSBcIlwiICsgc3BhY2UgKyBjb21tYW5kICsgKHBvaW50c1tpXS50cmltKCkpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIG5vcm1hbGl6ZWRQYXRoO1xuXHQgIH07XG5cblx0ICBQYXRoRWFzaW5nLnByb3RvdHlwZS5fbm9ybWFsaXplU2VnbWVudCA9IGZ1bmN0aW9uKHNlZ21lbnQsIHZhbHVlKSB7XG5cdCAgICB2YXIgaSwgaiwgbGFzdFBvaW50LCBsZW4xLCBuUmd4LCBwYWlycywgcGFyc2VkWCwgcG9pbnQsIHNwYWNlLCB4O1xuXHQgICAgaWYgKHZhbHVlID09IG51bGwpIHtcblx0ICAgICAgdmFsdWUgPSAwO1xuXHQgICAgfVxuXHQgICAgc2VnbWVudCA9IHNlZ21lbnQudHJpbSgpO1xuXHQgICAgblJneCA9IC8oLXxcXCspPygoXFxkKyhcXC4oXFxkfFxcZSgtfFxcKyk/KSspPyl8KFxcLj8oXFxkfFxcZXwoXFwtfFxcKykpKykpL2dpbTtcblx0ICAgIHBhaXJzID0gdGhpcy5fZ2V0U2VnbWVudFBhaXJzKHNlZ21lbnQubWF0Y2goblJneCkpO1xuXHQgICAgbGFzdFBvaW50ID0gcGFpcnNbcGFpcnMubGVuZ3RoIC0gMV07XG5cdCAgICB4ID0gbGFzdFBvaW50WzBdO1xuXHQgICAgcGFyc2VkWCA9IE51bWJlcih4KTtcblx0ICAgIGlmIChwYXJzZWRYICE9PSB2YWx1ZSkge1xuXHQgICAgICBzZWdtZW50ID0gJyc7XG5cdCAgICAgIGxhc3RQb2ludFswXSA9IHZhbHVlO1xuXHQgICAgICBmb3IgKGkgPSBqID0gMCwgbGVuMSA9IHBhaXJzLmxlbmd0aDsgaiA8IGxlbjE7IGkgPSArK2opIHtcblx0ICAgICAgICBwb2ludCA9IHBhaXJzW2ldO1xuXHQgICAgICAgIHNwYWNlID0gaSA9PT0gMCA/ICcnIDogJyAnO1xuXHQgICAgICAgIHNlZ21lbnQgKz0gXCJcIiArIHNwYWNlICsgcG9pbnRbMF0gKyBcIixcIiArIHBvaW50WzFdO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gc2VnbWVudDtcblx0ICB9O1xuXG5cdCAgUGF0aEVhc2luZy5wcm90b3R5cGUuX2dldFNlZ21lbnRQYWlycyA9IGZ1bmN0aW9uKGFycmF5KSB7XG5cdCAgICB2YXIgaSwgaiwgbGVuMSwgbmV3QXJyYXksIHBhaXIsIHZhbHVlO1xuXHQgICAgaWYgKGFycmF5Lmxlbmd0aCAlIDIgIT09IDApIHtcblx0ICAgICAgaC5lcnJvcignRmFpbGVkIHRvIHBhcnNlIHRoZSBwYXRoIC0gc2VnbWVudCBwYWlycyBhcmUgbm90IGV2ZW4uJywgYXJyYXkpO1xuXHQgICAgfVxuXHQgICAgbmV3QXJyYXkgPSBbXTtcblx0ICAgIGZvciAoaSA9IGogPSAwLCBsZW4xID0gYXJyYXkubGVuZ3RoOyBqIDwgbGVuMTsgaSA9IGogKz0gMikge1xuXHQgICAgICB2YWx1ZSA9IGFycmF5W2ldO1xuXHQgICAgICBwYWlyID0gW2FycmF5W2ldLCBhcnJheVtpICsgMV1dO1xuXHQgICAgICBuZXdBcnJheS5wdXNoKHBhaXIpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIG5ld0FycmF5O1xuXHQgIH07XG5cblx0ICBQYXRoRWFzaW5nLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbihwYXRoLCBvKSB7XG5cdCAgICB2YXIgaGFuZGxlcjtcblx0ICAgIGhhbmRsZXIgPSBuZXcgUGF0aEVhc2luZyhwYXRoLCBvKTtcblx0ICAgIGhhbmRsZXIuc2FtcGxlLnBhdGggPSBoYW5kbGVyLnBhdGg7XG5cdCAgICByZXR1cm4gaGFuZGxlci5zYW1wbGU7XG5cdCAgfTtcblxuXHQgIHJldHVybiBQYXRoRWFzaW5nO1xuXG5cdH0pKCk7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBQYXRoRWFzaW5nO1xuXG5cbi8qKiovIH0pLFxuLyogMTA4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0dmFyIGNyZWF0ZSwgZWFzaW5nLCBnZXROZWFyZXN0LCBtaXgsIHBhcnNlSWZFYXNpbmcsIHNvcnQsXG5cdCAgc2xpY2UgPSBbXS5zbGljZTtcblxuXHRlYXNpbmcgPSBudWxsO1xuXG5cdHBhcnNlSWZFYXNpbmcgPSBmdW5jdGlvbihpdGVtKSB7XG5cdCAgaWYgKHR5cGVvZiBpdGVtLnZhbHVlID09PSAnbnVtYmVyJykge1xuXHQgICAgcmV0dXJuIGl0ZW0udmFsdWU7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHJldHVybiBlYXNpbmcucGFyc2VFYXNpbmcoaXRlbS52YWx1ZSk7XG5cdCAgfVxuXHR9O1xuXG5cdHNvcnQgPSBmdW5jdGlvbihhLCBiKSB7XG5cdCAgdmFyIHJldHVyblZhbHVlO1xuXHQgIGEudmFsdWUgPSBwYXJzZUlmRWFzaW5nKGEpO1xuXHQgIGIudmFsdWUgPSBwYXJzZUlmRWFzaW5nKGIpO1xuXHQgIHJldHVyblZhbHVlID0gMDtcblx0ICBhLnRvIDwgYi50byAmJiAocmV0dXJuVmFsdWUgPSAtMSk7XG5cdCAgYS50byA+IGIudG8gJiYgKHJldHVyblZhbHVlID0gMSk7XG5cdCAgcmV0dXJuIHJldHVyblZhbHVlO1xuXHR9O1xuXG5cdGdldE5lYXJlc3QgPSBmdW5jdGlvbihhcnJheSwgcHJvZ3Jlc3MpIHtcblx0ICB2YXIgaSwgaW5kZXgsIGosIGxlbiwgdmFsdWU7XG5cdCAgaW5kZXggPSAwO1xuXHQgIGZvciAoaSA9IGogPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7IGogPCBsZW47IGkgPSArK2opIHtcblx0ICAgIHZhbHVlID0gYXJyYXlbaV07XG5cdCAgICBpbmRleCA9IGk7XG5cdCAgICBpZiAodmFsdWUudG8gPiBwcm9ncmVzcykge1xuXHQgICAgICBicmVhaztcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIGluZGV4O1xuXHR9O1xuXG5cdG1peCA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciBhcmdzO1xuXHQgIGFyZ3MgPSAxIDw9IGFyZ3VtZW50cy5sZW5ndGggPyBzbGljZS5jYWxsKGFyZ3VtZW50cywgMCkgOiBbXTtcblx0ICBpZiAoYXJncy5sZW5ndGggPiAxKSB7XG5cdCAgICBhcmdzID0gYXJncy5zb3J0KHNvcnQpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBhcmdzWzBdLnZhbHVlID0gcGFyc2VJZkVhc2luZyhhcmdzWzBdKTtcblx0ICB9XG5cdCAgcmV0dXJuIGZ1bmN0aW9uKHByb2dyZXNzKSB7XG5cdCAgICB2YXIgaW5kZXgsIHZhbHVlO1xuXHQgICAgaW5kZXggPSBnZXROZWFyZXN0KGFyZ3MsIHByb2dyZXNzKTtcblx0ICAgIGlmIChpbmRleCAhPT0gLTEpIHtcblx0ICAgICAgdmFsdWUgPSBhcmdzW2luZGV4XS52YWx1ZTtcblx0ICAgICAgaWYgKGluZGV4ID09PSBhcmdzLmxlbmd0aCAtIDEgJiYgcHJvZ3Jlc3MgPiBhcmdzW2luZGV4XS50bykge1xuXHQgICAgICAgIHJldHVybiAxO1xuXHQgICAgICB9XG5cdCAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICByZXR1cm4gdmFsdWUocHJvZ3Jlc3MpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH07XG5cdH07XG5cblx0Y3JlYXRlID0gZnVuY3Rpb24oZSkge1xuXHQgIGVhc2luZyA9IGU7XG5cdCAgcmV0dXJuIG1peDtcblx0fTtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZTtcblxuXG4vKioqLyB9KSxcbi8qIDEwOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5cdHZhciBfdHlwZW9mMiA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cblx0dmFyIF90eXBlb2YzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHlwZW9mMik7XG5cblx0dmFyIF9oID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MSk7XG5cblx0dmFyIF9oMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2gpO1xuXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cblx0Lypcblx0ICBNZXRob2QgdG8gYm9vdHN0cmFwIGFwcHJveGltYXRpb24gZnVuY3Rpb24uXG5cdCAgQHByaXZhdGVcblx0ICBAcGFyYW0gICB7T2JqZWN0fSBTYW1wbGVzIE9iamVjdC5cblx0ICBAcmV0dXJucyB7RnVuY3Rpb259IEFwcHJveGltYXRlIGZ1bmN0aW9uLlxuXHQqL1xuXHR2YXIgX3Byb3hpbWF0ZSA9IGZ1bmN0aW9uIF9wcm94aW1hdGUoc2FtcGxlcykge1xuXHQgIHZhciBuID0gc2FtcGxlcy5iYXNlLFxuXHQgICAgICBzYW1wbGVzQW1vdW50ID0gTWF0aC5wb3coMTAsIG4pLFxuXHQgICAgICBzYW1wbGVzU3RlcCA9IDEgLyBzYW1wbGVzQW1vdW50O1xuXG5cdCAgZnVuY3Rpb24gUm91bmROdW1iZXIoaW5wdXQsIG51bWJlckRlY2ltYWxzKSB7XG5cdCAgICBudW1iZXJEZWNpbWFscyA9ICtudW1iZXJEZWNpbWFscyB8fCAwOyAvLyArdmFyIG1hZ2ljIVxuXG5cdCAgICB2YXIgbXVsdGlwbHllciA9IE1hdGgucG93KDEwLjAsIG51bWJlckRlY2ltYWxzKTtcblxuXHQgICAgcmV0dXJuIE1hdGgucm91bmQoaW5wdXQgKiBtdWx0aXBseWVyKSAvIG11bHRpcGx5ZXI7XG5cdCAgfVxuXG5cdCAgdmFyIGNhY2hlZCA9IGZ1bmN0aW9uIGNhY2hlZChwKSB7XG5cdCAgICB2YXIgbmV3S2V5ID0gUm91bmROdW1iZXIocCwgbiksXG5cdCAgICAgICAgc2FtcGxlID0gc2FtcGxlc1tuZXdLZXkudG9TdHJpbmcoKV07XG5cblx0ICAgIGlmIChNYXRoLmFicyhwIC0gbmV3S2V5KSA8IHNhbXBsZXNTdGVwKSB7XG5cdCAgICAgIHJldHVybiBzYW1wbGU7XG5cdCAgICB9XG5cblx0ICAgIGlmIChwID4gbmV3S2V5KSB7XG5cdCAgICAgIHZhciBuZXh0SW5kZXggPSBuZXdLZXkgKyBzYW1wbGVzU3RlcDtcblx0ICAgICAgdmFyIG5leHRWYWx1ZSA9IHNhbXBsZXNbbmV4dEluZGV4XTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHZhciBuZXh0SW5kZXggPSBuZXdLZXkgLSBzYW1wbGVzU3RlcDtcblx0ICAgICAgdmFyIG5leHRWYWx1ZSA9IHNhbXBsZXNbbmV4dEluZGV4XTtcblx0ICAgIH1cblxuXHQgICAgdmFyIGRMZW5ndGggPSBuZXh0SW5kZXggLSBuZXdLZXk7XG5cdCAgICB2YXIgZFZhbHVlID0gbmV4dFZhbHVlIC0gc2FtcGxlO1xuXHQgICAgaWYgKGRWYWx1ZSA8IHNhbXBsZXNTdGVwKSB7XG5cdCAgICAgIHJldHVybiBzYW1wbGU7XG5cdCAgICB9XG5cblx0ICAgIHZhciBwcm9ncmVzc1NjYWxlID0gKHAgLSBuZXdLZXkpIC8gZExlbmd0aDtcblx0ICAgIHZhciBjb2VmID0gbmV4dFZhbHVlID4gc2FtcGxlID8gLTEgOiAxO1xuXHQgICAgdmFyIHNjYWxlZERpZmZlcmVuY2UgPSBjb2VmICogcHJvZ3Jlc3NTY2FsZSAqIGRWYWx1ZTtcblxuXHQgICAgcmV0dXJuIHNhbXBsZSArIHNjYWxlZERpZmZlcmVuY2U7XG5cdCAgfTtcblxuXHQgIGNhY2hlZC5nZXRTYW1wbGVzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuIHNhbXBsZXM7XG5cdCAgfTtcblxuXHQgIHJldHVybiBjYWNoZWQ7XG5cdH07XG5cdC8qXG5cdCAgICBNZXRob2QgdG8gdGFrZSBzYW1wbGVzIG9mIHRoZSBmdW5jdGlvbiBhbmQgY2FsbCB0aGUgX3Byb3hpbWF0ZVxuXHQgICAgbWV0aG9kIHdpdGggdGhlIGR1bmN0aW9uIGFuZCBzYW1wbGVzLiBPciBpZiBzYW1wbGVzIHBhc3NlZCAtIHBpcGVcblx0ICAgIHRoZW0gdG8gdGhlIF9wcm94aW1hdGUgbWV0aG9kIHdpdGhvdXQgc2FtcGxpbmcuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtGdW5jdGlvbn0gRnVuY3Rpb24gdG8gc2FtcGxlLlxuXHQgICAgQHBhcmFtIHtOdW1iZXIsIE9iamVjdCwgU3RyaW5nfSBQcmVjaXNpb24gb3IgcHJlY29tcHV0ZWQgc2FtcGxlcy5cblx0ICAqL1xuXHR2YXIgX3NhbXBsZSA9IGZ1bmN0aW9uIF9zYW1wbGUoZm4pIHtcblx0ICB2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogNDtcblxuXG5cdCAgdmFyIG5UeXBlID0gdHlwZW9mIG4gPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiAoMCwgX3R5cGVvZjMuZGVmYXVsdCkobik7XG5cblx0ICB2YXIgc2FtcGxlcyA9IHt9O1xuXHQgIGlmIChuVHlwZSA9PT0gJ251bWJlcicpIHtcblx0ICAgIHZhciBwID0gMCxcblx0ICAgICAgICBzYW1wbGVzQ291bnQgPSBNYXRoLnBvdygxMCwgbiksXG5cdCAgICAgICAgc3RlcCA9IDEgLyBzYW1wbGVzQ291bnQ7XG5cblx0ICAgIHNhbXBsZXNbMF0gPSBmbigwKTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2FtcGxlc0NvdW50IC0gMTsgaSsrKSB7XG5cdCAgICAgIHAgKz0gc3RlcDtcblxuXHQgICAgICB2YXIgaW5kZXggPSBwYXJzZUZsb2F0KHAudG9GaXhlZChuKSk7XG5cdCAgICAgIHNhbXBsZXNbaW5kZXhdID0gZm4ocCk7XG5cdCAgICB9XG5cdCAgICBzYW1wbGVzWzFdID0gZm4oMSk7XG5cblx0ICAgIHNhbXBsZXMuYmFzZSA9IG47XG5cdCAgfSBlbHNlIGlmIChuVHlwZSA9PT0gJ29iamVjdCcpIHtcblx0ICAgIHNhbXBsZXMgPSBuO1xuXHQgIH0gZWxzZSBpZiAoblR5cGUgPT09ICdzdHJpbmcnKSB7XG5cdCAgICBzYW1wbGVzID0gSlNPTi5wYXJzZShuKTtcblx0ICB9XG5cblx0ICByZXR1cm4gQXBwcm94aW1hdGUuX3NhbXBsZS5fcHJveGltYXRlKHNhbXBsZXMpO1xuXHR9O1xuXG5cdHZhciBBcHByb3hpbWF0ZSA9IHsgX3NhbXBsZTogX3NhbXBsZSwgX3Byb3hpbWF0ZTogX3Byb3hpbWF0ZSB9O1xuXHRBcHByb3hpbWF0ZS5fc2FtcGxlLl9wcm94aW1hdGUgPSBBcHByb3hpbWF0ZS5fcHJveGltYXRlO1xuXG5cdGV4cG9ydHMuZGVmYXVsdCA9IEFwcHJveGltYXRlLl9zYW1wbGU7XG5cbi8qKiovIH0pLFxuLyogMTEwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cblx0dmFyIF9nZXRJdGVyYXRvcjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExMSk7XG5cblx0dmFyIF9nZXRJdGVyYXRvcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRJdGVyYXRvcjIpO1xuXG5cdHZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NCk7XG5cblx0dmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG5cdHZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc1KTtcblxuXHR2YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIpO1xuXG5cdHZhciBfaW5oZXJpdHMyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Nik7XG5cblx0dmFyIF9pbmhlcml0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmhlcml0czIpO1xuXG5cdHZhciBfaCA9IF9fd2VicGFja19yZXF1aXJlX18oNzEpO1xuXG5cdHZhciBfaDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oKTtcblxuXHR2YXIgX3R3ZWVuZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwMik7XG5cblx0dmFyIF90d2VlbmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R3ZWVuZXIpO1xuXG5cdHZhciBfdHdlZW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwMSk7XG5cblx0dmFyIF90d2VlbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90d2Vlbik7XG5cblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuXHR2YXIgVGltZWxpbmUgPSBmdW5jdGlvbiAoX1R3ZWVuKSB7XG5cdCAgKDAsIF9pbmhlcml0czMuZGVmYXVsdCkoVGltZWxpbmUsIF9Ud2Vlbik7XG5cblx0ICAvKlxuXHQgICAgQVBJIG1ldGhvZCB0byBhZGQgY2hpbGQgdHdlZW5zL3RpbWVsaW5lcy5cblx0ICAgIEBwdWJsaWNcblx0ICAgIEBwYXJhbSB7T2JqZWN0LCBBcnJheX0gVHdlZW4vVGltZWxpbmUgb3IgYW4gYXJyYXkgb2Ygc3VjaC5cblx0ICAgIEByZXR1cm5zIHtPYmplY3R9IFNlbGYuXG5cdCAgKi9cblx0ICBUaW1lbGluZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKCkge1xuXHQgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcblx0ICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5fcHVzaFRpbWVsaW5lQXJyYXkoYXJncyk7XG5cdCAgICB0aGlzLl9jYWxjRGltZW50aW9ucygpO1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgQVBJIG1ldGhvZCB0byBhcHBlbmQgdGhlIFR3ZWVuL1RpbWVsaW5lIHRvIHRoZSBlbmQgb2YgdGhlXG5cdCAgICB0aW1lbGluZS4gRWFjaCBhcmd1bWVudCBpcyB0cmVhdGVkIGFzIGEgbmV3IGFwcGVuZC5cblx0ICAgIEFycmF5IG9mIHR3ZWVucyBpcyB0cmVhdGVkIGFzIGEgcGFyYWxsZWwgc2VxdWVuY2UuIFxuXHQgICAgQHB1YmxpY1xuXHQgICAgQHBhcmFtIHtPYmplY3QsIEFycmF5fSBUd2Vlbi9UaW1lbGluZSB0byBhcHBlbmQgb3IgYXJyYXkgb2Ygc3VjaC5cblx0ICAgIEByZXR1cm5zIHtPYmplY3R9IFNlbGYuXG5cdCAgKi9cblxuXG5cdCAgVGltZWxpbmUucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIGFwcGVuZCgpIHtcblx0ICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgdGltZWxpbmUgPSBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuXHQgICAgICB0aW1lbGluZVtfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuXHQgICAgfVxuXG5cdCAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSB0aW1lbGluZSwgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvciksIF9pID0gMCwgX2l0ZXJhdG9yID0gX2lzQXJyYXkgPyBfaXRlcmF0b3IgOiAoMCwgX2dldEl0ZXJhdG9yMy5kZWZhdWx0KShfaXRlcmF0b3IpOzspIHtcblx0ICAgICAgdmFyIF9yZWY7XG5cblx0ICAgICAgaWYgKF9pc0FycmF5KSB7XG5cdCAgICAgICAgaWYgKF9pID49IF9pdGVyYXRvci5sZW5ndGgpIGJyZWFrO1xuXHQgICAgICAgIF9yZWYgPSBfaXRlcmF0b3JbX2krK107XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgX2kgPSBfaXRlcmF0b3IubmV4dCgpO1xuXHQgICAgICAgIGlmIChfaS5kb25lKSBicmVhaztcblx0ICAgICAgICBfcmVmID0gX2kudmFsdWU7XG5cdCAgICAgIH1cblxuXHQgICAgICB2YXIgdG0gPSBfcmVmO1xuXG5cdCAgICAgIGlmIChfaDIuZGVmYXVsdC5pc0FycmF5KHRtKSkge1xuXHQgICAgICAgIHRoaXMuX2FwcGVuZFRpbWVsaW5lQXJyYXkodG0pO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHRoaXMuX2FwcGVuZFRpbWVsaW5lKHRtLCB0aGlzLl90aW1lbGluZXMubGVuZ3RoKTtcblx0ICAgICAgfVxuXHQgICAgICB0aGlzLl9jYWxjRGltZW50aW9ucygpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgQVBJIG1ldGhvZCB0byBzdG9wIHRoZSBUd2Vlbi5cblx0ICAgIEBwdWJsaWNcblx0ICAgIEBwYXJhbSAgIHtOdW1iZXJ9IFByb2dyZXNzIFswLi4xXSB0byBzZXQgd2hlbiBzdG9wcGVkLlxuXHQgICAgQHJldHVybnMge09iamVjdH0gU2VsZi5cblx0ICAqL1xuXG5cblx0ICBUaW1lbGluZS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uIHN0b3AocHJvZ3Jlc3MpIHtcblx0ICAgIF9Ud2Vlbi5wcm90b3R5cGUuc3RvcC5jYWxsKHRoaXMsIHByb2dyZXNzKTtcblx0ICAgIHRoaXMuX3N0b3BDaGlsZHJlbihwcm9ncmVzcyk7XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gcmVzZXQgdHdlZW4ncyBzdGF0ZSBhbmQgcHJvcGVydGllcy5cblx0ICAgIEBwdWJsaWNcblx0ICAgIEBvdmVycmlkZXMgQCBUd2VlblxuXHQgICAgQHJldHVybnMgdGhpcy5cblx0ICAqL1xuXG5cblx0ICBUaW1lbGluZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcblx0ICAgIF9Ud2Vlbi5wcm90b3R5cGUucmVzZXQuY2FsbCh0aGlzKTtcblx0ICAgIHRoaXMuX3Jlc2V0Q2hpbGRyZW4oKTtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBjYWxsIGByZXNldGAgbWV0aG9kIG9uIGFsbCBjaGlsZHJlbi5cblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblxuXG5cdCAgVGltZWxpbmUucHJvdG90eXBlLl9yZXNldENoaWxkcmVuID0gZnVuY3Rpb24gX3Jlc2V0Q2hpbGRyZW4oKSB7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3RpbWVsaW5lcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICB0aGlzLl90aW1lbGluZXNbaV0ucmVzZXQoKTtcblx0ICAgIH1cblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gY2FsbCBgc3RvcGAgbWV0aG9kIG9uIGFsbCBjaGlsZHJlbi5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0gICB7TnVtYmVyfSBQcm9ncmVzcyBbMC4uMV0gdG8gc2V0IHdoZW4gc3RvcHBlZC5cblx0ICAqL1xuXG5cblx0ICBUaW1lbGluZS5wcm90b3R5cGUuX3N0b3BDaGlsZHJlbiA9IGZ1bmN0aW9uIF9zdG9wQ2hpbGRyZW4ocHJvZ3Jlc3MpIHtcblx0ICAgIGZvciAodmFyIGkgPSB0aGlzLl90aW1lbGluZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0ICAgICAgdGhpcy5fdGltZWxpbmVzW2ldLnN0b3AocHJvZ3Jlc3MpO1xuXHQgICAgfVxuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBzZXQgdHdlZW4ncyBzdGF0ZSB0byBjb21wbGV0ZS5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAb3ZlcnJpZGVzIEAgVHdlZW5cblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBDdXJyZW50IHRpbWUuXG5cdCAgICBAcGFyYW0ge0Jvb2xlYW59IElzIHlveW8gcGVyaW9kLlxuXHQgICovXG5cdCAgLy8gX2NvbXBsZXRlICggdGltZSwgaXNZb3lvICkge1xuXHQgIC8vICAgLy8gdGhpcy5fdXBkYXRlQ2hpbGRyZW4oIDEsIHRpbWUsIGlzWW95byApO1xuXHQgIC8vICAgLy8gdGhpcy5fc2V0UHJvZ3Jlc3MoIDEsIHRpbWUsIGlzWW95byApO1xuXHQgIC8vICAgc3VwZXIuX2NvbXBsZXRlKCB0aW1lLCBpc1lveW8gKTtcblx0ICAvLyAgIC8vIHRoaXMuX3Jlc2V0Q2hpbGRyZW4oKTtcblx0ICAvLyB9XG5cblx0ICAvLyBeIFBVQkxJQyAgTUVUSE9EKFMpIF5cblx0ICAvLyB2IFBSSVZBVEUgTUVUSE9EKFMpIHZcblxuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gYXBwZW5kIFR3ZWVuL1RpbWVsaW5lIGFycmF5IG9yIG1peCBvZiBzdWNoLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7QXJyYXl9IEFycmF5IG9mIFR3ZWVucy9UaW1lbGluZXMuXG5cdCAgKi9cblxuXG5cdCAgVGltZWxpbmUucHJvdG90eXBlLl9hcHBlbmRUaW1lbGluZUFycmF5ID0gZnVuY3Rpb24gX2FwcGVuZFRpbWVsaW5lQXJyYXkodGltZWxpbmVBcnJheSkge1xuXHQgICAgdmFyIGkgPSB0aW1lbGluZUFycmF5Lmxlbmd0aCxcblx0ICAgICAgICB0aW1lID0gdGhpcy5fcHJvcHMucmVwZWF0VGltZSAtIHRoaXMuX3Byb3BzLmRlbGF5LFxuXHQgICAgICAgIGxlbiA9IHRoaXMuX3RpbWVsaW5lcy5sZW5ndGg7XG5cblx0ICAgIHdoaWxlIChpLS0pIHtcblx0ICAgICAgdGhpcy5fYXBwZW5kVGltZWxpbmUodGltZWxpbmVBcnJheVtpXSwgbGVuLCB0aW1lKTtcblx0ICAgIH1cblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gYXBwZW5kIGEgc2luZ2xlIHRpbWVsaW5lIHRvIHRoZSBUaW1lbGluZS5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge09iamVjdH0gVHdlZW4vVGltbGluZSB0byBhcHBlbmQuXG5cdCAgICBAcGFyYW0ge051bWJlcn0gSW5kZXggb2YgdGhlIGFwcGVuZC5cblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBTaGlmdCB0aW1lLlxuXHQgICovXG5cblxuXHQgIFRpbWVsaW5lLnByb3RvdHlwZS5fYXBwZW5kVGltZWxpbmUgPSBmdW5jdGlvbiBfYXBwZW5kVGltZWxpbmUodGltZWxpbmUsIGluZGV4LCB0aW1lKSB7XG5cdCAgICAvLyBpZiB0aW1lbGluZSBpcyBhIG1vZHVsZSB3aXRoIHRpbWVsaW5lIHByb3BlcnR5IHRoZW4gZXh0cmFjdCBpdFxuXHQgICAgaWYgKHRpbWVsaW5lLnRpbWVsaW5lIGluc3RhbmNlb2YgVGltZWxpbmUpIHtcblx0ICAgICAgdGltZWxpbmUgPSB0aW1lbGluZS50aW1lbGluZTtcblx0ICAgIH1cblx0ICAgIGlmICh0aW1lbGluZS50d2VlbiBpbnN0YW5jZW9mIF90d2VlbjIuZGVmYXVsdCkge1xuXHQgICAgICB0aW1lbGluZSA9IHRpbWVsaW5lLnR3ZWVuO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgc2hpZnQgPSB0aW1lICE9IG51bGwgPyB0aW1lIDogdGhpcy5fcHJvcHMuZHVyYXRpb247XG5cdCAgICBzaGlmdCArPSB0aW1lbGluZS5fcHJvcHMuc2hpZnRUaW1lIHx8IDA7XG5cdCAgICB0aW1lbGluZS5pbmRleCA9IGluZGV4O3RoaXMuX3B1c2hUaW1lbGluZSh0aW1lbGluZSwgc2hpZnQpO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIFByaXZhdGVNZXRob2QgdG8gcHVzaCBUd2Vlbi9UaW1lbGluZSBhcnJheS5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge0FycmF5fSBBcnJheSBvZiBUd2VlbnMvVGltZWxpbmVzLlxuXHQgICovXG5cblxuXHQgIFRpbWVsaW5lLnByb3RvdHlwZS5fcHVzaFRpbWVsaW5lQXJyYXkgPSBmdW5jdGlvbiBfcHVzaFRpbWVsaW5lQXJyYXkoYXJyYXkpIHtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIHRtID0gYXJyYXlbaV07XG5cdCAgICAgIC8vIHJlY3Vyc2l2ZSBwdXNoIHRvIGhhbmRsZSBhcnJheXMgb2YgYXJyYXlzXG5cdCAgICAgIGlmIChfaDIuZGVmYXVsdC5pc0FycmF5KHRtKSkge1xuXHQgICAgICAgIHRoaXMuX3B1c2hUaW1lbGluZUFycmF5KHRtKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB0aGlzLl9wdXNoVGltZWxpbmUodG0pO1xuXHQgICAgICB9XG5cdCAgICB9O1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBwdXNoIGEgc2luZ2xlIFR3ZWVuL1RpbWVsaW5lLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBUd2VlbiBvciBUaW1lbGluZSB0byBwdXNoLlxuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IE51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gc2hpZnQgdGhlIHN0YXJ0IHRpbWVcblx0ICAgICAgICAgICAgICAgICAgICBvZiB0aGUgVHdlZW4vVGltZWxpbmUuXG5cdCAgKi9cblxuXG5cdCAgVGltZWxpbmUucHJvdG90eXBlLl9wdXNoVGltZWxpbmUgPSBmdW5jdGlvbiBfcHVzaFRpbWVsaW5lKHRpbWVsaW5lLCBzaGlmdCkge1xuXHQgICAgLy8gaWYgdGltZWxpbmUgaXMgYSBtb2R1bGUgd2l0aCB0aW1lbGluZSBwcm9wZXJ0eSB0aGVuIGV4dHJhY3QgaXRcblx0ICAgIGlmICh0aW1lbGluZS50aW1lbGluZSBpbnN0YW5jZW9mIFRpbWVsaW5lKSB7XG5cdCAgICAgIHRpbWVsaW5lID0gdGltZWxpbmUudGltZWxpbmU7XG5cdCAgICB9XG5cdCAgICBpZiAodGltZWxpbmUudHdlZW4gaW5zdGFuY2VvZiBfdHdlZW4yLmRlZmF1bHQpIHtcblx0ICAgICAgdGltZWxpbmUgPSB0aW1lbGluZS50d2Vlbjtcblx0ICAgIH1cblx0ICAgIC8vIGFkZCBzZWxmIGRlbGF5IHRvIHRoZSB0aW1lbGluZVxuXHQgICAgc2hpZnQgIT0gbnVsbCAmJiB0aW1lbGluZS5fc2V0UHJvcCh7ICdzaGlmdFRpbWUnOiBzaGlmdCB9KTtcblx0ICAgIHRoaXMuX3RpbWVsaW5lcy5wdXNoKHRpbWVsaW5lKTtcblx0ICAgIHRoaXMuX3JlY2FsY0R1cmF0aW9uKHRpbWVsaW5lKTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2Qgc2V0IHByb2dyZXNzIG9uIHNlbGYgYW5kIGNoaWxkIFR3ZWVucy9UaW1lbGluZXMuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IFByb2dyZXNzIHRvIHNldC5cblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBDdXJyZW50IHVwZGF0ZSB0aW1lLlxuXHQgICovXG5cblxuXHQgIFRpbWVsaW5lLnByb3RvdHlwZS5fc2V0UHJvZ3Jlc3MgPSBmdW5jdGlvbiBfc2V0UHJvZ3Jlc3MocCwgdGltZSwgaXNZb3lvKSB7XG5cdCAgICAvLyB3ZSBuZWVkIHRvIHBhc3Mgc2VsZiBwcmV2aW91cyB0aW1lIHRvIGNoaWxkcmVuXG5cdCAgICAvLyB0byBwcmV2ZW50IGluaXRpYWwgX3dhc1Vua25vd25VcGRhdGUgbmVzdGVkIHdhdGVyZmFsbFxuXHQgICAgLy8gaWYgbm90IHlveW8gb3B0aW9uIHNldCwgcGFzcyB0aGUgcHJldmlvdXMgdGltZVxuXHQgICAgLy8gb3RoZXJ3aXNlLCBwYXNzIHByZXZpb3VzIG9yIG5leHQgdGltZSByZWdhcmRpbmcgeW95byBwZXJpb2QuXG5cblx0ICAgIC8vIENPVkVSIENVUlJFTlQgU1dBUFBFRCBPUkRFUlxuXHQgICAgdGhpcy5fdXBkYXRlQ2hpbGRyZW4ocCwgdGltZSwgaXNZb3lvKTtcblxuXHQgICAgX3R3ZWVuMi5kZWZhdWx0LnByb3RvdHlwZS5fc2V0UHJvZ3Jlc3MuY2FsbCh0aGlzLCBwLCB0aW1lKTtcblx0ICB9O1xuXG5cdCAgVGltZWxpbmUucHJvdG90eXBlLl91cGRhdGVDaGlsZHJlbiA9IGZ1bmN0aW9uIF91cGRhdGVDaGlsZHJlbihwLCB0aW1lLCBpc1lveW8pIHtcblx0ICAgIHZhciBjb2VmID0gdGltZSA+IHRoaXMuX3ByZXZUaW1lID8gLTEgOiAxO1xuXHQgICAgaWYgKHRoaXMuX3Byb3BzLmlzWW95byAmJiBpc1lveW8pIHtcblx0ICAgICAgY29lZiAqPSAtMTtcblx0ICAgIH1cblx0ICAgIHZhciB0aW1lVG9UaW1lbGluZXMgPSB0aGlzLl9wcm9wcy5zdGFydFRpbWUgKyBwICogdGhpcy5fcHJvcHMuZHVyYXRpb24sXG5cdCAgICAgICAgcHJldlRpbWVUb1RpbWVsaW5lcyA9IHRpbWVUb1RpbWVsaW5lcyArIGNvZWYsXG5cdCAgICAgICAgbGVuID0gdGhpcy5fdGltZWxpbmVzLmxlbmd0aDtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHQgICAgICAvLyBzcGVjaWZ5IHRoZSBjaGlsZHJlbidzIGFycmF5IHVwZGF0ZSBsb29wIGRpcmVjdGlvblxuXHQgICAgICAvLyBpZiB0aW1lID4gcHJldlRpbWUgZ28gZnJvbSAwLT5sZW5ndGggZWxzZSBmcm9tIGxlbmd0aC0+MFxuXHQgICAgICAvLyB2YXIgaiA9ICggdGltZSA+IHRoaXMuX3ByZXZUaW1lICkgPyBpIDogKGxlbi0xKSAtIGkgO1xuXHQgICAgICB2YXIgaiA9IHRpbWVUb1RpbWVsaW5lcyA+IHByZXZUaW1lVG9UaW1lbGluZXMgPyBpIDogbGVuIC0gMSAtIGk7XG5cdCAgICAgIHRoaXMuX3RpbWVsaW5lc1tqXS5fdXBkYXRlKHRpbWVUb1RpbWVsaW5lcywgcHJldlRpbWVUb1RpbWVsaW5lcywgdGhpcy5fcHJldllveW8sIHRoaXMuX29uRWRnZSk7XG5cdCAgICB9XG5cdCAgICB0aGlzLl9wcmV2WW95byA9IGlzWW95bztcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgY2FsY3VsYXRlIHNlbGYgZHVyYXRpb24gYmFzZWQgb24gdGltZWxpbmUncyBkdXJhdGlvbi5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge09iamVjdH0gVHdlZW4gb3IgVGltZWxpbmUgdG8gY2FsY3VsYXRlLlxuXHQgICovXG5cblxuXHQgIFRpbWVsaW5lLnByb3RvdHlwZS5fcmVjYWxjRHVyYXRpb24gPSBmdW5jdGlvbiBfcmVjYWxjRHVyYXRpb24odGltZWxpbmUpIHtcblx0ICAgIHZhciBwID0gdGltZWxpbmUuX3Byb3BzLFxuXHQgICAgICAgIHRpbWVsaW5lVGltZSA9IHAucmVwZWF0VGltZSAvIHAuc3BlZWQgKyAocC5zaGlmdFRpbWUgfHwgMCkgKyB0aW1lbGluZS5fbmVnYXRpdmVTaGlmdDtcblxuXHQgICAgdGhpcy5fcHJvcHMuZHVyYXRpb24gPSBNYXRoLm1heCh0aW1lbGluZVRpbWUsIHRoaXMuX3Byb3BzLmR1cmF0aW9uKTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgY2FsY3VsYXRlIHNlbGYgZHVyYXRpb24gZnJvbSBza3JldGNoLlxuXHQgICAgQHByaXZhdGVcblx0ICAqL1xuXG5cblx0ICBUaW1lbGluZS5wcm90b3R5cGUuX3JlY2FsY1RvdGFsRHVyYXRpb24gPSBmdW5jdGlvbiBfcmVjYWxjVG90YWxEdXJhdGlvbigpIHtcblx0ICAgIHZhciBpID0gdGhpcy5fdGltZWxpbmVzLmxlbmd0aDtcblx0ICAgIHRoaXMuX3Byb3BzLmR1cmF0aW9uID0gMDtcblx0ICAgIHdoaWxlIChpLS0pIHtcblx0ICAgICAgdmFyIHRtID0gdGhpcy5fdGltZWxpbmVzW2ldO1xuXHQgICAgICAvLyByZWNhbGMgdG90YWwgZHVyYXRpb24gb24gY2hpbGQgdGltZWxpbmVzXG5cdCAgICAgIHRtLl9yZWNhbGNUb3RhbER1cmF0aW9uICYmIHRtLl9yZWNhbGNUb3RhbER1cmF0aW9uKCk7XG5cdCAgICAgIC8vIGFkZCB0aGUgdGltZWxpbmUncyBkdXJhdGlvbiB0byBzZWxmdCBkdXJhdGlvblxuXHQgICAgICB0aGlzLl9yZWNhbGNEdXJhdGlvbih0bSk7XG5cdCAgICB9XG5cdCAgICB0aGlzLl9jYWxjRGltZW50aW9ucygpO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCBzZXQgc3RhcnQgYW5kIGVuZCB0aW1lcy5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge051bWJlciwgTnVsbH0gVGltZSB0byBzdGFydCB3aXRoLlxuXHQgICovXG5cblxuXHQgIFRpbWVsaW5lLnByb3RvdHlwZS5fc2V0U3RhcnRUaW1lID0gZnVuY3Rpb24gX3NldFN0YXJ0VGltZSh0aW1lKSB7XG5cdCAgICB2YXIgaXNSZXNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcblxuXHQgICAgX1R3ZWVuLnByb3RvdHlwZS5fc2V0U3RhcnRUaW1lLmNhbGwodGhpcywgdGltZSk7XG5cdCAgICB0aGlzLl9zdGFydFRpbWVsaW5lcyh0aGlzLl9wcm9wcy5zdGFydFRpbWUsIGlzUmVzZXQpO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCBjYWxjdWxhdGUgc2VsZiBkdXJhdGlvbiBiYXNlZCBvbiB0aW1lbGluZSdzIGR1cmF0aW9uLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7TnVtYmVyLCBOdWxsfSBUaW1lIHRvIHN0YXJ0IHdpdGguXG5cdCAgKi9cblxuXG5cdCAgVGltZWxpbmUucHJvdG90eXBlLl9zdGFydFRpbWVsaW5lcyA9IGZ1bmN0aW9uIF9zdGFydFRpbWVsaW5lcyh0aW1lKSB7XG5cdCAgICB2YXIgaXNSZXNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcblxuXHQgICAgdmFyIHAgPSB0aGlzLl9wcm9wcyxcblx0ICAgICAgICBpc1N0b3AgPSB0aGlzLl9zdGF0ZSA9PT0gJ3N0b3AnO1xuXG5cdCAgICB0aW1lID09IG51bGwgJiYgKHRpbWUgPSB0aGlzLl9wcm9wcy5zdGFydFRpbWUpO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3RpbWVsaW5lcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIgdG0gPSB0aGlzLl90aW1lbGluZXNbaV07XG5cdCAgICAgIHRtLl9zZXRTdGFydFRpbWUodGltZSwgaXNSZXNldCk7XG5cdCAgICAgIC8vIGlmIGZyb20gYF9zdWJQbGF5YCBhbmQgYF9wcmV2VGltZWAgaXMgc2V0IGFuZCBzdGF0ZSBpcyBgc3RvcGBcblx0ICAgICAgLy8gcHJldlRpbWUgbm9ybWFsaXppbmcgaXMgZm9yIHBsYXkvcGF1c2UgZnVuY3Rpb25hbGl0eSwgc28gbm9cblx0ICAgICAgLy8gbmVlZCB0byBub3JtYWxpemUgaWYgdGhlIHRpbWVsaW5lIGlzIGluIGBzdG9wYCBzdGF0ZS5cblx0ICAgICAgaWYgKCFpc1Jlc2V0ICYmIHRtLl9wcmV2VGltZSAhPSBudWxsICYmICFpc1N0b3ApIHtcblx0ICAgICAgICB0bS5fcHJldlRpbWUgPSB0bS5fbm9ybVByZXZUaW1lRm9yd2FyZCgpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGxhdW5jaCBvblJlZnJlc2ggY2FsbGJhY2suXG5cdCAgICBAbWV0aG9kIF9yZWZyZXNoXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQG92ZXJyaWRlcyBAIFR3ZWVuXG5cdCAgICBAcGFyYW0ge0Jvb2xlYW59IElmIHJlZnJlc2ggZXZlbiBiZWZvcmUgc3RhcnQgdGltZS5cblx0ICAqL1xuXG5cblx0ICBUaW1lbGluZS5wcm90b3R5cGUuX3JlZnJlc2ggPSBmdW5jdGlvbiBfcmVmcmVzaChpc0JlZm9yZSkge1xuXHQgICAgdmFyIGxlbiA9IHRoaXMuX3RpbWVsaW5lcy5sZW5ndGg7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdCAgICAgIHRoaXMuX3RpbWVsaW5lc1tpXS5fcmVmcmVzaChpc0JlZm9yZSk7XG5cdCAgICB9XG5cdCAgICBfVHdlZW4ucHJvdG90eXBlLl9yZWZyZXNoLmNhbGwodGhpcywgaXNCZWZvcmUpO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCBkbyBkZWNsYXJlIGRlZmF1bHRzIGJ5IHRoaXMuX2RlZmF1bHRzIG9iamVjdFxuXHQgICAgQHByaXZhdGVcblx0ICAqL1xuXG5cblx0ICBUaW1lbGluZS5wcm90b3R5cGUuX2RlY2xhcmVEZWZhdWx0cyA9IGZ1bmN0aW9uIF9kZWNsYXJlRGVmYXVsdHMoKSB7XG5cdCAgICAvLyBpZiBkdXJhdGlvbiB3YXMgcGFzc2VkIG9uIGluaXRpYWxpemF0aW9uIHN0YWdlLCB3YXJuIHVzZXIgYW5kIHJlc2V0IGl0LlxuXHQgICAgaWYgKHRoaXMuX28uZHVyYXRpb24gIT0gbnVsbCkge1xuXHQgICAgICBfaDIuZGVmYXVsdC5lcnJvcignRHVyYXRpb24gY2FuIG5vdCBiZSBkZWNsYXJlZCBvbiBUaW1lbGluZSwgYnV0IFwiJyArIHRoaXMuX28uZHVyYXRpb24gKyAnXCIgaXMuIFlvdSBwcm9iYWJseSB3YW50IHRvIHVzZSBUd2VlbiBpbnN0ZWFkLicpO1xuXHQgICAgICB0aGlzLl9vLmR1cmF0aW9uID0gMDtcblx0ICAgIH1cblx0ICAgIF9Ud2Vlbi5wcm90b3R5cGUuX2RlY2xhcmVEZWZhdWx0cy5jYWxsKHRoaXMpO1xuXHQgICAgLy8gcmVtb3ZlIGRlZmF1bHQgXG5cdCAgICB0aGlzLl9kZWZhdWx0cy5kdXJhdGlvbiA9IDA7XG5cdCAgICB0aGlzLl9kZWZhdWx0cy5lYXNpbmcgPSAnTGluZWFyLk5vbmUnO1xuXHQgICAgdGhpcy5fZGVmYXVsdHMuYmFja3dhcmRFYXNpbmcgPSAnTGluZWFyLk5vbmUnO1xuXHQgICAgdGhpcy5fZGVmYXVsdHMubmFtZUJhc2UgPSAnVGltZWxpbmUnO1xuXHQgIH07XG5cblx0ICBmdW5jdGlvbiBUaW1lbGluZSgpIHtcblx0ICAgIHZhciBvID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblx0ICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIFRpbWVsaW5lKTtcblx0ICAgIHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zLmRlZmF1bHQpKHRoaXMsIF9Ud2Vlbi5jYWxsKHRoaXMsIG8pKTtcblx0ICB9XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBkZWNsYXJlIHNvbWUgdmFycy5cblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblxuXG5cdCAgVGltZWxpbmUucHJvdG90eXBlLl92YXJzID0gZnVuY3Rpb24gX3ZhcnMoKSB7XG5cdCAgICB0aGlzLl90aW1lbGluZXMgPSBbXTtcblx0ICAgIF9Ud2Vlbi5wcm90b3R5cGUuX3ZhcnMuY2FsbCh0aGlzKTtcblx0ICB9O1xuXG5cdCAgcmV0dXJuIFRpbWVsaW5lO1xuXHR9KF90d2VlbjIuZGVmYXVsdCk7XG5cblx0ZXhwb3J0cy5kZWZhdWx0ID0gVGltZWxpbmU7XG5cbi8qKiovIH0pLFxuLyogMTExICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDExMiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuLyoqKi8gfSksXG4vKiAxMTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDUwKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblx0bW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExMyk7XG5cbi8qKiovIH0pLFxuLyogMTEzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSlcblx0ICAsIGdldCAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTQpO1xuXHRtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpLmdldEl0ZXJhdG9yID0gZnVuY3Rpb24oaXQpe1xuXHQgIHZhciBpdGVyRm4gPSBnZXQoaXQpO1xuXHQgIGlmKHR5cGVvZiBpdGVyRm4gIT0gJ2Z1bmN0aW9uJyl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBpdGVyYWJsZSEnKTtcblx0ICByZXR1cm4gYW5PYmplY3QoaXRlckZuLmNhbGwoaXQpKTtcblx0fTtcblxuLyoqKi8gfSksXG4vKiAxMTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgY2xhc3NvZiAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTUpXG5cdCAgLCBJVEVSQVRPUiAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3KSgnaXRlcmF0b3InKVxuXHQgICwgSXRlcmF0b3JzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOSk7XG5cdG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCkuZ2V0SXRlcmF0b3JNZXRob2QgPSBmdW5jdGlvbihpdCl7XG5cdCAgaWYoaXQgIT0gdW5kZWZpbmVkKXJldHVybiBpdFtJVEVSQVRPUl1cblx0ICAgIHx8IGl0WydAQGl0ZXJhdG9yJ11cblx0ICAgIHx8IEl0ZXJhdG9yc1tjbGFzc29mKGl0KV07XG5cdH07XG5cbi8qKiovIH0pLFxuLyogMTE1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0Ly8gZ2V0dGluZyB0YWcgZnJvbSAxOS4xLjMuNiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClcblx0dmFyIGNvZiA9IF9fd2VicGFja19yZXF1aXJlX18oMzcpXG5cdCAgLCBUQUcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3KSgndG9TdHJpbmdUYWcnKVxuXHQgIC8vIEVTMyB3cm9uZyBoZXJlXG5cdCAgLCBBUkcgPSBjb2YoZnVuY3Rpb24oKXsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxuXHQvLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxuXHR2YXIgdHJ5R2V0ID0gZnVuY3Rpb24oaXQsIGtleSl7XG5cdCAgdHJ5IHtcblx0ICAgIHJldHVybiBpdFtrZXldO1xuXHQgIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cblx0fTtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcblx0ICB2YXIgTywgVCwgQjtcblx0ICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcblx0ICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuXHQgICAgOiB0eXBlb2YgKFQgPSB0cnlHZXQoTyA9IE9iamVjdChpdCksIFRBRykpID09ICdzdHJpbmcnID8gVFxuXHQgICAgLy8gYnVpbHRpblRhZyBjYXNlXG5cdCAgICA6IEFSRyA/IGNvZihPKVxuXHQgICAgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuXHQgICAgOiAoQiA9IGNvZihPKSkgPT0gJ09iamVjdCcgJiYgdHlwZW9mIE8uY2FsbGVlID09ICdmdW5jdGlvbicgPyAnQXJndW1lbnRzJyA6IEI7XG5cdH07XG5cbi8qKiovIH0pLFxuLyogMTE2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cblx0dmFyIF9rZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NSk7XG5cblx0dmFyIF9rZXlzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2tleXMpO1xuXG5cdHZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NCk7XG5cblx0dmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG5cdHZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc1KTtcblxuXHR2YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIpO1xuXG5cdHZhciBfaW5oZXJpdHMyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Nik7XG5cblx0dmFyIF9pbmhlcml0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmhlcml0czIpO1xuXG5cdHZhciBfaCA9IF9fd2VicGFja19yZXF1aXJlX18oNzEpO1xuXG5cdHZhciBfaDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oKTtcblxuXHR2YXIgX3RoZW5hYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5OSk7XG5cblx0dmFyIF90aGVuYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90aGVuYWJsZSk7XG5cblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuXHR2YXIgVHVuZWFibGUgPSBmdW5jdGlvbiAoX1RoZW5hYmxlKSB7XG5cdCAgKDAsIF9pbmhlcml0czMuZGVmYXVsdCkoVHVuZWFibGUsIF9UaGVuYWJsZSk7XG5cblx0ICBmdW5jdGlvbiBUdW5lYWJsZSgpIHtcblx0ICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIFR1bmVhYmxlKTtcblx0ICAgIHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zLmRlZmF1bHQpKHRoaXMsIF9UaGVuYWJsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcblx0ICB9XG5cblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHN0YXJ0IHRoZSBhbmltYXRpb24gd2l0aCBvcHRpb25hbCBuZXcgb3B0aW9ucy5cblx0ICAgIEBwdWJsaWNcblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBOZXcgb3B0aW9ucyB0byBzZXQgb24gdGhlIHJ1bi5cblx0ICAgIEByZXR1cm5zIHtPYmplY3R9IHRoaXMuXG5cdCAgKi9cblx0ICBUdW5lYWJsZS5wcm90b3R5cGUudHVuZSA9IGZ1bmN0aW9uIHR1bmUobykge1xuXHQgICAgLy8gaWYgb3B0aW9ucyBvYmplY3Qgd2FzIHBhc3NlZFxuXHQgICAgaWYgKG8gJiYgKDAsIF9rZXlzMi5kZWZhdWx0KShvKS5sZW5ndGgpIHtcblx0ICAgICAgdGhpcy5fdHJhbnNmb3JtSGlzdG9yeShvKTtcblx0ICAgICAgdGhpcy5fdHVuZU5ld09wdGlvbnMobyk7XG5cdCAgICAgIC8vIHJlc3RvcmUgYXJyYXkgcHJvcCB2YWx1ZXMgYmVjYXVzZSBfcHJvcHNcblx0ICAgICAgLy8gY29udGFpbiB0aGVtIGFzIHBhcnNlZCBhcnJheXNcblx0ICAgICAgLy8gYnV0IHdlIG5lZWQgdGhlIGFzIHN0cmluZ3MgdG8gc3RvcmUgaW4gaGlzdG9yeVxuXHQgICAgICAvLyBhbmQgbWVyZ2UgaW4gaGlzdG9yeSBjaGFpbnNcblx0ICAgICAgdGhpcy5faGlzdG9yeVswXSA9IF9oMi5kZWZhdWx0LmNsb25lT2JqKHRoaXMuX3Byb3BzKTtcblx0ICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuX2FycmF5UHJvcGVydHlNYXApIHtcblx0ICAgICAgICBpZiAob1trZXldICE9IG51bGwpIHtcblx0ICAgICAgICAgIHRoaXMuX2hpc3RvcnlbMF1ba2V5XSA9IHRoaXMuX3ByZXBhcnNlUHJvcFZhbHVlKGtleSwgb1trZXldKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICB0aGlzLl90dW5lU3ViTW9kdWxlcygpO1xuXHQgICAgICB0aGlzLl9yZXNldFR3ZWVucygpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHJlZ2VuZXJhdGUgYWxsIHRoZSByYW5kb20gcHJvcGVydGllcyBmb3JtIGluaXRpYWwgb2JqZWN0LlxuXHQgICAgQHB1YmxpY1xuXHQgICAgQHJldHVybnMgdGhpcy5cblx0ICAqL1xuXG5cblx0ICBUdW5lYWJsZS5wcm90b3R5cGUuZ2VuZXJhdGUgPSBmdW5jdGlvbiBnZW5lcmF0ZSgpIHtcblx0ICAgIHJldHVybiB0aGlzLnR1bmUodGhpcy5fbyk7XG5cdCAgfTtcblxuXHQgIC8vIF4gUFVCTElDICBNRVRIT0QoUykgXlxuXHQgIC8vIHYgUFJJVkFURSBNRVRIT0QoUykgdlxuXG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBwcmVwYXJzZSBvcHRpb25zIGluIG9iamVjdC5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge09iamVjdH0gT2JqZWN0IHRvIHByZXBhcnNlIHByb3BlcnRpZXMgb24uXG5cdCAgICBAcmV0dXJucyB7T2JqZWN0fSBQYXNzZWQgb2JqZWN0IHdpdGggcHJlcGFyc2VkIHByb3BzLlxuXHQgICovXG5cdCAgLy8gX3ByZVBhcnNlT3B0aW9ucyAoIG8gKSB7XG5cdCAgLy8gICBmb3IgKHZhciBrZXkgaW4gbykge1xuXHQgIC8vICAgICBvW2tleV0gPSB0aGlzLl9wcmVwYXJzZVByb3BWYWx1ZSgga2V5LCBvW2tleV0gKTtcblx0ICAvLyAgIH1cblx0ICAvLyAgIHJldHVybiBvO1xuXHQgIC8vIH1cblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHRyYW5zZm9ybSBoaXN0b3J5IHJld3JpdGUgbmV3IG9wdGlvbnMgb2JqZWN0IGNoYWluIG9uIHJ1bi5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge09iamVjdH0gTmV3IG9wdGlvbnMgdG8gdHVuZSBmb3IuXG5cdCAgKi9cblxuXG5cdCAgVHVuZWFibGUucHJvdG90eXBlLl90cmFuc2Zvcm1IaXN0b3J5ID0gZnVuY3Rpb24gX3RyYW5zZm9ybUhpc3Rvcnkobykge1xuXHQgICAgZm9yICh2YXIga2V5IGluIG8pIHtcblx0ICAgICAgdmFyIHZhbHVlID0gb1trZXldO1xuXHQgICAgICAvLyBkb24ndCB0cmFuc2Zvcm0gZm9yIGNoaWxkT3B0aW9uc1xuXHQgICAgICAvLyBpZiAoIGtleSA9PT0gJ2NoaWxkT3B0aW9ucycgKSB7IGNvbnRpbnVlOyB9XG5cdCAgICAgIHRoaXMuX3RyYW5zZm9ybUhpc3RvcnlGb3Ioa2V5LCB0aGlzLl9wcmVwYXJzZVByb3BWYWx1ZShrZXksIHZhbHVlKSk7XG5cdCAgICB9XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHRyYW5zZm9ybSBoaXN0b3J5IGNoYWluIGZvciBzcGVjaWZpYyBrZXkvdmFsdWUuXG5cdCAgICBAcGFyYW0ge1N0cmluZ30gTmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gdHJhbnNmb3JtIGhpc3RvcnkgZm9yLlxuXHQgICAgQHBhcmFtIHtBbnl9IFRoZSBuZXcgcHJvcGVydHkncyB2YWx1ZS5cblx0ICAqL1xuXG5cblx0ICBUdW5lYWJsZS5wcm90b3R5cGUuX3RyYW5zZm9ybUhpc3RvcnlGb3IgPSBmdW5jdGlvbiBfdHJhbnNmb3JtSGlzdG9yeUZvcihrZXksIHZhbHVlKSB7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2hpc3RvcnkubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgaWYgKHZhbHVlID0gdGhpcy5fdHJhbnNmb3JtSGlzdG9yeVJlY29yZChpLCBrZXksIHZhbHVlKSkge1xuXHQgICAgICAgIC8vIGJyZWFrIGlmIG5vIGZ1cnRoZXIgaGlzdG9yeSBtb2RpZmljYXRpb25zIG5lZWRlZFxuXHQgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG5cdCAgICAgICAgICBicmVhaztcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gdHJhbnNmb3JtIGhpc3RvcnkgcmVjb2Qgd2l0aCBrZXkvdmFsdWUuXG5cdCAgICBAcGFyYW0ge051bWJlcn0gSW5kZXggb2YgdGhlIGhpc3RvcnkgcmVjb3JkIHRvIHRyYW5zZm9ybS5cblx0ICAgIEBwYXJhbSB7U3RyaW5nfSBQcm9wZXJ0eSBuYW1lIHRvIHRyYW5zZm9ybS5cblx0ICAgIEBwYXJhbSB7QW55fSBQcm9wZXJ0eSB2YWx1ZSB0byB0cmFuc2Zvcm0gdG8uXG5cdCAgICBAcGFyYW0ge09iamVjdH0gT3B0aW9uYWwgdGhlIGN1cnJlbnQgaGlzdG9yeSByZWNvcmQuXG5cdCAgICBAcGFyYW0ge09iamVjdH0gT3B0aW9uYWwgdGhlIG5leHQgaGlzdG9yeSByZWNvcmQuXG5cdCAgICBAcmV0dXJucyB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIG5vIGZ1cnRoZXJcblx0ICAgICAgICAgICAgICAgICAgICAgICBoaXN0b3J5IG1vZGlmaWNhdGlvbnMgaXMgbmVlZGVkLlxuXHQgICovXG5cblxuXHQgIFR1bmVhYmxlLnByb3RvdHlwZS5fdHJhbnNmb3JtSGlzdG9yeVJlY29yZCA9IGZ1bmN0aW9uIF90cmFuc2Zvcm1IaXN0b3J5UmVjb3JkKGluZGV4LCBrZXksIG5ld1ZhbCwgY3VyclJlY29yZCwgbmV4dFJlY29yZCkge1xuXHQgICAgLy8gbmV3VmFsID0gdGhpcy5fcGFyc2VQcm9wZXJ0eSgga2V5LCBuZXdWYWwgKTtcblx0ICAgIGlmIChuZXdWYWwgPT0gbnVsbCkge1xuXHQgICAgICByZXR1cm4gbnVsbDtcblx0ICAgIH1cblxuXHQgICAgLy8gZmFsbGJhY2sgdG8gaGlzdG9yeSByZWNvcmRzLCBpZiB3YXNuJ3Qgc3BlY2lmaWVkXG5cdCAgICBjdXJyUmVjb3JkID0gY3VyclJlY29yZCA9PSBudWxsID8gdGhpcy5faGlzdG9yeVtpbmRleF0gOiBjdXJyUmVjb3JkO1xuXHQgICAgbmV4dFJlY29yZCA9IG5leHRSZWNvcmQgPT0gbnVsbCA/IHRoaXMuX2hpc3RvcnlbaW5kZXggKyAxXSA6IG5leHRSZWNvcmQ7XG5cblx0ICAgIHZhciBvbGRWYWwgPSBjdXJyUmVjb3JkW2tleV0sXG5cdCAgICAgICAgbmV4dFZhbCA9IG5leHRSZWNvcmQgPT0gbnVsbCA/IG51bGwgOiBuZXh0UmVjb3JkW2tleV07XG5cblx0ICAgIC8vIGlmIGluZGV4IGlzIDAgLSBhbHdheXMgc2F2ZSB0aGUgbmV3VmFsXG5cdCAgICAvLyBhbmQgcmV0dXJuIG5vbi1kZWx0YSBmb3Igc3Vic2VxdWVudCBtb2RpZmljYXRpb25zXG5cdCAgICBpZiAoaW5kZXggPT09IDApIHtcblx0ICAgICAgY3VyclJlY29yZFtrZXldID0gbmV3VmFsO1xuXHQgICAgICAvLyBhbHdheXMgcmV0dXJuIG9uIHR3ZWVuIHByb3BlcnRpZXNcblx0ICAgICAgaWYgKF9oMi5kZWZhdWx0LmlzVHdlZW5Qcm9wKGtleSkgJiYga2V5ICE9PSAnZHVyYXRpb24nKSB7XG5cdCAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgIH1cblx0ICAgICAgLy8gbm9udHdlZW4gcHJvcGVydGllc1xuXHQgICAgICB2YXIgaXNSZXdyaXRlTmV4dCA9IHRoaXMuX2lzUmV3cml0ZU5leHQob2xkVmFsLCBuZXh0VmFsKSxcblx0ICAgICAgICAgIHJldHVyblZhbCA9IHRoaXMuX2lzRGVsdGEobmV3VmFsKSA/IF9oMi5kZWZhdWx0LmdldERlbHRhRW5kKG5ld1ZhbCkgOiBuZXdWYWw7XG5cdCAgICAgIHJldHVybiBpc1Jld3JpdGVOZXh0ID8gcmV0dXJuVmFsIDogbnVsbDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIC8vIGlmIHdhcyBkZWx0YSBhbmQgY2FtZSBub25lLWRlbHR0YSAtIHJld3JpdGVcblx0ICAgICAgLy8gdGhlIHN0YXJ0IG9mIHRoZSBkZWx0YSBhbmQgc3RvcFxuXHQgICAgICBpZiAodGhpcy5faXNEZWx0YShvbGRWYWwpKSB7XG5cdCAgICAgICAgdmFyIF9jdXJyUmVjb3JkJGtleTtcblxuXHQgICAgICAgIGN1cnJSZWNvcmRba2V5XSA9IChfY3VyclJlY29yZCRrZXkgPSB7fSwgX2N1cnJSZWNvcmQka2V5W25ld1ZhbF0gPSBfaDIuZGVmYXVsdC5nZXREZWx0YUVuZChvbGRWYWwpLCBfY3VyclJlY29yZCRrZXkpO1xuXHQgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIC8vIGlmIHRoZSBvbGQgdmFsdWUgaXMgbm90IGRlbHRhIGFuZCB0aGUgbmV3IG9uZSBpc1xuXHQgICAgICAgIGN1cnJSZWNvcmRba2V5XSA9IG5ld1ZhbDtcblx0ICAgICAgICAvLyBpZiB0aGUgbmV4dCBpdGVtIGhhcyB0aGUgc2FtZSB2YWx1ZSAtIHJldHVybiB0aGVcblx0ICAgICAgICAvLyBpdGVtIGZvciBzdWJzZXF1ZW50IG1vZGlmaWNhdGlvbnMgb3Igc3RvcFxuXHQgICAgICAgIHJldHVybiB0aGlzLl9pc1Jld3JpdGVOZXh0KG9sZFZhbCwgbmV4dFZhbCkgPyBuZXdWYWwgOiBudWxsO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGNoZWNrIGlmIHRoZSBuZXh0IGl0ZW0gc2hvdWxkXG5cdCAgICBiZSByZXdyaXRlZCBpbiB0cmFuc2Zvcm0gaGlzdG9yeSBvcGVyYXRpb24uXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtBbnl9IEN1cnJlbnQgdmFsdWUuXG5cdCAgICBAcGFyYW0ge0FueX0gTmV4dCB2YWx1ZS5cblx0ICAgIEByZXR1cm5zIHtCb29sZWFufSBJZiBuZWVkIHRvIHJld3JpdGUgdGhlIG5leHQgdmFsdWUuXG5cdCAgKi9cblxuXG5cdCAgVHVuZWFibGUucHJvdG90eXBlLl9pc1Jld3JpdGVOZXh0ID0gZnVuY3Rpb24gX2lzUmV3cml0ZU5leHQoY3VyclZhbCwgbmV4dFZhbCkge1xuXHQgICAgLy8gcmV0dXJuIGZhbHNlIGlmIG5vdGhpbmcgdG8gcmV3cml0ZSBuZXh0XG5cdCAgICBpZiAobmV4dFZhbCA9PSBudWxsICYmIGN1cnJWYWwgIT0gbnVsbCkge1xuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cblx0ICAgIHZhciBpc0VxdWFsID0gY3VyclZhbCA9PT0gbmV4dFZhbCxcblx0ICAgICAgICBpc05leHREZWx0YSA9IHRoaXMuX2lzRGVsdGEobmV4dFZhbCksXG5cdCAgICAgICAgaXNEZWx0YSA9IHRoaXMuX2lzRGVsdGEoY3VyclZhbCksXG5cdCAgICAgICAgaXNWYWx1ZURlbHRhQ2hhaW4gPSBmYWxzZSxcblx0ICAgICAgICBpc0RlbHRhQ2hhaW4gPSBmYWxzZTtcblxuXHQgICAgaWYgKGlzRGVsdGEgJiYgaXNOZXh0RGVsdGEpIHtcblx0ICAgICAgaWYgKF9oMi5kZWZhdWx0LmdldERlbHRhRW5kKGN1cnJWYWwpID09IF9oMi5kZWZhdWx0LmdldERlbHRhU3RhcnQobmV4dFZhbCkpIHtcblx0ICAgICAgICBpc0RlbHRhQ2hhaW4gPSB0cnVlO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2UgaWYgKGlzTmV4dERlbHRhKSB7XG5cdCAgICAgIGlzVmFsdWVEZWx0YUNoYWluID0gX2gyLmRlZmF1bHQuZ2V0RGVsdGFTdGFydChuZXh0VmFsKSA9PT0gJycgKyBjdXJyVmFsO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gaXNFcXVhbCB8fCBpc1ZhbHVlRGVsdGFDaGFpbiB8fCBpc0RlbHRhQ2hhaW47XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHR1bmUgbmV3IGhpc3Rvcnkgb3B0aW9ucyB0byBhbGwgdGhlIHN1Ym1vZHVsZXMuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIFR1bmVhYmxlLnByb3RvdHlwZS5fdHVuZVN1Yk1vZHVsZXMgPSBmdW5jdGlvbiBfdHVuZVN1Yk1vZHVsZXMoKSB7XG5cdCAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMuX21vZHVsZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdGhpcy5fbW9kdWxlc1tpXS5fdHVuZU5ld09wdGlvbnModGhpcy5faGlzdG9yeVtpXSk7XG5cdCAgICB9XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHNldCBuZXcgb3B0aW9ucyBvbiBydW4uXG5cdCAgICBAcGFyYW0ge0Jvb2xlYW59IElmIGZvcmVpZ24gY29udGV4dC5cblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblxuXG5cdCAgVHVuZWFibGUucHJvdG90eXBlLl9yZXNldFR3ZWVucyA9IGZ1bmN0aW9uIF9yZXNldFR3ZWVucygpIHtcblx0ICAgIHZhciBpID0gMCxcblx0ICAgICAgICBzaGlmdCA9IDAsXG5cdCAgICAgICAgdHdlZW5zID0gdGhpcy50aW1lbGluZS5fdGltZWxpbmVzO1xuXG5cdCAgICAvLyBpZiBgaXNUaW1lbGluZUxlc3NgIHJldHVyblxuXHQgICAgaWYgKHR3ZWVucyA9PSBudWxsKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0d2VlbnMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIHR3ZWVuID0gdHdlZW5zW2ldLFxuXHQgICAgICAgICAgcHJldlR3ZWVuID0gdHdlZW5zW2kgLSAxXTtcblxuXHQgICAgICBzaGlmdCArPSBwcmV2VHdlZW4gPyBwcmV2VHdlZW4uX3Byb3BzLnJlcGVhdFRpbWUgOiAwO1xuXHQgICAgICB0aGlzLl9yZXNldFR3ZWVuKHR3ZWVuLCB0aGlzLl9oaXN0b3J5W2ldLCBzaGlmdCk7XG5cdCAgICB9XG5cdCAgICB0aGlzLnRpbWVsaW5lLl9zZXRQcm9wKHRoaXMuX3Byb3BzLnRpbWVsaW5lKTtcblx0ICAgIHRoaXMudGltZWxpbmUuX3JlY2FsY1RvdGFsRHVyYXRpb24oKTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gcmVzZXQgdHdlZW4gd2l0aCBuZXcgb3B0aW9ucy5cblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBUd2VlbiB0byByZXNldC5cblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBUd2VlbidzIHRvIHJlc2V0IHR3ZWVuIHdpdGguXG5cdCAgICBAcGFyYW0ge051bWJlcn0gT3B0aW9uYWwgbnVtYmVyIHRvIHNoaWZ0IHR3ZWVuIHN0YXJ0IHRpbWUuXG5cdCAgKi9cblxuXG5cdCAgVHVuZWFibGUucHJvdG90eXBlLl9yZXNldFR3ZWVuID0gZnVuY3Rpb24gX3Jlc2V0VHdlZW4odHdlZW4sIG8pIHtcblx0ICAgIHZhciBzaGlmdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcblxuXHQgICAgby5zaGlmdFRpbWUgPSBzaGlmdDt0d2Vlbi5fc2V0UHJvcChvKTtcblx0ICB9O1xuXG5cdCAgcmV0dXJuIFR1bmVhYmxlO1xuXHR9KF90aGVuYWJsZTIuZGVmYXVsdCk7XG5cblx0ZXhwb3J0cy5kZWZhdWx0ID0gVHVuZWFibGU7XG5cbi8qKiovIH0pLFxuLyogMTE3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cblx0dmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0KTtcblxuXHR2YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cblx0dmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9fd2VicGFja19yZXF1aXJlX18oNzUpO1xuXG5cdHZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMik7XG5cblx0dmFyIF9pbmhlcml0czIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc2KTtcblxuXHR2YXIgX2luaGVyaXRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luaGVyaXRzMik7XG5cblx0dmFyIF9zaGFwZSA9IF9fd2VicGFja19yZXF1aXJlX18oOTQpO1xuXG5cdHZhciBfc2hhcGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2hhcGUpO1xuXG5cdHZhciBfaCA9IF9fd2VicGFja19yZXF1aXJlX18oNzEpO1xuXG5cdHZhciBfaDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oKTtcblxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5cdC8qXG5cdCAgKlRPRE86KlxuXHQgIC0tLVxuXHQgIC0gdHdlYWsgdGhlbiBjaGFpbnNcblx0Ki9cblxuXHR2YXIgU2hhcGVTd2lybCA9IGZ1bmN0aW9uIChfU2hhcGUpIHtcblx0ICAoMCwgX2luaGVyaXRzMy5kZWZhdWx0KShTaGFwZVN3aXJsLCBfU2hhcGUpO1xuXG5cdCAgZnVuY3Rpb24gU2hhcGVTd2lybCgpIHtcblx0ICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIFNoYXBlU3dpcmwpO1xuXHQgICAgcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMuZGVmYXVsdCkodGhpcywgX1NoYXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuXHQgIH1cblxuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gZGVjbGFyZSBfZGVmYXVsdHMgYW5kIG90aGVyIGRlZmF1bHQgb2JqZWN0cy5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAb3ZlcnJpZGUgQCBTaGFwZVxuXHQgICovXG5cdCAgU2hhcGVTd2lybC5wcm90b3R5cGUuX2RlY2xhcmVEZWZhdWx0cyA9IGZ1bmN0aW9uIF9kZWNsYXJlRGVmYXVsdHMoKSB7XG5cdCAgICBfU2hhcGUucHJvdG90eXBlLl9kZWNsYXJlRGVmYXVsdHMuY2FsbCh0aGlzKTtcblxuXHQgICAgLyogX0RFRkFVTFRTIEFSRSAtIFNoYXBlIERFRkFVTFRTICsgVEhFU0U6ICovXG5cblx0ICAgIC8qIFtib29sZWFuXSA6OiBJZiBzaGFwZSBzaG91bGQgZm9sbG93IHNpbnVzb2lkYWwgcGF0aC4gKi9cblx0ICAgIHRoaXMuX2RlZmF1bHRzLmlzU3dpcmwgPSB0cnVlO1xuXHQgICAgLyog4oiGIDo6IFtudW1iZXIgPiAwXSA6OiBEZWdyZWUgc2l6ZSBvZiB0aGUgc2ludXNvaWRhbCBwYXRoLiAqL1xuXHQgICAgdGhpcy5fZGVmYXVsdHMuc3dpcmxTaXplID0gMTA7XG5cdCAgICAvKiDiiIYgOjogW251bWJlciA+IDBdIDo6IEZyZXF1ZW5jeSBvZiB0aGUgc2ludXNvaWRhbCBwYXRoLiAqL1xuXHQgICAgdGhpcy5fZGVmYXVsdHMuc3dpcmxGcmVxdWVuY3kgPSAzO1xuXHQgICAgLyog4oiGIDo6IFtudW1iZXIgPiAwXSA6OiBTaW51c29pZGFsIHBhdGggbGVuZ3RoIHNjYWxlLiAqL1xuXHQgICAgdGhpcy5fZGVmYXVsdHMucGF0aFNjYWxlID0gMTtcblx0ICAgIC8qIOKIhiA6OiBbbnVtYmVyXSA6OiBEZWdyZWUgc2hpZnQgZm9yIHRoZSBzaW51c29pZGFsIHBhdGguICovXG5cdCAgICB0aGlzLl9kZWZhdWx0cy5kZWdyZWVTaGlmdCA9IDA7XG5cdCAgICAvKiDiiIYgOjogW251bWJlcl0gOjogUmFkaXVzIG9mIHRoZSBzaGFwZS4gKi9cblx0ICAgIHRoaXMuX2RlZmF1bHRzLnJhZGl1cyA9IDU7XG5cdCAgICAvLyDiiIYgOjogVW5pdHMgOjogUG9zc2libGUgdmFsdWVzOiBbIG51bWJlciwgc3RyaW5nIF1cblx0ICAgIHRoaXMuX2RlZmF1bHRzLnggPSAwO1xuXHQgICAgLy8g4oiGIDo6IFVuaXRzIDo6IFBvc3NpYmxlIHZhbHVlczogWyBudW1iZXIsIHN0cmluZyBdXG5cdCAgICB0aGlzLl9kZWZhdWx0cy55ID0gMDtcblx0ICAgIC8vIOKIhiA6OiBQb3NzaWJsZSB2YWx1ZXM6IFsgbnVtYmVyIF1cblx0ICAgIHRoaXMuX2RlZmF1bHRzLnNjYWxlID0geyAxOiAwIH07XG5cdCAgICAvKiBbbnVtYmVyOiAtMSwgMV0gOjogRGlyZWN0b24gb2YgU3dpcmwuICovXG5cdCAgICB0aGlzLl9kZWZhdWx0cy5kaXJlY3Rpb24gPSAxO1xuXHQgIH07XG5cblx0ICAvLyBeIFBVQkxJQyAgTUVUSE9EKFMpIF5cblx0ICAvLyB2IFBSSVZBVEUgTUVUSE9EKFMpIHZcblxuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gY29weSBfbyBvcHRpb25zIHRvIF9wcm9wcyB3aXRoXG5cdCAgICBmYWxsYmFjayB0byBfZGVmYXVsdHMuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQG92ZXJyaWRlIEAgTW9kdWxlXG5cdCAgKi9cblxuXG5cdCAgU2hhcGVTd2lybC5wcm90b3R5cGUuX2V4dGVuZERlZmF1bHRzID0gZnVuY3Rpb24gX2V4dGVuZERlZmF1bHRzKCkge1xuXHQgICAgX1NoYXBlLnByb3RvdHlwZS5fZXh0ZW5kRGVmYXVsdHMuY2FsbCh0aGlzKTtcblx0ICAgIHRoaXMuX2NhbGNQb3NEYXRhKCk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHR1bmUgbmV3IG9wcmlvbnMgdG8gX28gYW5kIF9wcm9wcyBvYmplY3QuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQG92ZXJyaWRlcyBAIE1vZHVsZVxuXHQgICAgQHBhcmFtIHtPYmplY3R9IE9wdGlvbnMgb2JqZWN0IHRvIHR1bmUgdG8uXG5cdCAgKi9cblxuXG5cdCAgU2hhcGVTd2lybC5wcm90b3R5cGUuX3R1bmVOZXdPcHRpb25zID0gZnVuY3Rpb24gX3R1bmVOZXdPcHRpb25zKG8pIHtcblx0ICAgIGlmIChvID09IG51bGwpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICBfU2hhcGUucHJvdG90eXBlLl90dW5lTmV3T3B0aW9ucy5jYWxsKHRoaXMsIG8pO1xuXHQgICAgaWYgKG8ueCAhPSBudWxsIHx8IG8ueSAhPSBudWxsKSB7XG5cdCAgICAgIHRoaXMuX2NhbGNQb3NEYXRhKCk7XG5cdCAgICB9XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGNhbGN1bGF0ZSBTd2lybCdzIHBvc2l0aW9uIGRhdGEuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIFNoYXBlU3dpcmwucHJvdG90eXBlLl9jYWxjUG9zRGF0YSA9IGZ1bmN0aW9uIF9jYWxjUG9zRGF0YSgpIHtcblx0ICAgIHZhciB4ID0gdGhpcy5fZ2V0UG9zVmFsdWUoJ3gnKSxcblx0ICAgICAgICB5ID0gdGhpcy5fZ2V0UG9zVmFsdWUoJ3knKSxcblx0ICAgICAgICBhbmdsZSA9IDkwICsgTWF0aC5hdGFuKHkuZGVsdGEgLyB4LmRlbHRhIHx8IDApICogX2gyLmRlZmF1bHQuUkFEX1RPX0RFRztcblxuXHQgICAgdGhpcy5fcG9zRGF0YSA9IHtcblx0ICAgICAgcmFkaXVzOiBNYXRoLnNxcnQoeC5kZWx0YSAqIHguZGVsdGEgKyB5LmRlbHRhICogeS5kZWx0YSksXG5cdCAgICAgIGFuZ2xlOiB4LmRlbHRhIDwgMCA/IGFuZ2xlICsgMTgwIDogYW5nbGUsXG5cdCAgICAgIHg6IHgsIHk6IHlcblx0ICAgIH07XG5cdCAgICAvLyBzZXQgdGhlIGxhc3QgcG9zaXRpb24gdG8gX3Byb3BzXG5cdCAgICAvLyB0aGlzLl9jYWxjU3dpcmxYWSggMSApO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIEdldHMgYHhgIG9yIGB5YCBwb3NpdGlvbiB2YWx1ZS5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge1N0cmluZ30gTmFtZSBvZiB0aGUgcHJvcGVydHkuXG5cdCAgKi9cblxuXG5cdCAgU2hhcGVTd2lybC5wcm90b3R5cGUuX2dldFBvc1ZhbHVlID0gZnVuY3Rpb24gX2dldFBvc1ZhbHVlKG5hbWUpIHtcblx0ICAgIHZhciBkZWx0YSA9IHRoaXMuX2RlbHRhc1tuYW1lXTtcblx0ICAgIGlmIChkZWx0YSkge1xuXHQgICAgICAvLyBkZWxldGUgZnJvbSBkZWx0YXMgdG8gcHJldmVudCBub3JtYWxcblx0ICAgICAgZGVsZXRlIHRoaXMuX2RlbHRhc1tuYW1lXTtcblx0ICAgICAgcmV0dXJuIHtcblx0ICAgICAgICBzdGFydDogZGVsdGEuc3RhcnQudmFsdWUsXG5cdCAgICAgICAgZW5kOiBkZWx0YS5lbmQudmFsdWUsXG5cdCAgICAgICAgZGVsdGE6IGRlbHRhLmRlbHRhLFxuXHQgICAgICAgIHVuaXRzOiBkZWx0YS5lbmQudW5pdFxuXHQgICAgICB9O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdmFyIHBvcyA9IF9oMi5kZWZhdWx0LnBhcnNlVW5pdCh0aGlzLl9wcm9wc1tuYW1lXSk7XG5cdCAgICAgIHJldHVybiB7IHN0YXJ0OiBwb3MudmFsdWUsIGVuZDogcG9zLnZhbHVlLCBkZWx0YTogMCwgdW5pdHM6IHBvcy51bml0IH07XG5cdCAgICB9XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGNhbGN1bGF0ZSB0aGUgcHJvZ3Jlc3Mgb2YgdGhlIFN3aXJsLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBvdmVycmlkZXMgQCBTaGFwZVxuXHQgICAgQHBhcmFtIHtOdW1lcn0gRWFzZWQgcHJvZ3Jlc3Mgb2YgdGhlIFN3aXJsIGluIHJhbmdlIG9mIFswLi4xXVxuXHQgICAgQHBhcmFtIHtOdW1lcn0gUHJvZ3Jlc3Mgb2YgdGhlIFN3aXJsIGluIHJhbmdlIG9mIFswLi4xXVxuXHQgICovXG5cblxuXHQgIFNoYXBlU3dpcmwucHJvdG90eXBlLl9zZXRQcm9ncmVzcyA9IGZ1bmN0aW9uIF9zZXRQcm9ncmVzcyhlYXNlZFByb2dyZXNzLCBwcm9ncmVzcykge1xuXHQgICAgdGhpcy5fcHJvZ3Jlc3MgPSBlYXNlZFByb2dyZXNzO1xuXHQgICAgdGhpcy5fY2FsY0N1cnJlbnRQcm9wcyhlYXNlZFByb2dyZXNzLCBwcm9ncmVzcyk7XG5cdCAgICB0aGlzLl9jYWxjU3dpcmxYWShlYXNlZFByb2dyZXNzKTtcblx0ICAgIC8vIHRoaXMuX2NhbGNPcmlnaW4oKTtcblx0ICAgIHRoaXMuX2RyYXcoZWFzZWRQcm9ncmVzcyk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGNhbGN1bGF0ZSB4L3kgZm9yIFN3aXJsJ3MgcHJvZ3Jlc3Ncblx0ICAgIEBwcml2YXRlXG5cdCAgICBAbXV0YXRlcyBfcHJvcHNcblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBDdXJyZW50IHByb2dyZXNzIGluIFswLi4uMV1cblx0ICAqL1xuXG5cblx0ICBTaGFwZVN3aXJsLnByb3RvdHlwZS5fY2FsY1N3aXJsWFkgPSBmdW5jdGlvbiBfY2FsY1N3aXJsWFkocHJvYykge1xuXHQgICAgdmFyIHAgPSB0aGlzLl9wcm9wcyxcblx0ICAgICAgICBhbmdsZSA9IHRoaXMuX3Bvc0RhdGEuYW5nbGUgKyBwLmRlZ3JlZVNoaWZ0LFxuXHQgICAgICAgIHBvaW50ID0gX2gyLmRlZmF1bHQuZ2V0UmFkaWFsUG9pbnQoe1xuXHQgICAgICBhbmdsZTogcC5pc1N3aXJsID8gYW5nbGUgKyB0aGlzLl9nZXRTd2lybChwcm9jKSA6IGFuZ2xlLFxuXHQgICAgICByYWRpdXM6IHByb2MgKiB0aGlzLl9wb3NEYXRhLnJhZGl1cyAqIHAucGF0aFNjYWxlLFxuXHQgICAgICBjZW50ZXI6IHtcblx0ICAgICAgICB4OiB0aGlzLl9wb3NEYXRhLnguc3RhcnQsXG5cdCAgICAgICAgeTogdGhpcy5fcG9zRGF0YS55LnN0YXJ0XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLy8gaWYgZm9yZWlnbiBzdmcgY2FudmFzIC0gc2V0IHBvc2l0aW9uIHdpdGhvdXQgdW5pdHNcblx0ICAgIHZhciB4ID0gcG9pbnQueCxcblx0ICAgICAgICB5ID0gcG9pbnQueSxcblx0ICAgICAgICBzbWFsbE51bWJlciA9IDAuMDAwMDAxO1xuXG5cdCAgICAvLyByZW1vdmUgdmVyeSBzbWFsbCBudW1iZXJzIHRvIHByZXZlbnQgZXhwb25lbnRpYWwgZm9ybXNcblx0ICAgIGlmICh4ID4gMCAmJiB4IDwgc21hbGxOdW1iZXIpIHtcblx0ICAgICAgeCA9IHNtYWxsTnVtYmVyO1xuXHQgICAgfVxuXHQgICAgaWYgKHkgPiAwICYmIHkgPCBzbWFsbE51bWJlcikge1xuXHQgICAgICB5ID0gc21hbGxOdW1iZXI7XG5cdCAgICB9XG5cdCAgICBpZiAoeCA8IDAgJiYgeCA+IC1zbWFsbE51bWJlcikge1xuXHQgICAgICB4ID0gLXNtYWxsTnVtYmVyO1xuXHQgICAgfVxuXHQgICAgaWYgKHkgPCAwICYmIHkgPiAtc21hbGxOdW1iZXIpIHtcblx0ICAgICAgeSA9IC1zbWFsbE51bWJlcjtcblx0ICAgIH1cblxuXHQgICAgcC54ID0gdGhpcy5fby5jdHggPyB4IDogJycgKyB4ICsgdGhpcy5fcG9zRGF0YS54LnVuaXRzO1xuXHQgICAgcC55ID0gdGhpcy5fby5jdHggPyB5IDogJycgKyB5ICsgdGhpcy5fcG9zRGF0YS55LnVuaXRzO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBnZXQgcHJvZ3Jlc3Mgb2YgdGhlIHN3aXJsLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBQcm9ncmVzcyBvZiB0aGUgU3dpcmwuXG5cdCAgICBAcmV0dXJucyB7TnVtYmVyfSBQcm9ncmVzcyBvZiB0aGUgc3dpcmwuXG5cdCAgKi9cblxuXG5cdCAgU2hhcGVTd2lybC5wcm90b3R5cGUuX2dldFN3aXJsID0gZnVuY3Rpb24gX2dldFN3aXJsKHByb2MpIHtcblx0ICAgIHZhciBwID0gdGhpcy5fcHJvcHM7XG5cdCAgICByZXR1cm4gcC5kaXJlY3Rpb24gKiBwLnN3aXJsU2l6ZSAqIE1hdGguc2luKHAuc3dpcmxGcmVxdWVuY3kgKiBwcm9jKTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gZHJhdyBzaGFwZS5cblx0ICAgIElmICFpc1dpdGhTaGFwZSAtIGRyYXcgc2VsZiBlbCBvbmx5LCBidXQgbm90IHNoYXBlLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBvdmVycmlkZXMgQCBTaGFwZS5cblx0ICAqL1xuXG5cblx0ICBTaGFwZVN3aXJsLnByb3RvdHlwZS5fZHJhdyA9IGZ1bmN0aW9uIF9kcmF3KCkge1xuXHQgICAgLy8gY2FsbCBfZHJhdyBvciBqdXN0IF9kcmF3RWwgQCBTaGFwZSBkZXBlbmRpbmcgaWYgdGhlcmUgaXMgYHNoYXBlYFxuXHQgICAgdmFyIG1ldGhvZE5hbWUgPSB0aGlzLl9wcm9wcy5pc1dpdGhTaGFwZSA/ICdfZHJhdycgOiAnX2RyYXdFbCc7XG5cdCAgICBfc2hhcGUyLmRlZmF1bHQucHJvdG90eXBlW21ldGhvZE5hbWVdLmNhbGwodGhpcyk7XG5cdCAgfTtcblxuXHQgIHJldHVybiBTaGFwZVN3aXJsO1xuXHR9KF9zaGFwZTIuZGVmYXVsdCk7XG5cblx0ZXhwb3J0cy5kZWZhdWx0ID0gU2hhcGVTd2lybDtcblxuLyoqKi8gfSksXG4vKiAxMTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuXHR2YXIgX2tleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1KTtcblxuXHR2YXIgX2tleXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfa2V5cyk7XG5cblx0dmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0KTtcblxuXHR2YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cblx0dmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9fd2VicGFja19yZXF1aXJlX18oNzUpO1xuXG5cdHZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMik7XG5cblx0dmFyIF9pbmhlcml0czIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc2KTtcblxuXHR2YXIgX2luaGVyaXRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luaGVyaXRzMik7XG5cblx0dmFyIF90aW1lbGluZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEwKTtcblxuXHR2YXIgX3RpbWVsaW5lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RpbWVsaW5lKTtcblxuXHR2YXIgX3NoYXBlU3dpcmwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExNyk7XG5cblx0dmFyIF9zaGFwZVN3aXJsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NoYXBlU3dpcmwpO1xuXG5cdHZhciBfdHVuYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTE2KTtcblxuXHR2YXIgX3R1bmFibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHVuYWJsZSk7XG5cblx0dmFyIF9oID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MSk7XG5cblx0dmFyIF9oMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2gpO1xuXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cblx0Ly8gaW1wb3J0IFNoYXBlICAgIGZyb20gJy4vc2hhcGUnO1xuXHR2YXIgQnVyc3QgPSBmdW5jdGlvbiAoX1R1bmFibGUpIHtcblx0ICAoMCwgX2luaGVyaXRzMy5kZWZhdWx0KShCdXJzdCwgX1R1bmFibGUpO1xuXG5cdCAgZnVuY3Rpb24gQnVyc3QoKSB7XG5cdCAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBCdXJzdCk7XG5cdCAgICByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMy5kZWZhdWx0KSh0aGlzLCBfVHVuYWJsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcblx0ICB9XG5cblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGRlY2xhcmUgZGVmYXVsdHMuXG5cdCAgICBAb3ZlcnJpZGUgQCBTaGFwZVN3aXJsLlxuXHQgICovXG5cdCAgQnVyc3QucHJvdG90eXBlLl9kZWNsYXJlRGVmYXVsdHMgPSBmdW5jdGlvbiBfZGVjbGFyZURlZmF1bHRzKCkge1xuXHQgICAgdGhpcy5fZGVmYXVsdHMgPSB7XG5cdCAgICAgIC8qIFtudW1iZXIgPiAwXSA6OiBRdWFudGl0eSBvZiBCdXJzdCBwYXJ0aWNsZXMuICovXG5cdCAgICAgIGNvdW50OiA1LFxuXHQgICAgICAvKiBbMCA8IG51bWJlciA8IDM2MF0gOjogRGVncmVlIG9mIHRoZSBCdXJzdC4gKi9cblx0ICAgICAgZGVncmVlOiAzNjAsXG5cdCAgICAgIC8qIOKIhiA6OiBbbnVtYmVyID4gMF0gOjogUmFkaXVzIG9mIHRoZSBCdXJzdC4gKi9cblx0ICAgICAgcmFkaXVzOiB7IDA6IDUwIH0sXG5cdCAgICAgIC8qIOKIhiA6OiBbbnVtYmVyID4gMF0gOjogWCByYWRpdXMgb2YgdGhlIEJ1cnN0LiAqL1xuXHQgICAgICByYWRpdXNYOiBudWxsLFxuXHQgICAgICAvKiDiiIYgOjogW251bWJlciA+IDBdIDo6IFkgcmFkaXVzIG9mIHRoZSBCdXJzdC4gKi9cblx0ICAgICAgcmFkaXVzWTogbnVsbCxcblx0ICAgICAgLyogW251bWJlciA+PSAwXSA6OiB3aWR0aCBvZiB0aGUgbWFpbiBzd2lybC4gKi9cblx0ICAgICAgd2lkdGg6IDAsXG5cdCAgICAgIC8qIFtudW1iZXIgPj0gMF0gOjogaGVpZ2h0IG9mIHRoZSBtYWluIHN3aXJsLiAqL1xuXHQgICAgICBoZWlnaHQ6IDBcblx0ICAgIH07XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGNyZWF0ZSBhIHRoZW4gcmVjb3JkIGZvciB0aGUgbW9kdWxlLlxuXHQgICAgQHB1YmxpY1xuXHQgICAgb3ZlcnJpZGVzIEAgVGhlbmFibGVcblx0ICAgIEBwYXJhbSAgICB7T2JqZWN0fSBPcHRpb25zIGZvciB0aGUgbmV4dCBhbmltYXRpb24uXG5cdCAgICBAcmV0dXJucyAge09iamVjdH0gdGhpcy5cblx0ICAqL1xuXG5cblx0ICBCdXJzdC5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uIHRoZW4obykge1xuXHQgICAgLy8gcmVtb3ZlIHR3ZWVuIHByb3BlcnRpZXMgKG5vdCBjYWxsYmFja3MpXG5cdCAgICB0aGlzLl9yZW1vdmVUd2VlblByb3BlcnRpZXMobyk7XG5cblx0ICAgIHZhciBuZXdNYXN0ZXIgPSB0aGlzLl9tYXN0ZXJUaGVuKG8pLFxuXHQgICAgICAgIG5ld1N3aXJscyA9IHRoaXMuX2NoaWxkVGhlbihvKTtcblxuXHQgICAgdGhpcy5fc2V0U3dpcmxEdXJhdGlvbihuZXdNYXN0ZXIsIHRoaXMuX2NhbGNQYWNrVGltZShuZXdTd2lybHMpKTtcblxuXHQgICAgdGhpcy50aW1lbGluZS5fcmVjYWxjVG90YWxEdXJhdGlvbigpO1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHN0YXJ0IHRoZSBhbmltYXRpb24gd2l0aCBvcHRpb25hbCBuZXcgb3B0aW9ucy5cblx0ICAgIEBwdWJsaWNcblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBOZXcgb3B0aW9ucyB0byBzZXQgb24gdGhlIHJ1bi5cblx0ICAgIEByZXR1cm5zIHtPYmplY3R9IHRoaXMuXG5cdCAgKi9cblxuXG5cdCAgQnVyc3QucHJvdG90eXBlLnR1bmUgPSBmdW5jdGlvbiB0dW5lKG8pIHtcblx0ICAgIGlmIChvID09IG51bGwpIHtcblx0ICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9XG5cdCAgICAvLyBzYXZlIHRpbWVsaW5lIG9wdGlvbnMgdG8gX3RpbWVsaW5lT3B0aW9uc1xuXHQgICAgLy8gYW5kIGRlbGV0ZSB0aGUgdGltZWxpbmUgb3B0aW9ucyBvbiBvXG5cdCAgICAvLyBjdXogbWFzdGVyU3dpcmwgc2hvdWxkIG5vdCBnZXQgdGhlbVxuXHQgICAgdGhpcy5fc2F2ZVRpbWVsaW5lT3B0aW9ucyhvKTtcblxuXHQgICAgLy8gYWRkIG5ldyB0aW1lbGluZSBwcm9wZXJ0aWVzIHRvIHRpbWVsaW5lXG5cdCAgICB0aGlzLnRpbWVsaW5lLl9zZXRQcm9wKHRoaXMuX3RpbWVsaW5lT3B0aW9ucyk7XG5cblx0ICAgIC8vIHJlbW92ZSB0d2VlbiBvcHRpb25zIChub3QgY2FsbGJhY2tzKVxuXHQgICAgdGhpcy5fcmVtb3ZlVHdlZW5Qcm9wZXJ0aWVzKG8pO1xuXG5cdCAgICAvLyB0dW5lIF9wcm9wc1xuXHQgICAgdGhpcy5fdHVuZU5ld09wdGlvbnMobyk7XG5cblx0ICAgIC8vIHR1bmUgbWFzdGVyIHN3aXJsXG5cdCAgICB0aGlzLm1hc3RlclN3aXJsLnR1bmUobyk7XG5cblx0ICAgIC8vIHR1bmUgY2hpbGQgc3dpcmxzXG5cdCAgICB0aGlzLl90dW5lU3dpcmxzKG8pO1xuXG5cdCAgICAvLyByZWNhbGMgdGltZSBmb3IgbW9kdWxlc1xuXHQgICAgdGhpcy5fcmVjYWxjTW9kdWxlc1RpbWUoKTtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cblx0ICAvLyBeIFBVQkxJQyAgTUVUSE9EUyBeXG5cdCAgLy8gdiBQUklWQVRFIE1FVEhPRFMgdlxuXG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBjb3B5IGBfb2Agb3B0aW9ucyB0byBgX3Byb3BzYCBvYmplY3Rcblx0ICAgIHdpdGggZmFsbGJhY2sgdG8gYF9kZWZhdWx0c2AuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQG92ZXJyaWRlcyBAIE1vZHVsZVxuXHQgICovXG5cblxuXHQgIEJ1cnN0LnByb3RvdHlwZS5fZXh0ZW5kRGVmYXVsdHMgPSBmdW5jdGlvbiBfZXh0ZW5kRGVmYXVsdHMoKSB7XG5cdCAgICAvLyByZW1vdmUgdHdlZW4gcHJvcGVydGllcyAobm90IGNhbGxiYWNrcylcblx0ICAgIHRoaXMuX3JlbW92ZVR3ZWVuUHJvcGVydGllcyh0aGlzLl9vKTtcblx0ICAgIF9UdW5hYmxlLnByb3RvdHlwZS5fZXh0ZW5kRGVmYXVsdHMuY2FsbCh0aGlzKTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gcmVtb3ZlIGFsbCB0d2VlbiAoZXhjbHVkaW5nXG5cdCAgICBjYWxsYmFja3MpIHByb3BzIGZyb20gb2JqZWN0LlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBPYmplY3Qgd2hpY2ggc2hvdWxkIGJlIGNsZWFuZWRcblx0ICAgICAgICAgICAgICAgICAgICB1cCBmcm9tIHR3ZWVuIHByb3BlcnRpZXMuXG5cdCAgKi9cblxuXG5cdCAgQnVyc3QucHJvdG90eXBlLl9yZW1vdmVUd2VlblByb3BlcnRpZXMgPSBmdW5jdGlvbiBfcmVtb3ZlVHdlZW5Qcm9wZXJ0aWVzKG8pIHtcblx0ICAgIGZvciAodmFyIGtleSBpbiBfaDIuZGVmYXVsdC50d2Vlbk9wdGlvbk1hcCkge1xuXHQgICAgICAvLyByZW1vdmUgYWxsIGl0ZW1zIHRoYXQgYXJlIG5vdCBkZWNsYXJlZCBpbiBfZGVmYXVsdHNcblx0ICAgICAgaWYgKHRoaXMuX2RlZmF1bHRzW2tleV0gPT0gbnVsbCkge1xuXHQgICAgICAgIGRlbGV0ZSBvW2tleV07XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gcmVjYWxjIG1vZHVsZXMgY2hhaW4gdHdlZW5cblx0ICAgIHRpbWVzIGFmdGVyIHR1bmluZyBuZXcgb3B0aW9ucy5cblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblxuXG5cdCAgQnVyc3QucHJvdG90eXBlLl9yZWNhbGNNb2R1bGVzVGltZSA9IGZ1bmN0aW9uIF9yZWNhbGNNb2R1bGVzVGltZSgpIHtcblx0ICAgIHZhciBtb2R1bGVzID0gdGhpcy5tYXN0ZXJTd2lybC5fbW9kdWxlcyxcblx0ICAgICAgICBzd2lybHMgPSB0aGlzLl9zd2lybHMsXG5cdCAgICAgICAgc2hpZnRUaW1lID0gMDtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciB0d2VlbiA9IG1vZHVsZXNbaV0udHdlZW4sXG5cdCAgICAgICAgICBwYWNrVGltZSA9IHRoaXMuX2NhbGNQYWNrVGltZShzd2lybHNbaV0pO1xuXHQgICAgICB0d2Vlbi5fc2V0UHJvcCh7ICdkdXJhdGlvbic6IHBhY2tUaW1lLCAnc2hpZnRUaW1lJzogc2hpZnRUaW1lIH0pO1xuXHQgICAgICBzaGlmdFRpbWUgKz0gcGFja1RpbWU7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMudGltZWxpbmUuX3JlY2FsY1RvdGFsRHVyYXRpb24oKTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gdHVuZSBTd2lybHMgd2l0aCBuZXcgb3B0aW9ucy5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge09iamVjdH0gTmV3IG9wdGlvbnMuXG5cdCAgKi9cblxuXG5cdCAgQnVyc3QucHJvdG90eXBlLl90dW5lU3dpcmxzID0gZnVuY3Rpb24gX3R1bmVTd2lybHMobykge1xuXHQgICAgLy8gZ2V0IHN3aXJscyBpbiBmaXJzdCBwYWNrXG5cdCAgICB2YXIgcGFjazAgPSB0aGlzLl9zd2lybHNbMF07XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhY2swLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciBzd2lybCA9IHBhY2swW2ldLFxuXHQgICAgICAgICAgb3B0aW9uID0gdGhpcy5fZ2V0Q2hpbGRPcHRpb24obyB8fCB7fSwgaSk7XG5cblx0ICAgICAgLy8gc2luY2UgdGhlIGBkZWdyZWVTaGlmdGAgcGFydGljaXBhdGUgaW5cblx0ICAgICAgLy8gY2hpbGRyZW4gcG9zaXRpb24gY2FsY3VsYXRpb25zLCB3ZSBuZWVkIHRvIGtlZXBcblx0ICAgICAgLy8gdGhlIG9sZCBgZGVncmVlU2hpZnRgIHZhbHVlIGlmIG5ldyBub3Qgc2V0XG5cdCAgICAgIHZhciBpc0RlZ3JlZVNoaWZ0ID0gb3B0aW9uLmRlZ3JlZVNoaWZ0ICE9IG51bGw7XG5cdCAgICAgIGlmICghaXNEZWdyZWVTaGlmdCkge1xuXHQgICAgICAgIG9wdGlvbi5kZWdyZWVTaGlmdCA9IHRoaXMuX3N3aXJsc1swXVtpXS5fcHJvcHMuZGVncmVlU2hpZnQ7XG5cdCAgICAgIH1cblxuXHQgICAgICB0aGlzLl9hZGRCdXJzdFByb3BlcnRpZXMob3B0aW9uLCBpKTtcblxuXHQgICAgICAvLyBhZnRlciBidXJzdCBwb3NpdGlvbiBjYWxjdWxhdGlvbiAtIGRlbGV0ZSB0aGUgb2xkIGBkZWdyZWVTaGlmdGBcblx0ICAgICAgLy8gZnJvbSB0aGUgb3B0aW9ucywgc2luY2UgYW55d2F5cyB3ZSBoYXZlIGNvcGllZCBpdCBmcm9tIHRoZSBzd2lybFxuXHQgICAgICBpZiAoIWlzRGVncmVlU2hpZnQpIHtcblx0ICAgICAgICBkZWxldGUgb3B0aW9uLmRlZ3JlZVNoaWZ0O1xuXHQgICAgICB9XG5cblx0ICAgICAgc3dpcmwudHVuZShvcHRpb24pO1xuXHQgICAgICB0aGlzLl9yZWZyZXNoQnVyc3RPcHRpb25zKHN3aXJsLl9tb2R1bGVzLCBpKTtcblx0ICAgIH1cblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gcmVmcmVzaCBidXJzdCB4L3kvYW5nbGUgb3B0aW9ucyBvbiBmdXJ0aGVyIGNoYWluZWQgXG5cdCAgICBzd2lybHMsIGJlY2F1c2UgdGhleSB3aWxsIGJlIG92ZXJyaWRlbiBhZnRlciBgdHVuZWAgY2FsbCBvblxuXHQgICAgdmVyeSBmaXJzdCBzd2lybC5cblx0ICAgIEBwYXJhbSB7QXJyYXl9IENoYWluZWQgbW9kdWxlcyBhcnJheVxuXHQgICAgcGFyYW0ge051bWJlcn0gSW5kZXggb2YgdGhlIGZpcnN0IHN3aXJsIGluIHRoZSBjaGFpbi5cblx0ICAqL1xuXG5cblx0ICBCdXJzdC5wcm90b3R5cGUuX3JlZnJlc2hCdXJzdE9wdGlvbnMgPSBmdW5jdGlvbiBfcmVmcmVzaEJ1cnN0T3B0aW9ucyhtb2R1bGVzLCBpKSB7XG5cdCAgICBmb3IgKHZhciBqID0gMTsgaiA8IG1vZHVsZXMubGVuZ3RoOyBqKyspIHtcblx0ICAgICAgdmFyIG1vZHVsZSA9IG1vZHVsZXNbal0sXG5cdCAgICAgICAgICBvcHRpb25zID0ge307XG5cdCAgICAgIHRoaXMuX2FkZEJ1cnN0UHJvcGVydGllcyhvcHRpb25zLCBpLCBqKTtcblx0ICAgICAgbW9kdWxlLl90dW5lTmV3T3B0aW9ucyhvcHRpb25zKTtcblx0ICAgIH1cblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gY2FsbCB0aGVuIG9uIG1hc3RlclN3aXJsLlxuXHQgICAgQHBhcmFtIHtPYmplY3R9IFRoZW4gb3B0aW9ucy5cblx0ICAgIEByZXR1cm5zIHtPYmplY3R9IE5ldyBtYXN0ZXIgc3dpcmwuXG5cdCAgKi9cblxuXG5cdCAgQnVyc3QucHJvdG90eXBlLl9tYXN0ZXJUaGVuID0gZnVuY3Rpb24gX21hc3RlclRoZW4obykge1xuXHQgICAgdGhpcy5tYXN0ZXJTd2lybC50aGVuKG8pO1xuXHQgICAgLy8gZ2V0IHRoZSBsYXRlc3QgbWFzdGVyIHN3aXJsIGluIHRoZW4gY2hhaW5cblx0ICAgIHZhciBuZXdNYXN0ZXJTd2lybCA9IF9oMi5kZWZhdWx0LmdldExhc3RJdGVtKHRoaXMubWFzdGVyU3dpcmwuX21vZHVsZXMpO1xuXHQgICAgLy8gc2F2ZSB0byBtYXN0ZXJTd2lybHNcblx0ICAgIHRoaXMuX21hc3RlclN3aXJscy5wdXNoKG5ld01hc3RlclN3aXJsKTtcblx0ICAgIHJldHVybiBuZXdNYXN0ZXJTd2lybDtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gY2FsbCB0aGVuIG9uIGNoaWxkIHN3aWxycy5cblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBUaGVuIG9wdGlvbnMuXG5cdCAgICBAcmV0dXJuIHtBcnJheX0gQXJyYXkgb2YgbmV3IFN3aXJscy5cblx0ICAqL1xuXG5cblx0ICBCdXJzdC5wcm90b3R5cGUuX2NoaWxkVGhlbiA9IGZ1bmN0aW9uIF9jaGlsZFRoZW4obykge1xuXHQgICAgdmFyIHBhY2sgPSB0aGlzLl9zd2lybHNbMF0sXG5cdCAgICAgICAgbmV3UGFjayA9IFtdO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhY2subGVuZ3RoOyBpKyspIHtcblx0ICAgICAgLy8gZ2V0IG9wdGlvbiBieSBtb2R1bHVzXG5cdCAgICAgIHZhciBvcHRpb25zID0gdGhpcy5fZ2V0Q2hpbGRPcHRpb24obywgaSk7XG5cdCAgICAgIHZhciBzd2lybCA9IHBhY2tbaV07XG5cdCAgICAgIHZhciBsYXN0U3dpcmwgPSBfaDIuZGVmYXVsdC5nZXRMYXN0SXRlbShzd2lybC5fbW9kdWxlcyk7XG5cdCAgICAgIC8vIGFkZCBuZXcgTWFzdGVyIFN3aXJsIGFzIHBhcmVudCBvZiBuZXcgY2hpbGRzd2lybFxuXHQgICAgICBvcHRpb25zLnBhcmVudCA9IHRoaXMuZWw7XG5cblx0ICAgICAgdGhpcy5fYWRkQnVyc3RQcm9wZXJ0aWVzKG9wdGlvbnMsIGksIHRoaXMuX21hc3RlclN3aXJscy5sZW5ndGggLSAxKTtcblxuXHQgICAgICBzd2lybC50aGVuKG9wdGlvbnMpO1xuXG5cdCAgICAgIC8vIHNhdmUgdGhlIG5ldyBpdGVtIGluIGB0aGVuYCBjaGFpblxuXHQgICAgICBuZXdQYWNrLnB1c2goX2gyLmRlZmF1bHQuZ2V0TGFzdEl0ZW0oc3dpcmwuX21vZHVsZXMpKTtcblx0ICAgIH1cblx0ICAgIC8vIHNhdmUgdGhlIHBhY2sgdG8gX3N3aXJscyBvYmplY3Rcblx0ICAgIHRoaXMuX3N3aXJsc1t0aGlzLl9tYXN0ZXJTd2lybHMubGVuZ3RoIC0gMV0gPSBuZXdQYWNrO1xuXHQgICAgcmV0dXJuIG5ld1BhY2s7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGluaXRpYWxpemUgcHJvcGVydGllcy5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAb3ZlcnJpZGVzIEAgVGhlbmFibGVcblx0ICAqL1xuXG5cblx0ICBCdXJzdC5wcm90b3R5cGUuX3ZhcnMgPSBmdW5jdGlvbiBfdmFycygpIHtcblx0ICAgIF9UdW5hYmxlLnByb3RvdHlwZS5fdmFycy5jYWxsKHRoaXMpO1xuXHQgICAgLy8ganVzdCBidWZmZXIgdGltZWxpbmUgZm9yIGNhbGN1bGF0aW9uc1xuXHQgICAgdGhpcy5fYnVmZmVyVGltZWxpbmUgPSBuZXcgX3RpbWVsaW5lMi5kZWZhdWx0KCk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIGZvciBpbml0aWFsIHJlbmRlciBvZiB0aGUgbW9kdWxlLlxuXHQgICovXG5cblxuXHQgIEJ1cnN0LnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24gX3JlbmRlcigpIHtcblx0ICAgIHRoaXMuX28uaXNXaXRoU2hhcGUgPSBmYWxzZTtcblx0ICAgIHRoaXMuX28uaXNTd2lybCA9IHRoaXMuX3Byb3BzLmlzU3dpcmw7XG5cdCAgICB0aGlzLl9vLmNhbGxiYWNrc0NvbnRleHQgPSB0aGlzO1xuXHQgICAgLy8gc2F2ZSB0aW1lbGluZSBvcHRpb25zIGFuZCByZW1vdmUgZnJvbSBfb1xuXHQgICAgLy8gY3V6IHRoZSBtYXN0ZXIgc3dpcmwgc2hvdWxkIG5vdCBnZXQgdGhlbVxuXHQgICAgdGhpcy5fc2F2ZVRpbWVsaW5lT3B0aW9ucyh0aGlzLl9vKTtcblxuXHQgICAgdGhpcy5tYXN0ZXJTd2lybCA9IG5ldyBNYWluU3dpcmwodGhpcy5fbyk7XG5cdCAgICB0aGlzLl9tYXN0ZXJTd2lybHMgPSBbdGhpcy5tYXN0ZXJTd2lybF07XG5cdCAgICB0aGlzLmVsID0gdGhpcy5tYXN0ZXJTd2lybC5lbDtcblxuXHQgICAgdGhpcy5fcmVuZGVyU3dpcmxzKCk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIGZvciBpbml0aWFsIHJlbmRlciBvZiBzd2lybHMuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIEJ1cnN0LnByb3RvdHlwZS5fcmVuZGVyU3dpcmxzID0gZnVuY3Rpb24gX3JlbmRlclN3aXJscygpIHtcblx0ICAgIHZhciBwID0gdGhpcy5fcHJvcHMsXG5cdCAgICAgICAgcGFjayA9IFtdO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHAuY291bnQ7IGkrKykge1xuXHQgICAgICB2YXIgb3B0aW9uID0gdGhpcy5fZ2V0Q2hpbGRPcHRpb24odGhpcy5fbywgaSk7XG5cdCAgICAgIHBhY2sucHVzaChuZXcgQ2hpbGRTd2lybCh0aGlzLl9hZGRPcHRpb25hbFByb3BzKG9wdGlvbiwgaSkpKTtcblx0ICAgIH1cblx0ICAgIHRoaXMuX3N3aXJscyA9IHsgMDogcGFjayB9O1xuXHQgICAgdGhpcy5fc2V0U3dpcmxEdXJhdGlvbih0aGlzLm1hc3RlclN3aXJsLCB0aGlzLl9jYWxjUGFja1RpbWUocGFjaykpO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBzYXZlIHRpbWVsaW5lIG9wdGlvbnMgdG8gX3RpbWVsaW5lT3B0aW9uc1xuXHQgICAgYW5kIGRlbGV0ZSB0aGUgcHJvcGVydHkgb24gdGhlIG9iamVjdC5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge09iamVjdH0gVGhlIG9iamVjdCB0byBzYXZlIHRoZSB0aW1lbGluZSBvcHRpb25zIGZyb20uXG5cdCAgKi9cblxuXG5cdCAgQnVyc3QucHJvdG90eXBlLl9zYXZlVGltZWxpbmVPcHRpb25zID0gZnVuY3Rpb24gX3NhdmVUaW1lbGluZU9wdGlvbnMobykge1xuXHQgICAgdGhpcy5fdGltZWxpbmVPcHRpb25zID0gby50aW1lbGluZTtcblx0ICAgIGRlbGV0ZSBvLnRpbWVsaW5lO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBjYWxjdWxhdGUgdG90YWwgdGltZSBvZiBhcnJheSBvZlxuXHQgICAgY29uY3VycmVudCB0d2VlbnMuXG5cdCAgICBAcGFyYW0gICB7QXJyYXl9ICBQYWNrIHRvIGNhbGN1bGF0ZSB0aGUgdG90YWwgdGltZSBmb3IuXG5cdCAgICBAcmV0dXJucyB7TnVtYmVyfSBUb3RhbCBwYWNrIGR1cmF0aW9uLlxuXHQgICovXG5cblxuXHQgIEJ1cnN0LnByb3RvdHlwZS5fY2FsY1BhY2tUaW1lID0gZnVuY3Rpb24gX2NhbGNQYWNrVGltZShwYWNrKSB7XG5cdCAgICB2YXIgbWF4VGltZSA9IDA7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhY2subGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIHR3ZWVuID0gcGFja1tpXS50d2Vlbixcblx0ICAgICAgICAgIHAgPSB0d2Vlbi5fcHJvcHM7XG5cblx0ICAgICAgbWF4VGltZSA9IE1hdGgubWF4KHAucmVwZWF0VGltZSAvIHAuc3BlZWQsIG1heFRpbWUpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gbWF4VGltZTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gc2V0IGR1cmF0aW9uIGZvciBTd2lybC5cblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBTd2lybCBpbnN0YW5jZSB0byBzZXQgdGhlIGR1cmF0aW9uIHRvLlxuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IER1cmF0aW9uIHRvIHNldC5cblx0ICAqL1xuXG5cblx0ICBCdXJzdC5wcm90b3R5cGUuX3NldFN3aXJsRHVyYXRpb24gPSBmdW5jdGlvbiBfc2V0U3dpcmxEdXJhdGlvbihzd2lybCwgZHVyYXRpb24pIHtcblx0ICAgIHN3aXJsLnR3ZWVuLl9zZXRQcm9wKCdkdXJhdGlvbicsIGR1cmF0aW9uKTtcblx0ICAgIHZhciBpc1JlY2FsYyA9IHN3aXJsLnRpbWVsaW5lICYmIHN3aXJsLnRpbWVsaW5lLl9yZWNhbGNUb3RhbER1cmF0aW9uO1xuXHQgICAgaXNSZWNhbGMgJiYgc3dpcmwudGltZWxpbmUuX3JlY2FsY1RvdGFsRHVyYXRpb24oKTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gZ2V0IGNoaWxkT3B0aW9uIGZvcm0gb2JqZWN0IGNhbGwgYnkgbW9kdWx1cy5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0gICB7T2JqZWN0fSBPYmplY3QgdG8gbG9vayBpbi5cblx0ICAgIEBwYXJhbSAgIHtOdW1iZXJ9IEluZGV4IG9mIHRoZSBjdXJyZW50IFN3aXJsLlxuXHQgICAgQHJldHVybnMge09iamVjdH0gT3B0aW9ucyBmb3IgdGhlIGN1cnJlbnQgc3dpcmwuXG5cdCAgKi9cblxuXG5cdCAgQnVyc3QucHJvdG90eXBlLl9nZXRDaGlsZE9wdGlvbiA9IGZ1bmN0aW9uIF9nZXRDaGlsZE9wdGlvbihvYmosIGkpIHtcblx0ICAgIHZhciBvcHRpb25zID0ge307XG5cdCAgICBmb3IgKHZhciBrZXkgaW4gb2JqLmNoaWxkcmVuKSB7XG5cdCAgICAgIG9wdGlvbnNba2V5XSA9IHRoaXMuX2dldFByb3BCeU1vZChrZXksIGksIG9iai5jaGlsZHJlbik7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gb3B0aW9ucztcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gZ2V0IHByb3BlcnR5IGJ5IG1vZHVsdXMuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtTdHJpbmd9IE5hbWUgb2YgdGhlIHByb3BlcnR5LlxuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IEluZGV4IGZvciB0aGUgbW9kdWx1cy5cblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBTb3VyY2Ugb2JqZWN0IHRvIGNoZWNrIGluLlxuXHQgICAgQHJldHVybnMge0FueX0gUHJvcGVydHkuXG5cdCAgKi9cblxuXG5cdCAgQnVyc3QucHJvdG90eXBlLl9nZXRQcm9wQnlNb2QgPSBmdW5jdGlvbiBfZ2V0UHJvcEJ5TW9kKG5hbWUsIGluZGV4KSB7XG5cdCAgICB2YXIgc291cmNlT2JqID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuXHQgICAgdmFyIHByb3AgPSBzb3VyY2VPYmpbbmFtZV07XG5cdCAgICByZXR1cm4gX2gyLmRlZmF1bHQuaXNBcnJheShwcm9wKSA/IHByb3BbaW5kZXggJSBwcm9wLmxlbmd0aF0gOiBwcm9wO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBhZGQgb3B0aW9uYWwgU3dpcmxzJyBwcm9wZXJ0aWVzIHRvIHBhc3NlZCBvYmplY3QuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtPYmplY3R9IE9iamVjdCB0byBhZGQgdGhlIHByb3BlcnRpZXMgdG8uXG5cdCAgICBAcGFyYW0ge051bWJlcn0gSW5kZXggb2YgdGhlIHByb3BlcnR5LlxuXHQgICovXG5cblxuXHQgIEJ1cnN0LnByb3RvdHlwZS5fYWRkT3B0aW9uYWxQcm9wcyA9IGZ1bmN0aW9uIF9hZGRPcHRpb25hbFByb3BzKG9wdGlvbnMsIGluZGV4KSB7XG5cdCAgICBvcHRpb25zLmluZGV4ID0gaW5kZXg7XG5cdCAgICBvcHRpb25zLnBhcmVudCA9IHRoaXMubWFzdGVyU3dpcmwuZWw7XG5cblx0ICAgIHRoaXMuX2FkZEJ1cnN0UHJvcGVydGllcyhvcHRpb25zLCBpbmRleCk7XG5cblx0ICAgIHJldHVybiBvcHRpb25zO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBhZGQgQnVyc3Qgb3B0aW9ucyB0byBvYmplY3QuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtPYmplY3R9IE9wdGlvbnMgdG8gYWRkIHRoZSBwcm9wZXJ0aWVzIHRvLlxuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IEluZGV4IG9mIHRoZSBTd2lybC5cblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBJbmRleCBvZiB0aGUgbWFpbiBzd2lybC5cblx0ICAqL1xuXG5cblx0ICBCdXJzdC5wcm90b3R5cGUuX2FkZEJ1cnN0UHJvcGVydGllcyA9IGZ1bmN0aW9uIF9hZGRCdXJzdFByb3BlcnRpZXMob3B0aW9ucywgaW5kZXgsIGkpIHtcblx0ICAgIC8vIHNhdmUgaW5kZXggb2YgdGhlIG1vZHVsZVxuXHQgICAgdmFyIG1haW5JbmRleCA9IHRoaXMuX2luZGV4O1xuXHQgICAgLy8gdGVtcG9yYXJ5IGNoYW5nZSB0aGUgaW5kZXggdG8gcGFyc2UgaW5kZXggYmFzZWQgcHJvcGVydGllcyBsaWtlIHN0YWdnZXJcblx0ICAgIHRoaXMuX2luZGV4ID0gaW5kZXg7XG5cdCAgICAvLyBwYXJzZSBkZWdyZWUgc2hpZnQgZm9yIHRoZSBiaXRcblx0ICAgIHZhciBkZWdyZWVTaGlmdCA9IHRoaXMuX3BhcnNlUHJvcGVydHkoJ2RlZ3JlZVNoaWZ0Jywgb3B0aW9ucy5kZWdyZWVTaGlmdCB8fCAwKTtcblx0ICAgIC8vIHB1dCB0aGUgaW5kZXggb2YgdGhlIG1vZHVsZSBiYWNrXG5cdCAgICB0aGlzLl9pbmRleCA9IG1haW5JbmRleDtcblxuXHQgICAgdmFyIHAgPSB0aGlzLl9wcm9wcyxcblx0ICAgICAgICBkZWdyZWVDbnQgPSBwLmRlZ3JlZSAlIDM2MCA9PT0gMCA/IHAuY291bnQgOiBwLmNvdW50IC0gMSB8fCAxLFxuXHQgICAgICAgIHN0ZXAgPSBwLmRlZ3JlZSAvIGRlZ3JlZUNudCxcblx0ICAgICAgICBwb2ludFN0YXJ0ID0gdGhpcy5fZ2V0U2lkZVBvaW50KCdzdGFydCcsIGluZGV4ICogc3RlcCArIGRlZ3JlZVNoaWZ0LCBpKSxcblx0ICAgICAgICBwb2ludEVuZCA9IHRoaXMuX2dldFNpZGVQb2ludCgnZW5kJywgaW5kZXggKiBzdGVwICsgZGVncmVlU2hpZnQsIGkpO1xuXG5cdCAgICBvcHRpb25zLnggPSB0aGlzLl9nZXREZWx0YUZyb21Qb2ludHMoJ3gnLCBwb2ludFN0YXJ0LCBwb2ludEVuZCk7XG5cdCAgICBvcHRpb25zLnkgPSB0aGlzLl9nZXREZWx0YUZyb21Qb2ludHMoJ3knLCBwb2ludFN0YXJ0LCBwb2ludEVuZCk7XG5cblx0ICAgIG9wdGlvbnMuYW5nbGUgPSB0aGlzLl9nZXRCaXRBbmdsZShvcHRpb25zLmFuZ2xlIHx8IDAsIGRlZ3JlZVNoaWZ0LCBpbmRleCk7XG5cdCAgfTtcblx0ICAvKiBcblx0ICAgIE1ldGhvZCB0byBnZXQgc2hhcGVzIGFuZ2xlIGluIGJ1cnN0IHNvXG5cdCAgICBpdCB3aWxsIGZvbGxvdyBjaXJjdWxhciBzaGFwZS5cblx0ICAgICBcblx0ICAgICBAcGFyYW0gICAge051bWJlciwgT2JqZWN0fSBCYXNlIGFuZ2xlLlxuXHQgICAgIEBwYXJhbSAgICB7TnVtYmVyfSAgICAgICAgIEFuZ2xlIHNoaWZ0IGZvciB0aGUgYml0XG5cdCAgICAgQHBhcmFtICAgIHtOdW1iZXJ9ICAgICAgICAgU2hhcGUncyBpbmRleCBpbiBidXJzdC5cblx0ICAgICBAcmV0dXJucyAge051bWJlcn0gICAgICAgICBBbmdsZSBpbiBidXJzdC5cblx0ICAqL1xuXG5cblx0ICBCdXJzdC5wcm90b3R5cGUuX2dldEJpdEFuZ2xlID0gZnVuY3Rpb24gX2dldEJpdEFuZ2xlKCkge1xuXHQgICAgdmFyIGFuZ2xlUHJvcGVydHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG5cdCAgICB2YXIgYW5nbGVTaGlmdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcblx0ICAgIHZhciBpID0gYXJndW1lbnRzWzJdO1xuXG5cdCAgICB2YXIgcCA9IHRoaXMuX3Byb3BzLFxuXHQgICAgICAgIGRlZ0NudCA9IHAuZGVncmVlICUgMzYwID09PSAwID8gcC5jb3VudCA6IHAuY291bnQgLSAxIHx8IDEsXG5cdCAgICAgICAgc3RlcCA9IHAuZGVncmVlIC8gZGVnQ250LFxuXHQgICAgICAgIGFuZ2xlID0gaSAqIHN0ZXAgKyA5MDtcblxuXHQgICAgYW5nbGUgKz0gYW5nbGVTaGlmdDtcblx0ICAgIC8vIGlmIG5vdCBkZWx0YSBvcHRpb25cblx0ICAgIGlmICghdGhpcy5faXNEZWx0YShhbmdsZVByb3BlcnR5KSkge1xuXHQgICAgICBhbmdsZVByb3BlcnR5ICs9IGFuZ2xlO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdmFyIGRlbHRhID0ge30sXG5cdCAgICAgICAgICBrZXlzID0gKDAsIF9rZXlzMi5kZWZhdWx0KShhbmdsZVByb3BlcnR5KSxcblx0ICAgICAgICAgIHN0YXJ0ID0ga2V5c1swXSxcblx0ICAgICAgICAgIGVuZCA9IGFuZ2xlUHJvcGVydHlbc3RhcnRdO1xuXG5cdCAgICAgIHN0YXJ0ID0gX2gyLmRlZmF1bHQucGFyc2VTdHJpbmdPcHRpb24oc3RhcnQsIGkpO1xuXHQgICAgICBlbmQgPSBfaDIuZGVmYXVsdC5wYXJzZVN0cmluZ09wdGlvbihlbmQsIGkpO1xuXHQgICAgICAvLyBuZXcgc3RhcnQgPSBuZXdFbmRcblx0ICAgICAgZGVsdGFbcGFyc2VGbG9hdChzdGFydCkgKyBhbmdsZV0gPSBwYXJzZUZsb2F0KGVuZCkgKyBhbmdsZTtcblxuXHQgICAgICBhbmdsZVByb3BlcnR5ID0gZGVsdGE7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gYW5nbGVQcm9wZXJ0eTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gZ2V0IHJhZGlhbCBwb2ludCBvbiBgc3RhcnRgIG9yIGBlbmRgLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7U3RyaW5nfSBOYW1lIG9mIHRoZSBzaWRlIC0gW3N0YXJ0LCBlbmRdLlxuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IEFuZ2xlIG9mIHRoZSByYWRpYWwgcG9pbnQuXG5cdCAgICBAcGFyYW0ge051bWJlcn0gSW5kZXggb2YgdGhlIG1haW4gc3dpcmwuXG5cdCAgICBAcmV0dXJucyByYWRpYWwgcG9pbnQuXG5cdCAgKi9cblxuXG5cdCAgQnVyc3QucHJvdG90eXBlLl9nZXRTaWRlUG9pbnQgPSBmdW5jdGlvbiBfZ2V0U2lkZVBvaW50KHNpZGUsIGFuZ2xlLCBpKSB7XG5cdCAgICB2YXIgcCA9IHRoaXMuX3Byb3BzLFxuXHQgICAgICAgIHNpZGVSYWRpdXMgPSB0aGlzLl9nZXRTaWRlUmFkaXVzKHNpZGUsIGkpO1xuXG5cdCAgICByZXR1cm4gX2gyLmRlZmF1bHQuZ2V0UmFkaWFsUG9pbnQoe1xuXHQgICAgICByYWRpdXM6IHNpZGVSYWRpdXMucmFkaXVzLFxuXHQgICAgICByYWRpdXNYOiBzaWRlUmFkaXVzLnJhZGl1c1gsXG5cdCAgICAgIHJhZGl1c1k6IHNpZGVSYWRpdXMucmFkaXVzWSxcblx0ICAgICAgYW5nbGU6IGFuZ2xlLFxuXHQgICAgICAvLyBjZW50ZXI6ICB7IHg6IHAuY2VudGVyLCB5OiBwLmNlbnRlciB9XG5cdCAgICAgIGNlbnRlcjogeyB4OiAwLCB5OiAwIH1cblx0ICAgIH0pO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBnZXQgcmFkaXVzIG9mIHRoZSBzaWRlLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7U3RyaW5nfSBOYW1lIG9mIHRoZSBzaWRlIC0gW3N0YXJ0LCBlbmRdLlxuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IEluZGV4IG9mIHRoZSBtYWluIHN3aXJsLlxuXHQgICAgQHJldHVybnMge09iamVjdH0gUmFkaXVzLlxuXHQgICovXG5cblxuXHQgIEJ1cnN0LnByb3RvdHlwZS5fZ2V0U2lkZVJhZGl1cyA9IGZ1bmN0aW9uIF9nZXRTaWRlUmFkaXVzKHNpZGUsIGkpIHtcblx0ICAgIHJldHVybiB7XG5cdCAgICAgIHJhZGl1czogdGhpcy5fZ2V0UmFkaXVzQnlLZXkoJ3JhZGl1cycsIHNpZGUsIGkpLFxuXHQgICAgICByYWRpdXNYOiB0aGlzLl9nZXRSYWRpdXNCeUtleSgncmFkaXVzWCcsIHNpZGUsIGkpLFxuXHQgICAgICByYWRpdXNZOiB0aGlzLl9nZXRSYWRpdXNCeUtleSgncmFkaXVzWScsIHNpZGUsIGkpXG5cdCAgICB9O1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBnZXQgcmFkaXVzIGZyb20g4oiGIG9yIHBsYWluIHByb3BlcnR5LlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7U3RyaW5nfSBLZXkgbmFtZS5cblx0ICAgIEBwYXJhbSB7U3RyaW5nfSBTaWRlIG5hbWUgLSBbc3RhcnQsIGVuZF0uXG5cdCAgICBAcGFyYW0ge051bWJlcn0gSW5kZXggb2YgdGhlIG1haW4gc3dpcmwuXG5cdCAgICBAcmV0dXJucyB7TnVtYmVyfSBSYWRpdXMgdmFsdWUuXG5cdCAgKi9cblxuXG5cdCAgQnVyc3QucHJvdG90eXBlLl9nZXRSYWRpdXNCeUtleSA9IGZ1bmN0aW9uIF9nZXRSYWRpdXNCeUtleShrZXksIHNpZGUpIHtcblx0ICAgIHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwO1xuXG5cdCAgICB2YXIgc3dpcmwgPSB0aGlzLl9tYXN0ZXJTd2lybHNbaV0sXG5cdCAgICAgICAgZGVsdGFzID0gc3dpcmwuX2RlbHRhcyxcblx0ICAgICAgICBwcm9wcyA9IHN3aXJsLl9wcm9wcztcblxuXHQgICAgaWYgKGRlbHRhc1trZXldICE9IG51bGwpIHtcblx0ICAgICAgcmV0dXJuIGRlbHRhc1trZXldW3NpZGVdO1xuXHQgICAgfSBlbHNlIGlmIChwcm9wc1trZXldICE9IG51bGwpIHtcblx0ICAgICAgcmV0dXJuIHByb3BzW2tleV07XG5cdCAgICB9XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGdldCBkZWx0YSBmcm9tIHN0YXJ0IGFuZCBlbmQgcG9zaXRpb24gcG9pbnRzLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7U3RyaW5nfSBLZXkgbmFtZS5cblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBTdGFydCBwb3NpdGlvbiBwb2ludC5cblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBFbmQgcG9zaXRpb24gcG9pbnQuXG5cdCAgICBAcmV0dXJucyB7T2JqZWN0fSBEZWx0YSBvZiB0aGUgZW5kL3N0YXJ0LlxuXHQgICovXG5cblxuXHQgIEJ1cnN0LnByb3RvdHlwZS5fZ2V0RGVsdGFGcm9tUG9pbnRzID0gZnVuY3Rpb24gX2dldERlbHRhRnJvbVBvaW50cyhrZXksIHBvaW50U3RhcnQsIHBvaW50RW5kKSB7XG5cdCAgICB2YXIgZGVsdGEgPSB7fTtcblx0ICAgIGlmIChwb2ludFN0YXJ0W2tleV0gPT09IHBvaW50RW5kW2tleV0pIHtcblx0ICAgICAgZGVsdGEgPSBwb2ludFN0YXJ0W2tleV07XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBkZWx0YVtwb2ludFN0YXJ0W2tleV1dID0gcG9pbnRFbmRba2V5XTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBkZWx0YTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gY3JlYXRlIHRpbWVsaW5lLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBvdmVycmlkZSBAIFR3ZWVuYWJsZVxuXHQgICovXG5cblxuXHQgIEJ1cnN0LnByb3RvdHlwZS5fbWFrZVRpbWVsaW5lID0gZnVuY3Rpb24gX21ha2VUaW1lbGluZSgpIHtcblx0ICAgIC8vIHJlc3RvcmUgdGltZWxpbmUgb3B0aW9ucyB0aGF0IHdlcmUgZGVsZXRlZCBpbiBfcmVuZGVyIG1ldGhvZFxuXHQgICAgdGhpcy5fby50aW1lbGluZSA9IHRoaXMuX3RpbWVsaW5lT3B0aW9ucztcblx0ICAgIF9UdW5hYmxlLnByb3RvdHlwZS5fbWFrZVRpbWVsaW5lLmNhbGwodGhpcyk7XG5cdCAgICB0aGlzLnRpbWVsaW5lLmFkZCh0aGlzLm1hc3RlclN3aXJsLCB0aGlzLl9zd2lybHNbMF0pO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBtYWtlIFR3ZWVuIGZvciB0aGUgbW9kdWxlLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBvdmVycmlkZSBAIFR3ZWVuYWJsZVxuXHQgICovXG5cblxuXHQgIEJ1cnN0LnByb3RvdHlwZS5fbWFrZVR3ZWVuID0gZnVuY3Rpb24gX21ha2VUd2VlbigpIHt9IC8qIGRvbid0IGNyZWF0ZSBhbnkgdHdlZW4gKi9cblx0ICAvKlxuXHQgICAgT3ZlcnJpZGUgYF9oaWRlYCBhbmQgYF9zaG93YCBtZXRob2RzIG9uIG1vZHVsZVxuXHQgICAgc2luY2Ugd2UgZG9uJ3QgaGF2ZSB0byBoaWRlIG5vciBzaG93IG9uIHRoZSBtb2R1bGUuXG5cdCAgKi9cblx0ICA7XG5cblx0ICBCdXJzdC5wcm90b3R5cGUuX2hpZGUgPSBmdW5jdGlvbiBfaGlkZSgpIHsvKiBkbyBub3RoaW5nICovfTtcblxuXHQgIEJ1cnN0LnByb3RvdHlwZS5fc2hvdyA9IGZ1bmN0aW9uIF9zaG93KCkgey8qIGRvIG5vdGhpbmcgKi99O1xuXG5cdCAgcmV0dXJuIEJ1cnN0O1xuXHR9KF90dW5hYmxlMi5kZWZhdWx0KTtcblxuXHR2YXIgQ2hpbGRTd2lybCA9IGZ1bmN0aW9uIChfU2hhcGVTd2lybCkge1xuXHQgICgwLCBfaW5oZXJpdHMzLmRlZmF1bHQpKENoaWxkU3dpcmwsIF9TaGFwZVN3aXJsKTtcblxuXHQgIGZ1bmN0aW9uIENoaWxkU3dpcmwoKSB7XG5cdCAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBDaGlsZFN3aXJsKTtcblx0ICAgIHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zLmRlZmF1bHQpKHRoaXMsIF9TaGFwZVN3aXJsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuXHQgIH1cblxuXHQgIENoaWxkU3dpcmwucHJvdG90eXBlLl9kZWNsYXJlRGVmYXVsdHMgPSBmdW5jdGlvbiBfZGVjbGFyZURlZmF1bHRzKCkge1xuXHQgICAgX1NoYXBlU3dpcmwucHJvdG90eXBlLl9kZWNsYXJlRGVmYXVsdHMuY2FsbCh0aGlzKTtcblx0ICAgIHRoaXMuX2RlZmF1bHRzLmlzU3dpcmwgPSBmYWxzZTtcblx0ICAgIHRoaXMuX28uZHVyYXRpb24gPSB0aGlzLl9vLmR1cmF0aW9uICE9IG51bGwgPyB0aGlzLl9vLmR1cmF0aW9uIDogNzAwO1xuXHQgIH07XG5cdCAgLy8gZGlzYWJsZSBkZWdyZWVzaGlmdCBjYWxjdWxhdGlvbnNcblxuXG5cdCAgQ2hpbGRTd2lybC5wcm90b3R5cGUuX2NhbGNTd2lybFhZID0gZnVuY3Rpb24gX2NhbGNTd2lybFhZKHByb2MpIHtcblx0ICAgIHZhciBkZWdyZWVTaGlmdCA9IHRoaXMuX3Byb3BzLmRlZ3JlZVNoaWZ0O1xuXG5cdCAgICB0aGlzLl9wcm9wcy5kZWdyZWVTaGlmdCA9IDA7XG5cdCAgICBfU2hhcGVTd2lybC5wcm90b3R5cGUuX2NhbGNTd2lybFhZLmNhbGwodGhpcywgcHJvYyk7XG5cdCAgICB0aGlzLl9wcm9wcy5kZWdyZWVTaGlmdCA9IGRlZ3JlZVNoaWZ0O1xuXHQgIH07XG5cblx0ICByZXR1cm4gQ2hpbGRTd2lybDtcblx0fShfc2hhcGVTd2lybDIuZGVmYXVsdCk7XG5cblx0dmFyIE1haW5Td2lybCA9IGZ1bmN0aW9uIChfQ2hpbGRTd2lybCkge1xuXHQgICgwLCBfaW5oZXJpdHMzLmRlZmF1bHQpKE1haW5Td2lybCwgX0NoaWxkU3dpcmwpO1xuXG5cdCAgZnVuY3Rpb24gTWFpblN3aXJsKCkge1xuXHQgICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgTWFpblN3aXJsKTtcblx0ICAgIHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zLmRlZmF1bHQpKHRoaXMsIF9DaGlsZFN3aXJsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuXHQgIH1cblxuXHQgIE1haW5Td2lybC5wcm90b3R5cGUuX2RlY2xhcmVEZWZhdWx0cyA9IGZ1bmN0aW9uIF9kZWNsYXJlRGVmYXVsdHMoKSB7XG5cdCAgICBfQ2hpbGRTd2lybC5wcm90b3R5cGUuX2RlY2xhcmVEZWZhdWx0cy5jYWxsKHRoaXMpO1xuXHQgICAgdGhpcy5fZGVmYXVsdHMuc2NhbGUgPSAxO1xuXHQgICAgdGhpcy5fZGVmYXVsdHMud2lkdGggPSAwO1xuXHQgICAgdGhpcy5fZGVmYXVsdHMuaGVpZ2h0ID0gMDtcblx0ICAgIHRoaXMuX2RlZmF1bHRzLnJhZGl1cyA9IHsgMjU6IDc1IH07XG5cdCAgICAvLyB0aGlzLl9kZWZhdWx0cy5kdXJhdGlvbiA9IDIwMDA7XG5cdCAgfTtcblxuXHQgIHJldHVybiBNYWluU3dpcmw7XG5cdH0oQ2hpbGRTd2lybCk7XG5cblx0QnVyc3QuQ2hpbGRTd2lybCA9IENoaWxkU3dpcmw7XG5cdEJ1cnN0Lk1haW5Td2lybCA9IE1haW5Td2lybDtcblxuXHRleHBvcnRzLmRlZmF1bHQgPSBCdXJzdDtcblxuLyoqKi8gfSksXG4vKiAxMTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuXHR2YXIgX2V4dGVuZHM0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMjApO1xuXG5cdHZhciBfZXh0ZW5kczUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9leHRlbmRzNCk7XG5cblx0dmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0KTtcblxuXHR2YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cblx0dmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9fd2VicGFja19yZXF1aXJlX18oNzUpO1xuXG5cdHZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMik7XG5cblx0dmFyIF9pbmhlcml0czIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc2KTtcblxuXHR2YXIgX2luaGVyaXRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luaGVyaXRzMik7XG5cblx0dmFyIF9rZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NSk7XG5cblx0dmFyIF9rZXlzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2tleXMpO1xuXG5cdHZhciBfdGhlbmFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk5KTtcblxuXHR2YXIgX3RoZW5hYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RoZW5hYmxlKTtcblxuXHR2YXIgX3R3ZWVuID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDEpO1xuXG5cdHZhciBfdHdlZW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHdlZW4pO1xuXG5cdHZhciBfZGVsdGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMjUpO1xuXG5cdHZhciBfZGVsdGFzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlbHRhcyk7XG5cblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuXHR2YXIgaCA9IF9fd2VicGFja19yZXF1aXJlX18oNzEpO1xuXG5cblx0Ly8gZ2V0IHR3ZWVuIHByb3BlcnRpZXNcblx0dmFyIG9iaiA9IHt9O1xuXHRfdHdlZW4yLmRlZmF1bHQucHJvdG90eXBlLl9kZWNsYXJlRGVmYXVsdHMuY2FsbChvYmopO1xuXHR2YXIga2V5cyA9ICgwLCBfa2V5czIuZGVmYXVsdCkob2JqLl9kZWZhdWx0cyk7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHQgIG9iai5fZGVmYXVsdHNba2V5c1tpXV0gPSAxO1xuXHR9XG5cdG9iai5fZGVmYXVsdHNbJ3RpbWVsaW5lJ10gPSAxO1xuXHR2YXIgVFdFRU5fUFJPUEVSVElFUyA9IG9iai5fZGVmYXVsdHM7XG5cblx0Lypcblx0ICBUT0RPOlxuXG5cdCAgICAtIGNoYW5nZSBfcHJvcHMgdG8gX3Byb3BzT2JqIGZvciBhbmltYXRpb25zXG5cdCAgICAtIGN1cnJlbnQgdmFsdWVzIGluIGRlbHRhc1xuXHQqL1xuXG5cdHZhciBIdG1sID0gZnVuY3Rpb24gKF9UaGVuYWJsZSkge1xuXHQgICgwLCBfaW5oZXJpdHMzLmRlZmF1bHQpKEh0bWwsIF9UaGVuYWJsZSk7XG5cblx0ICBmdW5jdGlvbiBIdG1sKCkge1xuXHQgICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgSHRtbCk7XG5cdCAgICByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMy5kZWZhdWx0KSh0aGlzLCBfVGhlbmFibGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG5cdCAgfVxuXG5cdCAgSHRtbC5wcm90b3R5cGUuX2RlY2xhcmVEZWZhdWx0cyA9IGZ1bmN0aW9uIF9kZWNsYXJlRGVmYXVsdHMoKSB7XG5cdCAgICB0aGlzLl9kZWZhdWx0cyA9IHtcblx0ICAgICAgeDogMCxcblx0ICAgICAgeTogMCxcblx0ICAgICAgejogMCxcblxuXHQgICAgICBza2V3WDogMCxcblx0ICAgICAgc2tld1k6IDAsXG5cblx0ICAgICAgLy8gYW5nbGU6ICAgICAgMCxcblx0ICAgICAgYW5nbGVYOiAwLFxuXHQgICAgICBhbmdsZVk6IDAsXG5cdCAgICAgIGFuZ2xlWjogMCxcblxuXHQgICAgICBzY2FsZTogMSxcblx0ICAgICAgc2NhbGVYOiAxLFxuXHQgICAgICBzY2FsZVk6IDEsXG5cblx0ICAgICAgaXNTb2Z0SGlkZTogdHJ1ZSxcblx0ICAgICAgaXNTaG93U3RhcnQ6IHRydWUsXG5cdCAgICAgIGlzU2hvd0VuZDogdHJ1ZSxcblx0ICAgICAgaXNGb3JjZTNkOiBmYWxzZSxcblx0ICAgICAgaXNSZWZyZXNoU3RhdGU6IHRydWVcblxuXHQgICAgfTtcblx0ICAgIC8vIGV4Y2x1ZGUgZnJvbSBhdXRvbWF0aWMgZHJhd2luZ1xuXHQgICAgdGhpcy5fZHJhd0V4Y2x1ZGUgPSB7IGVsOiAxIH07XG5cdCAgICAvLyBwcm9wZXJ0aWVzIHRoYXQgY2F1c2UgM2QgbGF5ZXJcblx0ICAgIHRoaXMuXzNkUHJvcGVydGllcyA9IFsnYW5nbGVYJywgJ2FuZ2xlWScsICd6J107XG5cdCAgICAvLyBwcm9wZXJ0aWVzIHRoYXQgaGF2ZSBhcnJheSB2YWx1ZXNcblx0ICAgIHRoaXMuX2FycmF5UHJvcGVydHlNYXAgPSB7IHRyYW5zZm9ybU9yaWdpbjogMSwgYmFja2dyb3VuZFBvc2l0aW9uOiAxIH07XG5cdCAgICAvLyBwcm9wZXJ0aWVzIHRoYXQgaGF2ZSBubyB1bml0c1xuXHQgICAgdGhpcy5fbnVtYmVyUHJvcGVydHlNYXAgPSB7XG5cdCAgICAgIG9wYWNpdHk6IDEsIHNjYWxlOiAxLCBzY2FsZVg6IDEsIHNjYWxlWTogMSxcblx0ICAgICAgLy8gYW5nbGU6IDEsXG5cdCAgICAgIGFuZ2xlWDogMSwgYW5nbGVZOiAxLCBhbmdsZVo6IDEsXG5cdCAgICAgIHNrZXdYOiAxLCBza2V3WTogMVxuXHQgICAgfTtcblx0ICAgIC8vIHByb3BlcnRpZXMgdGhhdCBzaG91bGQgYmUgcHJlZml4ZWQgXG5cdCAgICB0aGlzLl9wcmVmaXhQcm9wZXJ0eU1hcCA9IHsgdHJhbnNmb3JtOiAxLCB0cmFuc2Zvcm1PcmlnaW46IDEgfTtcblx0ICAgIC8vIHNhdmUgcHJlZml4XG5cdCAgICB0aGlzLl9wcmVmaXggPSBoLnByZWZpeC5jc3M7XG5cdCAgfTtcblxuXHQgIEh0bWwucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiB0aGVuKG8pIHtcblx0ICAgIC8vIHJldHVybiBpZiBub3RoaW5nIHdhcyBwYXNzZWRcblx0ICAgIGlmIChvID09IG51bGwgfHwgISgwLCBfa2V5czIuZGVmYXVsdCkobykubGVuZ3RoKSB7XG5cdCAgICAgIHJldHVybiAxO1xuXHQgICAgfVxuXG5cdCAgICAvLyBnZXQgdGhlIGxhc3QgaXRlbSBpbiBgdGhlbmAgY2hhaW5cblx0ICAgIHZhciBwcmV2TW9kdWxlID0gaC5nZXRMYXN0SXRlbSh0aGlzLl9tb2R1bGVzKTtcblx0ICAgIC8vIHNldCBkZWx0YXMgdG8gdGhlIGZpbmlzaCBzdGF0ZVxuXHQgICAgcHJldk1vZHVsZS5kZWx0YXMucmVmcmVzaChmYWxzZSk7XG5cdCAgICAvLyBjb3B5IGZpbmlzaCBzdGF0ZSB0byB0aGUgbGFzdCBoaXN0b3J5IHJlY29yZFxuXHQgICAgdGhpcy5faGlzdG9yeVt0aGlzLl9oaXN0b3J5Lmxlbmd0aCAtIDFdID0gcHJldk1vZHVsZS5fbztcblx0ICAgIC8vIGNhbGwgc3VwZXJcblx0ICAgIF9UaGVuYWJsZS5wcm90b3R5cGUudGhlbi5jYWxsKHRoaXMsIG8pO1xuXHQgICAgLy8gcmVzdG9yZSB0aGUgX3Byb3BzXG5cdCAgICBwcmV2TW9kdWxlLmRlbHRhcy5yZXN0b3JlKCk7XG5cblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBwaXBlIHN0YXJ0VmFsdWUgb2YgdGhlIGRlbHRhLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBvdmFycmlkZXMgQCBUaGVuYWJsZVxuXHQgICAgQHBhcmFtIHtTdHJpbmd9IFN0YXJ0IHByb3BlcnR5IG5hbWUuXG5cdCAgICBAcGFyYW0ge0FueX0gU3RhcnQgcHJvcGVydHkgdmFsdWUuXG5cdCAgICBAcmV0dXJucyB7QW55fSBTdGFydCBwcm9wZXJ0eSB2YWx1ZS5cblx0ICAqL1xuXG5cblx0ICBIdG1sLnByb3RvdHlwZS5fY2hlY2tTdGFydFZhbHVlID0gZnVuY3Rpb24gX2NoZWNrU3RhcnRWYWx1ZShrZXksIHZhbHVlKSB7XG5cdCAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuXHQgICAgICAvLyByZXR1cm4gZGVmYXVsdCB2YWx1ZSBmb3IgdHJhbnNmb3Jtc1xuXHQgICAgICBpZiAodGhpcy5fZGVmYXVsdHNba2V5XSAhPSBudWxsKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRzW2tleV07XG5cdCAgICAgIH1cblx0ICAgICAgLy8gcmV0dXJuIGRlZmF1bHQgdmFsdWUgZnJvbSBfY3VzdG9tUHJvcHNcblx0ICAgICAgaWYgKHRoaXMuX2N1c3RvbVByb3BzW2tleV0gIT0gbnVsbCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9jdXN0b21Qcm9wc1trZXldO1xuXHQgICAgICB9XG5cdCAgICAgIC8vIHRyeSB0byBnZXQgdGhlIGRlZmF1bHQgdmFsdWVcblx0ICAgICAgaWYgKGguZGVmYXVsdFN0eWxlc1trZXldICE9IG51bGwpIHtcblx0ICAgICAgICByZXR1cm4gaC5kZWZhdWx0U3R5bGVzW2tleV07XG5cdCAgICAgIH1cblx0ICAgICAgLy8gYXQgdGhlIGVuZCByZXR1cm4gMFxuXHQgICAgICByZXR1cm4gMDtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBkcmF3IF9wcm9wcyB0byBlbC5cblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblxuXG5cdCAgSHRtbC5wcm90b3R5cGUuX2RyYXcgPSBmdW5jdGlvbiBfZHJhdygpIHtcblx0ICAgIHZhciBwID0gdGhpcy5fcHJvcHM7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2RyYXdQcm9wcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIgbmFtZSA9IHRoaXMuX2RyYXdQcm9wc1tpXTtcblx0ICAgICAgdGhpcy5fc2V0U3R5bGUobmFtZSwgcFtuYW1lXSk7XG5cdCAgICB9XG5cdCAgICAvLyBkcmF3IHRyYW5zZm9ybXNcblx0ICAgIHRoaXMuX2RyYXdUcmFuc2Zvcm0oKTtcblx0ICAgIC8vIGNhbGwgY3VzdG9tIHRyYW5zZm9ybSBjYWxsYmFjayBpZiBleGlzdFxuXHQgICAgdGhpcy5fY3VzdG9tRHJhdyAmJiB0aGlzLl9jdXN0b21EcmF3KHRoaXMuX3Byb3BzLmVsLCB0aGlzLl9wcm9wcyk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHNldCB0cmFuc2Zvcm0gb24gZWxlbWVudC5cblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblxuXG5cdCAgSHRtbC5wcm90b3R5cGUuX2RyYXdUcmFuc2Zvcm0gPSBmdW5jdGlvbiBfZHJhd1RyYW5zZm9ybSgpIHtcblx0ICAgIHZhciBwID0gdGhpcy5fcHJvcHM7XG5cdCAgICB2YXIgc3RyaW5nID0gIXRoaXMuX2lzM2QgPyAndHJhbnNsYXRlKCcgKyBwLnggKyAnLCAnICsgcC55ICsgJylcXG4gICAgICAgICAgcm90YXRlKCcgKyBwLmFuZ2xlWiArICdkZWcpXFxuICAgICAgICAgIHNrZXcoJyArIHAuc2tld1ggKyAnZGVnLCAnICsgcC5za2V3WSArICdkZWcpXFxuICAgICAgICAgIHNjYWxlKCcgKyBwLnNjYWxlWCArICcsICcgKyBwLnNjYWxlWSArICcpJyA6ICd0cmFuc2xhdGUzZCgnICsgcC54ICsgJywgJyArIHAueSArICcsICcgKyBwLnogKyAnKVxcbiAgICAgICAgICByb3RhdGVYKCcgKyBwLmFuZ2xlWCArICdkZWcpXFxuICAgICAgICAgIHJvdGF0ZVkoJyArIHAuYW5nbGVZICsgJ2RlZylcXG4gICAgICAgICAgcm90YXRlWignICsgcC5hbmdsZVogKyAnZGVnKVxcbiAgICAgICAgICBza2V3KCcgKyBwLnNrZXdYICsgJ2RlZywgJyArIHAuc2tld1kgKyAnZGVnKVxcbiAgICAgICAgICBzY2FsZSgnICsgcC5zY2FsZVggKyAnLCAnICsgcC5zY2FsZVkgKyAnKSc7XG5cblx0ICAgIHRoaXMuX3NldFN0eWxlKCd0cmFuc2Zvcm0nLCBzdHJpbmcpO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byByZW5kZXIgb24gaW5pdGlhbGl6YXRpb24uXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQG92ZXJyaWRlcyBAIE1vZHVsZVxuXHQgICovXG5cblxuXHQgIEh0bWwucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiBfcmVuZGVyKCkge1xuXHQgICAgLy8gcmV0dXJuIGltbWVkaWF0ZWx5IGlmIG5vdCB0aGUgZmlyc3QgaW4gYHRoZW5gIGNoYWluXG5cdCAgICBpZiAodGhpcy5fby5wcmV2Q2hhaW5Nb2R1bGUpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgcCA9IHRoaXMuX3Byb3BzO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3JlbmRlclByb3BzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciBuYW1lID0gdGhpcy5fcmVuZGVyUHJvcHNbaV0sXG5cdCAgICAgICAgICB2YWx1ZSA9IHBbbmFtZV07XG5cblx0ICAgICAgdmFsdWUgPSB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInID8gdmFsdWUgKyAncHgnIDogdmFsdWU7XG5cdCAgICAgIHRoaXMuX3NldFN0eWxlKG5hbWUsIHZhbHVlKTtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5fZHJhdygpO1xuXG5cdCAgICBpZiAoIXAuaXNTaG93U3RhcnQpIHtcblx0ICAgICAgdGhpcy5faGlkZSgpO1xuXHQgICAgfVxuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBzZXQgc3R5bGUgb24gZWwuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtTdHJpbmd9IFN0eWxlIHByb3BlcnR5IG5hbWUuXG5cdCAgICBAcGFyYW0ge1N0cmluZ30gU3R5bGUgcHJvcGVydHkgdmFsdWUuXG5cdCAgKi9cblxuXG5cdCAgSHRtbC5wcm90b3R5cGUuX3NldFN0eWxlID0gZnVuY3Rpb24gX3NldFN0eWxlKG5hbWUsIHZhbHVlKSB7XG5cdCAgICBpZiAodGhpcy5fc3RhdGVbbmFtZV0gIT09IHZhbHVlKSB7XG5cdCAgICAgIHZhciBzdHlsZSA9IHRoaXMuX3Byb3BzLmVsLnN0eWxlO1xuXHQgICAgICAvLyBzZXQgc3R5bGVcblx0ICAgICAgc3R5bGVbbmFtZV0gPSB2YWx1ZTtcblx0ICAgICAgLy8gaWYgcHJlZml4IG5lZWRlZCAtIHNldCBpdFxuXHQgICAgICBpZiAodGhpcy5fcHJlZml4UHJvcGVydHlNYXBbbmFtZV0pIHtcblx0ICAgICAgICBzdHlsZVsnJyArIHRoaXMuX3ByZWZpeCArIG5hbWVdID0gdmFsdWU7XG5cdCAgICAgIH1cblx0ICAgICAgLy8gY2FjaGUgdGhlIGxhc3Qgc2V0IHZhbHVlXG5cdCAgICAgIHRoaXMuX3N0YXRlW25hbWVdID0gdmFsdWU7XG5cdCAgICB9XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGNvcHkgYF9vYCBvcHRpb25zIHRvIGBfcHJvcHNgIG9iamVjdC5cblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblxuXG5cdCAgSHRtbC5wcm90b3R5cGUuX2V4dGVuZERlZmF1bHRzID0gZnVuY3Rpb24gX2V4dGVuZERlZmF1bHRzKCkge1xuXHQgICAgdGhpcy5fcHJvcHMgPSB0aGlzLl9vLnByb3BzIHx8IHt9O1xuXHQgICAgLy8gcHJvcHMgZm9yIGludGlhbCByZW5kZXIgb25seVxuXHQgICAgdGhpcy5fcmVuZGVyUHJvcHMgPSBbXTtcblx0ICAgIC8vIHByb3BzIGZvciBkcmF3IG9uIGV2ZXJ5IGZyYW1lIHVwZGF0ZVxuXHQgICAgdGhpcy5fZHJhd1Byb3BzID0gW107XG5cdCAgICAvLyBzYXZlIGN1c3RvbSBwcm9wZXJ0aWVzIGlmIHByZXNlbnRcblx0ICAgIHRoaXMuX3NhdmVDdXN0b21Qcm9wZXJ0aWVzKHRoaXMuX28pO1xuXHQgICAgLy8gY29weSB0aGUgb3B0aW9uc1xuXHQgICAgdmFyIG8gPSAoMCwgX2V4dGVuZHM1LmRlZmF1bHQpKHt9LCB0aGlzLl9vKTtcblx0ICAgIC8vIGV4dGVuZCBvcHRpb25zIHdpdGggZGVmYXVsdHNcblx0ICAgIG8gPSB0aGlzLl9hZGREZWZhdWx0cyhvKTtcblxuXHQgICAgdmFyIGtleXMgPSAoMCwgX2tleXMyLmRlZmF1bHQpKG8pO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXHQgICAgICAvLyBpbmNsdWRlIHRoZSBwcm9wZXJ0eSBpZiBpdCBpcyBub3QgaW4gZHJhd0V4Y2x1ZGUgb2JqZWN0XG5cdCAgICAgIC8vIGFuZCBub3QgaW4gZGVmYXVsdHMgPSBub3QgYSB0cmFuc2Zvcm1cblx0ICAgICAgdmFyIGlzSW5jbHVkZSA9ICF0aGlzLl9kcmF3RXhjbHVkZVtrZXldICYmIC8vIG5vdCBpbiBleGNsdWRlIG1hcFxuXHQgICAgICB0aGlzLl9kZWZhdWx0c1trZXldID09IG51bGwgJiYgLy8gbm90IHRyYW5zZm9ybSBwcm9wZXJ0eVxuXHQgICAgICAhVFdFRU5fUFJPUEVSVElFU1trZXldOyAvLyBub3QgdHdlZW4gcHJvcGVydHlcblxuXHQgICAgICB2YXIgaXNDdXN0b20gPSB0aGlzLl9jdXN0b21Qcm9wc1trZXldO1xuXHQgICAgICAvLyBjb3B5IGFsbCBub24tZGVsdGEgcHJvcGVydGllcyB0byB0aGUgcHJvcHNcblx0ICAgICAgLy8gaWYgbm90IGRlbHRhIHRoZW4gYWRkIHRoZSBwcm9wZXJ0eSB0byByZW5kZXJcblx0ICAgICAgLy8gbGlzdCB0aGF0IGlzIGNhbGxlZCBvbiBpbml0aWFsaXphdGlvblxuXHQgICAgICAvLyBvdGhlcndpc2UgYWRkIGl0IHRvIHRoZSBkcmF3IGxpc3QgdGhhdCB3aWxsXG5cdCAgICAgIC8vIGJlIGRyYXdlZCBvbiBlYWNoIGZyYW1lXG5cdCAgICAgIGlmICghaC5pc0RlbHRhKG9ba2V5XSkgJiYgIVRXRUVOX1BST1BFUlRJRVNba2V5XSkge1xuXHQgICAgICAgIHRoaXMuX3BhcnNlT3B0aW9uKGtleSwgb1trZXldKTtcblx0ICAgICAgICBpZiAoa2V5ID09PSAnZWwnKSB7XG5cdCAgICAgICAgICB0aGlzLl9wcm9wcy5lbCA9IGgucGFyc2VFbChvLmVsKTtcblx0ICAgICAgICAgIHRoaXMuZWwgPSB0aGlzLl9wcm9wcy5lbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGlzSW5jbHVkZSAmJiAhaXNDdXN0b20pIHtcblx0ICAgICAgICAgIHRoaXMuX3JlbmRlclByb3BzLnB1c2goa2V5KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gY29weSBkZWx0YSBwcm9wIGJ1dCBub3QgdHJhbnNmb3Jtc1xuXHQgICAgICAgIC8vIG90aGVyd2lzZSBwdXNoIGl0IHRvIGRyYXcgbGlzdCB0aGF0IGdldHMgdHJhdmVyc2VkIG9uIGV2ZXJ5IGRyYXdcblx0ICAgICAgfSBlbHNlIGlmIChpc0luY2x1ZGUgJiYgIWlzQ3VzdG9tKSB7XG5cdCAgICAgICAgdGhpcy5fZHJhd1Byb3BzLnB1c2goa2V5KTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICB0aGlzLl9jcmVhdGVEZWx0YXMobyk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHNhdmUgY3VzdG9tUHJvcGVydGllcyB0byBfY3VzdG9tUHJvcHMuXG5cdCAgICBAcGFyYW0ge09iamVjdH0gT3B0aW9ucyBvZiB0aGUgbW9kdWxlLlxuXHQgICovXG5cblxuXHQgIEh0bWwucHJvdG90eXBlLl9zYXZlQ3VzdG9tUHJvcGVydGllcyA9IGZ1bmN0aW9uIF9zYXZlQ3VzdG9tUHJvcGVydGllcygpIHtcblx0ICAgIHZhciBvID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuXHQgICAgdGhpcy5fY3VzdG9tUHJvcHMgPSBvLmN1c3RvbVByb3BlcnRpZXMgfHwge307XG5cdCAgICB0aGlzLl9jdXN0b21Qcm9wcyA9ICgwLCBfZXh0ZW5kczUuZGVmYXVsdCkoe30sIHRoaXMuX2N1c3RvbVByb3BzKTtcblx0ICAgIHRoaXMuX2N1c3RvbURyYXcgPSB0aGlzLl9jdXN0b21Qcm9wcy5kcmF3O1xuXHQgICAgZGVsZXRlIHRoaXMuX2N1c3RvbVByb3BzLmRyYXc7XG5cdCAgICBkZWxldGUgby5jdXN0b21Qcm9wZXJ0aWVzO1xuXG5cdCAgICB0aGlzLl9jb3B5RGVmYXVsdEN1c3RvbVByb3BzKCk7XG5cblx0ICAgIC8vIGlmICggdGhpcy5fY3VzdG9tUHJvcHMgKSB7fVxuXHQgICAgLy8gdGhpcy5fY3VzdG9tUHJvcHMgPSB0aGlzLl9jdXN0b21Qcm9wcyB8fCB7fTtcblx0ICB9O1xuXG5cdCAgSHRtbC5wcm90b3R5cGUuX2NvcHlEZWZhdWx0Q3VzdG9tUHJvcHMgPSBmdW5jdGlvbiBfY29weURlZmF1bHRDdXN0b21Qcm9wcygpIHtcblx0ICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl9jdXN0b21Qcm9wcykge1xuXHQgICAgICBpZiAodGhpcy5fb1trZXldID09IG51bGwpIHtcblx0ICAgICAgICB0aGlzLl9vW2tleV0gPSB0aGlzLl9jdXN0b21Qcm9wc1trZXldO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHJlc2V0IHNvbWUgZmxhZ3Mgb24gbWVyZ2VkIG9wdGlvbnMgb2JqZWN0LlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBvdmVycmlkZXMgQCBUaGVuYWJsZVxuXHQgICAgQHBhcmFtICAge09iamVjdH0gT3B0aW9ucyBvYmplY3QuXG5cdCAgICBAcmV0dXJucyB7T2JqZWN0fSBPcHRpb25zIG9iamVjdC5cblx0ICAqL1xuXG5cblx0ICBIdG1sLnByb3RvdHlwZS5fcmVzZXRNZXJnZWRGbGFncyA9IGZ1bmN0aW9uIF9yZXNldE1lcmdlZEZsYWdzKG8pIHtcblx0ICAgIF9UaGVuYWJsZS5wcm90b3R5cGUuX3Jlc2V0TWVyZ2VkRmxhZ3MuY2FsbCh0aGlzLCBvKTtcblx0ICAgIG8ucHJvcHMgPSB0aGlzLl9wcm9wcztcblx0ICAgIG8uY3VzdG9tUHJvcGVydGllcyA9IHRoaXMuX2N1c3RvbVByb3BzO1xuXHQgICAgcmV0dXJuIG87XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHBhcnNlIG9wdGlvbiB2YWx1ZS5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge1N0cmluZ30gT3B0aW9uIG5hbWUuXG5cdCAgICBAcGFyYW0ge0FueX0gT3B0aW9uIHZhbHVlLlxuXHQgICovXG5cblxuXHQgIEh0bWwucHJvdG90eXBlLl9wYXJzZU9wdGlvbiA9IGZ1bmN0aW9uIF9wYXJzZU9wdGlvbihrZXksIHZhbHVlKSB7XG5cdCAgICBfVGhlbmFibGUucHJvdG90eXBlLl9wYXJzZU9wdGlvbi5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuXHQgICAgLy8gYXQgdGhpcyBwb2ludCB0aGUgcHJvcGVydHkgaXMgcGFyc2VkXG5cdCAgICB2YXIgcGFyc2VkID0gdGhpcy5fcHJvcHNba2V5XTtcblx0ICAgIC8vIGNhc3QgaXQgdG8gc3RyaW5nIGlmIGl0IGlzIGFycmF5XG5cdCAgICBpZiAoaC5pc0FycmF5KHBhcnNlZCkpIHtcblx0ICAgICAgdGhpcy5fcHJvcHNba2V5XSA9IHRoaXMuX2FyclRvU3RyaW5nKHBhcnNlZCk7XG5cdCAgICB9XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIGNhc3QgYXJyYXkgdG8gc3RyaW5nIHZhbHVlLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7QXJyYXl9IEFycmF5IG9mIHBhcnNlZCBudW1iZXJzIHdpdGggdW5pdHMuXG5cdCAgICBAcmV0dXJucyB7U3RyaW5nfSBDYXN0ZWQgYXJyYXkuXG5cdCAgKi9cblxuXG5cdCAgSHRtbC5wcm90b3R5cGUuX2FyclRvU3RyaW5nID0gZnVuY3Rpb24gX2FyclRvU3RyaW5nKGFycikge1xuXHQgICAgdmFyIHN0cmluZyA9ICcnO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgc3RyaW5nICs9IGFycltpXS5zdHJpbmcgKyAnICc7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gc3RyaW5nO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBhZGQgZGVmYXVscyB0byBwYXNzZWQgb2JqZWN0LlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBPYmplY3QgdG8gYWRkIGRlZmF1bHRzIHRvLlxuXHQgICovXG5cblxuXHQgIEh0bWwucHJvdG90eXBlLl9hZGREZWZhdWx0cyA9IGZ1bmN0aW9uIF9hZGREZWZhdWx0cyhvYmopIHtcblx0ICAgIC8vIGZsYWcgdGhhdCBhZnRlciBhbGwgZGVmYXVsdHMgYXJlIHNldCB3aWxsIGluZGljYXRlXG5cdCAgICAvLyBpZiB1c2VyIGhhdmUgc2V0IHRoZSAzZCB0cmFuc2Zvcm1cblx0ICAgIHRoaXMuX2lzM2QgPSBmYWxzZTtcblxuXHQgICAgZm9yICh2YXIga2V5IGluIHRoaXMuX2RlZmF1bHRzKSB7XG5cdCAgICAgIC8vIHNraXAgcHJvcGVydHkgaWYgaXQgaXMgbGlzdGVkIGluIF9za2lwUHJvcHNcblx0ICAgICAgLy8gaWYgKHRoaXMuX3NraXBQcm9wcyAmJiB0aGlzLl9za2lwUHJvcHNba2V5XSkgeyBjb250aW51ZTsgfVxuXG5cdCAgICAgIC8vIGNvcHkgdGhlIHByb3BlcnRpZXMgdG8gdGhlIF9vIG9iamVjdFxuXHQgICAgICAvLyBpZiBpdCdzIG51bGwgLSBzZXQgdGhlIGRlZmF1bHQgdmFsdWVcblx0ICAgICAgaWYgKG9ialtrZXldID09IG51bGwpIHtcblx0ICAgICAgICAvLyBzY2FsZVggYW5kIHNjYWxlWSBzaG91bGQgZmFsbGJhY2sgdG8gc2NhbGVcblx0ICAgICAgICBpZiAoa2V5ID09PSAnc2NhbGVYJyB8fCBrZXkgPT09ICdzY2FsZVknKSB7XG5cdCAgICAgICAgICBvYmpba2V5XSA9IG9ialsnc2NhbGUnXSAhPSBudWxsID8gb2JqWydzY2FsZSddIDogdGhpcy5fZGVmYXVsdHNbJ3NjYWxlJ107XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIG9ialtrZXldID0gdGhpcy5fZGVmYXVsdHNba2V5XTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgLy8gZ2V0IGlmIDNkIHByb3BlcnR5IHdhcyBzZXQuXG5cdCAgICAgICAgaWYgKHRoaXMuXzNkUHJvcGVydGllcy5pbmRleE9mKGtleSkgIT09IC0xKSB7XG5cdCAgICAgICAgICB0aGlzLl9pczNkID0gdHJ1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgaWYgKHRoaXMuX28uaXNGb3JjZTNkKSB7XG5cdCAgICAgIHRoaXMuX2lzM2QgPSB0cnVlO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gb2JqO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIExpZmVjeWNsZSBtZXRob2QgdG8gZGVjbGFyZSB2YXJpYWJsZXMuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIEh0bWwucHJvdG90eXBlLl92YXJzID0gZnVuY3Rpb24gX3ZhcnMoKSB7XG5cdCAgICAvLyBzZXQgZGVsdGFzIHRvIHRoZSBsYXN0IHZhbHVlLCBzbyB0aGUgX3Byb3BzIHdpdGhcblx0ICAgIC8vIGVuZCB2YWx1ZXMgd2lsbCBiZSBjb3BpZWQgdG8gdGhlIF9oaXN0b3J5LCBpdCBpc1xuXHQgICAgLy8gY3J1Y2lhbCBmb3IgYHRoZW5gIGNoYWluaW5nXG5cdCAgICB0aGlzLmRlbHRhcy5yZWZyZXNoKGZhbHNlKTtcblx0ICAgIC8vIGNhbGwgc3VwZXIgdmFyc1xuXHQgICAgX1RoZW5hYmxlLnByb3RvdHlwZS5fdmFycy5jYWxsKHRoaXMpO1xuXHQgICAgLy8gc3RhdGUgb2Ygc2V0IHByb3BlcnRpZXNcblx0ICAgIHRoaXMuX3N0YXRlID0ge307XG5cdCAgICAvLyByZXN0b3JlIGRlbHRhIHZhbHVlcyB0aGF0IHdlIGhhdmUgcmVmcmVzaGVkIGJlZm9yZVxuXHQgICAgdGhpcy5kZWx0YXMucmVzdG9yZShmYWxzZSk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGNyZWF0ZSBkZWx0YXMgZnJvbSBwYXNzZWQgb2JqZWN0LlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBPcHRpb25zIG9iamVjdCB0byBwYXNzIHRvIHRoZSBEZWx0YXMuXG5cdCAgKi9cblxuXG5cdCAgSHRtbC5wcm90b3R5cGUuX2NyZWF0ZURlbHRhcyA9IGZ1bmN0aW9uIF9jcmVhdGVEZWx0YXMob3B0aW9ucykge1xuXHQgICAgdGhpcy5kZWx0YXMgPSBuZXcgX2RlbHRhczIuZGVmYXVsdCh7XG5cdCAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG5cdCAgICAgIHByb3BzOiB0aGlzLl9wcm9wcyxcblx0ICAgICAgYXJyYXlQcm9wZXJ0eU1hcDogdGhpcy5fYXJyYXlQcm9wZXJ0eU1hcCxcblx0ICAgICAgbnVtYmVyUHJvcGVydHlNYXA6IHRoaXMuX251bWJlclByb3BlcnR5TWFwLFxuXHQgICAgICBjdXN0b21Qcm9wczogdGhpcy5fY3VzdG9tUHJvcHMsXG5cdCAgICAgIGNhbGxiYWNrc0NvbnRleHQ6IG9wdGlvbnMuY2FsbGJhY2tzQ29udGV4dCB8fCB0aGlzLFxuXHQgICAgICBpc0NoYWluZWQ6ICEhdGhpcy5fby5wcmV2Q2hhaW5Nb2R1bGVcblx0ICAgIH0pO1xuXG5cdCAgICAvLyBpZiBjaGFpbmVkIG1vZHVsZSBzZXQgdGltZWxpbmUgdG8gZGVsdGFzJyB0aW1lbGluZSBcblx0ICAgIGlmICh0aGlzLl9vLnByZXZDaGFpbk1vZHVsZSkge1xuXHQgICAgICB0aGlzLnRpbWVsaW5lID0gdGhpcy5kZWx0YXMudGltZWxpbmU7XG5cdCAgICB9XG5cdCAgfTtcblx0ICAvKiBAb3ZlcnJpZGVzIEAgVHdlZW5hYmxlICovXG5cblxuXHQgIEh0bWwucHJvdG90eXBlLl9tYWtlVHdlZW4gPSBmdW5jdGlvbiBfbWFrZVR3ZWVuKCkge307XG5cblx0ICBIdG1sLnByb3RvdHlwZS5fbWFrZVRpbWVsaW5lID0gZnVuY3Rpb24gX21ha2VUaW1lbGluZSgpIHtcblx0ICAgIC8vIGRvIG5vdCBjcmVhdGUgdGltZWxpbmUgaWYgbW9kdWxlIGlmIGNoYWluZWRcblx0ICAgIGlmICh0aGlzLl9vLnByZXZDaGFpbk1vZHVsZSkge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICAvLyBhZGQgY2FsbGJhY2tzIG92ZXJyaWRlc1xuXHQgICAgdGhpcy5fby50aW1lbGluZSA9IHRoaXMuX28udGltZWxpbmUgfHwge307XG5cdCAgICB0aGlzLl9hZGRDYWxsYmFja092ZXJyaWRlcyh0aGlzLl9vLnRpbWVsaW5lKTtcblx0ICAgIF9UaGVuYWJsZS5wcm90b3R5cGUuX21ha2VUaW1lbGluZS5jYWxsKHRoaXMpO1xuXHQgICAgdGhpcy50aW1lbGluZS5hZGQodGhpcy5kZWx0YXMpO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBhZGQgY2FsbGJhY2sgb3ZlcnJpZGVzIHRvIHBhc3NlZCBvYmplY3Qgb2JqZWN0LlxuXHQgICAgQHBhcmFtIHtPYmplY3R9IE9iamVjdCB0byBhZGQgb3ZlcnJpZGVzIG9uLlxuXHQgICovXG5cblxuXHQgIEh0bWwucHJvdG90eXBlLl9hZGRDYWxsYmFja092ZXJyaWRlcyA9IGZ1bmN0aW9uIF9hZGRDYWxsYmFja092ZXJyaWRlcyhvKSB7XG5cdCAgICB2YXIgaXQgPSB0aGlzO1xuXHQgICAgdmFyIHAgPSB0aGlzLl9wcm9wcztcblx0ICAgIG8uY2FsbGJhY2tPdmVycmlkZXMgPSB7XG5cdCAgICAgIG9uVXBkYXRlOiB0aGlzLl9kcmF3LFxuXHQgICAgICBvblJlZnJlc2g6IHRoaXMuX3Byb3BzLmlzUmVmcmVzaFN0YXRlID8gdGhpcy5fZHJhdyA6IHZvaWQgMCxcblx0ICAgICAgb25TdGFydDogZnVuY3Rpb24gb25TdGFydChpc0Z3ZCkge1xuXHQgICAgICAgIC8vIGRvbid0IHRvdWNoIG1haW4gYGVsYCBvblN0YXJ0IGluIGNoYWluZWQgZWxlbWVudHNcblx0ICAgICAgICBpZiAoaXQuX2lzQ2hhaW5lZCkge1xuXHQgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgLy8gc2hvdyBpZiB3YXMgaGlkZGVuIGF0IHN0YXJ0XG5cdCAgICAgICAgaWYgKGlzRndkICYmICFwLmlzU2hvd1N0YXJ0KSB7XG5cdCAgICAgICAgICBpdC5fc2hvdygpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBoaWRlIGlmIHNob3VsZCBiZSBoaWRkZW4gYXQgc3RhcnRcblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgaWYgKCFwLmlzU2hvd1N0YXJ0KSB7XG5cdCAgICAgICAgICAgICAgaXQuX2hpZGUoKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICB9LFxuXHQgICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbiBvbkNvbXBsZXRlKGlzRndkKSB7XG5cdCAgICAgICAgLy8gZG9uJ3QgdG91Y2ggbWFpbiBgZWxgIGlmIG5vdCB0aGUgbGFzdCBpbiBgdGhlbmAgY2hhaW5cblx0ICAgICAgICBpZiAoaXQuX2lzQ2hhaW5lZCkge1xuXHQgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoaXNGd2QpIHtcblx0ICAgICAgICAgIGlmICghcC5pc1Nob3dFbmQpIHtcblx0ICAgICAgICAgICAgaXQuX2hpZGUoKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2UgaWYgKCFwLmlzU2hvd0VuZCkge1xuXHQgICAgICAgICAgaXQuX3Nob3coKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH07XG5cdCAgfTtcblxuXHQgIC8qXG5cdCAgICBNZXRob2QgdGhhdCBnZXRzIGNhbGxlZCBvbiBgc29mdGAgc2hvdyBvZiB0aGUgbW9kdWxlLFxuXHQgICAgaXQgc2hvdWxkIHJlc3RvcmUgdHJhbnNmb3JtIHN0eWxlcyBvZiB0aGUgbW9kdWxlLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBvdmVycmlkZXMgQCBNb2R1bGVcblx0ICAqL1xuXG5cblx0ICBIdG1sLnByb3RvdHlwZS5fc2hvd0J5VHJhbnNmb3JtID0gZnVuY3Rpb24gX3Nob3dCeVRyYW5zZm9ybSgpIHtcblx0ICAgIHRoaXMuX2RyYXdUcmFuc2Zvcm0oKTtcblx0ICB9O1xuXG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBtZXJnZSBgc3RhcnRgIGFuZCBgZW5kYCBmb3IgYSBwcm9wZXJ0eSBpbiB0aGVuIHJlY29yZC5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge1N0cmluZ30gUHJvcGVydHkgbmFtZS5cblx0ICAgIEBwYXJhbSB7QW55fSAgICBTdGFydCB2YWx1ZSBvZiB0aGUgcHJvcGVydHkuXG5cdCAgICBAcGFyYW0ge0FueX0gICAgRW5kIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eS5cblx0ICAqL1xuXHQgIC8vICEhIENPVkVSICEhXG5cblxuXHQgIEh0bWwucHJvdG90eXBlLl9tZXJnZVRoZW5Qcm9wZXJ0eSA9IGZ1bmN0aW9uIF9tZXJnZVRoZW5Qcm9wZXJ0eShrZXksIHN0YXJ0VmFsdWUsIGVuZFZhbHVlKSB7XG5cdCAgICAvLyBpZiBpc250IHR3ZWVuIHByb3BlcnR5XG5cdCAgICB2YXIgaXNCb29sZWFuID0gdHlwZW9mIGVuZFZhbHVlID09PSAnYm9vbGVhbicsXG5cdCAgICAgICAgY3VydmUsXG5cdCAgICAgICAgZWFzaW5nO1xuXG5cdCAgICBpZiAoIWguaXNUd2VlblByb3Aoa2V5KSAmJiAhdGhpcy5fbm9uTWVyZ2VQcm9wc1trZXldICYmICFpc0Jvb2xlYW4pIHtcblxuXHQgICAgICB2YXIgVFdFRU5fUFJPUFMgPSB7fTtcblx0ICAgICAgaWYgKGguaXNPYmplY3QoZW5kVmFsdWUpICYmIGVuZFZhbHVlLnRvICE9IG51bGwpIHtcblx0ICAgICAgICBmb3IgKHZhciBfa2V5IGluIGVuZFZhbHVlKSB7XG5cdCAgICAgICAgICBpZiAoVFdFRU5fUFJPUEVSVElFU1tfa2V5XSB8fCBfa2V5ID09PSAnY3VydmUnKSB7XG5cdCAgICAgICAgICAgIFRXRUVOX1BST1BTW19rZXldID0gZW5kVmFsdWVbX2tleV07XG5cdCAgICAgICAgICAgIGRlbGV0ZSBlbmRWYWx1ZVtfa2V5XTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gY3VydmUgICAgPSBlbmRWYWx1ZS5jdXJ2ZTtcblx0ICAgICAgICAvLyBlYXNpbmcgICA9IGVuZFZhbHVlLmVhc2luZztcblx0ICAgICAgICBlbmRWYWx1ZSA9IGVuZFZhbHVlLnRvO1xuXHQgICAgICB9XG5cblx0ICAgICAgLy8gaWYgZW5kIHZhbHVlIGlzIGRlbHRhIC0ganVzdCBzYXZlIGl0XG5cdCAgICAgIGlmICh0aGlzLl9pc0RlbHRhKGVuZFZhbHVlKSkge1xuXG5cdCAgICAgICAgdmFyIF9UV0VFTl9QUk9QUyA9IHt9O1xuXHQgICAgICAgIGZvciAodmFyIF9rZXkyIGluIGVuZFZhbHVlKSB7XG5cdCAgICAgICAgICBpZiAoVFdFRU5fUFJPUEVSVElFU1tfa2V5Ml0gfHwgX2tleTIgPT09ICdjdXJ2ZScpIHtcblx0ICAgICAgICAgICAgX1RXRUVOX1BST1BTW19rZXkyXSA9IGVuZFZhbHVlW19rZXkyXTtcblx0ICAgICAgICAgICAgZGVsZXRlIGVuZFZhbHVlW19rZXkyXTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX3BhcnNlRGVsdGFWYWx1ZXMoa2V5LCBlbmRWYWx1ZSk7XG5cblx0ICAgICAgICByZXR1cm4gKDAsIF9leHRlbmRzNS5kZWZhdWx0KSh7fSwgcmVzdWx0LCBfVFdFRU5fUFJPUFMpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHZhciBwYXJzZWRFbmRWYWx1ZSA9IHRoaXMuX3BhcnNlUHJlQXJyYXlQcm9wZXJ0eShrZXksIGVuZFZhbHVlKTtcblx0ICAgICAgICAvLyBpZiBlbmQgdmFsdWUgaXMgbm90IGRlbHRhIC0gbWVyZ2Ugd2l0aCBzdGFydCB2YWx1ZVxuXHQgICAgICAgIGlmICh0aGlzLl9pc0RlbHRhKHN0YXJ0VmFsdWUpKSB7XG5cdCAgICAgICAgICB2YXIgX2V4dGVuZHMyO1xuXG5cdCAgICAgICAgICAvLyBpZiBzdGFydCB2YWx1ZSBpcyBkZWx0YSAtIHRha2UgdGhlIGVuZCB2YWx1ZVxuXHQgICAgICAgICAgLy8gYXMgc3RhcnQgdmFsdWUgb2YgdGhlIG5ldyBkZWx0YVxuXHQgICAgICAgICAgcmV0dXJuICgwLCBfZXh0ZW5kczUuZGVmYXVsdCkoKF9leHRlbmRzMiA9IHt9LCBfZXh0ZW5kczJbaC5nZXREZWx0YUVuZChzdGFydFZhbHVlKV0gPSBwYXJzZWRFbmRWYWx1ZSwgX2V4dGVuZHMyKSwgVFdFRU5fUFJPUFMpO1xuXHQgICAgICAgICAgLy8gaWYgYm90aCBzdGFydCBhbmQgZW5kIHZhbHVlIGFyZSBub3Qg4oiGIC0gbWFrZSDiiIZcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgdmFyIF9leHRlbmRzMztcblxuXHQgICAgICAgICAgcmV0dXJuICgwLCBfZXh0ZW5kczUuZGVmYXVsdCkoKF9leHRlbmRzMyA9IHt9LCBfZXh0ZW5kczNbc3RhcnRWYWx1ZV0gPSBwYXJzZWRFbmRWYWx1ZSwgX2V4dGVuZHMzKSwgVFdFRU5fUFJPUFMpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICAvLyBjb3B5IHRoZSB0d2VlbiB2YWx1ZXMgdW5hdHRlbmRlZFxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmV0dXJuIGVuZFZhbHVlO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICByZXR1cm4gSHRtbDtcblx0fShfdGhlbmFibGUyLmRlZmF1bHQpO1xuXG5cdGV4cG9ydHMuZGVmYXVsdCA9IEh0bWw7XG5cbi8qKiovIH0pLFxuLyogMTIwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuXHR2YXIgX2Fzc2lnbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTIxKTtcblxuXHR2YXIgX2Fzc2lnbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hc3NpZ24pO1xuXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cblx0ZXhwb3J0cy5kZWZhdWx0ID0gX2Fzc2lnbjIuZGVmYXVsdCB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG5cdCAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0ICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cblx0ICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcblx0ICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcblx0ICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHRhcmdldDtcblx0fTtcblxuLyoqKi8gfSksXG4vKiAxMjEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IF9fd2VicGFja19yZXF1aXJlX18oMTIyKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG4vKioqLyB9KSxcbi8qIDEyMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdF9fd2VicGFja19yZXF1aXJlX18oMTIzKTtcblx0bW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KS5PYmplY3QuYXNzaWduO1xuXG4vKioqLyB9KSxcbi8qIDEyMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8vIDE5LjEuMy4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UpXG5cdHZhciAkZXhwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG5cblx0JGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYsICdPYmplY3QnLCB7YXNzaWduOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyNCl9KTtcblxuLyoqKi8gfSksXG4vKiAxMjQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdC8vIDE5LjEuMi4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UsIC4uLilcblx0dmFyIGdldEtleXMgID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMylcblx0ICAsIGdPUFMgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Milcblx0ICAsIHBJRSAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Mylcblx0ICAsIHRvT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OSlcblx0ICAsIElPYmplY3QgID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNilcblx0ICAsICRhc3NpZ24gID0gT2JqZWN0LmFzc2lnbjtcblxuXHQvLyBzaG91bGQgd29yayB3aXRoIHN5bWJvbHMgYW5kIHNob3VsZCBoYXZlIGRldGVybWluaXN0aWMgcHJvcGVydHkgb3JkZXIgKFY4IGJ1Zylcblx0bW9kdWxlLmV4cG9ydHMgPSAhJGFzc2lnbiB8fCBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKShmdW5jdGlvbigpe1xuXHQgIHZhciBBID0ge31cblx0ICAgICwgQiA9IHt9XG5cdCAgICAsIFMgPSBTeW1ib2woKVxuXHQgICAgLCBLID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0Jztcblx0ICBBW1NdID0gNztcblx0ICBLLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uKGspeyBCW2tdID0gazsgfSk7XG5cdCAgcmV0dXJuICRhc3NpZ24oe30sIEEpW1NdICE9IDcgfHwgT2JqZWN0LmtleXMoJGFzc2lnbih7fSwgQikpLmpvaW4oJycpICE9IEs7XG5cdH0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXHQgIHZhciBUICAgICA9IHRvT2JqZWN0KHRhcmdldClcblx0ICAgICwgYUxlbiAgPSBhcmd1bWVudHMubGVuZ3RoXG5cdCAgICAsIGluZGV4ID0gMVxuXHQgICAgLCBnZXRTeW1ib2xzID0gZ09QUy5mXG5cdCAgICAsIGlzRW51bSAgICAgPSBwSUUuZjtcblx0ICB3aGlsZShhTGVuID4gaW5kZXgpe1xuXHQgICAgdmFyIFMgICAgICA9IElPYmplY3QoYXJndW1lbnRzW2luZGV4KytdKVxuXHQgICAgICAsIGtleXMgICA9IGdldFN5bWJvbHMgPyBnZXRLZXlzKFMpLmNvbmNhdChnZXRTeW1ib2xzKFMpKSA6IGdldEtleXMoUylcblx0ICAgICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuXHQgICAgICAsIGogICAgICA9IDBcblx0ICAgICAgLCBrZXk7XG5cdCAgICB3aGlsZShsZW5ndGggPiBqKWlmKGlzRW51bS5jYWxsKFMsIGtleSA9IGtleXNbaisrXSkpVFtrZXldID0gU1trZXldO1xuXHQgIH0gcmV0dXJuIFQ7XG5cdH0gOiAkYXNzaWduO1xuXG4vKioqLyB9KSxcbi8qIDEyNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5cdHZhciBfZXh0ZW5kczIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyMCk7XG5cblx0dmFyIF9leHRlbmRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V4dGVuZHMyKTtcblxuXHR2YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oNzQpO1xuXG5cdHZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxuXHR2YXIgX2tleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1KTtcblxuXHR2YXIgX2tleXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfa2V5cyk7XG5cblx0dmFyIF90aW1lbGluZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEwKTtcblxuXHR2YXIgX3RpbWVsaW5lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RpbWVsaW5lKTtcblxuXHR2YXIgX3R3ZWVuID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDEpO1xuXG5cdHZhciBfdHdlZW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHdlZW4pO1xuXG5cdHZhciBfZGVsdGEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyNik7XG5cblx0dmFyIF9kZWx0YTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZWx0YSk7XG5cblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuXHQvKlxuXHQgIFRoaXMgbW9kdWxlJ3MgdGFyZ2V0IGlzIHRvIHBhcnNlIG9wdGlvbnMgb2JqZWN0LFxuXHQgIGZpbmQgZGVsdGFzIGluIGl0IGFuZCBzZW5kIHRoZW0gdG8gYERlbHRhYCBjbGFzc2VzLlxuXHQgIFRoZSBgRGVsdGFgIGNsYXNzIGlzIGR1bGwgLSB0aGV5IGV4cGVjdCBhY3R1YWwgcGFyc2VkIGRlbHRhc1xuXHQgIGFuZCBzZXBhcmF0ZWQgdHdlZW4gb3B0aW9ucywgc28gd2Ugc2hvdWxkIHBhcnNlIHRoZW0gaGVyZS5cblx0ICBUaGUgdGltZWxpbmUgb2YgdGhlIG1vZHVsZSBjb250cm9scyB0aGUgYERlbHRhYCBtb2R1bGVzJyB0d2VlbnMuXG5cblx0ICBAcGFyYW0ge09iamVjdH0gcHJvcHMgT2JqZWN0IHRvIHNldCBkZWx0YXMgcmVzdWx0IHRvIChwYXNzIHRvIHRoZSBEZWx0YSBjbGFzc2VzKS5cblx0ICBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPYmplY3QgdG8gcGFyc2UgdGhlIGRlbHRhcyBmcm9tLlxuXHQgIEBwYXJhbSB7RnVuY3Rpb259IG9uVXBkYXRlIG9uVXBkYXRlIGNhbGxiYWNrLlxuXHQgIEBwYXJhbSBvcHRpb25hbCB7T2JqZWN0fSBhcnJheVByb3BlcnR5TWFwIExpc3Qgb2YgcHJvcGVydGllcyB3aXRoIHRydXRoeVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcyB3aGljaCBkZXNjcmliZSBwcm9wZXJ0aWVzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdCBzaG91bGQgYmUgcGFyc2VkIGFzIGFycmF5cy5cblx0ICBAcGFyYW0gb3B0aW9uYWwge09iamVjdH0gbnVtYmVyUHJvcGVydHlNYXAgTGlzdCBvZiBwcm9wZXJ0aWVzIHdpdGggdHJ1dGh5XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzIHdoaWNoIGRlc2NyaWJlIHByb3BlcnRpZXNcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0IHNob3VsZCBiZSBwYXJzZWQgYXMgbnVtYmVyc1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGhvdXQgdW5pdHMuXG5cdCovXG5cblx0Ly8gVE9ETzpcblx0Ly8gLSBjb2xvcnMgd2l0aCBjdXJ2ZXMgY2hhbmdlIGFscGhhIGxldmVsIHRvb1xuXHQvLyBjb25zdCBodG1sID0gbmV3IG1vanMuSHRtbCh7XG5cdC8vICAgZWw6ICcjanMtZWwnLFxuXHQvLyAgIHg6IHsgMDogMTAwIH0sXG5cdC8vICAgb25VcGRhdGUgKCkge1xuXHQvLyAgICAgY29uc29sZS5sb2codGhpcy5fcHJvcHMub3JpZ2luWCk7XG5cdC8vICAgfSxcblx0Ly8gICBvcmlnaW5YOiB7ICd3aGl0ZSc6ICdibGFjaycsIGN1cnZlOiAnTTAsMTAwIEwxMDAsIDAnIH0sXG5cdC8vICAgY3VzdG9tUHJvcGVydGllczoge1xuXHQvLyAgICAgb3JpZ2luWDoge1xuXHQvLyAgICAgICB0eXBlOiAnY29sb3InLFxuXHQvLyAgICAgICBkZWZhdWx0OiAnY3lhbidcblx0Ly8gICAgIH0sXG5cdC8vICAgICBkcmF3KCkgeyBjb25zb2xlLmxvZygnZHJhdycpOyB9XG5cdC8vICAgfVxuXHQvLyB9KTtcblxuXG5cdHZhciBlYXNpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwNSk7XG5cdHZhciBoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MSk7XG5cblxuXHQvLyBnZXQgdHdlZW4gcHJvcGVydGllc1xuXHR2YXIgb2JqID0ge307XG5cdF90d2VlbjIuZGVmYXVsdC5wcm90b3R5cGUuX2RlY2xhcmVEZWZhdWx0cy5jYWxsKG9iaik7XG5cdHZhciBrZXlzID0gKDAsIF9rZXlzMi5kZWZhdWx0KShvYmouX2RlZmF1bHRzKTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdCAgb2JqLl9kZWZhdWx0c1trZXlzW2ldXSA9IDE7XG5cdH1cblx0b2JqLl9kZWZhdWx0c1sndGltZWxpbmUnXSA9IDE7XG5cdHZhciBUV0VFTl9QUk9QRVJUSUVTID0gb2JqLl9kZWZhdWx0cztcblxuXHR2YXIgRGVsdGFzID0gZnVuY3Rpb24gKCkge1xuXHQgIGZ1bmN0aW9uIERlbHRhcygpIHtcblx0ICAgIHZhciBvID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblx0ICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIERlbHRhcyk7XG5cblx0ICAgIHRoaXMuX28gPSBvO1xuXG5cdCAgICB0aGlzLl9zaG9ydENvbG9ycyA9IHtcblx0ICAgICAgdHJhbnNwYXJlbnQ6ICdyZ2JhKDAsMCwwLDApJyxcblx0ICAgICAgbm9uZTogJ3JnYmEoMCwwLDAsMCknLFxuXHQgICAgICBhcXVhOiAncmdiKDAsMjU1LDI1NSknLFxuXHQgICAgICBibGFjazogJ3JnYigwLDAsMCknLFxuXHQgICAgICBibHVlOiAncmdiKDAsMCwyNTUpJyxcblx0ICAgICAgZnVjaHNpYTogJ3JnYigyNTUsMCwyNTUpJyxcblx0ICAgICAgZ3JheTogJ3JnYigxMjgsMTI4LDEyOCknLFxuXHQgICAgICBncmVlbjogJ3JnYigwLDEyOCwwKScsXG5cdCAgICAgIGxpbWU6ICdyZ2IoMCwyNTUsMCknLFxuXHQgICAgICBtYXJvb246ICdyZ2IoMTI4LDAsMCknLFxuXHQgICAgICBuYXZ5OiAncmdiKDAsMCwxMjgpJyxcblx0ICAgICAgb2xpdmU6ICdyZ2IoMTI4LDEyOCwwKScsXG5cdCAgICAgIHB1cnBsZTogJ3JnYigxMjgsMCwxMjgpJyxcblx0ICAgICAgcmVkOiAncmdiKDI1NSwwLDApJyxcblx0ICAgICAgc2lsdmVyOiAncmdiKDE5MiwxOTIsMTkyKScsXG5cdCAgICAgIHRlYWw6ICdyZ2IoMCwxMjgsMTI4KScsXG5cdCAgICAgIHdoaXRlOiAncmdiKDI1NSwyNTUsMjU1KScsXG5cdCAgICAgIHllbGxvdzogJ3JnYigyNTUsMjU1LDApJyxcblx0ICAgICAgb3JhbmdlOiAncmdiKDI1NSwxMjgsMCknXG5cdCAgICB9O1xuXG5cdCAgICB0aGlzLl9pZ25vcmVEZWx0YXNNYXAgPSB7IHByZXZDaGFpbk1vZHVsZTogMSwgbWFzdGVyTW9kdWxlOiAxIH07XG5cblx0ICAgIHRoaXMuX3BhcnNlRGVsdGFzKG8ub3B0aW9ucyk7XG5cdCAgICB0aGlzLl9jcmVhdGVEZWx0YXMoKTtcblx0ICAgIHRoaXMuX2NyZWF0ZVRpbWVsaW5lKHRoaXMuX21haW5Ud2Vlbk9wdGlvbnMpO1xuXHQgIH1cblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGNhbGwgYHJlZnJlc2hgIG9uIGFsbCBjaGlsZCBgZGVsdGFgIG9iamVjdHMuXG5cdCAgICBAcHVibGljXG5cdCAgICBAcGFyYW0ge0Jvb2xlYW59IElmIGJlZm9yZSBzdGFydCB0aW1lICh0cnVlKSBvciBhZnRlciBlbmQgdGltZSAoZmFsc2UpLlxuXHQgICovXG5cblxuXHQgIERlbHRhcy5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uIHJlZnJlc2goaXNCZWZvcmUpIHtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZGVsdGFzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHRoaXMuX2RlbHRhc1tpXS5yZWZyZXNoKGlzQmVmb3JlKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBjYWxsIGByZXN0b3JlYCBvbiBhbGwgY2hpbGQgYGRlbHRhYCBvYmplY3RzLlxuXHQgICAgQHB1YmxpY1xuXHQgICovXG5cblxuXHQgIERlbHRhcy5wcm90b3R5cGUucmVzdG9yZSA9IGZ1bmN0aW9uIHJlc3RvcmUoKSB7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2RlbHRhcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICB0aGlzLl9kZWx0YXNbaV0ucmVzdG9yZSgpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGNyZWF0ZSBUaW1lbGluZS5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge09iamVjdH0gVGltZWxpbmUgb3B0aW9ucy5cblx0ICAqL1xuXG5cblx0ICBEZWx0YXMucHJvdG90eXBlLl9jcmVhdGVUaW1lbGluZSA9IGZ1bmN0aW9uIF9jcmVhdGVUaW1lbGluZSgpIHtcblx0ICAgIHZhciBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuXHQgICAgLy8gY29uc3QgbyA9IHRoaXMuX287XG5cdCAgICAvLyBvcHRzLnRpbWVsaW5lID0gb3B0cy50aW1lbGluZSB8fCB7fTtcblx0ICAgIC8vIG9wdHMudGltZWxpbmUuY2FsbGJhY2tPdmVycmlkZXMgPSB7XG5cdCAgICAvLyAgIG9uVXBkYXRlOiAgIG8ub25VcGRhdGUsXG5cdCAgICAvLyAgIG9uUmVmcmVzaDogIG8ub25VcGRhdGVcblx0ICAgIC8vIH1cblx0ICAgIC8vIHNlbmQgY2FsbGJhY2tzQ29udGV4dCB0byB0aW1lbGluZSBpZiBzZXRcblx0ICAgIC8vIG8uY2FsbGJhY2tzQ29udGV4dCAmJiAob3B0cy50aW1lbGluZS5jYWxsYmFja3NDb250ZXh0ID0gby5jYWxsYmFja3NDb250ZXh0KTtcblx0ICAgIC8vIG9wdHMudGltZWxpbmVcblx0ICAgIHRoaXMudGltZWxpbmUgPSBuZXcgX3RpbWVsaW5lMi5kZWZhdWx0KCk7XG5cdCAgICB0aGlzLnRpbWVsaW5lLmFkZCh0aGlzLl9kZWx0YXMpO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBjcmVhdGUgRGVsdGFzIGZyb20gcGFyc2VkIG9wdGlvbnMuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIERlbHRhcy5wcm90b3R5cGUuX2NyZWF0ZURlbHRhcyA9IGZ1bmN0aW9uIF9jcmVhdGVEZWx0YXMoKSB7XG5cdCAgICB0aGlzLl9kZWx0YXMgPSBbXTtcblxuXHQgICAgLy8gY3JlYXRlIG1haW4gZGVsdGEgb2JqZWN0XG5cdCAgICB0aGlzLl9kZWx0YXMucHVzaCh0aGlzLl9jcmVhdGVEZWx0YSh0aGlzLl9tYWluRGVsdGFzLCB0aGlzLl9tYWluVHdlZW5PcHRpb25zKSk7XG5cblx0ICAgIC8vIGNyZWF0ZSBjaGlsZCBkZWx0YSBvYmplY3Rcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2hpbGREZWx0YXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIGRlbHRhID0gdGhpcy5fY2hpbGREZWx0YXNbaV07XG5cdCAgICAgIHRoaXMuX2RlbHRhcy5wdXNoKHRoaXMuX2NyZWF0ZURlbHRhKFtkZWx0YS5kZWx0YV0sIGRlbHRhLnR3ZWVuT3B0aW9ucykpO1xuXHQgICAgfVxuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBjcmVhdGUgRGVsdGEgb2JqZWN0IHdpdGggcGFzc2VkIG9wdGlvbnMuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtBcnJheX0gQXJyYXkgb2YgZGVsdGFzLlxuXHQgICAgQHBhcmFtIHtPYmplY3R9IFR3ZWVuIHByb3BlcnRpZXMuXG5cdCAgICBAcmV0dXJucyB7T2JqZWN0fSBEZWx0YSBvYmplY3Rcblx0ICAqL1xuXG5cblx0ICBEZWx0YXMucHJvdG90eXBlLl9jcmVhdGVEZWx0YSA9IGZ1bmN0aW9uIF9jcmVhdGVEZWx0YShkZWx0YXMsIHR3ZWVuT3B0aW9ucykge1xuXHQgICAgdmFyIG8gPSB0aGlzLl9vO1xuXHQgICAgcmV0dXJuIG5ldyBfZGVsdGEyLmRlZmF1bHQoe1xuXHQgICAgICBkZWx0YXM6IGRlbHRhcywgdHdlZW5PcHRpb25zOiB0d2Vlbk9wdGlvbnMsXG5cdCAgICAgIHByb3BzOiBvLnByb3BzLFxuXHQgICAgICBpc0NoYWluZWQ6IG8uaXNDaGFpbmVkLFxuXHQgICAgICBjYWxsYmFja3NDb250ZXh0OiBvLmNhbGxiYWNrc0NvbnRleHRcblx0ICAgIH0pO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBwYXJzZSBkZWx0YSBvYmplY3RzIGZyb20gb3B0aW9ucy5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge09iamVjdH0gT3B0aW9ucyBvYmplY3QgdG8gcGFyc2UgdGhlIGRlbHRhcyBmcm9tLlxuXHQgICovXG5cblxuXHQgIERlbHRhcy5wcm90b3R5cGUuX3BhcnNlRGVsdGFzID0gZnVuY3Rpb24gX3BhcnNlRGVsdGFzKG9iaikge1xuXHQgICAgLy8gc3BpbHQgbWFpbiBhbmltYXRpb24gcHJvcGVydGllcyBhbmQgbWFpbiB0d2VlbiBwcm9wZXJ0aWVzXG5cdCAgICB2YXIgbWFpblNwbGl0ID0gdGhpcy5fc3BsaXRUd2Vlbk9wdGlvbnMob2JqKTtcblx0ICAgIC8vIG1haW4gYW5pbWF0aW9uIHByb3BlcnRpZXNcblx0ICAgIHZhciBvcHRzID0gbWFpblNwbGl0LmRlbHRhO1xuXHQgICAgLy8gbWFpbiB0d2VlbiBwcm9wZXJ0aWVzXG5cdCAgICB0aGlzLl9tYWluVHdlZW5PcHRpb25zID0gbWFpblNwbGl0LnR3ZWVuT3B0aW9ucztcblxuXHQgICAgdGhpcy5fbWFpbkRlbHRhcyA9IFtdO1xuXHQgICAgdGhpcy5fY2hpbGREZWx0YXMgPSBbXTtcblx0ICAgIHZhciBrZXlzID0gKDAsIF9rZXlzMi5kZWZhdWx0KShvcHRzKTtcblx0ICAgIC8vIGxvb3AgdGhydSBhbGwgcHJvcGVydGllcyB3aXRob3V0IHR3ZWVuIG9uZXNcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblx0ICAgICAgLy8gaXMgcHJvcGVydHkgaXMgZGVsdGEgLSBwYXJzZSBpdFxuXHQgICAgICBpZiAodGhpcy5faXNEZWx0YShvcHRzW2tleV0pICYmICF0aGlzLl9pZ25vcmVEZWx0YXNNYXBba2V5XSkge1xuXHQgICAgICAgIHZhciBkZWx0YSA9IHRoaXMuX3NwbGl0QW5kUGFyc2VEZWx0YShrZXksIG9wdHNba2V5XSk7XG5cdCAgICAgICAgLy8gaWYgcGFyc2VkIG9iamVjdCBoYXMgbm8gdHdlZW4gdmFsdWVzIC0gaXQncyBkZWx0YSBvZiB0aGUgbWFpbiBvYmplY3Rcblx0ICAgICAgICBpZiAoIWRlbHRhLnR3ZWVuT3B0aW9ucykge1xuXHQgICAgICAgICAgdGhpcy5fbWFpbkRlbHRhcy5wdXNoKGRlbHRhLmRlbHRhKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gb3RoZXJ3aXNlIGl0IGlzIGRpc3RpbmN0IGRlbHRhIG9iamVjdFxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICB0aGlzLl9jaGlsZERlbHRhcy5wdXNoKGRlbHRhKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBzcGxpdCB0d2VlbiB2YWx1ZXMgYW5kIHBhcnNlIHNpbmdsZSBkZWx0YSByZWNvcmQuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtTdHJpbmd9IFByb3BlcnR5IG5hbWUuXG5cdCAgICBAcGFyYW0ge09iamVjdH0gUmF3IGRlbHRhIG9iamVjdC5cblx0ICAgIEByZXR1cm5zIHtPYmplY3R9IFNwbGl0IG9iamVjdC5cblx0ICAgICAgICAgICAgICAgIEBwYXJhbSB7T2JqZWN0fSB0d2Vlbk9wdGlvbnMgVHdlZW4gcHJvcGVydGllcy5cblx0ICAgICAgICAgICAgICAgIEBwYXJhbSB7T2JqZWN0fSBkZWx0YSBQYXJzZWQgZGVsdGEuXG5cdCAgKi9cblxuXG5cdCAgRGVsdGFzLnByb3RvdHlwZS5fc3BsaXRBbmRQYXJzZURlbHRhID0gZnVuY3Rpb24gX3NwbGl0QW5kUGFyc2VEZWx0YShuYW1lLCBvYmplY3QpIHtcblx0ICAgIHZhciBzcGxpdCA9IHRoaXMuX3NwbGl0VHdlZW5PcHRpb25zKG9iamVjdCk7XG5cdCAgICAvLyBwYXJzZSBkZWx0YSBpbiB0aGUgb2JqZWN0XG5cdCAgICBzcGxpdC5kZWx0YSA9IHRoaXMuX3BhcnNlRGVsdGEobmFtZSwgc3BsaXQuZGVsdGEpO1xuXHQgICAgcmV0dXJuIHNwbGl0O1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBwYXJzZSBkZWx0YSBieSBkZWxlZ2F0aW5nIHRoZSB2YXJpYWJsZXMgdG8gX3BhcnNlKkRlbHRhIG1ldGhvZHMuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtTdHJpbmd9IFByb3BlcnR5IG5hbWUuXG5cdCAgICBAcGFyYW0ge09iamVjdH0gUmF3IGRlbHRhIG9iamVjdC5cblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBNb2R1bGUgaW5kZXguXG5cdCAgKi9cblxuXG5cdCAgRGVsdGFzLnByb3RvdHlwZS5fcGFyc2VEZWx0YSA9IGZ1bmN0aW9uIF9wYXJzZURlbHRhKG5hbWUsIG9iamVjdCwgaW5kZXgpIHtcblx0ICAgIC8vIGlmIG5hbWUgaXMgaW4gX28uY3VzdG9tUHJvcHMgLSBwYXJzZSBpdCByZWdhcmRpbmcgdGhlIHR5cGVcblx0ICAgIHJldHVybiB0aGlzLl9vLmN1c3RvbVByb3BzICYmIHRoaXMuX28uY3VzdG9tUHJvcHNbbmFtZV0gIT0gbnVsbCA/IHRoaXMuX3BhcnNlRGVsdGFCeUN1c3RvbShuYW1lLCBvYmplY3QsIGluZGV4KSA6IHRoaXMuX3BhcnNlRGVsdGFCeUd1ZXNzKG5hbWUsIG9iamVjdCwgaW5kZXgpO1xuXHQgIH07XG5cdCAgLyoqXG5cdCAgICBNZXRob2QgdG8gcGFyc2UgZGVsdGEgYnkgdGFraW5nIHRoZSB0eXBlIGZyb20gdGhlIGN1c3RvbVByb3BzIG9iamVjdC5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge1N0cmluZ30gUHJvcGVydHkgbmFtZS5cblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBSYXcgZGVsdGEgb2JqZWN0LlxuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IE1vZHVsZSBpbmRleC5cblx0ICAqL1xuXG5cblx0ICBEZWx0YXMucHJvdG90eXBlLl9wYXJzZURlbHRhQnlDdXN0b20gPSBmdW5jdGlvbiBfcGFyc2VEZWx0YUJ5Q3VzdG9tKG5hbWUsIG9iamVjdCwgaW5kZXgpIHtcblx0ICAgIHJldHVybiB0aGlzLl9wYXJzZU51bWJlckRlbHRhKG5hbWUsIG9iamVjdCwgaW5kZXgpO1xuXHQgICAgLy8gY29uc3QgY3VzdG9tUmVjb3JkID0gdGhpcy5fby5jdXN0b21Qcm9wc1tuYW1lXTtcblx0ICAgIC8vIHN3aXRjaCAoIGN1c3RvbVJlY29yZC50eXBlLnRvTG93ZXJDYXNlKCkgKSB7XG5cdCAgICAvLyAgIGNhc2UgJ2NvbG9yJzogIHsgcmV0dXJuIHRoaXMuX3BhcnNlQ29sb3JEZWx0YSggbmFtZSwgb2JqZWN0ICk7IH1cblx0ICAgIC8vICAgY2FzZSAnYXJyYXknOiAgeyByZXR1cm4gdGhpcy5fcGFyc2VBcnJheURlbHRhKCBuYW1lLCBvYmplY3QgKTsgfVxuXHQgICAgLy8gICBjYXNlICdudW1iZXInOiB7IHJldHVybiB0aGlzLl9wYXJzZU51bWJlckRlbHRhKCBuYW1lLCBvYmplY3QsIGluZGV4ICk7IH1cblx0ICAgIC8vICAgY2FzZSAndW5pdCc6ICAgeyByZXR1cm4gdGhpcy5fcGFyc2VVbml0RGVsdGEoIG5hbWUsIG9iamVjdCwgaW5kZXggKTsgfVxuXHQgICAgLy8gfVxuXHQgIH07XG5cdCAgLyoqXG5cdCAgICBNZXRob2QgdG8gcGFyc2UgZGVsdGEgYnkgcmVhc29uaW5nIGFib3V0IGl0J3MgdmFsdWUuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtTdHJpbmd9IFByb3BlcnR5IG5hbWUuXG5cdCAgICBAcGFyYW0ge09iamVjdH0gUmF3IGRlbHRhIG9iamVjdC5cblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBNb2R1bGUgaW5kZXguXG5cdCAgKi9cblxuXG5cdCAgRGVsdGFzLnByb3RvdHlwZS5fcGFyc2VEZWx0YUJ5R3Vlc3MgPSBmdW5jdGlvbiBfcGFyc2VEZWx0YUJ5R3Vlc3MobmFtZSwgb2JqZWN0LCBpbmRleCkge1xuXHQgICAgdmFyIF9wcmVwYXJzZURlbHRhMiA9IHRoaXMuX3ByZXBhcnNlRGVsdGEob2JqZWN0KSxcblx0ICAgICAgICBzdGFydCA9IF9wcmVwYXJzZURlbHRhMi5zdGFydDtcblxuXHQgICAgdmFyIG8gPSB0aGlzLl9vO1xuXG5cdCAgICAvLyBjb2xvciB2YWx1ZXNcblx0ICAgIGlmIChpc05hTihwYXJzZUZsb2F0KHN0YXJ0KSkgJiYgIXN0YXJ0Lm1hdGNoKC9yYW5kXFwoLykgJiYgIXN0YXJ0Lm1hdGNoKC9zdGFnZ2VyXFwoLykpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlQ29sb3JEZWx0YShuYW1lLCBvYmplY3QpO1xuXHQgICAgICAvLyBhcnJheSB2YWx1ZXNcblx0ICAgIH0gZWxzZSBpZiAoby5hcnJheVByb3BlcnR5TWFwICYmIG8uYXJyYXlQcm9wZXJ0eU1hcFtuYW1lXSkge1xuXHQgICAgICByZXR1cm4gdGhpcy5fcGFyc2VBcnJheURlbHRhKG5hbWUsIG9iamVjdCk7XG5cdCAgICAgIC8vIHVuaXQgb3IgbnVtYmVyIHZhbHVlc1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmV0dXJuIG8ubnVtYmVyUHJvcGVydHlNYXAgJiYgby5udW1iZXJQcm9wZXJ0eU1hcFtuYW1lXSA/XG5cdCAgICAgIC8vIGlmIHRoZSBwcm9wZXJ0eSBpcyBpbiB0aGUgbnVtYmVyIHByb3BlcnR5IG1hcCAtIHBhcnNlIGl0IGxpa2UgbnVtYmVyXG5cdCAgICAgIHRoaXMuX3BhcnNlTnVtYmVyRGVsdGEobmFtZSwgb2JqZWN0LCBpbmRleClcblx0ICAgICAgLy8gb3RoZXJ3aXNlIC0gbGlrZSBudW1iZXIgd2l0aCB1bml0c1xuXHQgICAgICA6IHRoaXMuX3BhcnNlVW5pdERlbHRhKG5hbWUsIG9iamVjdCwgaW5kZXgpO1xuXHQgICAgfVxuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBzZXBhcmF0ZSB0d2VlbiBvcHRpb25zIGZyb20gZGVsdGEgcHJvcGVydGllcy5cblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBPYmplY3QgZm9yIHNlcGFyYXRpb24uXG5cdCAgICBAcmV0dXJucyB7T2JqZWN0fSBPYmplY3QgdGhhdCBjb250YWlucyAyIG9iamVjdHNcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLSBvbmUgZGVsdGEgb3B0aW9uc1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAtIG9uZSB0d2VlbiBvcHRpb25zICggY291bGQgYmUgZW1wdHkgaWYgbm8gdHdlZW4gb3B0cyApXG5cdCAgKi9cblxuXG5cdCAgRGVsdGFzLnByb3RvdHlwZS5fc3BsaXRUd2Vlbk9wdGlvbnMgPSBmdW5jdGlvbiBfc3BsaXRUd2Vlbk9wdGlvbnMoZGVsdGEpIHtcblx0ICAgIGRlbHRhID0gKDAsIF9leHRlbmRzMy5kZWZhdWx0KSh7fSwgZGVsdGEpO1xuXG5cdCAgICB2YXIga2V5cyA9ICgwLCBfa2V5czIuZGVmYXVsdCkoZGVsdGEpLFxuXHQgICAgICAgIHR3ZWVuT3B0aW9ucyA9IHt9O1xuXHQgICAgdmFyIGlzVHdlZW4gPSBudWxsO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cdCAgICAgIGlmIChUV0VFTl9QUk9QRVJUSUVTW2tleV0pIHtcblx0ICAgICAgICBpZiAoZGVsdGFba2V5XSAhPSBudWxsKSB7XG5cdCAgICAgICAgICB0d2Vlbk9wdGlvbnNba2V5XSA9IGRlbHRhW2tleV07XG5cdCAgICAgICAgICBpc1R3ZWVuID0gdHJ1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZGVsZXRlIGRlbHRhW2tleV07XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiB7XG5cdCAgICAgIGRlbHRhOiBkZWx0YSxcblx0ICAgICAgdHdlZW5PcHRpb25zOiBpc1R3ZWVuID8gdHdlZW5PcHRpb25zIDogdW5kZWZpbmVkXG5cdCAgICB9O1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBjaGVjayBpZiB0aGUgcHJvcGVydHkgaXMgZGVsdGEgcHJvcGVydHkuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtBbnl9IFBhcmFtZXRlciB2YWx1ZSB0byBjaGVjay5cblx0ICAgIEByZXR1cm5zIHtCb29sZWFufVxuXHQgICovXG5cblxuXHQgIERlbHRhcy5wcm90b3R5cGUuX2lzRGVsdGEgPSBmdW5jdGlvbiBfaXNEZWx0YShvcHRpb25zVmFsdWUpIHtcblx0ICAgIHZhciBpc09iamVjdCA9IGguaXNPYmplY3Qob3B0aW9uc1ZhbHVlKTtcblx0ICAgIGlzT2JqZWN0ID0gaXNPYmplY3QgJiYgIW9wdGlvbnNWYWx1ZS51bml0O1xuXHQgICAgcmV0dXJuICEoIWlzT2JqZWN0IHx8IGguaXNBcnJheShvcHRpb25zVmFsdWUpIHx8IGguaXNET00ob3B0aW9uc1ZhbHVlKSk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHBhcnNlIGNvbG9yIGRlbHRhIHZhbHVlcy5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge1N0cmluZ30gTmFtZSBvZiB0aGUgcHJvcGVydHkuXG5cdCAgICBAcGFyYW0ge0FueX0gUHJvcGVydHkgdmFsdWUuXG5cdCAgICBAcmV0dXJucyB7T2JqZWN0fSBQYXJzZWQgZGVsdGEuXG5cdCAgKi9cblxuXG5cdCAgRGVsdGFzLnByb3RvdHlwZS5fcGFyc2VDb2xvckRlbHRhID0gZnVuY3Rpb24gX3BhcnNlQ29sb3JEZWx0YShrZXksIHZhbHVlKSB7XG5cdCAgICBpZiAoa2V5ID09PSAnc3Ryb2tlTGluZWNhcCcpIHtcblx0ICAgICAgaC53YXJuKCdTb3JyeSwgc3Ryb2tlLWxpbmVjYXAgcHJvcGVydHkgaXMgbm90IGFuaW1hdGFibGUgeWV0LCB1c2luZyB0aGUgc3RhcnQoI3tzdGFydH0pIHZhbHVlIGluc3RlYWQnLCB2YWx1ZSk7XG5cdCAgICAgIHJldHVybiB7fTtcblx0ICAgIH1cblx0ICAgIHZhciBwcmVQYXJzZSA9IHRoaXMuX3ByZXBhcnNlRGVsdGEodmFsdWUpO1xuXG5cdCAgICB2YXIgc3RhcnRDb2xvck9iaiA9IHRoaXMuX21ha2VDb2xvck9iaihwcmVQYXJzZS5zdGFydCksXG5cdCAgICAgICAgZW5kQ29sb3JPYmogPSB0aGlzLl9tYWtlQ29sb3JPYmoocHJlUGFyc2UuZW5kKTtcblxuXHQgICAgdmFyIGRlbHRhID0ge1xuXHQgICAgICB0eXBlOiAnY29sb3InLFxuXHQgICAgICBuYW1lOiBrZXksXG5cdCAgICAgIHN0YXJ0OiBzdGFydENvbG9yT2JqLFxuXHQgICAgICBlbmQ6IGVuZENvbG9yT2JqLFxuXHQgICAgICBjdXJ2ZTogcHJlUGFyc2UuY3VydmUsXG5cdCAgICAgIGRlbHRhOiB7XG5cdCAgICAgICAgcjogZW5kQ29sb3JPYmouciAtIHN0YXJ0Q29sb3JPYmoucixcblx0ICAgICAgICBnOiBlbmRDb2xvck9iai5nIC0gc3RhcnRDb2xvck9iai5nLFxuXHQgICAgICAgIGI6IGVuZENvbG9yT2JqLmIgLSBzdGFydENvbG9yT2JqLmIsXG5cdCAgICAgICAgYTogZW5kQ29sb3JPYmouYSAtIHN0YXJ0Q29sb3JPYmouYVxuXHQgICAgICB9XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIGRlbHRhO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBwYXJzZSBhcnJheSBkZWx0YSB2YWx1ZXMuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtTdHJpbmd9IE5hbWUgb2YgdGhlIHByb3BlcnR5LlxuXHQgICAgQHBhcmFtIHtBbnl9IFByb3BlcnR5IHZhbHVlLlxuXHQgICAgQHJldHVybnMge09iamVjdH0gUGFyc2VkIGRlbHRhLlxuXHQgICovXG5cblxuXHQgIERlbHRhcy5wcm90b3R5cGUuX3BhcnNlQXJyYXlEZWx0YSA9IGZ1bmN0aW9uIF9wYXJzZUFycmF5RGVsdGEoa2V5LCB2YWx1ZSkge1xuXHQgICAgdmFyIHByZVBhcnNlID0gdGhpcy5fcHJlcGFyc2VEZWx0YSh2YWx1ZSk7XG5cblx0ICAgIHZhciBzdGFydEFyciA9IHRoaXMuX3N0clRvQXJyKHByZVBhcnNlLnN0YXJ0KSxcblx0ICAgICAgICBlbmRBcnIgPSB0aGlzLl9zdHJUb0FycihwcmVQYXJzZS5lbmQpO1xuXG5cdCAgICBoLm5vcm1EYXNoQXJyYXlzKHN0YXJ0QXJyLCBlbmRBcnIpO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXJ0QXJyLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciBlbmQgPSBlbmRBcnJbaV07XG5cdCAgICAgIGgubWVyZ2VVbml0cyhzdGFydEFycltpXSwgZW5kLCBrZXkpO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgZGVsdGEgPSB7XG5cdCAgICAgIHR5cGU6ICdhcnJheScsXG5cdCAgICAgIG5hbWU6IGtleSxcblx0ICAgICAgc3RhcnQ6IHN0YXJ0QXJyLFxuXHQgICAgICBlbmQ6IGVuZEFycixcblx0ICAgICAgZGVsdGE6IGguY2FsY0FyckRlbHRhKHN0YXJ0QXJyLCBlbmRBcnIpLFxuXHQgICAgICBjdXJ2ZTogcHJlUGFyc2UuY3VydmVcblx0ICAgIH07XG5cblx0ICAgIHJldHVybiBkZWx0YTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gcGFyc2UgbnVtZXJpYyBkZWx0YSB2YWx1ZXMgd2l0aCB1bml0cy5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge1N0cmluZ30gTmFtZSBvZiB0aGUgcHJvcGVydHkuXG5cdCAgICBAcGFyYW0ge0FueX0gUHJvcGVydHkgdmFsdWUuXG5cdCAgICBAcGFyYW0ge051bWJlcn0gSW5kZXggb2YgdGhlIG1vZHVsZS5cblx0ICAgIEByZXR1cm5zIHtPYmplY3R9IFBhcnNlZCBkZWx0YS5cblx0ICAqL1xuXG5cblx0ICBEZWx0YXMucHJvdG90eXBlLl9wYXJzZVVuaXREZWx0YSA9IGZ1bmN0aW9uIF9wYXJzZVVuaXREZWx0YShrZXksIHZhbHVlLCBpbmRleCkge1xuXHQgICAgdmFyIHByZVBhcnNlID0gdGhpcy5fcHJlcGFyc2VEZWx0YSh2YWx1ZSk7XG5cblx0ICAgIHZhciBlbmQgPSBoLnBhcnNlVW5pdChoLnBhcnNlU3RyaW5nT3B0aW9uKHByZVBhcnNlLmVuZCwgaW5kZXgpKSxcblx0ICAgICAgICBzdGFydCA9IGgucGFyc2VVbml0KGgucGFyc2VTdHJpbmdPcHRpb24ocHJlUGFyc2Uuc3RhcnQsIGluZGV4KSk7XG5cblx0ICAgIGgubWVyZ2VVbml0cyhzdGFydCwgZW5kLCBrZXkpO1xuXHQgICAgdmFyIGRlbHRhID0ge1xuXHQgICAgICB0eXBlOiAndW5pdCcsXG5cdCAgICAgIG5hbWU6IGtleSxcblx0ICAgICAgc3RhcnQ6IHN0YXJ0LFxuXHQgICAgICBlbmQ6IGVuZCxcblx0ICAgICAgZGVsdGE6IGVuZC52YWx1ZSAtIHN0YXJ0LnZhbHVlLFxuXHQgICAgICBjdXJ2ZTogcHJlUGFyc2UuY3VydmVcblx0ICAgIH07XG5cdCAgICByZXR1cm4gZGVsdGE7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHBhcnNlIG51bWVyaWMgZGVsdGEgdmFsdWVzIHdpdGhvdXQgdW5pdHMuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtTdHJpbmd9IE5hbWUgb2YgdGhlIHByb3BlcnR5LlxuXHQgICAgQHBhcmFtIHtBbnl9IFByb3BlcnR5IHZhbHVlLlxuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IEluZGV4IG9mIHRoZSBtb2R1bGUuXG5cdCAgICBAcmV0dXJucyB7T2JqZWN0fSBQYXJzZWQgZGVsdGEuXG5cdCAgKi9cblxuXG5cdCAgRGVsdGFzLnByb3RvdHlwZS5fcGFyc2VOdW1iZXJEZWx0YSA9IGZ1bmN0aW9uIF9wYXJzZU51bWJlckRlbHRhKGtleSwgdmFsdWUsIGluZGV4KSB7XG5cdCAgICB2YXIgcHJlUGFyc2UgPSB0aGlzLl9wcmVwYXJzZURlbHRhKHZhbHVlKTtcblxuXHQgICAgdmFyIGVuZCA9IHBhcnNlRmxvYXQoaC5wYXJzZVN0cmluZ09wdGlvbihwcmVQYXJzZS5lbmQsIGluZGV4KSksXG5cdCAgICAgICAgc3RhcnQgPSBwYXJzZUZsb2F0KGgucGFyc2VTdHJpbmdPcHRpb24ocHJlUGFyc2Uuc3RhcnQsIGluZGV4KSk7XG5cblx0ICAgIHZhciBkZWx0YSA9IHtcblx0ICAgICAgdHlwZTogJ251bWJlcicsXG5cdCAgICAgIG5hbWU6IGtleSxcblx0ICAgICAgc3RhcnQ6IHN0YXJ0LFxuXHQgICAgICBlbmQ6IGVuZCxcblx0ICAgICAgZGVsdGE6IGVuZCAtIHN0YXJ0LFxuXHQgICAgICBjdXJ2ZTogcHJlUGFyc2UuY3VydmVcblx0ICAgIH07XG5cblx0ICAgIHJldHVybiBkZWx0YTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gZXh0cmFjdCBgY3VydmVgIGFuZCBgc3RhcnRgL2BlbmRgIHZhbHVlcy5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge09iamVjdH0gRGVsdGEgb2JqZWN0LlxuXHQgICAgQHJldHVybnMge09iamVjdH0gUHJlcGFyc2VkIGRlbHRhLlxuXHQgICAgICAgICAgICAgIEBwcm9wZXJ0eSB7U3RyaW5nfSBTdGFydCB2YWx1ZS5cblx0ICAgICAgICAgICAgICBAcHJvcGVydHkge1N0cmluZywgTnVtYmVyfSBFbmQgdmFsdWUuXG5cdCAgKi9cblxuXG5cdCAgRGVsdGFzLnByb3RvdHlwZS5fcHJlcGFyc2VEZWx0YSA9IGZ1bmN0aW9uIF9wcmVwYXJzZURlbHRhKHZhbHVlKSB7XG5cdCAgICAvLyBjbG9uZSB2YWx1ZSBvYmplY3Rcblx0ICAgIHZhbHVlID0gKDAsIF9leHRlbmRzMy5kZWZhdWx0KSh7fSwgdmFsdWUpO1xuXHQgICAgLy8gcGFyc2UgY3VydmUgaWYgZXhpc3Rcblx0ICAgIHZhciBjdXJ2ZSA9IHZhbHVlLmN1cnZlO1xuXHQgICAgaWYgKGN1cnZlICE9IG51bGwpIHtcblx0ICAgICAgY3VydmUgPSBlYXNpbmcucGFyc2VFYXNpbmcoY3VydmUpO1xuXHQgICAgICBjdXJ2ZS5fcGFyZW50ID0gdGhpcztcblx0ICAgIH1cblx0ICAgIGRlbGV0ZSB2YWx1ZS5jdXJ2ZTtcblx0ICAgIC8vIHBhcnNlIHN0YXJ0IGFuZCBlbmQgdmFsdWVzXG5cdCAgICB2YXIgc3RhcnQgPSAoMCwgX2tleXMyLmRlZmF1bHQpKHZhbHVlKVswXSxcblx0ICAgICAgICBlbmQgPSB2YWx1ZVtzdGFydF07XG5cblx0ICAgIHJldHVybiB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQsIGN1cnZlOiBjdXJ2ZSB9O1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBwYXJzZSBjb2xvciBpbnRvIHVzYWJsZSBvYmplY3QuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtTdHJpbmd9IENvbG9yIHN0cmluZy5cblx0ICAgIEByZXR1cm5zIHtPYmplY3R9IFBhcnNlZCBjb2xvciB2YWx1ZS5cblx0ICAqL1xuXG5cblx0ICBEZWx0YXMucHJvdG90eXBlLl9tYWtlQ29sb3JPYmogPSBmdW5jdGlvbiBfbWFrZUNvbG9yT2JqKGNvbG9yKSB7XG5cdCAgICAvLyBIRVhcblx0ICAgIHZhciBjb2xvck9iaiA9IHt9O1xuXHQgICAgaWYgKGNvbG9yWzBdID09PSAnIycpIHtcblx0ICAgICAgdmFyIHJlc3VsdCA9IC9eIz8oW2EtZlxcZF17MSwyfSkoW2EtZlxcZF17MSwyfSkoW2EtZlxcZF17MSwyfSkkL2kuZXhlYyhjb2xvcik7XG5cdCAgICAgIGlmIChyZXN1bHQpIHtcblx0ICAgICAgICB2YXIgciA9IHJlc3VsdFsxXS5sZW5ndGggPT09IDIgPyByZXN1bHRbMV0gOiByZXN1bHRbMV0gKyByZXN1bHRbMV0sXG5cdCAgICAgICAgICAgIGcgPSByZXN1bHRbMl0ubGVuZ3RoID09PSAyID8gcmVzdWx0WzJdIDogcmVzdWx0WzJdICsgcmVzdWx0WzJdLFxuXHQgICAgICAgICAgICBiID0gcmVzdWx0WzNdLmxlbmd0aCA9PT0gMiA/IHJlc3VsdFszXSA6IHJlc3VsdFszXSArIHJlc3VsdFszXTtcblxuXHQgICAgICAgIGNvbG9yT2JqID0ge1xuXHQgICAgICAgICAgcjogcGFyc2VJbnQociwgMTYpLCBnOiBwYXJzZUludChnLCAxNiksIGI6IHBhcnNlSW50KGIsIDE2KSwgYTogMVxuXHQgICAgICAgIH07XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgLy8gbm90IEhFWFxuXHQgICAgLy8gc2hvcnRoYW5kIGNvbG9yIGFuZCByZ2IoKVxuXHQgICAgaWYgKGNvbG9yWzBdICE9PSAnIycpIHtcblx0ICAgICAgdmFyIGlzUmdiID0gY29sb3JbMF0gPT09ICdyJyAmJiBjb2xvclsxXSA9PT0gJ2cnICYmIGNvbG9yWzJdID09PSAnYic7XG5cdCAgICAgIHZhciByZ2JDb2xvciA9IHZvaWQgMDtcblx0ICAgICAgLy8gcmdiIGNvbG9yXG5cdCAgICAgIGlmIChpc1JnYikge1xuXHQgICAgICAgIHJnYkNvbG9yID0gY29sb3I7XG5cdCAgICAgIH07XG5cdCAgICAgIC8vIHNob3J0aGFuZCBjb2xvciBuYW1lXG5cdCAgICAgIGlmICghaXNSZ2IpIHtcblx0ICAgICAgICBpZiAoIXRoaXMuX3Nob3J0Q29sb3JzW2NvbG9yXSkge1xuXHQgICAgICAgICAgaC5kaXYuc3R5bGUuY29sb3IgPSBjb2xvcjtcblx0ICAgICAgICAgIHJnYkNvbG9yID0gaC5jb21wdXRlZFN0eWxlKGguZGl2KS5jb2xvcjtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgcmdiQ29sb3IgPSB0aGlzLl9zaG9ydENvbG9yc1tjb2xvcl07XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgdmFyIHJlZ2V4U3RyaW5nMSA9ICdecmdiYT9cXFxcKChcXFxcZHsxLDN9KSxcXFxccz8oXFxcXGR7MSwzfSksJyxcblx0ICAgICAgICAgIHJlZ2V4U3RyaW5nMiA9ICdcXFxccz8oXFxcXGR7MSwzfSksP1xcXFxzPyhcXFxcZHsxfXwwP1xcXFwuXFxcXGR7MSx9KT9cXFxcKSQnLFxuXHQgICAgICAgICAgX3Jlc3VsdCA9IG5ldyBSZWdFeHAocmVnZXhTdHJpbmcxICsgcmVnZXhTdHJpbmcyLCAnZ2knKS5leGVjKHJnYkNvbG9yKSxcblx0ICAgICAgICAgIGFscGhhID0gcGFyc2VGbG9hdChfcmVzdWx0WzRdIHx8IDEpO1xuXG5cdCAgICAgIGlmIChfcmVzdWx0KSB7XG5cdCAgICAgICAgY29sb3JPYmogPSB7XG5cdCAgICAgICAgICByOiBwYXJzZUludChfcmVzdWx0WzFdLCAxMCksXG5cdCAgICAgICAgICBnOiBwYXJzZUludChfcmVzdWx0WzJdLCAxMCksXG5cdCAgICAgICAgICBiOiBwYXJzZUludChfcmVzdWx0WzNdLCAxMCksXG5cdCAgICAgICAgICBhOiBhbHBoYSAhPSBudWxsICYmICFpc05hTihhbHBoYSkgPyBhbHBoYSA6IDFcblx0ICAgICAgICB9O1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBjb2xvck9iajtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gcGFyc2Ugc3RyaW5nIGludG8gYXJyYXkuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtTdHJpbmcsIE51bWJlcn0gU3RyaW5nIG9yIG51bWJlciB0byBwYXJzZS5cblx0ICAgIEByZXR1cm5zIHtBcnJheX0gUGFyc2VkIGFycmF5LlxuXHQgICovXG5cblxuXHQgIERlbHRhcy5wcm90b3R5cGUuX3N0clRvQXJyID0gZnVuY3Rpb24gX3N0clRvQXJyKHN0cmluZykge1xuXHQgICAgdmFyIGFyciA9IFtdO1xuXHQgICAgLy8gcGxhaW4gbnVtYmVyXG5cdCAgICBpZiAodHlwZW9mIHN0cmluZyA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHN0cmluZykpIHtcblx0ICAgICAgYXJyLnB1c2goaC5wYXJzZVVuaXQoc3RyaW5nKSk7XG5cdCAgICAgIHJldHVybiBhcnI7XG5cdCAgICB9XG5cdCAgICAvLyBzdHJpbmcgYXJyYXlcblx0ICAgIHN0cmluZy50cmltKCkuc3BsaXQoL1xccysvZ2ltKS5mb3JFYWNoKGZ1bmN0aW9uIChzdHIpIHtcblx0ICAgICAgYXJyLnB1c2goaC5wYXJzZVVuaXQoaC5wYXJzZUlmUmFuZChzdHIpKSk7XG5cdCAgICB9KTtcblx0ICAgIHJldHVybiBhcnI7XG5cdCAgfTtcblxuXHQgIHJldHVybiBEZWx0YXM7XG5cdH0oKTtcblxuXHRleHBvcnRzLmRlZmF1bHQgPSBEZWx0YXM7XG5cbi8qKiovIH0pLFxuLyogMTI2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cblx0dmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0KTtcblxuXHR2YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cblx0dmFyIF90d2VlbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTAxKTtcblxuXHR2YXIgX3R3ZWVuMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R3ZWVuKTtcblxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5cdHZhciBoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MSk7XG5cblx0dmFyIERlbHRhID0gZnVuY3Rpb24gKCkge1xuXHQgIGZ1bmN0aW9uIERlbHRhKCkge1xuXHQgICAgdmFyIG8gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXHQgICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgRGVsdGEpO1xuXG5cdCAgICB0aGlzLl9vID0gbztcblx0ICAgIHRoaXMuX2NyZWF0ZVR3ZWVuKG8udHdlZW5PcHRpb25zKTtcblx0ICAgIC8vIGluaXRpYWwgcHJvcGVydGllcyByZW5kZXJcblx0ICAgICF0aGlzLl9vLmlzQ2hhaW5lZCAmJiB0aGlzLnJlZnJlc2godHJ1ZSk7XG5cdCAgfVxuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gY2FsbCBgX3JlZnJlc2hgIG1ldGhvZCBvbiBgdHdlZW5gLlxuXHQgICAgVXNlIHN3aXRjaCBiZXR3ZWVuIGAwYCBhbmQgYDFgIHByb2dyZXNzIGZvciBkZWx0YSB2YWx1ZS5cblx0ICAgIEBwdWJsaWNcblx0ICAgIEBwYXJhbSB7Qm9vbGVhbn0gSWYgcmVmcmVzaCBiZWZvcmUgc3RhcnQgdGltZSBvciBhZnRlci5cblx0ICAgIEByZXR1cm5zIHRoaXMuXG5cdCAgKi9cblxuXG5cdCAgRGVsdGEucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbiByZWZyZXNoKGlzQmVmb3JlKSB7XG5cdCAgICB0aGlzLl9wcmV2aW91c1ZhbHVlcyA9IFtdO1xuXG5cdCAgICB2YXIgZGVsdGFzID0gdGhpcy5fby5kZWx0YXM7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlbHRhcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIgbmFtZSA9IGRlbHRhc1tpXS5uYW1lO1xuXHQgICAgICB0aGlzLl9wcmV2aW91c1ZhbHVlcy5wdXNoKHtcblx0ICAgICAgICBuYW1lOiBuYW1lLCB2YWx1ZTogdGhpcy5fby5wcm9wc1tuYW1lXVxuXHQgICAgICB9KTtcblx0ICAgIH1cblxuXHQgICAgdGhpcy50d2Vlbi5fcmVmcmVzaChpc0JlZm9yZSk7XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gcmVzdG9yZSBhbGwgc2F2ZWQgcHJvcGVydGllcyBmcm9tIGBfcHJldmlvdXNWYWx1ZXNgIGFycmF5LlxuXHQgICAgQHB1YmxpY1xuXHQgICAgQHJldHVybnMgdGhpcy5cblx0ICAqL1xuXG5cblx0ICBEZWx0YS5wcm90b3R5cGUucmVzdG9yZSA9IGZ1bmN0aW9uIHJlc3RvcmUoKSB7XG5cdCAgICB2YXIgcHJldiA9IHRoaXMuX3ByZXZpb3VzVmFsdWVzO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmV2Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciByZWNvcmQgPSBwcmV2W2ldO1xuXHQgICAgICB0aGlzLl9vLnByb3BzW3JlY29yZC5uYW1lXSA9IHJlY29yZC52YWx1ZTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBjcmVhdGUgdHdlZW4gb2YgdGhlIGRlbHRhLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBPcHRpb25zIG9iamVjdC5cblx0ICAqL1xuXG5cblx0ICBEZWx0YS5wcm90b3R5cGUuX2NyZWF0ZVR3ZWVuID0gZnVuY3Rpb24gX2NyZWF0ZVR3ZWVuKCkge1xuXHQgICAgdmFyIG8gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG5cdCAgICB2YXIgaXQgPSB0aGlzO1xuXHQgICAgby5jYWxsYmFja092ZXJyaWRlcyA9IHtcblx0ICAgICAgb25VcGRhdGU6IGZ1bmN0aW9uIG9uVXBkYXRlKGVwLCBwKSB7XG5cdCAgICAgICAgaXQuX2NhbGNDdXJyZW50UHJvcHMoZXAsIHApO1xuXHQgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvLyBpZiBub3QgY2hhaW5lZCAtIGFkZCB0aGUgb25SZWZyZXNoIGNhbGxiYWNrXG5cdCAgICAvLyB0byByZWZyZXNoIHRoZSB0d2VlbiB3aGVuIG5lZWRlZFxuXHQgICAgaWYgKCF0aGlzLl9vLmlzQ2hhaW5lZCkge1xuXHQgICAgICBvLmNhbGxiYWNrT3ZlcnJpZGVzLm9uUmVmcmVzaCA9IGZ1bmN0aW9uIChpc0JlZm9yZSwgZXAsIHApIHtcblx0ICAgICAgICBpdC5fY2FsY0N1cnJlbnRQcm9wcyhlcCwgcCk7XG5cdCAgICAgIH07XG5cdCAgICB9XG5cblx0ICAgIG8uY2FsbGJhY2tzQ29udGV4dCA9IHRoaXMuX28uY2FsbGJhY2tzQ29udGV4dDtcblx0ICAgIHRoaXMudHdlZW4gPSBuZXcgX3R3ZWVuMi5kZWZhdWx0KG8pO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBjYWxjdWxhdGUgY3VycmVudCBwcm9ncmVzcyBvZiB0aGUgZGVsdGFzLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBFYXNlZCBwcm9ncmVzcyB0byBjYWxjdWxhdGUgLSBbMC4uMV0uXG5cdCAgICBAcGFyYW0ge051bWJlcn0gUHJvZ3Jlc3MgdG8gY2FsY3VsYXRlIC0gWzAuLjFdLlxuXHQgICovXG5cblxuXHQgIERlbHRhLnByb3RvdHlwZS5fY2FsY0N1cnJlbnRQcm9wcyA9IGZ1bmN0aW9uIF9jYWxjQ3VycmVudFByb3BzKGVhc2VkUHJvZ3Jlc3MsIHApIHtcblx0ICAgIHZhciBkZWx0YXMgPSB0aGlzLl9vLmRlbHRhcztcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVsdGFzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciB0eXBlID0gZGVsdGFzW2ldLnR5cGU7XG5cdCAgICAgIHRoaXNbJ19jYWxjQ3VycmVudF8nICsgdHlwZV0oZGVsdGFzW2ldLCBlYXNlZFByb2dyZXNzLCBwKTtcblx0ICAgIH1cblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gY2FsYyB0aGUgY3VycmVudCBjb2xvciBkZWx0YSB2YWx1ZS5cblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBEZWx0YVxuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IEVhc2VkIHByb2dyZXNzIFswLi4xXS5cblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBQbGFpbiBwcm9ncmVzcyBbMC4uMV0uXG5cdCAgKi9cblxuXG5cdCAgRGVsdGEucHJvdG90eXBlLl9jYWxjQ3VycmVudF9jb2xvciA9IGZ1bmN0aW9uIF9jYWxjQ3VycmVudF9jb2xvcihkZWx0YSwgZXAsIHApIHtcblx0ICAgIHZhciByLFxuXHQgICAgICAgIGcsXG5cdCAgICAgICAgYixcblx0ICAgICAgICBhLFxuXHQgICAgICAgIHN0YXJ0ID0gZGVsdGEuc3RhcnQsXG5cdCAgICAgICAgZCA9IGRlbHRhLmRlbHRhO1xuXHQgICAgaWYgKCFkZWx0YS5jdXJ2ZSkge1xuXHQgICAgICByID0gcGFyc2VJbnQoc3RhcnQuciArIGVwICogZC5yLCAxMCk7XG5cdCAgICAgIGcgPSBwYXJzZUludChzdGFydC5nICsgZXAgKiBkLmcsIDEwKTtcblx0ICAgICAgYiA9IHBhcnNlSW50KHN0YXJ0LmIgKyBlcCAqIGQuYiwgMTApO1xuXHQgICAgICBhID0gcGFyc2VGbG9hdChzdGFydC5hICsgZXAgKiBkLmEpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdmFyIGNwID0gZGVsdGEuY3VydmUocCk7XG5cdCAgICAgIHIgPSBwYXJzZUludChjcCAqIChzdGFydC5yICsgcCAqIGQuciksIDEwKTtcblx0ICAgICAgZyA9IHBhcnNlSW50KGNwICogKHN0YXJ0LmcgKyBwICogZC5nKSwgMTApO1xuXHQgICAgICBiID0gcGFyc2VJbnQoY3AgKiAoc3RhcnQuYiArIHAgKiBkLmIpLCAxMCk7XG5cdCAgICAgIGEgPSBwYXJzZUZsb2F0KGNwICogKHN0YXJ0LmEgKyBwICogZC5hKSk7XG5cdCAgICB9XG5cdCAgICB0aGlzLl9vLnByb3BzW2RlbHRhLm5hbWVdID0gJ3JnYmEoJyArIHIgKyAnLCcgKyBnICsgJywnICsgYiArICcsJyArIGEgKyAnKSc7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGNhbGMgdGhlIGN1cnJlbnQgbnVtYmVyIGRlbHRhIHZhbHVlLlxuXHQgICAgQHBhcmFtIHtPYmplY3R9IERlbHRhXG5cdCAgICBAcGFyYW0ge051bWJlcn0gRWFzZWQgcHJvZ3Jlc3MgWzAuLjFdLlxuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IFBsYWluIHByb2dyZXNzIFswLi4xXS5cblx0ICAqL1xuXG5cblx0ICBEZWx0YS5wcm90b3R5cGUuX2NhbGNDdXJyZW50X251bWJlciA9IGZ1bmN0aW9uIF9jYWxjQ3VycmVudF9udW1iZXIoZGVsdGEsIGVwLCBwKSB7XG5cdCAgICB0aGlzLl9vLnByb3BzW2RlbHRhLm5hbWVdID0gIWRlbHRhLmN1cnZlID8gZGVsdGEuc3RhcnQgKyBlcCAqIGRlbHRhLmRlbHRhIDogZGVsdGEuY3VydmUocCkgKiAoZGVsdGEuc3RhcnQgKyBwICogZGVsdGEuZGVsdGEpO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBjYWxjIHRoZSBjdXJyZW50IG51bWJlciB3aXRoIHVuaXRzIGRlbHRhIHZhbHVlLlxuXHQgICAgQHBhcmFtIHtPYmplY3R9IERlbHRhXG5cdCAgICBAcGFyYW0ge051bWJlcn0gRWFzZWQgcHJvZ3Jlc3MgWzAuLjFdLlxuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IFBsYWluIHByb2dyZXNzIFswLi4xXS5cblx0ICAqL1xuXG5cblx0ICBEZWx0YS5wcm90b3R5cGUuX2NhbGNDdXJyZW50X3VuaXQgPSBmdW5jdGlvbiBfY2FsY0N1cnJlbnRfdW5pdChkZWx0YSwgZXAsIHApIHtcblx0ICAgIHZhciBjdXJyZW50VmFsdWUgPSAhZGVsdGEuY3VydmUgPyBkZWx0YS5zdGFydC52YWx1ZSArIGVwICogZGVsdGEuZGVsdGEgOiBkZWx0YS5jdXJ2ZShwKSAqIChkZWx0YS5zdGFydC52YWx1ZSArIHAgKiBkZWx0YS5kZWx0YSk7XG5cblx0ICAgIHRoaXMuX28ucHJvcHNbZGVsdGEubmFtZV0gPSAnJyArIGN1cnJlbnRWYWx1ZSArIGRlbHRhLmVuZC51bml0O1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBjYWxjIHRoZSBjdXJyZW50IGFycmF5IGRlbHRhIHZhbHVlLlxuXHQgICAgQHBhcmFtIHtPYmplY3R9IERlbHRhXG5cdCAgICBAcGFyYW0ge051bWJlcn0gRWFzZWQgcHJvZ3Jlc3MgWzAuLjFdLlxuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IFBsYWluIHByb2dyZXNzIFswLi4xXS5cblx0ICAqL1xuXG5cblx0ICBEZWx0YS5wcm90b3R5cGUuX2NhbGNDdXJyZW50X2FycmF5ID0gZnVuY3Rpb24gX2NhbGNDdXJyZW50X2FycmF5KGRlbHRhLCBlcCwgcCkge1xuXHQgICAgLy8gdmFyIGFycixcblx0ICAgIHZhciBuYW1lID0gZGVsdGEubmFtZSxcblx0ICAgICAgICBwcm9wcyA9IHRoaXMuX28ucHJvcHMsXG5cdCAgICAgICAgc3RyaW5nID0gJyc7XG5cblx0ICAgIC8vIHRvIHByZXZlbnQgR0MgYm90aGVyaW5nIHdpdGggYXJyYXlzIGdhcmJhZ2Vcblx0ICAgIC8vIGlmICggaC5pc0FycmF5KCBwcm9wc1tuYW1lXSApICkge1xuXHQgICAgLy8gICBhcnIgPSBwcm9wc1tuYW1lXTtcblx0ICAgIC8vICAgYXJyLmxlbmd0aCA9IDA7XG5cdCAgICAvLyB9IGVsc2UgeyBhcnIgPSBbXTsgfVxuXG5cdCAgICAvLyBqdXN0IG9wdGltaXphdGlvbiB0byBwcmV2ZW50IGN1cnZlXG5cdCAgICAvLyBjYWxjdWxhdGlvbnMgb24gZXZlcnkgYXJyYXkgaXRlbVxuXHQgICAgdmFyIHByb2MgPSBkZWx0YS5jdXJ2ZSA/IGRlbHRhLmN1cnZlKHApIDogbnVsbDtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWx0YS5kZWx0YS5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIgaXRlbSA9IGRlbHRhLmRlbHRhW2ldLFxuXHQgICAgICAgICAgZGFzaCA9ICFkZWx0YS5jdXJ2ZSA/IGRlbHRhLnN0YXJ0W2ldLnZhbHVlICsgZXAgKiBpdGVtLnZhbHVlIDogcHJvYyAqIChkZWx0YS5zdGFydFtpXS52YWx1ZSArIHAgKiBpdGVtLnZhbHVlKTtcblxuXHQgICAgICBzdHJpbmcgKz0gJycgKyBkYXNoICsgaXRlbS51bml0ICsgJyAnO1xuXHQgICAgICAvLyBhcnIucHVzaCh7XG5cdCAgICAgIC8vICAgc3RyaW5nOiBgJHtkYXNofSR7aXRlbS51bml0fWAsXG5cdCAgICAgIC8vICAgdmFsdWU6ICBkYXNoLFxuXHQgICAgICAvLyAgIHVuaXQ6ICAgaXRlbS51bml0LFxuXHQgICAgICAvLyB9KTtcblx0ICAgIH1cblx0ICAgIHByb3BzW25hbWVdID0gc3RyaW5nO1xuXHQgIH07XG5cblx0ICByZXR1cm4gRGVsdGE7XG5cdH0oKTtcblxuXHRleHBvcnRzLmRlZmF1bHQgPSBEZWx0YTtcblxuLyoqKi8gfSksXG4vKiAxMjcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIF9rZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NSk7XG5cblx0dmFyIF9rZXlzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2tleXMpO1xuXG5cdHZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NCk7XG5cblx0dmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG5cdHZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc1KTtcblxuXHR2YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIpO1xuXG5cdHZhciBfaW5oZXJpdHMyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Nik7XG5cblx0dmFyIF9pbmhlcml0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmhlcml0czIpO1xuXG5cdHZhciBfaCA9IF9fd2VicGFja19yZXF1aXJlX18oNzEpO1xuXG5cdHZhciBfaDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oKTtcblxuXHR2YXIgX3RpbWVsaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTApO1xuXG5cdHZhciBfdGltZWxpbmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGltZWxpbmUpO1xuXG5cdHZhciBfdHVuYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTE2KTtcblxuXHR2YXIgX3R1bmFibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHVuYWJsZSk7XG5cblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuXHR2YXIgU3RhZ2dlciA9IGZ1bmN0aW9uIChfVHVuYWJsZSkge1xuXHQgICgwLCBfaW5oZXJpdHMzLmRlZmF1bHQpKFN0YWdnZXIsIF9UdW5hYmxlKTtcblxuXHQgIGZ1bmN0aW9uIFN0YWdnZXIob3B0aW9ucywgTW9kdWxlKSB7XG5cdCAgICB2YXIgX3JldDtcblxuXHQgICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgU3RhZ2dlcik7XG5cblx0ICAgIHZhciBfdGhpcyA9ICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMuZGVmYXVsdCkodGhpcywgX1R1bmFibGUuY2FsbCh0aGlzKSk7XG5cblx0ICAgIHJldHVybiBfcmV0ID0gX3RoaXMuX2luaXQob3B0aW9ucywgTW9kdWxlKSwgKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMy5kZWZhdWx0KShfdGhpcywgX3JldCk7XG5cdCAgfVxuXHQgIC8qXHJcblx0ICAgIE1ldGhvZCB0byBjcmVhdGUgdGhlbiBjaGFpbiBvbiBjaGlsZCBtb2R1bGVzLlxyXG5cdCAgICBAcGFyYW0ge09iamVjdH0gVGhlbiBvcHRpb25zLlxyXG5cdCAgICBAcmV0dXJuIHtPYmplY3R9IHRoaXMuXHJcblx0ICAqL1xuXG5cblx0ICBTdGFnZ2VyLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gdGhlbihvKSB7XG5cdCAgICBpZiAobyA9PSBudWxsKSB7XG5cdCAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfVxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9tb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIC8vIGdldCBjaGlsZCBtb2R1bGUncyBvcHRpb24gYW5kIHBhc3MgdG8gdGhlIGNoaWxkIGB0aGVuYFxuXHQgICAgICB0aGlzLl9tb2R1bGVzW2ldLnRoZW4odGhpcy5fZ2V0T3B0aW9uQnlJbmRleChpLCBvKSk7XG5cdCAgICB9XG5cdCAgICB0aGlzLnRpbWVsaW5lLl9yZWNhbGNUb3RhbER1cmF0aW9uKCk7XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXHQgIC8qXHJcblx0ICAgIE1ldGhvZCB0byB0dW5lIGNoaWxkIG1vZHVsZXMuXHJcblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBUdW5lIG9wdGlvbnMuXHJcblx0ICAgIEByZXR1cm4ge09iamVjdH0gdGhpcy5cclxuXHQgICovXG5cblxuXHQgIFN0YWdnZXIucHJvdG90eXBlLnR1bmUgPSBmdW5jdGlvbiB0dW5lKG8pIHtcblx0ICAgIGlmIChvID09IG51bGwpIHtcblx0ICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX21vZHVsZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgLy8gZ2V0IGNoaWxkIG1vZHVsZSdzIG9wdGlvbiBhbmQgcGFzcyB0byB0aGUgY2hpbGQgYHRoZW5gXG5cdCAgICAgIHRoaXMuX21vZHVsZXNbaV0udHVuZSh0aGlzLl9nZXRPcHRpb25CeUluZGV4KGksIG8pKTtcblx0ICAgIH1cblx0ICAgIHRoaXMudGltZWxpbmUuX3JlY2FsY1RvdGFsRHVyYXRpb24oKTtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cdCAgLypcclxuXHQgICAgTWV0aG9kIHRvIGdlbmVyYXRlIGNoaWxkIG1vZHVsZXMuXHJcblx0ICAgIEByZXR1cm4ge09iamVjdH0gdGhpcy5cclxuXHQgICovXG5cblxuXHQgIFN0YWdnZXIucHJvdG90eXBlLmdlbmVyYXRlID0gZnVuY3Rpb24gZ2VuZXJhdGUoKSB7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX21vZHVsZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgLy8gZ2V0IGNoaWxkIG1vZHVsZSdzIG9wdGlvbiBhbmQgcGFzcyB0byB0aGUgY2hpbGQgYHRoZW5gXG5cdCAgICAgIHRoaXMuX21vZHVsZXNbaV0uZ2VuZXJhdGUoKTtcblx0ICAgIH1cblx0ICAgIHRoaXMudGltZWxpbmUuX3JlY2FsY1RvdGFsRHVyYXRpb24oKTtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cdCAgLypcclxuXHQgICAgTWV0aG9kIHRvIGdldCBhbiBvcHRpb24gYnkgbW9kdWxvIGFuZCBuYW1lLlxyXG5cdCAgICBAcGFyYW0ge1N0cmluZ30gTmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxyXG5cdCAgICBAcGFyYW0ge051bWJlcn0gSW5kZXggZm9yIHRoZSBtb2R1bG8gY2FsY3VsYXRpb24uXHJcblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBPcHRpb25zIGhhc2ggdG8gbG9vayBpbi5cclxuXHQgICAgQHJldHVybiB7QW55fSBQcm9wZXJ0eS5cclxuXHQgICovXG5cblxuXHQgIFN0YWdnZXIucHJvdG90eXBlLl9nZXRPcHRpb25CeU1vZCA9IGZ1bmN0aW9uIF9nZXRPcHRpb25CeU1vZChuYW1lLCBpLCBzdG9yZSkge1xuXHQgICAgdmFyIHByb3BzID0gc3RvcmVbbmFtZV07XG5cdCAgICAvLyBpZiBub3QgZG9tIGxpc3QgdGhlbiBjbG9uZSBpdCB0byBhcnJheVxuXHQgICAgaWYgKHByb3BzICsgJycgPT09ICdbb2JqZWN0IE5vZGVMaXN0XScgfHwgcHJvcHMgKyAnJyA9PT0gJ1tvYmplY3QgSFRNTENvbGxlY3Rpb25dJykgcHJvcHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChwcm9wcywgMCk7XG5cdCAgICAvLyBnZXQgdGhlIHZhbHVlIGluIGFycmF5IG9yIHJldHVybiB0aGUgdmFsdWUgaXRzZWxmXG5cdCAgICB2YXIgdmFsdWUgPSBfaDIuZGVmYXVsdC5pc0FycmF5KHByb3BzKSA/IHByb3BzW2kgJSBwcm9wcy5sZW5ndGhdIDogcHJvcHM7XG5cdCAgICAvLyBjaGVjayBpZiB2YWx1ZSBoYXMgdGhlIHN0YWdnZXIgZXhwcmVzc2lvbiwgaWYgc28gcGFyc2UgaXRcblx0ICAgIHJldHVybiBfaDIuZGVmYXVsdC5wYXJzZUlmU3RhZ2dlcih2YWx1ZSwgaSk7XG5cdCAgfTtcblx0ICAvKlxyXG5cdCAgICBNZXRob2QgdG8gZ2V0IG9wdGlvbiBieSBtb2R1bG8gb2YgaW5kZXguXHJcblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBJbmRleCBmb3IgbW9kdWxvIGNhbGN1bGF0aW9ucy5cclxuXHQgICAgQHBhcmFtIHtPYmplY3R9IE9wdGlvbnMgaGFzaCB0byBsb29rIGluLlxyXG5cdCAgKi9cblxuXG5cdCAgU3RhZ2dlci5wcm90b3R5cGUuX2dldE9wdGlvbkJ5SW5kZXggPSBmdW5jdGlvbiBfZ2V0T3B0aW9uQnlJbmRleChpLCBzdG9yZSkge1xuXHQgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cblx0ICAgIHZhciBvcHRpb25zID0ge307XG5cdCAgICAoMCwgX2tleXMyLmRlZmF1bHQpKHN0b3JlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgICAgcmV0dXJuIG9wdGlvbnNba2V5XSA9IF90aGlzMi5fZ2V0T3B0aW9uQnlNb2Qoa2V5LCBpLCBzdG9yZSk7XG5cdCAgICB9KTtcblx0ICAgIHJldHVybiBvcHRpb25zO1xuXHQgIH07XG5cdCAgLypcclxuXHQgICAgTWV0aG9kIHRvIGdldCB0b3RhbCBjaGlsZCBtb2R1bGVzIHF1YW50aXR5LlxyXG5cdCAgICBAcGFyYW0gIHtTdHJpbmd9IE5hbWUgb2YgcXVhbnRpZmllciBpbiBvcHRpb25zIGhhc2guXHJcblx0ICAgIEBwYXJhbSAge09iamVjdH0gT3B0aW9ucyBoYXNoIG9iamVjdC5cclxuXHQgICAgQHJldHVybiB7TnVtYmVyfSBOdW1iZXIgb2YgY2hpbGQgb2JqZWN0IHRoYXQgc2hvdWxkIGJlIGRlZmluZWQuXHJcblx0ICAqL1xuXG5cblx0ICBTdGFnZ2VyLnByb3RvdHlwZS5fZ2V0Q2hpbGRRdWFudGl0eSA9IGZ1bmN0aW9uIF9nZXRDaGlsZFF1YW50aXR5KG5hbWUsIHN0b3JlKSB7XG5cdCAgICAvLyBpZiBudW1iZXIgd2FzIHNldFxuXHQgICAgaWYgKHR5cGVvZiBuYW1lID09PSAnbnVtYmVyJykge1xuXHQgICAgICByZXR1cm4gbmFtZTtcblx0ICAgIH1cblxuXHQgICAgdmFyIHF1YW50aWZpZXIgPSBzdG9yZVtuYW1lXTtcblx0ICAgIGlmIChfaDIuZGVmYXVsdC5pc0FycmF5KHF1YW50aWZpZXIpKSB7XG5cdCAgICAgIHJldHVybiBxdWFudGlmaWVyLmxlbmd0aDtcblx0ICAgIH0gZWxzZSBpZiAocXVhbnRpZmllciArICcnID09PSAnW29iamVjdCBOb2RlTGlzdF0nKSB7XG5cdCAgICAgIHJldHVybiBxdWFudGlmaWVyLmxlbmd0aDtcblx0ICAgIH0gZWxzZSBpZiAocXVhbnRpZmllciArICcnID09PSAnW29iamVjdCBIVE1MQ29sbGVjdGlvbl0nKSB7XG5cdCAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChxdWFudGlmaWVyLCAwKS5sZW5ndGg7XG5cdCAgICB9IGVsc2UgaWYgKHF1YW50aWZpZXIgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuXHQgICAgICByZXR1cm4gMTtcblx0ICAgIH0gZWxzZSBpZiAodHlwZW9mIHF1YW50aWZpZXIgPT0gJ3N0cmluZycpIHtcblx0ICAgICAgcmV0dXJuIDE7XG5cdCAgICB9XG5cdCAgfTtcblx0ICAvKlxyXG5cdCAgICBNZXRob2QgdG8gbWFrZSBzdGFnZ2VyIGZvcm0gb3B0aW9uc1xyXG5cdCAgICBAcGFyYW0ge09iamVjdH0gT3B0aW9ucy5cclxuXHQgICAgQHBhcmFtIHtPYmplY3R9IENoaWxkIGNsYXNzLlxyXG5cdCAgKi9cblxuXG5cdCAgU3RhZ2dlci5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiBfaW5pdChvcHRpb25zLCBNb2R1bGUpIHtcblx0ICAgIHZhciBjb3VudCA9IHRoaXMuX2dldENoaWxkUXVhbnRpdHkob3B0aW9ucy5xdWFudGlmaWVyIHx8ICdlbCcsIG9wdGlvbnMpO1xuXHQgICAgdGhpcy5fY3JlYXRlVGltZWxpbmUob3B0aW9ucyk7dGhpcy5fbW9kdWxlcyA9IFtdO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG5cdCAgICAgIC8vIGdldCBjaGlsZCBtb2R1bGUncyBvcHRpb25cblx0ICAgICAgdmFyIG9wdGlvbiA9IHRoaXMuX2dldE9wdGlvbkJ5SW5kZXgoaSwgb3B0aW9ucyk7XG5cdCAgICAgIG9wdGlvbi5pc1J1bkxlc3MgPSB0cnVlO1xuXHQgICAgICAvLyBzZXQgaW5kZXggb2YgdGhlIG1vZHVsZVxuXHQgICAgICBvcHRpb24uaW5kZXggPSBpO1xuXHQgICAgICAvLyBjcmVhdGUgY2hpbGQgbW9kdWxlXG5cdCAgICAgIHZhciBtb2R1bGUgPSBuZXcgTW9kdWxlKG9wdGlvbik7dGhpcy5fbW9kdWxlcy5wdXNoKG1vZHVsZSk7XG5cdCAgICAgIC8vIGFkZCBjaGlsZCBtb2R1bGUncyB0aW1lbGluZSB0byB0aGUgc2VsZiB0aW1lbGluZVxuXHQgICAgICB0aGlzLnRpbWVsaW5lLmFkZChtb2R1bGUpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblx0ICAvKlxyXG5cdCAgICBNZXRob2QgdG8gY3JlYXRlIHRpbWVsaW5lLlxyXG5cdCAgICBAcGFyYW0ge09iamVjdH0gVGltZWxpbmUgb3B0aW9ucy5cclxuXHQgICovXG5cblxuXHQgIFN0YWdnZXIucHJvdG90eXBlLl9jcmVhdGVUaW1lbGluZSA9IGZ1bmN0aW9uIF9jcmVhdGVUaW1lbGluZSgpIHtcblx0ICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuXHQgICAgdGhpcy50aW1lbGluZSA9IG5ldyBfdGltZWxpbmUyLmRlZmF1bHQob3B0aW9ucy50aW1lbGluZSk7XG5cdCAgfTtcblxuXHQgIC8qIEBvdmVycmlkZXMgQCBUd2VlbmFibGUgKi9cblxuXG5cdCAgU3RhZ2dlci5wcm90b3R5cGUuX21ha2VUd2VlbiA9IGZ1bmN0aW9uIF9tYWtlVHdlZW4oKSB7fTtcblxuXHQgIFN0YWdnZXIucHJvdG90eXBlLl9tYWtlVGltZWxpbmUgPSBmdW5jdGlvbiBfbWFrZVRpbWVsaW5lKCkge307XG5cblx0ICByZXR1cm4gU3RhZ2dlcjtcblx0fShfdHVuYWJsZTIuZGVmYXVsdCk7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTW9kdWxlKSB7XG5cdCAgcmV0dXJuIGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdCAgICByZXR1cm4gbmV3IFN0YWdnZXIob3B0aW9ucywgTW9kdWxlKTtcblx0ICB9O1xuXHR9O1xuXG4vKioqLyB9KSxcbi8qIDEyOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5cdHZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NCk7XG5cblx0dmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG5cdHZhciBfaCA9IF9fd2VicGFja19yZXF1aXJlX18oNzEpO1xuXG5cdHZhciBfaDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oKTtcblxuXHR2YXIgX3R3ZWVuID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDEpO1xuXG5cdHZhciBfdHdlZW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHdlZW4pO1xuXG5cdHZhciBfdGltZWxpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExMCk7XG5cblx0dmFyIF90aW1lbGluZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90aW1lbGluZSk7XG5cblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuXHQvKlxyXG5cdCAgQ2xhc3MgZm9yIHRvZ2dsaW5nIG9wYWNpdHkgb24gYnVuY2ggb2YgZWxlbWVudHNcclxuXHQgIEBjbGFzcyBTcHJpdGVyXHJcblx0ICBAdG9kb1xyXG5cdCAgICAtIGFkZCBpc0ZvcmNlM2Qgb3B0aW9uXHJcblx0ICAgIC0gYWRkIHJ1biBuZXcgb3B0aW9uIG1lcmdpbmdcclxuXHQgICAgLSBhZGQgdGhlbiBjaGFpbnNcclxuXHQqL1xuXHR2YXIgU3ByaXRlciA9IGZ1bmN0aW9uICgpIHtcblx0ICAvKlxyXG5cdCAgICBEZWZhdWx0cy9BUElzXHJcblx0ICAqL1xuXHQgIFNwcml0ZXIucHJvdG90eXBlLl9kZWNsYXJlRGVmYXVsdHMgPSBmdW5jdGlvbiBfZGVjbGFyZURlZmF1bHRzKCkge1xuXHQgICAgdGhpcy5fZGVmYXVsdHMgPSB7XG5cdCAgICAgIC8qXHJcblx0ICAgICAgICBEdXJhdGlvblxyXG5cdCAgICAgICAgQHByb3BlcnR5IGR1cmF0aW9uXHJcblx0ICAgICAgICBAdHlwZSAgICAge051bWJlcn1cclxuXHQgICAgICAqL1xuXHQgICAgICBkdXJhdGlvbjogNTAwLFxuXHQgICAgICAvKlxyXG5cdCAgICAgICAgRGVsYXlcclxuXHQgICAgICAgIEBwcm9wZXJ0eSBkZWxheVxyXG5cdCAgICAgICAgQHR5cGUgICAgIHtOdW1iZXJ9XHJcblx0ICAgICAgKi9cblx0ICAgICAgZGVsYXk6IDAsXG5cdCAgICAgIC8qXHJcblx0ICAgICAgICBFYXNpbmcuIFBsZWFzZSBzZWUgdGhlIFxyXG5cdCAgICAgICAgW3RpbWVsaW5lIG1vZHVsZSBwYXJzZUVhc2luZyBmdW5jdGlvbl0odGltZWxpbmUuY29mZmVlLmh0bWwjcGFyc2VFYXNpbmcpXHJcblx0ICAgICAgICBmb3IgYWxsIGF2YWxpYWJsZSBvcHRpb25zLlxyXG5cdCAgICAgICAgICBAcHJvcGVydHkgZWFzaW5nXHJcblx0ICAgICAgICBAdHlwZSAgICAge1N0cmluZywgRnVuY3Rpb259XHJcblx0ICAgICAgKi9cblx0ICAgICAgZWFzaW5nOiAnbGluZWFyLm5vbmUnLFxuXHQgICAgICAvKlxyXG5cdCAgICAgICAgUmVwZWF0IHRpbWVzIGNvdW50XHJcblx0ICAgICAgICBcclxuXHQgICAgICAgIEBwcm9wZXJ0eSByZXBlYXRcclxuXHQgICAgICAgIEB0eXBlICAgICB7TnVtYmVyfVxyXG5cdCAgICAgICovXG5cdCAgICAgIHJlcGVhdDogMCxcblx0ICAgICAgLypcclxuXHQgICAgICAgIFlveW8gb3B0aW9uIGRlZmluZXMgaWYgYW5pbWF0aW9uIHNob3VsZCBiZSBhbHRlcmVkIG9uIHJlcGVhdC5cclxuXHQgICAgICAgIFxyXG5cdCAgICAgICAgQHByb3BlcnR5IHlveW9cclxuXHQgICAgICAgIEB0eXBlICAgICB7Qm9vbGVhbn1cclxuXHQgICAgICAqL1xuXHQgICAgICB5b3lvOiBmYWxzZSxcblx0ICAgICAgLypcclxuXHQgICAgICAgIGlzUnVuTGVzcyBvcHRpb24gcHJldmVudHMgYW5pbWF0aW9uIGZyb20gcnVubmluZyBpbW1lZGlhdGVseSBhZnRlclxyXG5cdCAgICAgICAgaW5pdGlhbGl6YXRpb24uXHJcblx0ICAgICAgICBcclxuXHQgICAgICAgIEBwcm9wZXJ0eSBpc1J1bkxlc3NcclxuXHQgICAgICAgIEB0eXBlICAgICB7Qm9vbGVhbn1cclxuXHQgICAgICAqL1xuXHQgICAgICBpc1J1bkxlc3M6IGZhbHNlLFxuXHQgICAgICAvKlxyXG5cdCAgICAgICAgaXNTaG93RW5kIG9wdGlvbiBkZWZpbmVzIGlmIHRoZSBsYXN0IGZyYW1lIHNob3VsZCBiZSBzaG93biB3aGVuXHJcblx0ICAgICAgICBhbmltYXRpb24gY29tcGxldGVkLlxyXG5cdCAgICAgICAgXHJcblx0ICAgICAgICBAcHJvcGVydHkgaXNTaG93RW5kXHJcblx0ICAgICAgICBAdHlwZSAgICAge0Jvb2xlYW59XHJcblx0ICAgICAgKi9cblx0ICAgICAgaXNTaG93RW5kOiBmYWxzZSxcblx0ICAgICAgLypcclxuXHQgICAgICAgIG9uU3RhcnQgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgb25jZSBvbiBhbmltYXRpb24gc3RhcnQuXHJcblx0ICAgICAgICBcclxuXHQgICAgICAgIEBwcm9wZXJ0eSBvblN0YXJ0XHJcblx0ICAgICAgICBAdHlwZSAgICAge0Z1bmN0aW9ufVxyXG5cdCAgICAgICovXG5cdCAgICAgIG9uU3RhcnQ6IG51bGwsXG5cdCAgICAgIC8qXHJcblx0ICAgICAgICBvblVwZGF0ZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBvbiBldmVyeSBmcmFtZSBvZiB0aGUgYW5pbWF0aW9uLlxyXG5cdCAgICAgICAgVGhlIGN1cnJlbnQgcHJvZ3Jlc3MgaW4gcmFuZ2UgKipbMCwxXSoqIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBjYWxsYmFjay5cclxuXHQgICAgICAgIFxyXG5cdCAgICAgICAgQHByb3BlcnR5IG9uVXBkYXRlXHJcblx0ICAgICAgICBAdHlwZSAgICAge0Z1bmN0aW9ufVxyXG5cdCAgICAgICovXG5cdCAgICAgIG9uVXBkYXRlOiBudWxsLFxuXHQgICAgICAvKlxyXG5cdCAgICAgICAgb25Db21wbGV0ZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBvbmNlIG9uIGFuaW1hdGlvbiBjb21wbGV0ZS5cclxuXHQgICAgICAgIFxyXG5cdCAgICAgICAgQHByb3BlcnR5IG9uQ29tcGxldGVcclxuXHQgICAgICAgIEB0eXBlICAgICB7RnVuY3Rpb259XHJcblx0ICAgICAgKi9cblx0ICAgICAgb25Db21wbGV0ZTogbnVsbFxuXHQgICAgfTtcblx0ICB9O1xuXG5cdCAgZnVuY3Rpb24gU3ByaXRlcigpIHtcblx0ICAgIHZhciBvID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblx0ICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIFNwcml0ZXIpO1xuXG5cdCAgICB0aGlzLm8gPSBvO1xuXHQgICAgaWYgKCF0aGlzLm8uZWwpIHtcblx0ICAgICAgcmV0dXJuIF9oMi5kZWZhdWx0LmVycm9yKCdObyBcImVsXCIgb3B0aW9uIHNwZWNpZmllZCwgYWJvcnRpbmcnKTtcblx0ICAgIH1cblx0ICAgIHRoaXMuX3ZhcnMoKTt0aGlzLl9kZWNsYXJlRGVmYXVsdHMoKTt0aGlzLl9leHRlbmREZWZhdWx0cygpO3RoaXMuX3BhcnNlRnJhbWVzKCk7XG5cdCAgICBpZiAodGhpcy5fZnJhbWVzLmxlbmd0aCA8PSAyKSBfaDIuZGVmYXVsdC53YXJuKCdTcHJpdGVyOiBvbmx5ICcgKyB0aGlzLl9mcmFtZXMubGVuZ3RoICsgJyBmcmFtZXMgZm91bmQnKTtcblx0ICAgIGlmICh0aGlzLl9mcmFtZXMubGVuZ3RoIDwgMSkgX2gyLmRlZmF1bHQuZXJyb3IoXCJTcHJpdGVyOiB0aGVyZSBpcyBubyBmcmFtZXMgdG8gYW5pbWF0ZSwgYWJvcnRpbmdcIik7XG5cdCAgICB0aGlzLl9jcmVhdGVUd2VlbigpO1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfVxuXHQgIC8qXHJcblx0ICAgIE1ldGhvZCB0byBkZWNsYXJlIHNvbWUgdmFyaWFibGVzLlxyXG5cdCAgICBcclxuXHQgICAgQG1ldGhvZCBydW5cclxuXHQgICAgQHBhcmFtICB7T2JqZWN0fSBOZXcgb3B0aW9uc1xyXG5cdCAgICBAdG9kbyAgIEltcGxlbWVudCBuZXcgb2JqZWN0IG1lcmdpbmdcclxuXHQgICovXG5cblxuXHQgIFNwcml0ZXIucHJvdG90eXBlLl92YXJzID0gZnVuY3Rpb24gX3ZhcnMoKSB7XG5cdCAgICB0aGlzLl9wcm9wcyA9IF9oMi5kZWZhdWx0LmNsb25lT2JqKHRoaXMubyk7XG5cdCAgICB0aGlzLmVsID0gdGhpcy5vLmVsO1xuXHQgICAgdGhpcy5fZnJhbWVzID0gW107XG5cdCAgfTtcblx0ICAvKlxyXG5cdCAgICBNZXRob2QgdG8gcnVuIHRoZSBzcHJpdGVyIG9uIGRlbWFuZC5cclxuXHQgICAgXHJcblx0ICAgIEBtZXRob2QgcnVuXHJcblx0ICAgIEBwYXJhbSAge09iamVjdH0gTmV3IG9wdGlvbnNcclxuXHQgICAgQHRvZG8gICBJbXBsZW1lbnQgbmV3IG9iamVjdCBtZXJnaW5nXHJcblx0ICAqL1xuXG5cblx0ICBTcHJpdGVyLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiBydW4obykge1xuXHQgICAgcmV0dXJuIHRoaXMudGltZWxpbmUucGxheSgpO1xuXHQgIH07XG5cdCAgLypcclxuXHQgICAgTWV0aG9kIHRvIGV4dGVuZCBfcHJvcHMgYnkgb3B0aW9ucyh0aGlzLm8pXHJcblx0ICAgIFxyXG5cdCAgICBAbWV0aG9kIF9leHRlbmREZWZhdWx0c1xyXG5cdCAgKi9cblxuXG5cdCAgU3ByaXRlci5wcm90b3R5cGUuX2V4dGVuZERlZmF1bHRzID0gZnVuY3Rpb24gX2V4dGVuZERlZmF1bHRzKCkge1xuXHQgICAgcmV0dXJuIF9oMi5kZWZhdWx0LmV4dGVuZCh0aGlzLl9wcm9wcywgdGhpcy5fZGVmYXVsdHMpO1xuXHQgIH07XG5cdCAgLypcclxuXHQgICAgTWV0aG9kIHRvIHBhcnNlIGZyYW1lcyBhcyBjaGlsZCBub2RlcyBvZiBlbC5cclxuXHQgICAgXHJcblx0ICAgIEBtZXRob2QgX3BhcnNlRnJhbWVzXHJcblx0ICAqL1xuXG5cblx0ICBTcHJpdGVyLnByb3RvdHlwZS5fcGFyc2VGcmFtZXMgPSBmdW5jdGlvbiBfcGFyc2VGcmFtZXMoKSB7XG5cdCAgICB0aGlzLl9mcmFtZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLmVsLmNoaWxkcmVuLCAwKTtcblx0ICAgIHRoaXMuX2ZyYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChmcmFtZSwgaSkge1xuXHQgICAgICByZXR1cm4gZnJhbWUuc3R5bGUub3BhY2l0eSA9IDA7XG5cdCAgICB9KTtcblx0ICAgIHRoaXMuX2ZyYW1lU3RlcCA9IDEgLyB0aGlzLl9mcmFtZXMubGVuZ3RoO1xuXHQgIH07XG5cblx0ICAvKlxyXG5cdCAgICBNZXRob2QgdG8gY3JlYXRlIHR3ZWVuIGFuZCB0aW1lbGluZSBhbmQgc3VwcGx5IGNhbGxiYWNrcy5cclxuXHQgICAgXHJcblx0ICAgIEBtZXRob2QgX2NyZWF0ZVR3ZWVuXHJcblx0ICAqL1xuXG5cblx0ICBTcHJpdGVyLnByb3RvdHlwZS5fY3JlYXRlVHdlZW4gPSBmdW5jdGlvbiBfY3JlYXRlVHdlZW4oKSB7XG5cdCAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG5cdCAgICB0aGlzLl90d2VlbiA9IG5ldyBfdHdlZW4yLmRlZmF1bHQoe1xuXHQgICAgICBkdXJhdGlvbjogdGhpcy5fcHJvcHMuZHVyYXRpb24sXG5cdCAgICAgIGRlbGF5OiB0aGlzLl9wcm9wcy5kZWxheSxcblx0ICAgICAgeW95bzogdGhpcy5fcHJvcHMueW95byxcblx0ICAgICAgcmVwZWF0OiB0aGlzLl9wcm9wcy5yZXBlYXQsXG5cdCAgICAgIGVhc2luZzogdGhpcy5fcHJvcHMuZWFzaW5nLFxuXHQgICAgICBvblN0YXJ0OiBmdW5jdGlvbiBvblN0YXJ0KCkge1xuXHQgICAgICAgIHJldHVybiBfdGhpcy5fcHJvcHMub25TdGFydCAmJiBfdGhpcy5fcHJvcHMub25TdGFydCgpO1xuXHQgICAgICB9LFxuXHQgICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbiBvbkNvbXBsZXRlKCkge1xuXHQgICAgICAgIHJldHVybiBfdGhpcy5fcHJvcHMub25Db21wbGV0ZSAmJiBfdGhpcy5fcHJvcHMub25Db21wbGV0ZSgpO1xuXHQgICAgICB9LFxuXHQgICAgICBvblVwZGF0ZTogZnVuY3Rpb24gb25VcGRhdGUocCkge1xuXHQgICAgICAgIHJldHVybiBfdGhpcy5fc2V0UHJvZ3Jlc3MocCk7XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgdGhpcy50aW1lbGluZSA9IG5ldyBfdGltZWxpbmUyLmRlZmF1bHQoKTt0aGlzLnRpbWVsaW5lLmFkZCh0aGlzLl90d2Vlbik7XG5cdCAgICBpZiAoIXRoaXMuX3Byb3BzLmlzUnVuTGVzcykgdGhpcy5fc3RhcnRUd2VlbigpO1xuXHQgIH07XG5cblx0ICAvKlxyXG5cdCAgICBNZXRob2QgdG8gc3RhcnQgdHdlZW5cclxuXHQgICAgXHJcblx0ICAgIEBtZXRob2QgX3N0YXJ0VHdlZW5cclxuXHQgICovXG5cblxuXHQgIFNwcml0ZXIucHJvdG90eXBlLl9zdGFydFR3ZWVuID0gZnVuY3Rpb24gX3N0YXJ0VHdlZW4oKSB7XG5cdCAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuXHQgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJldHVybiBfdGhpczIudGltZWxpbmUucGxheSgpO1xuXHQgICAgfSwgMSk7XG5cdCAgfTtcblx0ICAvKlxyXG5cdCAgICBNZXRob2QgdG8gc2V0IHByb2dyZXNzIG9mIHRoZSBzcHJpdGVcclxuXHQgICAgXHJcblx0ICAgIEBtZXRob2QgX3NldFByb2dyZXNzXHJcblx0ICAgIEBwYXJhbSAge051bWJlcn0gUHJvZ3Jlc3MgaW4gcmFuZ2UgKipbMCwxXSoqXHJcblx0ICAqL1xuXG5cblx0ICBTcHJpdGVyLnByb3RvdHlwZS5fc2V0UHJvZ3Jlc3MgPSBmdW5jdGlvbiBfc2V0UHJvZ3Jlc3MocCkge1xuXHQgICAgLy8gZ2V0IHRoZSBmcmFtZSBudW1iZXJcblx0ICAgIHZhciBwcm9jID0gTWF0aC5mbG9vcihwIC8gdGhpcy5fZnJhbWVTdGVwKTtcblx0ICAgIC8vIHJlYWN0IG9ubHkgaWYgZnJhbWUgY2hhbmdlc1xuXHQgICAgaWYgKHRoaXMuX3ByZXZGcmFtZSAhPSB0aGlzLl9mcmFtZXNbcHJvY10pIHtcblx0ICAgICAgLy8gaWYgcHJldmlvdXMgZnJhbWUgaXNudCBjdXJyZW50IG9uZSwgaGlkZSBpdFxuXHQgICAgICBpZiAodGhpcy5fcHJldkZyYW1lKSB7XG5cdCAgICAgICAgdGhpcy5fcHJldkZyYW1lLnN0eWxlLm9wYWNpdHkgPSAwO1xuXHQgICAgICB9XG5cdCAgICAgIC8vIGlmIGVuZCBvZiBhbmltYXRpb24gYW5kIGlzU2hvd0VuZCBmbGFnIHdhcyBzcGVjaWZpZWRcblx0ICAgICAgLy8gdGhlbiBzaG93IHRoZSBsYXN0IGZyYW1lIGVsc2Ugc2hvdyBjdXJyZW50IGZyYW1lXG5cdCAgICAgIHZhciBjdXJyZW50TnVtID0gcCA9PT0gMSAmJiB0aGlzLl9wcm9wcy5pc1Nob3dFbmQgPyBwcm9jIC0gMSA6IHByb2M7XG5cdCAgICAgIC8vIHNob3cgdGhlIGN1cnJlbnQgZnJhbWVcblx0ICAgICAgaWYgKHRoaXMuX2ZyYW1lc1tjdXJyZW50TnVtXSkge1xuXHQgICAgICAgIHRoaXMuX2ZyYW1lc1tjdXJyZW50TnVtXS5zdHlsZS5vcGFjaXR5ID0gMTtcblx0ICAgICAgfVxuXHQgICAgICAvLyBzZXQgcHJldmlvdXMgZnJhbWUgYXMgY3VycmVudFxuXHQgICAgICB0aGlzLl9wcmV2RnJhbWUgPSB0aGlzLl9mcmFtZXNbcHJvY107XG5cdCAgICB9XG5cdCAgICBpZiAodGhpcy5fcHJvcHMub25VcGRhdGUpIHtcblx0ICAgICAgdGhpcy5fcHJvcHMub25VcGRhdGUocCk7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIHJldHVybiBTcHJpdGVyO1xuXHR9KCk7XG5cblx0ZXhwb3J0cy5kZWZhdWx0ID0gU3ByaXRlcjtcblxuLyoqKi8gfSksXG4vKiAxMjkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgTW90aW9uUGF0aCwgVGltZWxpbmUsIFR3ZWVuLCBoLCByZXNpemUsXG5cdCAgYmluZCA9IGZ1bmN0aW9uKGZuLCBtZSl7IHJldHVybiBmdW5jdGlvbigpeyByZXR1cm4gZm4uYXBwbHkobWUsIGFyZ3VtZW50cyk7IH07IH07XG5cblx0aCA9IF9fd2VicGFja19yZXF1aXJlX18oNzEpO1xuXG5cdHJlc2l6ZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTMwKTtcblxuXHRUd2VlbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTAxKVtcImRlZmF1bHRcIl07XG5cblx0VGltZWxpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExMClbXCJkZWZhdWx0XCJdO1xuXG5cdE1vdGlvblBhdGggPSAoZnVuY3Rpb24oKSB7XG5cdCAgTW90aW9uUGF0aC5wcm90b3R5cGUuZGVmYXVsdHMgPSB7XG5cdCAgICBwYXRoOiBudWxsLFxuXHQgICAgY3VydmF0dXJlOiB7XG5cdCAgICAgIHg6ICc3NSUnLFxuXHQgICAgICB5OiAnNTAlJ1xuXHQgICAgfSxcblx0ICAgIGlzQ29tcG9zaXRlTGF5ZXI6IHRydWUsXG5cdCAgICBkZWxheTogMCxcblx0ICAgIGR1cmF0aW9uOiAxMDAwLFxuXHQgICAgZWFzaW5nOiBudWxsLFxuXHQgICAgcmVwZWF0OiAwLFxuXHQgICAgeW95bzogZmFsc2UsXG5cdCAgICBvblN0YXJ0OiBudWxsLFxuXHQgICAgb25Db21wbGV0ZTogbnVsbCxcblx0ICAgIG9uVXBkYXRlOiBudWxsLFxuXHQgICAgb2Zmc2V0WDogMCxcblx0ICAgIG9mZnNldFk6IDAsXG5cdCAgICBhbmdsZU9mZnNldDogbnVsbCxcblx0ICAgIHBhdGhTdGFydDogMCxcblx0ICAgIHBhdGhFbmQ6IDEsXG5cdCAgICBtb3Rpb25CbHVyOiAwLFxuXHQgICAgdHJhbnNmb3JtT3JpZ2luOiBudWxsLFxuXHQgICAgaXNBbmdsZTogZmFsc2UsXG5cdCAgICBpc1JldmVyc2U6IGZhbHNlLFxuXHQgICAgaXNSdW5MZXNzOiBmYWxzZSxcblx0ICAgIGlzUHJlc2V0UG9zaXRpb246IHRydWVcblx0ICB9O1xuXG5cdCAgZnVuY3Rpb24gTW90aW9uUGF0aChvMSkge1xuXHQgICAgdGhpcy5vID0gbzEgIT0gbnVsbCA/IG8xIDoge307XG5cdCAgICB0aGlzLmNhbGNIZWlnaHQgPSBiaW5kKHRoaXMuY2FsY0hlaWdodCwgdGhpcyk7XG5cdCAgICBpZiAodGhpcy52YXJzKCkpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgdGhpcy5jcmVhdGVUd2VlbigpO1xuXHQgICAgdGhpcztcblx0ICB9XG5cblx0ICBNb3Rpb25QYXRoLnByb3RvdHlwZS52YXJzID0gZnVuY3Rpb24oKSB7XG5cdCAgICB0aGlzLmdldFNjYWxlciA9IGguYmluZCh0aGlzLmdldFNjYWxlciwgdGhpcyk7XG5cdCAgICB0aGlzLnJlc2l6ZSA9IHJlc2l6ZTtcblx0ICAgIHRoaXMucHJvcHMgPSBoLmNsb25lT2JqKHRoaXMuZGVmYXVsdHMpO1xuXHQgICAgdGhpcy5leHRlbmRPcHRpb25zKHRoaXMubyk7XG5cdCAgICB0aGlzLmlzTW90aW9uQmx1clJlc2V0ID0gaC5pc1NhZmFyaSB8fCBoLmlzSUU7XG5cdCAgICB0aGlzLmlzTW90aW9uQmx1clJlc2V0ICYmICh0aGlzLnByb3BzLm1vdGlvbkJsdXIgPSAwKTtcblx0ICAgIHRoaXMuaGlzdG9yeSA9IFtoLmNsb25lT2JqKHRoaXMucHJvcHMpXTtcblx0ICAgIHJldHVybiB0aGlzLnBvc3RWYXJzKCk7XG5cdCAgfTtcblxuXHQgIE1vdGlvblBhdGgucHJvdG90eXBlLmN1cnZlVG9QYXRoID0gZnVuY3Rpb24obykge1xuXHQgICAgdmFyIGFuZ2xlLCBjdXJ2YXR1cmUsIGN1cnZhdHVyZVgsIGN1cnZhdHVyZVksIGN1cnZlUG9pbnQsIGN1cnZlWFBvaW50LCBkWCwgZFksIGVuZFBvaW50LCBwYXRoLCBwZXJjZW50LCByYWRpdXMsIHN0YXJ0O1xuXHQgICAgcGF0aCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhoLk5TLCAncGF0aCcpO1xuXHQgICAgc3RhcnQgPSBvLnN0YXJ0O1xuXHQgICAgZW5kUG9pbnQgPSB7XG5cdCAgICAgIHg6IHN0YXJ0LnggKyBvLnNoaWZ0LngsXG5cdCAgICAgIHk6IHN0YXJ0LnggKyBvLnNoaWZ0Lnlcblx0ICAgIH07XG5cdCAgICBjdXJ2YXR1cmUgPSBvLmN1cnZhdHVyZTtcblx0ICAgIGRYID0gby5zaGlmdC54O1xuXHQgICAgZFkgPSBvLnNoaWZ0Lnk7XG5cdCAgICByYWRpdXMgPSBNYXRoLnNxcnQoZFggKiBkWCArIGRZICogZFkpO1xuXHQgICAgcGVyY2VudCA9IHJhZGl1cyAvIDEwMDtcblx0ICAgIGFuZ2xlID0gTWF0aC5hdGFuKGRZIC8gZFgpICogKDE4MCAvIE1hdGguUEkpICsgOTA7XG5cdCAgICBpZiAoby5zaGlmdC54IDwgMCkge1xuXHQgICAgICBhbmdsZSA9IGFuZ2xlICsgMTgwO1xuXHQgICAgfVxuXHQgICAgY3VydmF0dXJlWCA9IGgucGFyc2VVbml0KGN1cnZhdHVyZS54KTtcblx0ICAgIGN1cnZhdHVyZVggPSBjdXJ2YXR1cmVYLnVuaXQgPT09ICclJyA/IGN1cnZhdHVyZVgudmFsdWUgKiBwZXJjZW50IDogY3VydmF0dXJlWC52YWx1ZTtcblx0ICAgIGN1cnZlWFBvaW50ID0gaC5nZXRSYWRpYWxQb2ludCh7XG5cdCAgICAgIGNlbnRlcjoge1xuXHQgICAgICAgIHg6IHN0YXJ0LngsXG5cdCAgICAgICAgeTogc3RhcnQueVxuXHQgICAgICB9LFxuXHQgICAgICByYWRpdXM6IGN1cnZhdHVyZVgsXG5cdCAgICAgIGFuZ2xlOiBhbmdsZVxuXHQgICAgfSk7XG5cdCAgICBjdXJ2YXR1cmVZID0gaC5wYXJzZVVuaXQoY3VydmF0dXJlLnkpO1xuXHQgICAgY3VydmF0dXJlWSA9IGN1cnZhdHVyZVkudW5pdCA9PT0gJyUnID8gY3VydmF0dXJlWS52YWx1ZSAqIHBlcmNlbnQgOiBjdXJ2YXR1cmVZLnZhbHVlO1xuXHQgICAgY3VydmVQb2ludCA9IGguZ2V0UmFkaWFsUG9pbnQoe1xuXHQgICAgICBjZW50ZXI6IHtcblx0ICAgICAgICB4OiBjdXJ2ZVhQb2ludC54LFxuXHQgICAgICAgIHk6IGN1cnZlWFBvaW50Lnlcblx0ICAgICAgfSxcblx0ICAgICAgcmFkaXVzOiBjdXJ2YXR1cmVZLFxuXHQgICAgICBhbmdsZTogYW5nbGUgKyA5MFxuXHQgICAgfSk7XG5cdCAgICBwYXRoLnNldEF0dHJpYnV0ZSgnZCcsIFwiTVwiICsgc3RhcnQueCArIFwiLFwiICsgc3RhcnQueSArIFwiIFFcIiArIGN1cnZlUG9pbnQueCArIFwiLFwiICsgY3VydmVQb2ludC55ICsgXCIgXCIgKyBlbmRQb2ludC54ICsgXCIsXCIgKyBlbmRQb2ludC55KTtcblx0ICAgIHJldHVybiBwYXRoO1xuXHQgIH07XG5cblx0ICBNb3Rpb25QYXRoLnByb3RvdHlwZS5wb3N0VmFycyA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdGhpcy5wcm9wcy5wYXRoU3RhcnQgPSBoLmNsYW1wKHRoaXMucHJvcHMucGF0aFN0YXJ0LCAwLCAxKTtcblx0ICAgIHRoaXMucHJvcHMucGF0aEVuZCA9IGguY2xhbXAodGhpcy5wcm9wcy5wYXRoRW5kLCB0aGlzLnByb3BzLnBhdGhTdGFydCwgMSk7XG5cdCAgICB0aGlzLmFuZ2xlID0gMDtcblx0ICAgIHRoaXMuc3BlZWRYID0gMDtcblx0ICAgIHRoaXMuc3BlZWRZID0gMDtcblx0ICAgIHRoaXMuYmx1clggPSAwO1xuXHQgICAgdGhpcy5ibHVyWSA9IDA7XG5cdCAgICB0aGlzLnByZXZDb29yZHMgPSB7fTtcblx0ICAgIHRoaXMuYmx1ckFtb3VudCA9IDIwO1xuXHQgICAgdGhpcy5wcm9wcy5tb3Rpb25CbHVyID0gaC5jbGFtcCh0aGlzLnByb3BzLm1vdGlvbkJsdXIsIDAsIDEpO1xuXHQgICAgdGhpcy5vblVwZGF0ZSA9IHRoaXMucHJvcHMub25VcGRhdGU7XG5cdCAgICBpZiAoIXRoaXMuby5lbCkge1xuXHQgICAgICBoLmVycm9yKCdNaXNzZWQgXCJlbFwiIG9wdGlvbi4gSXQgY291bGQgYmUgYSBzZWxlY3RvciwgRE9NTm9kZSBvciBhbm90aGVyIG1vZHVsZS4nKTtcblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cdCAgICB0aGlzLmVsID0gdGhpcy5wYXJzZUVsKHRoaXMucHJvcHMuZWwpO1xuXHQgICAgdGhpcy5wcm9wcy5tb3Rpb25CbHVyID4gMCAmJiB0aGlzLmNyZWF0ZUZpbHRlcigpO1xuXHQgICAgdGhpcy5wYXRoID0gdGhpcy5nZXRQYXRoKCk7XG5cdCAgICBpZiAoIXRoaXMucGF0aC5nZXRBdHRyaWJ1dGUoJ2QnKSkge1xuXHQgICAgICBoLmVycm9yKCdQYXRoIGhhcyBubyBjb29yZGluYXRlcyB0byB3b3JrIHdpdGgsIGFib3J0aW5nJyk7XG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXHQgICAgdGhpcy5sZW4gPSB0aGlzLnBhdGguZ2V0VG90YWxMZW5ndGgoKTtcblx0ICAgIHRoaXMuc2xpY2VkTGVuID0gdGhpcy5sZW4gKiAodGhpcy5wcm9wcy5wYXRoRW5kIC0gdGhpcy5wcm9wcy5wYXRoU3RhcnQpO1xuXHQgICAgdGhpcy5zdGFydExlbiA9IHRoaXMucHJvcHMucGF0aFN0YXJ0ICogdGhpcy5sZW47XG5cdCAgICB0aGlzLmZpbGwgPSB0aGlzLnByb3BzLmZpbGw7XG5cdCAgICBpZiAodGhpcy5maWxsICE9IG51bGwpIHtcblx0ICAgICAgdGhpcy5jb250YWluZXIgPSB0aGlzLnBhcnNlRWwodGhpcy5wcm9wcy5maWxsLmNvbnRhaW5lcik7XG5cdCAgICAgIHRoaXMuZmlsbFJ1bGUgPSB0aGlzLnByb3BzLmZpbGwuZmlsbFJ1bGUgfHwgJ2FsbCc7XG5cdCAgICAgIHRoaXMuZ2V0U2NhbGVyKCk7XG5cdCAgICAgIGlmICh0aGlzLmNvbnRhaW5lciAhPSBudWxsKSB7XG5cdCAgICAgICAgdGhpcy5yZW1vdmVFdmVudCh0aGlzLmNvbnRhaW5lciwgJ29ucmVzaXplJywgdGhpcy5nZXRTY2FsZXIpO1xuXHQgICAgICAgIHJldHVybiB0aGlzLmFkZEV2ZW50KHRoaXMuY29udGFpbmVyLCAnb25yZXNpemUnLCB0aGlzLmdldFNjYWxlcik7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgTW90aW9uUGF0aC5wcm90b3R5cGUuYWRkRXZlbnQgPSBmdW5jdGlvbihlbCwgdHlwZSwgaGFuZGxlcikge1xuXHQgICAgcmV0dXJuIGVsLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgZmFsc2UpO1xuXHQgIH07XG5cblx0ICBNb3Rpb25QYXRoLnByb3RvdHlwZS5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uKGVsLCB0eXBlLCBoYW5kbGVyKSB7XG5cdCAgICByZXR1cm4gZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XG5cdCAgfTtcblxuXHQgIE1vdGlvblBhdGgucHJvdG90eXBlLmNyZWF0ZUZpbHRlciA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIGRpdiwgc3ZnO1xuXHQgICAgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdCAgICB0aGlzLmZpbHRlcklEID0gXCJmaWx0ZXItXCIgKyAoaC5nZXRVbmlxSUQoKSk7XG5cdCAgICBkaXYuaW5uZXJIVE1MID0gXCI8c3ZnIGlkPVxcXCJzdmctXCIgKyB0aGlzLmZpbHRlcklEICsgXCJcXFwiXFxuICAgIHN0eWxlPVxcXCJ2aXNpYmlsaXR5OmhpZGRlbjsgd2lkdGg6MHB4OyBoZWlnaHQ6MHB4XFxcIj5cXG4gIDxmaWx0ZXIgaWQ9XFxcIlwiICsgdGhpcy5maWx0ZXJJRCArIFwiXFxcIiB5PVxcXCItMjBcXFwiIHg9XFxcIi0yMFxcXCIgd2lkdGg9XFxcIjQwXFxcIiBoZWlnaHQ9XFxcIjQwXFxcIj5cXG4gICAgPGZlT2Zmc2V0XFxuICAgICAgaWQ9XFxcImJsdXItb2Zmc2V0XFxcIiBpbj1cXFwiU291cmNlR3JhcGhpY1xcXCJcXG4gICAgICBkeD1cXFwiMFxcXCIgZHk9XFxcIjBcXFwiIHJlc3VsdD1cXFwib2Zmc2V0MlxcXCI+PC9mZU9mZnNldD5cXG4gICAgPGZlR2F1c3NpYW5ibHVyXFxuICAgICAgaWQ9XFxcImJsdXJcXFwiIGluPVxcXCJvZmZzZXQyXFxcIlxcbiAgICAgIHN0ZERldmlhdGlvbj1cXFwiMCwwXFxcIiByZXN1bHQ9XFxcImJsdXIyXFxcIj48L2ZlR2F1c3NpYW5ibHVyPlxcbiAgICA8ZmVNZXJnZT5cXG4gICAgICA8ZmVNZXJnZU5vZGUgaW49XFxcIlNvdXJjZUdyYXBoaWNcXFwiPjwvZmVNZXJnZU5vZGU+XFxuICAgICAgPGZlTWVyZ2VOb2RlIGluPVxcXCJibHVyMlxcXCI+PC9mZU1lcmdlTm9kZT5cXG4gICAgPC9mZU1lcmdlPlxcbiAgPC9maWx0ZXI+XFxuPC9zdmc+XCI7XG5cdCAgICBzdmcgPSBkaXYucXVlcnlTZWxlY3RvcihcIiNzdmctXCIgKyB0aGlzLmZpbHRlcklEKTtcblx0ICAgIHRoaXMuZmlsdGVyID0gc3ZnLnF1ZXJ5U2VsZWN0b3IoJyNibHVyJyk7XG5cdCAgICB0aGlzLmZpbHRlck9mZnNldCA9IHN2Zy5xdWVyeVNlbGVjdG9yKCcjYmx1ci1vZmZzZXQnKTtcblx0ICAgIGRvY3VtZW50LmJvZHkuaW5zZXJ0QmVmb3JlKHN2ZywgZG9jdW1lbnQuYm9keS5maXJzdENoaWxkKTtcblx0ICAgIHRoaXMuZWwuc3R5bGVbJ2ZpbHRlciddID0gXCJ1cmwoI1wiICsgdGhpcy5maWx0ZXJJRCArIFwiKVwiO1xuXHQgICAgcmV0dXJuIHRoaXMuZWwuc3R5bGVbaC5wcmVmaXguY3NzICsgXCJmaWx0ZXJcIl0gPSBcInVybCgjXCIgKyB0aGlzLmZpbHRlcklEICsgXCIpXCI7XG5cdCAgfTtcblxuXHQgIE1vdGlvblBhdGgucHJvdG90eXBlLnBhcnNlRWwgPSBmdW5jdGlvbihlbCkge1xuXHQgICAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcblx0ICAgICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWwpO1xuXHQgICAgfVxuXHQgICAgaWYgKGVsIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcblx0ICAgICAgcmV0dXJuIGVsO1xuXHQgICAgfVxuXHQgICAgaWYgKGVsLl9zZXRQcm9wICE9IG51bGwpIHtcblx0ICAgICAgdGhpcy5pc01vZHVsZSA9IHRydWU7XG5cdCAgICAgIHJldHVybiBlbDtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgTW90aW9uUGF0aC5wcm90b3R5cGUuZ2V0UGF0aCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIHBhdGg7XG5cdCAgICBwYXRoID0gaC5wYXJzZVBhdGgodGhpcy5wcm9wcy5wYXRoKTtcblx0ICAgIGlmIChwYXRoKSB7XG5cdCAgICAgIHJldHVybiBwYXRoO1xuXHQgICAgfVxuXHQgICAgaWYgKHRoaXMucHJvcHMucGF0aC54IHx8IHRoaXMucHJvcHMucGF0aC55KSB7XG5cdCAgICAgIHJldHVybiB0aGlzLmN1cnZlVG9QYXRoKHtcblx0ICAgICAgICBzdGFydDoge1xuXHQgICAgICAgICAgeDogMCxcblx0ICAgICAgICAgIHk6IDBcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNoaWZ0OiB7XG5cdCAgICAgICAgICB4OiB0aGlzLnByb3BzLnBhdGgueCB8fCAwLFxuXHQgICAgICAgICAgeTogdGhpcy5wcm9wcy5wYXRoLnkgfHwgMFxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgY3VydmF0dXJlOiB7XG5cdCAgICAgICAgICB4OiB0aGlzLnByb3BzLmN1cnZhdHVyZS54IHx8IHRoaXMuZGVmYXVsdHMuY3VydmF0dXJlLngsXG5cdCAgICAgICAgICB5OiB0aGlzLnByb3BzLmN1cnZhdHVyZS55IHx8IHRoaXMuZGVmYXVsdHMuY3VydmF0dXJlLnlcblx0ICAgICAgICB9XG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICBNb3Rpb25QYXRoLnByb3RvdHlwZS5nZXRTY2FsZXIgPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciBlbmQsIHNpemUsIHN0YXJ0O1xuXHQgICAgdGhpcy5jU2l6ZSA9IHtcblx0ICAgICAgd2lkdGg6IHRoaXMuY29udGFpbmVyLm9mZnNldFdpZHRoIHx8IDAsXG5cdCAgICAgIGhlaWdodDogdGhpcy5jb250YWluZXIub2Zmc2V0SGVpZ2h0IHx8IDBcblx0ICAgIH07XG5cdCAgICBzdGFydCA9IHRoaXMucGF0aC5nZXRQb2ludEF0TGVuZ3RoKDApO1xuXHQgICAgZW5kID0gdGhpcy5wYXRoLmdldFBvaW50QXRMZW5ndGgodGhpcy5sZW4pO1xuXHQgICAgc2l6ZSA9IHt9O1xuXHQgICAgdGhpcy5zY2FsZXIgPSB7fTtcblx0ICAgIHNpemUud2lkdGggPSBlbmQueCA+PSBzdGFydC54ID8gZW5kLnggLSBzdGFydC54IDogc3RhcnQueCAtIGVuZC54O1xuXHQgICAgc2l6ZS5oZWlnaHQgPSBlbmQueSA+PSBzdGFydC55ID8gZW5kLnkgLSBzdGFydC55IDogc3RhcnQueSAtIGVuZC55O1xuXHQgICAgc3dpdGNoICh0aGlzLmZpbGxSdWxlKSB7XG5cdCAgICAgIGNhc2UgJ2FsbCc6XG5cdCAgICAgICAgdGhpcy5jYWxjV2lkdGgoc2l6ZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuY2FsY0hlaWdodChzaXplKTtcblx0ICAgICAgY2FzZSAnd2lkdGgnOlxuXHQgICAgICAgIHRoaXMuY2FsY1dpZHRoKHNpemUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzLnNjYWxlci55ID0gdGhpcy5zY2FsZXIueDtcblx0ICAgICAgY2FzZSAnaGVpZ2h0Jzpcblx0ICAgICAgICB0aGlzLmNhbGNIZWlnaHQoc2l6ZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGVyLnggPSB0aGlzLnNjYWxlci55O1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICBNb3Rpb25QYXRoLnByb3RvdHlwZS5jYWxjV2lkdGggPSBmdW5jdGlvbihzaXplKSB7XG5cdCAgICB0aGlzLnNjYWxlci54ID0gdGhpcy5jU2l6ZS53aWR0aCAvIHNpemUud2lkdGg7XG5cdCAgICByZXR1cm4gIWlzRmluaXRlKHRoaXMuc2NhbGVyLngpICYmICh0aGlzLnNjYWxlci54ID0gMSk7XG5cdCAgfTtcblxuXHQgIE1vdGlvblBhdGgucHJvdG90eXBlLmNhbGNIZWlnaHQgPSBmdW5jdGlvbihzaXplKSB7XG5cdCAgICB0aGlzLnNjYWxlci55ID0gdGhpcy5jU2l6ZS5oZWlnaHQgLyBzaXplLmhlaWdodDtcblx0ICAgIHJldHVybiAhaXNGaW5pdGUodGhpcy5zY2FsZXIueSkgJiYgKHRoaXMuc2NhbGVyLnkgPSAxKTtcblx0ICB9O1xuXG5cdCAgTW90aW9uUGF0aC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24obykge1xuXHQgICAgdmFyIGZpc3RJdGVtLCBrZXksIHZhbHVlO1xuXHQgICAgaWYgKG8pIHtcblx0ICAgICAgZmlzdEl0ZW0gPSB0aGlzLmhpc3RvcnlbMF07XG5cdCAgICAgIGZvciAoa2V5IGluIG8pIHtcblx0ICAgICAgICB2YWx1ZSA9IG9ba2V5XTtcblx0ICAgICAgICBpZiAoaC5jYWxsYmFja3NNYXBba2V5XSB8fCBoLnR3ZWVuT3B0aW9uTWFwW2tleV0pIHtcblx0ICAgICAgICAgIGgud2FybihcInRoZSBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgcHJvcGVydHkgY2FuIG5vdCBiZSBvdmVycmlkZGVuIG9uIHJ1biB5ZXRcIik7XG5cdCAgICAgICAgICBkZWxldGUgb1trZXldO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICB0aGlzLmhpc3RvcnlbMF1ba2V5XSA9IHZhbHVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICB0aGlzLnR1bmVPcHRpb25zKG8pO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRoaXMuc3RhcnRUd2VlbigpO1xuXHQgIH07XG5cblx0ICBNb3Rpb25QYXRoLnByb3RvdHlwZS5jcmVhdGVUd2VlbiA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdGhpcy50d2VlbiA9IG5ldyBUd2Vlbih7XG5cdCAgICAgIGR1cmF0aW9uOiB0aGlzLnByb3BzLmR1cmF0aW9uLFxuXHQgICAgICBkZWxheTogdGhpcy5wcm9wcy5kZWxheSxcblx0ICAgICAgeW95bzogdGhpcy5wcm9wcy55b3lvLFxuXHQgICAgICByZXBlYXQ6IHRoaXMucHJvcHMucmVwZWF0LFxuXHQgICAgICBlYXNpbmc6IHRoaXMucHJvcHMuZWFzaW5nLFxuXHQgICAgICBvblN0YXJ0OiAoZnVuY3Rpb24oX3RoaXMpIHtcblx0ICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICB2YXIgcmVmO1xuXHQgICAgICAgICAgcmV0dXJuIChyZWYgPSBfdGhpcy5wcm9wcy5vblN0YXJ0KSAhPSBudWxsID8gcmVmLmFwcGx5KF90aGlzKSA6IHZvaWQgMDtcblx0ICAgICAgICB9O1xuXHQgICAgICB9KSh0aGlzKSxcblx0ICAgICAgb25Db21wbGV0ZTogKGZ1bmN0aW9uKF90aGlzKSB7XG5cdCAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgdmFyIHJlZjtcblx0ICAgICAgICAgIF90aGlzLnByb3BzLm1vdGlvbkJsdXIgJiYgX3RoaXMuc2V0Qmx1cih7XG5cdCAgICAgICAgICAgIGJsdXI6IHtcblx0ICAgICAgICAgICAgICB4OiAwLFxuXHQgICAgICAgICAgICAgIHk6IDBcblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgb2Zmc2V0OiB7XG5cdCAgICAgICAgICAgICAgeDogMCxcblx0ICAgICAgICAgICAgICB5OiAwXG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgcmV0dXJuIChyZWYgPSBfdGhpcy5wcm9wcy5vbkNvbXBsZXRlKSAhPSBudWxsID8gcmVmLmFwcGx5KF90aGlzKSA6IHZvaWQgMDtcblx0ICAgICAgICB9O1xuXHQgICAgICB9KSh0aGlzKSxcblx0ICAgICAgb25VcGRhdGU6IChmdW5jdGlvbihfdGhpcykge1xuXHQgICAgICAgIHJldHVybiBmdW5jdGlvbihwKSB7XG5cdCAgICAgICAgICByZXR1cm4gX3RoaXMuc2V0UHJvZ3Jlc3MocCk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgfSkodGhpcyksXG5cdCAgICAgIG9uRmlyc3RVcGRhdGU6IChmdW5jdGlvbihfdGhpcykge1xuXHQgICAgICAgIHJldHVybiBmdW5jdGlvbihpc0ZvcndhcmQsIGlzWW95bykge1xuXHQgICAgICAgICAgaWYgKCFpc0ZvcndhcmQpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIF90aGlzLmhpc3RvcnkubGVuZ3RoID4gMSAmJiBfdGhpcy50dW5lT3B0aW9ucyhfdGhpcy5oaXN0b3J5WzBdKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9O1xuXHQgICAgICB9KSh0aGlzKVxuXHQgICAgfSk7XG5cdCAgICB0aGlzLnRpbWVsaW5lID0gbmV3IFRpbWVsaW5lO1xuXHQgICAgdGhpcy50aW1lbGluZS5hZGQodGhpcy50d2Vlbik7XG5cdCAgICAhdGhpcy5wcm9wcy5pc1J1bkxlc3MgJiYgdGhpcy5zdGFydFR3ZWVuKCk7XG5cdCAgICByZXR1cm4gdGhpcy5wcm9wcy5pc1ByZXNldFBvc2l0aW9uICYmIHRoaXMuc2V0UHJvZ3Jlc3MoMCwgdHJ1ZSk7XG5cdCAgfTtcblxuXHQgIE1vdGlvblBhdGgucHJvdG90eXBlLnN0YXJ0VHdlZW4gPSBmdW5jdGlvbigpIHtcblx0ICAgIHJldHVybiBzZXRUaW1lb3V0KCgoZnVuY3Rpb24oX3RoaXMpIHtcblx0ICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuXHQgICAgICAgIHZhciByZWY7XG5cdCAgICAgICAgcmV0dXJuIChyZWYgPSBfdGhpcy50aW1lbGluZSkgIT0gbnVsbCA/IHJlZi5wbGF5KCkgOiB2b2lkIDA7XG5cdCAgICAgIH07XG5cdCAgICB9KSh0aGlzKSksIDEpO1xuXHQgIH07XG5cblx0ICBNb3Rpb25QYXRoLnByb3RvdHlwZS5zZXRQcm9ncmVzcyA9IGZ1bmN0aW9uKHAsIGlzSW5pdCkge1xuXHQgICAgdmFyIGxlbiwgcG9pbnQsIHgsIHk7XG5cdCAgICBsZW4gPSB0aGlzLnN0YXJ0TGVuICsgKCF0aGlzLnByb3BzLmlzUmV2ZXJzZSA/IHAgKiB0aGlzLnNsaWNlZExlbiA6ICgxIC0gcCkgKiB0aGlzLnNsaWNlZExlbik7XG5cdCAgICBwb2ludCA9IHRoaXMucGF0aC5nZXRQb2ludEF0TGVuZ3RoKGxlbik7XG5cdCAgICB4ID0gcG9pbnQueCArIHRoaXMucHJvcHMub2Zmc2V0WDtcblx0ICAgIHkgPSBwb2ludC55ICsgdGhpcy5wcm9wcy5vZmZzZXRZO1xuXHQgICAgdGhpcy5fZ2V0Q3VycmVudEFuZ2xlKHBvaW50LCBsZW4sIHApO1xuXHQgICAgdGhpcy5fc2V0VHJhbnNmb3JtT3JpZ2luKHApO1xuXHQgICAgdGhpcy5fc2V0VHJhbnNmb3JtKHgsIHksIHAsIGlzSW5pdCk7XG5cdCAgICByZXR1cm4gdGhpcy5wcm9wcy5tb3Rpb25CbHVyICYmIHRoaXMubWFrZU1vdGlvbkJsdXIoeCwgeSk7XG5cdCAgfTtcblxuXHQgIE1vdGlvblBhdGgucHJvdG90eXBlLnNldEVsUG9zaXRpb24gPSBmdW5jdGlvbih4LCB5LCBwKSB7XG5cdCAgICB2YXIgY29tcG9zaXRlLCBpc0NvbXBvc2l0ZSwgcm90YXRlLCB0cmFuc2Zvcm07XG5cdCAgICByb3RhdGUgPSB0aGlzLmFuZ2xlICE9PSAwID8gXCJyb3RhdGUoXCIgKyB0aGlzLmFuZ2xlICsgXCJkZWcpXCIgOiAnJztcblx0ICAgIGlzQ29tcG9zaXRlID0gdGhpcy5wcm9wcy5pc0NvbXBvc2l0ZUxheWVyICYmIGguaXMzZDtcblx0ICAgIGNvbXBvc2l0ZSA9IGlzQ29tcG9zaXRlID8gJ3RyYW5zbGF0ZVooMCknIDogJyc7XG5cdCAgICB0cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIHggKyBcInB4LFwiICsgeSArIFwicHgpIFwiICsgcm90YXRlICsgXCIgXCIgKyBjb21wb3NpdGU7XG5cdCAgICByZXR1cm4gaC5zZXRQcmVmaXhlZFN0eWxlKHRoaXMuZWwsICd0cmFuc2Zvcm0nLCB0cmFuc2Zvcm0pO1xuXHQgIH07XG5cblx0ICBNb3Rpb25QYXRoLnByb3RvdHlwZS5zZXRNb2R1bGVQb3NpdGlvbiA9IGZ1bmN0aW9uKHgsIHkpIHtcblx0ICAgIHRoaXMuZWwuX3NldFByb3Aoe1xuXHQgICAgICBzaGlmdFg6IHggKyBcInB4XCIsXG5cdCAgICAgIHNoaWZ0WTogeSArIFwicHhcIixcblx0ICAgICAgYW5nbGU6IHRoaXMuYW5nbGVcblx0ICAgIH0pO1xuXHQgICAgcmV0dXJuIHRoaXMuZWwuX2RyYXcoKTtcblx0ICB9O1xuXG5cdCAgTW90aW9uUGF0aC5wcm90b3R5cGUuX2dldEN1cnJlbnRBbmdsZSA9IGZ1bmN0aW9uKHBvaW50LCBsZW4sIHApIHtcblx0ICAgIHZhciBhdGFuLCBpc1RyYW5zZm9ybUZ1bk9yaWdpbiwgcHJldlBvaW50LCB4MSwgeDI7XG5cdCAgICBpc1RyYW5zZm9ybUZ1bk9yaWdpbiA9IHR5cGVvZiB0aGlzLnByb3BzLnRyYW5zZm9ybU9yaWdpbiA9PT0gJ2Z1bmN0aW9uJztcblx0ICAgIGlmICh0aGlzLnByb3BzLmlzQW5nbGUgfHwgKHRoaXMucHJvcHMuYW5nbGVPZmZzZXQgIT0gbnVsbCkgfHwgaXNUcmFuc2Zvcm1GdW5PcmlnaW4pIHtcblx0ICAgICAgcHJldlBvaW50ID0gdGhpcy5wYXRoLmdldFBvaW50QXRMZW5ndGgobGVuIC0gMSk7XG5cdCAgICAgIHgxID0gcG9pbnQueSAtIHByZXZQb2ludC55O1xuXHQgICAgICB4MiA9IHBvaW50LnggLSBwcmV2UG9pbnQueDtcblx0ICAgICAgYXRhbiA9IE1hdGguYXRhbih4MSAvIHgyKTtcblx0ICAgICAgIWlzRmluaXRlKGF0YW4pICYmIChhdGFuID0gMCk7XG5cdCAgICAgIHRoaXMuYW5nbGUgPSBhdGFuICogaC5SQURfVE9fREVHO1xuXHQgICAgICBpZiAoKHR5cGVvZiB0aGlzLnByb3BzLmFuZ2xlT2Zmc2V0KSAhPT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgIHJldHVybiB0aGlzLmFuZ2xlICs9IHRoaXMucHJvcHMuYW5nbGVPZmZzZXQgfHwgMDtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5hbmdsZSA9IHRoaXMucHJvcHMuYW5nbGVPZmZzZXQuY2FsbCh0aGlzLCB0aGlzLmFuZ2xlLCBwKTtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuYW5nbGUgPSAwO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICBNb3Rpb25QYXRoLnByb3RvdHlwZS5fc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24oeCwgeSwgcCwgaXNJbml0KSB7XG5cdCAgICB2YXIgdHJhbnNmb3JtO1xuXHQgICAgaWYgKHRoaXMuc2NhbGVyKSB7XG5cdCAgICAgIHggKj0gdGhpcy5zY2FsZXIueDtcblx0ICAgICAgeSAqPSB0aGlzLnNjYWxlci55O1xuXHQgICAgfVxuXHQgICAgdHJhbnNmb3JtID0gbnVsbDtcblx0ICAgIGlmICghaXNJbml0KSB7XG5cdCAgICAgIHRyYW5zZm9ybSA9IHR5cGVvZiB0aGlzLm9uVXBkYXRlID09PSBcImZ1bmN0aW9uXCIgPyB0aGlzLm9uVXBkYXRlKHAsIHtcblx0ICAgICAgICB4OiB4LFxuXHQgICAgICAgIHk6IHksXG5cdCAgICAgICAgYW5nbGU6IHRoaXMuYW5nbGVcblx0ICAgICAgfSkgOiB2b2lkIDA7XG5cdCAgICB9XG5cdCAgICBpZiAodGhpcy5pc01vZHVsZSkge1xuXHQgICAgICByZXR1cm4gdGhpcy5zZXRNb2R1bGVQb3NpdGlvbih4LCB5KTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGlmICh0eXBlb2YgdHJhbnNmb3JtICE9PSAnc3RyaW5nJykge1xuXHQgICAgICAgIHJldHVybiB0aGlzLnNldEVsUG9zaXRpb24oeCwgeSwgcCk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcmV0dXJuIGguc2V0UHJlZml4ZWRTdHlsZSh0aGlzLmVsLCAndHJhbnNmb3JtJywgdHJhbnNmb3JtKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH07XG5cblx0ICBNb3Rpb25QYXRoLnByb3RvdHlwZS5fc2V0VHJhbnNmb3JtT3JpZ2luID0gZnVuY3Rpb24ocCkge1xuXHQgICAgdmFyIGlzVHJhbnNmb3JtRnVuT3JpZ2luLCB0T3JpZ2luO1xuXHQgICAgaWYgKHRoaXMucHJvcHMudHJhbnNmb3JtT3JpZ2luKSB7XG5cdCAgICAgIGlzVHJhbnNmb3JtRnVuT3JpZ2luID0gdHlwZW9mIHRoaXMucHJvcHMudHJhbnNmb3JtT3JpZ2luID09PSAnZnVuY3Rpb24nO1xuXHQgICAgICB0T3JpZ2luID0gIWlzVHJhbnNmb3JtRnVuT3JpZ2luID8gdGhpcy5wcm9wcy50cmFuc2Zvcm1PcmlnaW4gOiB0aGlzLnByb3BzLnRyYW5zZm9ybU9yaWdpbih0aGlzLmFuZ2xlLCBwKTtcblx0ICAgICAgcmV0dXJuIGguc2V0UHJlZml4ZWRTdHlsZSh0aGlzLmVsLCAndHJhbnNmb3JtLW9yaWdpbicsIHRPcmlnaW4pO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICBNb3Rpb25QYXRoLnByb3RvdHlwZS5tYWtlTW90aW9uQmx1ciA9IGZ1bmN0aW9uKHgsIHkpIHtcblx0ICAgIHZhciBhYnNvbHV0ZUFuZ2xlLCBjb29yZHMsIGRYLCBkWSwgc2lnblgsIHNpZ25ZLCB0YWlsQW5nbGU7XG5cdCAgICB0YWlsQW5nbGUgPSAwO1xuXHQgICAgc2lnblggPSAxO1xuXHQgICAgc2lnblkgPSAxO1xuXHQgICAgaWYgKCh0aGlzLnByZXZDb29yZHMueCA9PSBudWxsKSB8fCAodGhpcy5wcmV2Q29vcmRzLnkgPT0gbnVsbCkpIHtcblx0ICAgICAgdGhpcy5zcGVlZFggPSAwO1xuXHQgICAgICB0aGlzLnNwZWVkWSA9IDA7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBkWCA9IHggLSB0aGlzLnByZXZDb29yZHMueDtcblx0ICAgICAgZFkgPSB5IC0gdGhpcy5wcmV2Q29vcmRzLnk7XG5cdCAgICAgIGlmIChkWCA+IDApIHtcblx0ICAgICAgICBzaWduWCA9IC0xO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChzaWduWCA8IDApIHtcblx0ICAgICAgICBzaWduWSA9IC0xO1xuXHQgICAgICB9XG5cdCAgICAgIHRoaXMuc3BlZWRYID0gTWF0aC5hYnMoZFgpO1xuXHQgICAgICB0aGlzLnNwZWVkWSA9IE1hdGguYWJzKGRZKTtcblx0ICAgICAgdGFpbEFuZ2xlID0gTWF0aC5hdGFuKGRZIC8gZFgpICogKDE4MCAvIE1hdGguUEkpICsgOTA7XG5cdCAgICB9XG5cdCAgICBhYnNvbHV0ZUFuZ2xlID0gdGFpbEFuZ2xlIC0gdGhpcy5hbmdsZTtcblx0ICAgIGNvb3JkcyA9IHRoaXMuYW5nVG9Db29yZHMoYWJzb2x1dGVBbmdsZSk7XG5cdCAgICB0aGlzLmJsdXJYID0gaC5jbGFtcCgodGhpcy5zcGVlZFggLyAxNikgKiB0aGlzLnByb3BzLm1vdGlvbkJsdXIsIDAsIDEpO1xuXHQgICAgdGhpcy5ibHVyWSA9IGguY2xhbXAoKHRoaXMuc3BlZWRZIC8gMTYpICogdGhpcy5wcm9wcy5tb3Rpb25CbHVyLCAwLCAxKTtcblx0ICAgIHRoaXMuc2V0Qmx1cih7XG5cdCAgICAgIGJsdXI6IHtcblx0ICAgICAgICB4OiAzICogdGhpcy5ibHVyWCAqIHRoaXMuYmx1ckFtb3VudCAqIE1hdGguYWJzKGNvb3Jkcy54KSxcblx0ICAgICAgICB5OiAzICogdGhpcy5ibHVyWSAqIHRoaXMuYmx1ckFtb3VudCAqIE1hdGguYWJzKGNvb3Jkcy55KVxuXHQgICAgICB9LFxuXHQgICAgICBvZmZzZXQ6IHtcblx0ICAgICAgICB4OiAzICogc2lnblggKiB0aGlzLmJsdXJYICogY29vcmRzLnggKiB0aGlzLmJsdXJBbW91bnQsXG5cdCAgICAgICAgeTogMyAqIHNpZ25ZICogdGhpcy5ibHVyWSAqIGNvb3Jkcy55ICogdGhpcy5ibHVyQW1vdW50XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgdGhpcy5wcmV2Q29vcmRzLnggPSB4O1xuXHQgICAgcmV0dXJuIHRoaXMucHJldkNvb3Jkcy55ID0geTtcblx0ICB9O1xuXG5cdCAgTW90aW9uUGF0aC5wcm90b3R5cGUuc2V0Qmx1ciA9IGZ1bmN0aW9uKG8pIHtcblx0ICAgIGlmICghdGhpcy5pc01vdGlvbkJsdXJSZXNldCkge1xuXHQgICAgICB0aGlzLmZpbHRlci5zZXRBdHRyaWJ1dGUoJ3N0ZERldmlhdGlvbicsIG8uYmx1ci54ICsgXCIsXCIgKyBvLmJsdXIueSk7XG5cdCAgICAgIHRoaXMuZmlsdGVyT2Zmc2V0LnNldEF0dHJpYnV0ZSgnZHgnLCBvLm9mZnNldC54KTtcblx0ICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyT2Zmc2V0LnNldEF0dHJpYnV0ZSgnZHknLCBvLm9mZnNldC55KTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgTW90aW9uUGF0aC5wcm90b3R5cGUuZXh0ZW5kRGVmYXVsdHMgPSBmdW5jdGlvbihvKSB7XG5cdCAgICB2YXIga2V5LCByZXN1bHRzLCB2YWx1ZTtcblx0ICAgIHJlc3VsdHMgPSBbXTtcblx0ICAgIGZvciAoa2V5IGluIG8pIHtcblx0ICAgICAgdmFsdWUgPSBvW2tleV07XG5cdCAgICAgIHJlc3VsdHMucHVzaCh0aGlzW2tleV0gPSB2YWx1ZSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmVzdWx0cztcblx0ICB9O1xuXG5cdCAgTW90aW9uUGF0aC5wcm90b3R5cGUuZXh0ZW5kT3B0aW9ucyA9IGZ1bmN0aW9uKG8pIHtcblx0ICAgIHZhciBrZXksIHJlc3VsdHMsIHZhbHVlO1xuXHQgICAgcmVzdWx0cyA9IFtdO1xuXHQgICAgZm9yIChrZXkgaW4gbykge1xuXHQgICAgICB2YWx1ZSA9IG9ba2V5XTtcblx0ICAgICAgcmVzdWx0cy5wdXNoKHRoaXMucHJvcHNba2V5XSA9IHZhbHVlKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiByZXN1bHRzO1xuXHQgIH07XG5cblx0ICBNb3Rpb25QYXRoLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24obykge1xuXHQgICAgdmFyIGl0LCBrZXksIG9wdHMsIHByZXZPcHRpb25zLCB2YWx1ZTtcblx0ICAgIHByZXZPcHRpb25zID0gdGhpcy5oaXN0b3J5W3RoaXMuaGlzdG9yeS5sZW5ndGggLSAxXTtcblx0ICAgIG9wdHMgPSB7fTtcblx0ICAgIGZvciAoa2V5IGluIHByZXZPcHRpb25zKSB7XG5cdCAgICAgIHZhbHVlID0gcHJldk9wdGlvbnNba2V5XTtcblx0ICAgICAgaWYgKCFoLmNhbGxiYWNrc01hcFtrZXldICYmICFoLnR3ZWVuT3B0aW9uTWFwW2tleV0gfHwga2V5ID09PSAnZHVyYXRpb24nKSB7XG5cdCAgICAgICAgaWYgKG9ba2V5XSA9PSBudWxsKSB7XG5cdCAgICAgICAgICBvW2tleV0gPSB2YWx1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgaWYgKG9ba2V5XSA9PSBudWxsKSB7XG5cdCAgICAgICAgICBvW2tleV0gPSB2b2lkIDA7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIGlmIChoLnR3ZWVuT3B0aW9uTWFwW2tleV0pIHtcblx0ICAgICAgICBvcHRzW2tleV0gPSBrZXkgIT09ICdkdXJhdGlvbicgPyBvW2tleV0gOiBvW2tleV0gIT0gbnVsbCA/IG9ba2V5XSA6IHByZXZPcHRpb25zW2tleV07XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHRoaXMuaGlzdG9yeS5wdXNoKG8pO1xuXHQgICAgaXQgPSB0aGlzO1xuXHQgICAgb3B0cy5vblVwZGF0ZSA9IChmdW5jdGlvbihfdGhpcykge1xuXHQgICAgICByZXR1cm4gZnVuY3Rpb24ocCkge1xuXHQgICAgICAgIHJldHVybiBfdGhpcy5zZXRQcm9ncmVzcyhwKTtcblx0ICAgICAgfTtcblx0ICAgIH0pKHRoaXMpO1xuXHQgICAgb3B0cy5vblN0YXJ0ID0gKGZ1bmN0aW9uKF90aGlzKSB7XG5cdCAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgICAgICB2YXIgcmVmO1xuXHQgICAgICAgIHJldHVybiAocmVmID0gX3RoaXMucHJvcHMub25TdGFydCkgIT0gbnVsbCA/IHJlZi5hcHBseShfdGhpcykgOiB2b2lkIDA7XG5cdCAgICAgIH07XG5cdCAgICB9KSh0aGlzKTtcblx0ICAgIG9wdHMub25Db21wbGV0ZSA9IChmdW5jdGlvbihfdGhpcykge1xuXHQgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgdmFyIHJlZjtcblx0ICAgICAgICByZXR1cm4gKHJlZiA9IF90aGlzLnByb3BzLm9uQ29tcGxldGUpICE9IG51bGwgPyByZWYuYXBwbHkoX3RoaXMpIDogdm9pZCAwO1xuXHQgICAgICB9O1xuXHQgICAgfSkodGhpcyk7XG5cdCAgICBvcHRzLm9uRmlyc3RVcGRhdGUgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgcmV0dXJuIGl0LnR1bmVPcHRpb25zKGl0Lmhpc3RvcnlbdGhpcy5pbmRleF0pO1xuXHQgICAgfTtcblx0ICAgIG9wdHMuaXNDaGFpbmVkID0gIW8uZGVsYXk7XG5cdCAgICB0aGlzLnRpbWVsaW5lLmFwcGVuZChuZXcgVHdlZW4ob3B0cykpO1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblxuXHQgIE1vdGlvblBhdGgucHJvdG90eXBlLnR1bmVPcHRpb25zID0gZnVuY3Rpb24obykge1xuXHQgICAgdGhpcy5leHRlbmRPcHRpb25zKG8pO1xuXHQgICAgcmV0dXJuIHRoaXMucG9zdFZhcnMoKTtcblx0ICB9O1xuXG5cdCAgTW90aW9uUGF0aC5wcm90b3R5cGUuYW5nVG9Db29yZHMgPSBmdW5jdGlvbihhbmdsZSkge1xuXHQgICAgdmFyIHJhZEFuZ2xlLCB4LCB5O1xuXHQgICAgYW5nbGUgPSBhbmdsZSAlIDM2MDtcblx0ICAgIHJhZEFuZ2xlID0gKChhbmdsZSAtIDkwKSAqIE1hdGguUEkpIC8gMTgwO1xuXHQgICAgeCA9IE1hdGguY29zKHJhZEFuZ2xlKTtcblx0ICAgIHkgPSBNYXRoLnNpbihyYWRBbmdsZSk7XG5cdCAgICB4ID0geCA8IDAgPyBNYXRoLm1heCh4LCAtMC43KSA6IE1hdGgubWluKHgsIC43KTtcblx0ICAgIHkgPSB5IDwgMCA/IE1hdGgubWF4KHksIC0wLjcpIDogTWF0aC5taW4oeSwgLjcpO1xuXHQgICAgcmV0dXJuIHtcblx0ICAgICAgeDogeCAqIDEuNDI4NTcxNDI5LFxuXHQgICAgICB5OiB5ICogMS40Mjg1NzE0Mjlcblx0ICAgIH07XG5cdCAgfTtcblxuXHQgIHJldHVybiBNb3Rpb25QYXRoO1xuXG5cdH0pKCk7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBNb3Rpb25QYXRoO1xuXG5cbi8qKiovIH0pLFxuLyogMTMwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fO1xuXHQvKiFcblx0ICBMZWdvTXVzaHJvb20gQGxlZ29tdXNocm9vbSBodHRwOi8vbGVnb211c2hyb29tLmNvbVxuXHQgIE1JVCBMaWNlbnNlIDIwMTRcblx0ICovXG5cblx0LyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0KGZ1bmN0aW9uKCkge1xuXHQgIHZhciBNYWluO1xuXHQgIE1haW4gPSAoZnVuY3Rpb24oKSB7XG5cdCAgICBmdW5jdGlvbiBNYWluKG8pIHtcblx0ICAgICAgdGhpcy5vID0gbyAhPSBudWxsID8gbyA6IHt9O1xuXHQgICAgICBpZiAod2luZG93LmlzQW55UmVzaXplRXZlbnRJbml0ZWQpIHtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblx0ICAgICAgdGhpcy52YXJzKCk7XG5cdCAgICAgIHRoaXMucmVkZWZpbmVQcm90bygpO1xuXHQgICAgfVxuXG5cdCAgICBNYWluLnByb3RvdHlwZS52YXJzID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgIHdpbmRvdy5pc0FueVJlc2l6ZUV2ZW50SW5pdGVkID0gdHJ1ZTtcblx0ICAgICAgdGhpcy5hbGxvd2VkUHJvdG9zID0gW0hUTUxEaXZFbGVtZW50LCBIVE1MRm9ybUVsZW1lbnQsIEhUTUxMaW5rRWxlbWVudCwgSFRNTEJvZHlFbGVtZW50LCBIVE1MUGFyYWdyYXBoRWxlbWVudCwgSFRNTEZpZWxkU2V0RWxlbWVudCwgSFRNTExlZ2VuZEVsZW1lbnQsIEhUTUxMYWJlbEVsZW1lbnQsIEhUTUxCdXR0b25FbGVtZW50LCBIVE1MVUxpc3RFbGVtZW50LCBIVE1MT0xpc3RFbGVtZW50LCBIVE1MTElFbGVtZW50LCBIVE1MSGVhZGluZ0VsZW1lbnQsIEhUTUxRdW90ZUVsZW1lbnQsIEhUTUxQcmVFbGVtZW50LCBIVE1MQlJFbGVtZW50LCBIVE1MRm9udEVsZW1lbnQsIEhUTUxIUkVsZW1lbnQsIEhUTUxNb2RFbGVtZW50LCBIVE1MUGFyYW1FbGVtZW50LCBIVE1MTWFwRWxlbWVudCwgSFRNTFRhYmxlRWxlbWVudCwgSFRNTFRhYmxlQ2FwdGlvbkVsZW1lbnQsIEhUTUxJbWFnZUVsZW1lbnQsIEhUTUxUYWJsZUNlbGxFbGVtZW50LCBIVE1MU2VsZWN0RWxlbWVudCwgSFRNTElucHV0RWxlbWVudCwgSFRNTFRleHRBcmVhRWxlbWVudCwgSFRNTEFuY2hvckVsZW1lbnQsIEhUTUxPYmplY3RFbGVtZW50LCBIVE1MVGFibGVDb2xFbGVtZW50LCBIVE1MVGFibGVTZWN0aW9uRWxlbWVudCwgSFRNTFRhYmxlUm93RWxlbWVudF07XG5cdCAgICAgIHJldHVybiB0aGlzLnRpbWVyRWxlbWVudHMgPSB7XG5cdCAgICAgICAgaW1nOiAxLFxuXHQgICAgICAgIHRleHRhcmVhOiAxLFxuXHQgICAgICAgIGlucHV0OiAxLFxuXHQgICAgICAgIGVtYmVkOiAxLFxuXHQgICAgICAgIG9iamVjdDogMSxcblx0ICAgICAgICBzdmc6IDEsXG5cdCAgICAgICAgY2FudmFzOiAxLFxuXHQgICAgICAgIHRyOiAxLFxuXHQgICAgICAgIHRib2R5OiAxLFxuXHQgICAgICAgIHRoZWFkOiAxLFxuXHQgICAgICAgIHRmb290OiAxLFxuXHQgICAgICAgIGE6IDEsXG5cdCAgICAgICAgc2VsZWN0OiAxLFxuXHQgICAgICAgIG9wdGlvbjogMSxcblx0ICAgICAgICBvcHRncm91cDogMSxcblx0ICAgICAgICBkbDogMSxcblx0ICAgICAgICBkdDogMSxcblx0ICAgICAgICBicjogMSxcblx0ICAgICAgICBiYXNlZm9udDogMSxcblx0ICAgICAgICBmb250OiAxLFxuXHQgICAgICAgIGNvbDogMSxcblx0ICAgICAgICBpZnJhbWU6IDFcblx0ICAgICAgfTtcblx0ICAgIH07XG5cblx0ICAgIE1haW4ucHJvdG90eXBlLnJlZGVmaW5lUHJvdG8gPSBmdW5jdGlvbigpIHtcblx0ICAgICAgdmFyIGksIGl0LCBwcm90bywgdDtcblx0ICAgICAgaXQgPSB0aGlzO1xuXHQgICAgICByZXR1cm4gdCA9IChmdW5jdGlvbigpIHtcblx0ICAgICAgICB2YXIgaiwgbGVuLCByZWYsIHJlc3VsdHM7XG5cdCAgICAgICAgcmVmID0gdGhpcy5hbGxvd2VkUHJvdG9zO1xuXHQgICAgICAgIHJlc3VsdHMgPSBbXTtcblx0ICAgICAgICBmb3IgKGkgPSBqID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaiA8IGxlbjsgaSA9ICsraikge1xuXHQgICAgICAgICAgcHJvdG8gPSByZWZbaV07XG5cdCAgICAgICAgICBpZiAocHJvdG8ucHJvdG90eXBlID09IG51bGwpIHtcblx0ICAgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgICByZXN1bHRzLnB1c2goKGZ1bmN0aW9uKHByb3RvKSB7XG5cdCAgICAgICAgICAgIHZhciBsaXN0ZW5lciwgcmVtb3Zlcjtcblx0ICAgICAgICAgICAgbGlzdGVuZXIgPSBwcm90by5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciB8fCBwcm90by5wcm90b3R5cGUuYXR0YWNoRXZlbnQ7XG5cdCAgICAgICAgICAgIChmdW5jdGlvbihsaXN0ZW5lcikge1xuXHQgICAgICAgICAgICAgIHZhciB3cmFwcGVkTGlzdGVuZXI7XG5cdCAgICAgICAgICAgICAgd3JhcHBlZExpc3RlbmVyID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgb3B0aW9uO1xuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMgIT09IHdpbmRvdyB8fCB0aGlzICE9PSBkb2N1bWVudCkge1xuXHQgICAgICAgICAgICAgICAgICBvcHRpb24gPSBhcmd1bWVudHNbMF0gPT09ICdvbnJlc2l6ZScgJiYgIXRoaXMuaXNBbnlSZXNpemVFdmVudEluaXRlZDtcblx0ICAgICAgICAgICAgICAgICAgb3B0aW9uICYmIGl0LmhhbmRsZVJlc2l6ZSh7XG5cdCAgICAgICAgICAgICAgICAgICAgYXJnczogYXJndW1lbnRzLFxuXHQgICAgICAgICAgICAgICAgICAgIHRoYXQ6IHRoaXNcblx0ICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgIGlmIChwcm90by5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb3RvLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gd3JhcHBlZExpc3RlbmVyO1xuXHQgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvdG8ucHJvdG90eXBlLmF0dGFjaEV2ZW50KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvdG8ucHJvdG90eXBlLmF0dGFjaEV2ZW50ID0gd3JhcHBlZExpc3RlbmVyO1xuXHQgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSkobGlzdGVuZXIpO1xuXHQgICAgICAgICAgICByZW1vdmVyID0gcHJvdG8ucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgfHwgcHJvdG8ucHJvdG90eXBlLmRldGFjaEV2ZW50O1xuXHQgICAgICAgICAgICByZXR1cm4gKGZ1bmN0aW9uKHJlbW92ZXIpIHtcblx0ICAgICAgICAgICAgICB2YXIgd3JhcHBlZFJlbW92ZXI7XG5cdCAgICAgICAgICAgICAgd3JhcHBlZFJlbW92ZXIgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuaXNBbnlSZXNpemVFdmVudEluaXRlZCA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5pZnJhbWUgJiYgdGhpcy5yZW1vdmVDaGlsZCh0aGlzLmlmcmFtZSk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcmVtb3Zlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgaWYgKHByb3RvLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvdG8ucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSB3cmFwcGVkUmVtb3Zlcjtcblx0ICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByb3RvLnByb3RvdHlwZS5kZXRhY2hFdmVudCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb3RvLnByb3RvdHlwZS5kZXRhY2hFdmVudCA9IHdyYXBwZWRMaXN0ZW5lcjtcblx0ICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pKHJlbW92ZXIpO1xuXHQgICAgICAgICAgfSkocHJvdG8pKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG5cdCAgICAgIH0pLmNhbGwodGhpcyk7XG5cdCAgICB9O1xuXG5cdCAgICBNYWluLnByb3RvdHlwZS5oYW5kbGVSZXNpemUgPSBmdW5jdGlvbihhcmdzKSB7XG5cdCAgICAgIHZhciBjb21wdXRlZFN0eWxlLCBlbCwgaWZyYW1lLCBpc0VtcHR5LCBpc05vUG9zLCBpc1N0YXRpYywgcmVmO1xuXHQgICAgICBlbCA9IGFyZ3MudGhhdDtcblx0ICAgICAgaWYgKCF0aGlzLnRpbWVyRWxlbWVudHNbZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpXSkge1xuXHQgICAgICAgIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuXHQgICAgICAgIGVsLmFwcGVuZENoaWxkKGlmcmFtZSk7XG5cdCAgICAgICAgaWZyYW1lLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuXHQgICAgICAgIGlmcmFtZS5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG5cdCAgICAgICAgaWZyYW1lLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcblx0ICAgICAgICBpZnJhbWUuc3R5bGUuekluZGV4ID0gLTk5OTtcblx0ICAgICAgICBpZnJhbWUuc3R5bGUub3BhY2l0eSA9IDA7XG5cdCAgICAgICAgaWZyYW1lLnN0eWxlLnRvcCA9IDA7XG5cdCAgICAgICAgaWZyYW1lLnN0eWxlLmxlZnQgPSAwO1xuXHQgICAgICAgIGNvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSA/IGdldENvbXB1dGVkU3R5bGUoZWwpIDogZWwuY3VycmVudFN0eWxlO1xuXHQgICAgICAgIGlzTm9Qb3MgPSBlbC5zdHlsZS5wb3NpdGlvbiA9PT0gJyc7XG5cdCAgICAgICAgaXNTdGF0aWMgPSBjb21wdXRlZFN0eWxlLnBvc2l0aW9uID09PSAnc3RhdGljJyAmJiBpc05vUG9zO1xuXHQgICAgICAgIGlzRW1wdHkgPSBjb21wdXRlZFN0eWxlLnBvc2l0aW9uID09PSAnJyAmJiBlbC5zdHlsZS5wb3NpdGlvbiA9PT0gJyc7XG5cdCAgICAgICAgaWYgKGlzU3RhdGljIHx8IGlzRW1wdHkpIHtcblx0ICAgICAgICAgIGVsLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKChyZWYgPSBpZnJhbWUuY29udGVudFdpbmRvdykgIT0gbnVsbCkge1xuXHQgICAgICAgICAgcmVmLm9ucmVzaXplID0gKGZ1bmN0aW9uKF90aGlzKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG5cdCAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmRpc3BhdGNoRXZlbnQoZWwpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgfSkodGhpcyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsLmlmcmFtZSA9IGlmcmFtZTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB0aGlzLmluaXRUaW1lcihlbCk7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIGVsLmlzQW55UmVzaXplRXZlbnRJbml0ZWQgPSB0cnVlO1xuXHQgICAgfTtcblxuXHQgICAgTWFpbi5wcm90b3R5cGUuaW5pdFRpbWVyID0gZnVuY3Rpb24oZWwpIHtcblx0ICAgICAgdmFyIGhlaWdodCwgd2lkdGg7XG5cdCAgICAgIHdpZHRoID0gMDtcblx0ICAgICAgaGVpZ2h0ID0gMDtcblx0ICAgICAgcmV0dXJuIHRoaXMuaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoZnVuY3Rpb24oX3RoaXMpIHtcblx0ICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICB2YXIgbmV3SGVpZ2h0LCBuZXdXaWR0aDtcblx0ICAgICAgICAgIG5ld1dpZHRoID0gZWwub2Zmc2V0V2lkdGg7XG5cdCAgICAgICAgICBuZXdIZWlnaHQgPSBlbC5vZmZzZXRIZWlnaHQ7XG5cdCAgICAgICAgICBpZiAobmV3V2lkdGggIT09IHdpZHRoIHx8IG5ld0hlaWdodCAhPT0gaGVpZ2h0KSB7XG5cdCAgICAgICAgICAgIF90aGlzLmRpc3BhdGNoRXZlbnQoZWwpO1xuXHQgICAgICAgICAgICB3aWR0aCA9IG5ld1dpZHRoO1xuXHQgICAgICAgICAgICByZXR1cm4gaGVpZ2h0ID0gbmV3SGVpZ2h0O1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH07XG5cdCAgICAgIH0pKHRoaXMpLCB0aGlzLm8uaW50ZXJ2YWwgfHwgNjIuNSk7XG5cdCAgICB9O1xuXG5cdCAgICBNYWluLnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24oZWwpIHtcblx0ICAgICAgdmFyIGU7XG5cdCAgICAgIGlmIChkb2N1bWVudC5jcmVhdGVFdmVudCkge1xuXHQgICAgICAgIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpO1xuXHQgICAgICAgIGUuaW5pdEV2ZW50KCdvbnJlc2l6ZScsIGZhbHNlLCBmYWxzZSk7XG5cdCAgICAgICAgcmV0dXJuIGVsLmRpc3BhdGNoRXZlbnQoZSk7XG5cdCAgICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQuY3JlYXRlRXZlbnRPYmplY3QpIHtcblx0ICAgICAgICBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnRPYmplY3QoKTtcblx0ICAgICAgICByZXR1cm4gZWwuZmlyZUV2ZW50KCdvbnJlc2l6ZScsIGUpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgTWFpbi5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICB2YXIgaSwgaXQsIGosIGxlbiwgcHJvdG8sIHJlZiwgcmVzdWx0cztcblx0ICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsKTtcblx0ICAgICAgdGhpcy5pbnRlcnZhbCA9IG51bGw7XG5cdCAgICAgIHdpbmRvdy5pc0FueVJlc2l6ZUV2ZW50SW5pdGVkID0gZmFsc2U7XG5cdCAgICAgIGl0ID0gdGhpcztcblx0ICAgICAgcmVmID0gdGhpcy5hbGxvd2VkUHJvdG9zO1xuXHQgICAgICByZXN1bHRzID0gW107XG5cdCAgICAgIGZvciAoaSA9IGogPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBqIDwgbGVuOyBpID0gKytqKSB7XG5cdCAgICAgICAgcHJvdG8gPSByZWZbaV07XG5cdCAgICAgICAgaWYgKHByb3RvLnByb3RvdHlwZSA9PSBudWxsKSB7XG5cdCAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmVzdWx0cy5wdXNoKChmdW5jdGlvbihwcm90bykge1xuXHQgICAgICAgICAgdmFyIGxpc3RlbmVyO1xuXHQgICAgICAgICAgbGlzdGVuZXIgPSBwcm90by5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciB8fCBwcm90by5wcm90b3R5cGUuYXR0YWNoRXZlbnQ7XG5cdCAgICAgICAgICBpZiAocHJvdG8ucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIpIHtcblx0ICAgICAgICAgICAgcHJvdG8ucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBFbGVtZW50LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyO1xuXHQgICAgICAgICAgfSBlbHNlIGlmIChwcm90by5wcm90b3R5cGUuYXR0YWNoRXZlbnQpIHtcblx0ICAgICAgICAgICAgcHJvdG8ucHJvdG90eXBlLmF0dGFjaEV2ZW50ID0gRWxlbWVudC5wcm90b3R5cGUuYXR0YWNoRXZlbnQ7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgICBpZiAocHJvdG8ucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHByb3RvLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gRWxlbWVudC5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lcjtcblx0ICAgICAgICAgIH0gZWxzZSBpZiAocHJvdG8ucHJvdG90eXBlLmRldGFjaEV2ZW50KSB7XG5cdCAgICAgICAgICAgIHJldHVybiBwcm90by5wcm90b3R5cGUuZGV0YWNoRXZlbnQgPSBFbGVtZW50LnByb3RvdHlwZS5kZXRhY2hFdmVudDtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9KShwcm90bykpO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiByZXN1bHRzO1xuXHQgICAgfTtcblxuXHQgICAgcmV0dXJuIE1haW47XG5cblx0ICB9KSgpO1xuXHQgIGlmICh0cnVlKSB7XG5cdCAgICByZXR1cm4gIShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW10sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiBuZXcgTWFpbjtcblx0ICAgIH0uYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyksIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblx0ICB9IGVsc2UgaWYgKCh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiKSAmJiAodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiKSkge1xuXHQgICAgcmV0dXJuIG1vZHVsZS5leHBvcnRzID0gbmV3IE1haW47XG5cdCAgfSBlbHNlIHtcblx0ICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdyAhPT0gbnVsbCkge1xuXHQgICAgICB3aW5kb3cuQW55UmVzaXplRXZlbnQgPSBNYWluO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93ICE9PSBudWxsID8gd2luZG93LmFueVJlc2l6ZUV2ZW50ID0gbmV3IE1haW4gOiB2b2lkIDA7XG5cdCAgfVxuXHR9KSgpO1xuXG5cbi8qKiovIH0pXG4vKioqKioqLyBdKVxufSk7XG47XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW8tanMvYnVpbGQvbW8uanNcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=